<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-LeetCode-11-Container-With-Most-Water" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/20/LeetCode-11-Container-With-Most-Water/" class="article-date">
  <time datetime="2018-07-20T15:08:49.363Z" itemprop="datePublished">2018-07-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/20/LeetCode-11-Container-With-Most-Water/">LeetCode 11.Container With Most Water</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="O-NlgN-解法"><a href="#O-NlgN-解法" class="headerlink" title="$O(NlgN)$解法"></a>$O(NlgN)$解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 对于第i根柱子，求出它左边比他高或者相同高度的柱子中最远的那根的位置</span></span><br><span class="line"><span class="comment"> * 方法是递推</span></span><br><span class="line"><span class="comment"> * 首先，map是红黑树实现的，所以其是有序的</span></span><br><span class="line"><span class="comment"> * 然后，每次求出第i根柱子后，把 &lt;height[i], &lt;i, result&gt;&gt; push到map里</span></span><br><span class="line"><span class="comment"> * 可以从map中取出已经加进map的（也就是在第i根柱子左边的柱子）中，height</span></span><br><span class="line"><span class="comment"> * 刚好大于或者等于height[i]的，设为p，然后，柱子p的result就是柱子i的result</span></span><br><span class="line"><span class="comment"> * 反证法：假设不是，而是q，那么q应当是大于等于p并且在p的左边——否则i的result就还是p，因为p更左边。</span></span><br><span class="line"><span class="comment"> * 既然q大于等于p并且在左边，那么p的result应该是q</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, PII, greater&lt;<span class="keyword">int</span>&gt;&gt; tree;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, PII, greater&lt;<span class="keyword">int</span>&gt;&gt; rtree;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ct</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = height.begin(); it != height.end(); ++it, ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = tree.insert(pair&lt;<span class="keyword">int</span>, PII&gt;(*it, PII(i, i)));</span><br><span class="line">            <span class="keyword">if</span> (p != tree.begin()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> k = (--p)-&gt;second;</span><br><span class="line">                (++p)-&gt;second = PII(i, k.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">crt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = height.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = height.rbegin(); it != height.rend(); ++it, --i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = rtree.insert(pair&lt;<span class="keyword">int</span>, PII&gt;(*it, PII(i, i)));</span><br><span class="line">            <span class="keyword">if</span> (p != rtree.begin()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> k = (--p)-&gt;second;</span><br><span class="line">                (++p)-&gt;second = PII(i, k.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        ct(height);</span><br><span class="line">        crt(height);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = tree.begin(); it != tree.end(); ++it) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = (it-&gt;first) * (it-&gt;second.first - it-&gt;second.second);</span><br><span class="line">            ans = ans &lt; p ? p : ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = rtree.begin(); it != rtree.end(); ++it) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = (it-&gt;first) * (it-&gt;second.second - it-&gt;second.first);</span><br><span class="line">            ans = ans &lt; p ? p : ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/20/LeetCode-11-Container-With-Most-Water/" data-id="cjjzt64fo00096bg4p06oe5h9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ACM/">ACM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/">Leetcode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vim不支持系统剪切板的解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/05/vim不支持系统剪切板的解决方案/" class="article-date">
  <time datetime="2018-06-05T07:15:31.000Z" itemprop="datePublished">2018-06-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/运维/">运维</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/05/vim不支持系统剪切板的解决方案/">vim 不支持系统剪切板的解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="判断vim是否支持系统剪切板"><a href="#判断vim是否支持系统剪切板" class="headerlink" title="判断vim是否支持系统剪切板"></a>判断vim是否支持系统剪切板</h3><ul>
<li><p>在终端输入<code>vim -version</code>，如果<code>clipboard</code> 那一项是<code>-clipboard</code> ，以及<code>xterm_clipboard</code> 那一项是<code>-xterm_clipboard</code> ，说明并不支持。可以通过重新编译来解决</p>
</li>
<li><p>以下引用另一位博主的解决方案，<a href="https://www.evernote.com/shard/s258/sh/8f17d13f-5040-45b4-a312-294ef7304fe5/c0c182567f72325da680fb38d66436ae" target="_blank" rel="noopener">原文地址</a></p>
</li>
<li><blockquote>
<p>+clipboard +xterm_clipboard</p>
<p>solution:</p>
<p>–with-x –x-includes=/usr/include/X11 –x-libraries=/usr/lib/X11</p>
<p>You’ll need to install the appropriate X development library like <code>xlib</code> and <code>xtst</code> for <code>--with-x</code> to work. On ubuntu it should be enough to install <code>libx11-dev</code> and <code>libxtst-dev</code>., xlibs-dev</p>
<p>and   sudo apt-get build-dep vim-gtk </p>
</blockquote>
</li>
<li><p>编译方法，在github vim 主页下载源码zip包，解压后进入第一层目录，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--enable-cscope \</span><br><span class="line">--with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11 \</span><br><span class="line">--with-features=normal \</span><br><span class="line">--enable-multibyte \</span><br><span class="line">--enable-rubyinterp \</span><br><span class="line">--enable-pythoninterp \</span><br><span class="line">--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \</span><br><span class="line">--enable-perlinterp \</span><br><span class="line">--enable-luainterp \</span><br><span class="line">--enable-gui=gtk2 --enable-cscope --prefix=/usr</span><br><span class="line"> make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>
<p>上面的配置选项可以根据自己的需求修改</p>
<p>完成后可以在<code>src/auto/config.log</code> 查看log</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/05/vim不支持系统剪切板的解决方案/" data-id="cjjzt64fu000j6bg4yy4lifuq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/clipboard/">clipboard</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vim/">vim</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xterm-clipboard/">xterm_clipboard</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统剪切板/">系统剪切板</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-洛谷2577-午餐" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/20/洛谷2577-午餐/" class="article-date">
  <time datetime="2018-05-20T00:20:06.000Z" itemprop="datePublished">2018-05-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/20/洛谷2577-午餐/">洛谷2577 午餐</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。</p>
<p>THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。</p>
<p>现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。</p>
<p>假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。</p>
<p>现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。</p>
<h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><p>输入格式：</p>
<p>第一行一个整数N，代表总共有N个人。</p>
<p>以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。</p>
<p>输出格式：</p>
<p>一个整数T，代表所有人吃完饭的最早时刻。</p>
<h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入样例#1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 2</span><br><span class="line">7 7</span><br><span class="line">1 3</span><br><span class="line">6 4</span><br><span class="line">8 5</span><br></pre></td></tr></table></figure>
<p>输出样例#1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="吃饭时间越长越早排队"><a href="#吃饭时间越长越早排队" class="headerlink" title="吃饭时间越长越早排队"></a>吃饭时间越长越早排队</h4><ul>
<li>假设有一个最优分组方法，其中第一队内是按吃饭时间长短排序的——越长排在越前。然后尝试交换该队内的某两个人，<code>i</code>、<code>j</code> ——即原先是<code>i</code> 排在<code>j</code> 前面，并且两人各自的吃饭时间$b[j]&lt;b[i]$，现在交换过来</li>
<li>首先，交换前从队头到到<code>j</code> 总的打饭时间或者是交换后从队头到<code>i</code> 的总的打饭时间都是$T$</li>
<li>然后以前$T$时间后，<code>j</code> 开始吃饭，现在是$T$时间后，<code>i</code> 开始吃饭。如果以前最终吃饭完成的时间是$T+b[j]$ （$b[j]$ 是<code>j</code> 的吃饭时间），那么现在就是$T+b[i]&gt;T+b[j]$ 。如果以前最终吃饭完成时间比$T+b[j]$ 后，那么现在最终吃饭完成时间就大于或者等于$T+b[i]$ </li>
</ul>
<h4 id="如何记录状态以及状态转移方程"><a href="#如何记录状态以及状态转移方程" class="headerlink" title="如何记录状态以及状态转移方程"></a>如何记录状态以及状态转移方程</h4><ul>
<li><p>$dp[i][j][k]$ ：表示当排到第<code>i</code> 个人时，第一队的排队耗时是<code>j</code> ，第二队的排队耗时是<code>k</code> </p>
</li>
<li><p>先定义符号，$man[i].a$ 表示第<code>i</code> 人的打饭时间，$man[i].b$ 是第<code>i</code> 人的吃饭时间，$sum[x]=\Sigma_{i=0}^x man[i].a$</p>
</li>
<li><p>因为，对于确定的<code>i</code> ，$k=sum[i]-j$ ，所以，$dp[i][j][k]=dp[i][j][sum[i]-j]$ </p>
</li>
<li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = MAX(dp[i<span class="number">-1</span>][j-man[i].a][k], j+man[i].b);</span><br><span class="line"><span class="keyword">int</span> y = MAX(dp[i<span class="number">-1</span>][j][k-man[i].a], k+man[i].b);</span><br><span class="line">dp[i][j][k] = dp[i][j][sum[i]-j] = MIN(x, y);</span><br></pre></td></tr></table></figure>
</li>
<li><p>之所以要取MAX，是因为$dp[i-1][j-man[i].a][k]$ 可能是第一队达到的最长吃饭完成时间，也可能是第二队达到的，而即使是第一队达到的，也有可能现在第一队最后一个吃完的时间$j+man[i].b$ 比$dp[i-1][j-man[i].a][k]$ 早，所以要取MAX</p>
</li>
<li><p>因为无需枚举<code>k</code> ，所以无需使用三维数组。并且可以使用滚动数组，从而压缩为一维数组</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FWD(x, b, e) for (int x = b; x &lt; e; x++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BWD(x, b, e) for (int x = b; x &gt;= e; x--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MAX</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? y : x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;<span class="comment">// a is pick time, b is eat time</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;y) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;b &gt; y.b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node man[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">80010</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;man[i].a, &amp;man[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(man, man + n);</span><br><span class="line"></span><br><span class="line">    sum[<span class="number">0</span>] = man[<span class="number">0</span>].a;</span><br><span class="line">    FWD(i, <span class="number">1</span>, n) &#123; sum[i] = sum[i - <span class="number">1</span>] + man[i].a; &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">10</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = man[<span class="number">0</span>].b + man[<span class="number">0</span>].a;</span><br><span class="line">    dp[man[<span class="number">0</span>].a] = man[<span class="number">0</span>].b + man[<span class="number">0</span>].a;</span><br><span class="line">    FWD(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        BWD(j, sum[i], <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp1 = INF, tmp2 = INF;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= man[i].a) &#123;</span><br><span class="line">                tmp1 = MAX(dp[j - man[i].a], j + man[i].b);<span class="comment">// 第一个人放在1队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum[i] - j &gt;= man[i].a) &#123;</span><br><span class="line">                tmp2 = MAX(dp[j], sum[i] - j + man[i].b);<span class="comment">// 第i个人放在二队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果j只能允许man[i].a放在一队，则i就放一队</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= man[i].a &amp;&amp; sum[i] - j &lt; man[i].a) &#123;</span><br><span class="line">                dp[j] = tmp1;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j &lt; man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123;</span><br><span class="line">                dp[j] = tmp2;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123;</span><br><span class="line">                dp[j] = MIN(tmp2, tmp1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    FWD(i, <span class="number">0</span>, sum[n - <span class="number">1</span>] + <span class="number">1</span>) &#123; ans = ans &lt; dp[i] ? ans : dp[i]; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注意，在枚举$dp[i][j]$ 的<code>j</code> 时，要注意该<code>j</code> 是否允许<code>man[i].a</code> 放在第一队，或者会放在第二队，所以，给$dp[i][j]$ 赋值时也要注意是否只能放在其中一队，从而直接赋值就行了，如果能放在其中两队，那么就要取MIN</p>
</li>
<li><p>注意，此题初始化时不可以把从$man[i].a+1$ 到$sum[n-1]$ 的dp都赋值为$man[i].a+man[i].b$ ，而应该赋值为INF。因为后面进行dp时，枚举$j$ 时，可能出现一种情况$j&lt;man[i].a$ 导致这个j时不可以放在第一队，并且$sum[i]-j&lt;man[i].a$ 导致也不可以放在第二队，这种情况就应该INF。</p>
</li>
<li><p>此题如果使用自顶向下应该可以节省一些冗余状态——就是直接把上面的循环改成尾递归</p>
<p><img src="./洛谷2577-午餐/1.png" alt=""></p>
</li>
<li><p><a href="https://www.luogu.org/problemnew/solution/P2577" target="_blank" rel="noopener">截图来源 </a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/20/洛谷2577-午餐/" data-id="cjjzt64g900126bg46rgdkone" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ACM/">ACM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态规划/">动态规划</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-洛谷2320-鬼谷子的钱袋-形式化证明" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/17/洛谷2320-鬼谷子的钱袋-形式化证明/" class="article-date">
  <time datetime="2018-05-16T17:33:21.000Z" itemprop="datePublished">2018-05-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/17/洛谷2320-鬼谷子的钱袋-形式化证明/">洛谷2320 鬼谷子的钱袋 形式化证明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p><img src="./洛谷2320-鬼谷子的钱袋-形式化证明/1.png" alt=""></p>
<h4 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">3</span><br><span class="line">输出</span><br><span class="line">2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>对于m个待装袋的金币，取$\lceil m/2\rceil$ 个金币装入第一个袋子，然后递归求解</li>
</ul>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><ul>
<li>对于一个数m，采用每次分割一半的方法，共分割出$\lfloor lg_2m\rfloor+1$ 个袋子</li>
<li>按照题意，我们需要给出一个k个元素的序列，这个序列有$2^k$ 种选择元素的方法。每种选择法得出一个值。而因为需要能构造出所有可能的值，也就是要构造出$[0,m]$ 内的所有值，共m+1个值，所以$k\geq \lceil lg_2(m+1)\rceil$ </li>
<li>对于$m\geq1$，$\lceil lg_2(m+1)\rceil= \lfloor lg_2m\rfloor+1$</li>
<li>所以我们的解法已经达到了最优</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/17/洛谷2320-鬼谷子的钱袋-形式化证明/" data-id="cjjzt64g8000y6bg4fjol52uz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ACM/">ACM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数学/">数学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/递归/">递归</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-组合数之错排数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/14/组合数之错排数/" class="article-date">
  <time datetime="2018-05-14T13:51:56.000Z" itemprop="datePublished">2018-05-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数学/">数学</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/14/组合数之错排数/">组合数之错排数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="错排数的定义"><a href="#错排数的定义" class="headerlink" title="错排数的定义"></a>错排数的定义</h2><ul>
<li>假设有n个元素，n个位置，每个元素都有自己唯一的正确位置，问，所有元素都处在错误位置有多少可能</li>
</ul>
<h2 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h2><ul>
<li>设$f(n)$ 表示n个元素的错排种数，则$f(n+1)=n*(f(n)+f(n-1))$ </li>
<li>解释如下<ul>
<li>假设已经有n个元素错排，新来一个元素，那么该元素处于已有的n个元素的位置都可以实现错排，所以有$n*f(n)$ 种可能</li>
<li>假设已有n个元素，其中n-1个是错排的，另外一个是正确的，这种情况有n种。新来一个元素，这个元素唯有跟那个正确元素交换位置才可以实现n+1个元素的错排。所以有$n*f(n-2)$ 种可能</li>
</ul>
</li>
<li>为什么没有其他可能？<ul>
<li>因为对于n+1个元素的某个错排来说，假设第$n+1$个元素处于第i位($i\neq n+1$)，然后第$n+1$个位置有第k个元素，那么要么$k=i$ 或者$k\neq i$ ，没有其他可能情况</li>
</ul>
</li>
</ul>
<h2 id="ACM题"><a href="#ACM题" class="headerlink" title="ACM题"></a>ACM题</h2><ul>
<li>hdu2049</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/14/组合数之错排数/" data-id="cjjzt64gf00186bg4rb7r2wan" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ACM/">ACM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/组合数/">组合数</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/错排/">错排</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-天梯L3-007-天梯地图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/13/天梯L3-007-天梯地图/" class="article-date">
  <time datetime="2018-05-13T07:10:04.000Z" itemprop="datePublished">2018-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/13/天梯L3-007-天梯地图/">天梯L3 007 天梯地图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="./天梯L3-007-天梯地图/1.png" alt=""></p>
<h4 id="输入示例一"><a href="#输入示例一" class="headerlink" title="输入示例一"></a>输入示例一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">10 15</span><br><span class="line">0 1 0 1 1</span><br><span class="line">8 0 0 1 1</span><br><span class="line">4 8 1 1 1</span><br><span class="line">5 4 0 2 3</span><br><span class="line">5 9 1 1 4</span><br><span class="line">0 6 0 1 1</span><br><span class="line">7 3 1 1 2</span><br><span class="line">8 3 1 1 2</span><br><span class="line">2 5 0 2 2</span><br><span class="line">2 1 1 1 1</span><br><span class="line">1 5 0 1 3</span><br><span class="line">1 4 0 1 1</span><br><span class="line">9 7 1 1 3</span><br><span class="line">3 1 0 2 5</span><br><span class="line">6 3 1 2 1</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure>
<h4 id="输出示例一"><a href="#输出示例一" class="headerlink" title="输出示例一"></a>输出示例一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time = 6: 5 =&gt; 4 =&gt; 8 =&gt; 3</span><br><span class="line">Distance = 3: 5 =&gt; 1 =&gt; 3</span><br></pre></td></tr></table></figure>
<h4 id="输入示例二"><a href="#输入示例二" class="headerlink" title="输入示例二"></a>输入示例二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">7 9</span><br><span class="line">0 4 1 1 1</span><br><span class="line">1 6 1 3 1</span><br><span class="line">2 6 1 1 1</span><br><span class="line">2 5 1 2 2</span><br><span class="line">3 0 0 1 1</span><br><span class="line">3 1 1 3 1</span><br><span class="line">3 2 1 2 1</span><br><span class="line">4 5 0 2 2</span><br><span class="line">6 5 1 2 1</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure>
<h4 id="输出示例二"><a href="#输出示例二" class="headerlink" title="输出示例二"></a>输出示例二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time = 3; Distance = 4: 3 =&gt; 2 =&gt; 5</span><br></pre></td></tr></table></figure>
<h2 id="Dijstra算法"><a href="#Dijstra算法" class="headerlink" title="Dijstra算法"></a>Dijstra算法</h2><ul>
<li>bfs+优先队列其实就是dijstra算法</li>
<li>dijstra维护result set，源节点到这个set里的点的最短路径已经找到，所以result set只会有node被加进去而不会有node被踢出去</li>
<li>不同于算法导论描述的dijstra算法——算导里的堆是点的堆，所以当发现有新的路径可以以更小的代价到达某点时（该点之前已经在堆里），会使用堆decrease key操作——把这个点的权值减低，并且调整堆使得堆合法。但是stl的优先队列并没有decrease key的操作，所以使用另一种实现——允许某点多次加入到优先队列里——其实就等价于优先队列里放Edge。所以在从优先队列里pop出最小权的点时，要判断该点是否已经处于result set里。这样做会使得复杂度从$O((E+V)lgV)$ 变为$O(ElgE)$ </li>
</ul>
<h2 id="Dijstra找出所有最短路径"><a href="#Dijstra找出所有最短路径" class="headerlink" title="Dijstra找出所有最短路径"></a>Dijstra找出所有最短路径</h2><ul>
<li>从src到dest的路径上的某些节点有多种到达方法——这就导致了多条路径。所以我们要维护所有节点的parent list——无论从哪个parent 到这个节点都是最短的。</li>
<li>具体实现是：从优先队列其pop出某节点，该节点已经处于result set里，但是源节点到该节点的代价与result中的这个节点的路径代价相同，那么这条新的路径就是另一个条到达这个节点的路径。使用一个vector来存储某个节点的parent list——比如<code>vector&lt;int&gt; parent[600]</code> ，则<code>parent[n]</code> 代表的vector就是编号为n的节点的parent list</li>
<li>然后使用dfs去计算所有可能的路径的另外一种代价——比如此题，以时间为权重的最短路径有多条，但是我们还需要计算出这些路径在使用路径长度作为权重时该路径的代价。这一步可以使用记忆化搜索。</li>
</ul>
<h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><h4 id="不可以这样寻找同代价的不同parent-节点"><a href="#不可以这样寻找同代价的不同parent-节点" class="headerlink" title="不可以这样寻找同代价的不同parent 节点"></a>不可以这样寻找同代价的不同parent 节点</h4><ul>
<li><p>代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价</span></span><br><span class="line"><span class="comment">// 其实edge t就代表了节点me</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> me;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    Edge_t(<span class="keyword">int</span> m, <span class="keyword">int</span> h, <span class="keyword">int</span> y) : me(m), p(h), t(y) &#123;&#125; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge_t &amp;x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x.t &lt; <span class="keyword">this</span>-&gt;t; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    Edge_t t = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">while</span> (!que.empty() &amp;&amp; que.top().t == t.t &amp;&amp; que.top().me == t.me)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可能某<code>Edge h</code> 确实跟pop出来的<code>Edge t</code>是代表的是同一个节点——也就是<code>h.me==t.me</code> ，并且代价相同。但是在堆中，还有同等代价的<code>Edge p</code>，其终点不是<code>t.me</code> ——也就是<code>p.me!=t.me</code> ，然后该<code>Edge p</code> 在堆中的位置处在<code>Edge h</code> 前面，所以上面那个while就没办法获得<code>Edge h</code> 从而无法获取完整的parent list。</p>
</li>
<li><p>另一种情况更为严重——如果某边是0权重，那么就可能出现“把t.me加到result set之后，后面的循环才产生出另一条与src到t.me等代价的路径”——所以当pop出<code>Edge t</code> 后立刻寻找同等代价的路径是不行的，因为该边其实还没有进入到堆里</p>
</li>
</ul>
<h4 id="考虑自循环边"><a href="#考虑自循环边" class="headerlink" title="考虑自循环边"></a>考虑自循环边</h4><ul>
<li>直接判断要求某点A邻接的点不与A相同即可实现</li>
</ul>
<h4 id="因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意"><a href="#因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意" class="headerlink" title="因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意"></a>因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意</h4><ul>
<li>dfs递归访问某条路径时要维护已经访问到的节点的列表，确保不重复访问该条路径上已经出现过的点，做法是维护一个visit数组，有点类似回溯法</li>
</ul>
<h4 id="INF的取值要注意"><a href="#INF的取值要注意" class="headerlink" title="INF的取值要注意"></a>INF的取值要注意</h4><ul>
<li>dfs过程中有可能访问的那条路径无法从src到dest，从而递归到最深的那次dfs的调用会返回INF，如果INF是0xFFFFFFF，加上后面的权重，就会溢出，从而使得<code>INF+weight[i]</code>不再是INF</li>
</ul>
<h4 id="自己生成数据对拍时"><a href="#自己生成数据对拍时" class="headerlink" title="自己生成数据对拍时"></a>自己生成数据对拍时</h4><ul>
<li>要注意不要生成多重边，网上很多ac的代码都是不支持多重边的</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj;</span><br><span class="line">&#125;;</span><br><span class="line">Node v[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">int</span> length[<span class="number">600</span>][<span class="number">600</span>]; <span class="comment">// length[i][j]记录从node i到node j的length</span></span><br><span class="line"><span class="keyword">int</span> TIME[<span class="number">600</span>][<span class="number">600</span>]; <span class="comment">// TIME[i][j]记录从node i到node j的用时</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tp[<span class="number">600</span>];<span class="comment">// node's parent list</span></span><br><span class="line"><span class="keyword">int</span> tpResult[<span class="number">600</span>];<span class="comment">// 最终的node的parent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BEGIN, END; <span class="comment">// 题目输入的天梯队员的起点和要到达的终点</span></span><br><span class="line"><span class="keyword">int</span> vertexCnt, edgeCnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> weight[][<span class="number">600</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">bool</span> isLength)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outp</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                TIME[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                length[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            v[i].index = i;</span><br><span class="line">            v[i].adj.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tp[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vertexCnt = n, edgeCnt = m;</span><br><span class="line">        <span class="keyword">int</span> v1, v2, one, l, t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;v1, &amp;v2, &amp;one, &amp;l, &amp;t);</span><br><span class="line">            v[v1].adj.push_back(v2);</span><br><span class="line">            <span class="comment">// 这样做是为了避免输入多重边——比如说从i到j有多条边，那么我们直接选最小代价的边即可</span></span><br><span class="line">            length[v1][v2] = length[v1][v2] &lt; l ? length[v1][v2] : l;</span><br><span class="line">            TIME[v1][v2] = TIME[v1][v2] &lt; t ? TIME[v1][v2] : t;</span><br><span class="line">            <span class="keyword">if</span> (!one) &#123;</span><br><span class="line">                v[v2].adj.push_back(v1);</span><br><span class="line">                length[v2][v1] = length[v2][v1] &lt; l ? length[v2][v1] : l;</span><br><span class="line">                TIME[v2][v1] = TIME[v2][v1] &lt; t ? TIME[v2][v1] : t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;BEGIN, &amp;END);</span><br><span class="line">        <span class="keyword">if</span> (BEGIN == END) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time = "</span></span><br><span class="line">                 &lt;&lt; <span class="string">"0"</span></span><br><span class="line">                 &lt;&lt; <span class="string">"; Distance = "</span></span><br><span class="line">                 &lt;&lt; <span class="string">"0"</span></span><br><span class="line">                 &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; BEGIN &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; END &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time = "</span> &lt;&lt; TIME[BEGIN][END] &lt;&lt; <span class="string">"; Distance = "</span> &lt;&lt; length[BEGIN][END] &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; BEGIN &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; END &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> timeEND = dijstra(TIME);</span><br><span class="line"><span class="comment">//        outp(END, 0);</span></span><br><span class="line">        DFS(<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r1, r2;</span><br><span class="line">        r1.push_back(END);</span><br><span class="line">        <span class="comment">// 以下这种构造路径的方式是建立在起点不同于终点的情况下</span></span><br><span class="line">        <span class="keyword">int</span> tmp_tp = tpResult[END];</span><br><span class="line">        r1.push_back(tmp_tp);</span><br><span class="line">        <span class="keyword">while</span> (tmp_tp != BEGIN) &#123;</span><br><span class="line">            tmp_tp = tpResult[tmp_tp];</span><br><span class="line">            r1.push_back(tmp_tp);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(r1.begin(), r1.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tp[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenEND = dijstra(length);</span><br><span class="line"><span class="comment">//        outp(END, 0);</span></span><br><span class="line">        DFS(<span class="literal">true</span>);</span><br><span class="line">        r2.push_back(END);</span><br><span class="line">        tmp_tp = tpResult[END];</span><br><span class="line">        r2.push_back(tmp_tp);</span><br><span class="line">        <span class="keyword">while</span> (tmp_tp != BEGIN) &#123;</span><br><span class="line">            tmp_tp = tpResult[tmp_tp];</span><br><span class="line">            r2.push_back(tmp_tp);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(r2.begin(), r2.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isSame = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r1.size() == r2.size()) &#123;</span><br><span class="line">            isSame = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r1.size(); i++) &#123;</span><br><span class="line">                isSame = (r1[i] == r2[i]) &amp;&amp; isSame;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSame) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time = "</span> &lt;&lt; timeEND &lt;&lt; <span class="string">"; Distance = "</span> &lt;&lt; lenEND &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r1.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; r1[i] &lt;&lt; <span class="string">" =&gt; "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; r1[r1.size() - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time = "</span> &lt;&lt; timeEND &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r1.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; r1[i] &lt;&lt; <span class="string">" =&gt; "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; r1[r1.size() - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Distance = "</span> &lt;&lt; lenEND &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r2.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; r2[i] &lt;&lt; <span class="string">" =&gt; "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; r2[r2.size() - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> me;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    Edge_t(<span class="keyword">int</span> m, <span class="keyword">int</span> h, <span class="keyword">int</span> y) : me(m), p(h), t(y) &#123;&#125; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge_t &amp;x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x.t &lt; <span class="keyword">this</span>-&gt;t; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs+优先队列其实就是dijstra算法</span></span><br><span class="line"><span class="comment">// dijstra维护result set，源节点到这个set里的点的最短路径已经被找到</span></span><br><span class="line"><span class="comment">// 所以result set只会有node被加进去而不会有node被踢出去</span></span><br><span class="line"><span class="comment">// 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> weight[][<span class="number">600</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> resWei[<span class="number">600</span>];</span><br><span class="line">    priority_queue&lt;Edge_t&gt; que;</span><br><span class="line">    que.push(Edge_t(BEGIN, <span class="number">0</span>, <span class="number">0</span>));<span class="comment">// 后面用到了t.t+weight[t.me][adj[i]]，所以这里必须要取0</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> visit[vertexCnt];  <span class="comment">// 记录某点是否已经加入到dijstra的result set里</span></span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit) * <span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        Edge_t t = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="comment">// 因为这是Edge的堆，可能会有一些边pop出来时，其终点已经在result set里</span></span><br><span class="line">        <span class="keyword">if</span> (visit[t.me]) &#123;</span><br><span class="line">            assert(resWei[t.me] &lt;= t.t);</span><br><span class="line">            <span class="keyword">if</span> (resWei[t.me] == t.t) &#123;</span><br><span class="line">                tp[t.me].push_back(t.p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[t.me] = <span class="literal">true</span>;</span><br><span class="line">        tp[t.me].push_back(t.p);</span><br><span class="line">        resWei[t.me] = t.t;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;adj = v[t.me].adj;</span><br><span class="line">        <span class="keyword">int</span> al = adj.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; al; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj[i] == t.me)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            que.push(Edge_t(adj[i], t.me, t.t + weight[t.me][adj[i]]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resWei[END];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">bool</span> dpVisit[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __dfs(<span class="keyword">int</span> f, <span class="keyword">bool</span> isLength);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">bool</span> isLength)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(tpResult, <span class="number">0</span>, <span class="keyword">sizeof</span>(tpResult));</span><br><span class="line">    <span class="built_in">memset</span>(dpVisit, <span class="number">0</span>, <span class="keyword">sizeof</span>(dpVisit));</span><br><span class="line">    <span class="keyword">return</span> __dfs(END, isLength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __dfs(<span class="keyword">int</span> f, <span class="keyword">bool</span> isLength) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[f] &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[f];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f == BEGIN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;t = tp[f];</span><br><span class="line">    <span class="keyword">int</span> result = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]==f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (dpVisit[t[i]])  <span class="comment">// 代表该节点在这条路径上已经被访问过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dpVisit[f] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = __dfs(t[i], isLength) + (isLength ? <span class="number">1</span> : length[t[i]][f]);</span><br><span class="line">        dpVisit[f] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; result) &#123;</span><br><span class="line">            tpResult[f] = t[i];</span><br><span class="line">            result = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[f] = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> path[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">bool</span> outpVisit[<span class="number">600</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outp</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    outpVisit[f] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (f == BEGIN) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"outp: "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        outpVisit[f] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path[index] = f;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;t = tp[f];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outpVisit[t[i]])<span class="comment">// means that 前辈们已经访问过了，再访问就成环了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        outp(t[i], index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    outpVisit[f] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/13/天梯L3-007-天梯地图/" data-id="cjjzt64g3000s6bg4yocx9nr3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dijstra最短路/">Dijstra最短路</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/天梯赛/">天梯赛</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-有限存储的计算机等价于有限自动机（DFA、NFA）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/" class="article-date">
  <time datetime="2018-05-11T08:13:18.000Z" itemprop="datePublished">2018-05-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算理论/">计算理论</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/">有限存储的计算机等价于有限自动机（DFA、NFA）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="B-0-n1-n-n-ge0"><a href="#B-0-n1-n-n-ge0" class="headerlink" title="$B=\{0^n1^n|n\ge0\}$"></a>$B=\{0^n1^n|n\ge0\}$</h3><ul>
<li>Michael Sipser 的 <em>Introduction to the Theory of Computation</em> 的1.4提到一个非正则语言的例子，$B=\{0^n1^n|n\ge0\}$ ，并用Pumping lemma证明了其是非正则的，无法被DFA识别</li>
<li>但是我们的计算机似乎可以识别以上语言，所以，为什么我们的计算机还是DFA呢</li>
<li>事实上，我们的计算机只能识别n处于一定范围的B，而不能识别n为任意值的B。如果n过大，我们的计算机的存储单元无法表达，则会发生溢出，导致识别了另一个语言 $C=\{0^n1^m|n\ mod\ max=m\ mod\ max\}$ ，其中，max是我们的计算机的存储单元可以表达的最大值</li>
<li>如果是n处于一定范围内，容易构造出一台DFA识别B：<ul>
<li>设有两个变量a、b，a、b都可以取值$[0,1000]$ ，a表示0的数量，b表示1的数量</li>
<li>那么，a、b的所有笛卡尔积组成的集合的一个子集就是该DFA的状态集</li>
<li>转移方程为<ul>
<li>首先： $&lt;0,0&gt;\rightarrow&lt;1,0&gt;\rightarrow&lt;2,0&gt;\rightarrow…\rightarrow&lt;1000,0&gt;$</li>
<li>然后：从任意$&lt;n,0&gt;$ 都可以转移到 $&lt;n,1&gt;$</li>
<li>然后：一旦转移到 $&lt;n,1&gt;$ ，就不能转移到 $&lt;n+k,m&gt;, (k&gt;0)$ ，也就是不能增长n的值</li>
<li>最后：一旦转移到 $&lt;n, n&gt;$ 就accept</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="为什么现实中的计算机有可能是DFA"><a href="#为什么现实中的计算机有可能是DFA" class="headerlink" title="为什么现实中的计算机有可能是DFA"></a>为什么现实中的计算机有可能是DFA</h3><ul>
<li>计算机只有有限存储，such as，某计算机有$2^{32}$ 个8bit的cell，每个cell有 $2^8$ 种取值，所以，所有存储的取值有 $(2^8)^{2^{32}}$ 种，也就是，这台计算机的存储只能有 $(2^8)^{2^{32}}$ 种状态，这就使得把计算机转为DFA变为可能</li>
</ul>
<h3 id="对任意一段代码构造等价的NFA"><a href="#对任意一段代码构造等价的NFA" class="headerlink" title="对任意一段代码构造等价的NFA"></a>对任意一段代码构造等价的NFA</h3><h5 id="NFA构造方法描述"><a href="#NFA构造方法描述" class="headerlink" title="NFA构造方法描述"></a>NFA构造方法描述</h5><ul>
<li>假设该段代码的运行过程会改变的存储cell有c1、c2、c3、c4、c5，其中，c1到c5的取值范围都是[0,0xFF]，那么就可以构造$(2^8)^5$ 个$&lt;c1,c2,c3,c4,c5&gt;$ ，作为该NFA的状态集合。（注意，cs:ip 寄存器的值必然是这五个cell中的一个）</li>
</ul>
<ul>
<li>输入字符表是$\{0,1\}$ ，将所有计算机接受的输入全部编码成bit 串后读入该DFA，每次读一个0或者一个1。</li>
</ul>
<ul>
<li>假设该代码起始时，c1到c5的取值为$0,0,0,0,0$ ，则$&lt;0,0,0,0,0&gt;$ 就是起始态</li>
<li>假设该段代码处于accept状态时，c1到c5的取值分别为$1,2,3,4,5$ ，那么，$&lt;1,2,3,4,5&gt;$ 就是该NFA的accept state</li>
<li>该代码可以有输入，也可以无输入，可以在多个时候输入，也可以只在一个时候输入。假设其某次输入处于$&lt;d1,d2,d3,d4,d5&gt;$ ，输入后处于 $&lt;d6,d7,d8,d9,d10&gt;$ ，则在从$&lt;d1,d2,d3,d4,d5&gt;$ 到 $&lt;d6,d7,d8,d9,d10&gt;$ 是一个转移，转移使用的字符就是读入的字符。该代码也可以在无输入情况下由cpu作用，从一个状态转移到另一个状态，则在这两个状态之间使用$\varepsilon$ </li>
</ul>
<h5 id="为什么该NFA只接受允许的字符串，而不会接受多余的字符串"><a href="#为什么该NFA只接受允许的字符串，而不会接受多余的字符串" class="headerlink" title="为什么该NFA只接受允许的字符串，而不会接受多余的字符串"></a>为什么该NFA只接受允许的字符串，而不会接受多余的字符串</h5><ul>
<li>首先，可以使用以上方法对于每个接受的字符串都构造NFA，则该NFA只接受允许的那个字符串</li>
<li>设置一个新的起始态，该起始态有$\varepsilon$ 到所有为每个字符串构造的NFA</li>
<li>则最终的NFA只接受允许的字符串</li>
</ul>
<h5 id="是否会出现情况：代码两次处于某状态但是行为不一样"><a href="#是否会出现情况：代码两次处于某状态但是行为不一样" class="headerlink" title="是否会出现情况：代码两次处于某状态但是行为不一样"></a>是否会出现情况：代码两次处于某状态但是行为不一样</h5><ul>
<li>答案是肯定不会</li>
<li>计算机的行为由当前状态决定——下一步要执行什么代码，取决于正在被执行的代码段，以及ip寄存器的值，如果text段的内容相同，cs:ip寄存器的相同，指令使用的值也相同，那么下一步的行为就是确定的</li>
</ul>
<h3 id="对任意一台计算机构造等价的DFA"><a href="#对任意一台计算机构造等价的DFA" class="headerlink" title="对任意一台计算机构造等价的DFA"></a>对任意一台计算机构造等价的DFA</h3><ul>
<li>对于一台确定的计算机可以构造出确定的DFA，执行该计算机可以做的任何计算</li>
<li>先说明一些前置情况：<ul>
<li>现实中计算机使用源码处理特定的输入</li>
<li>把现实中计算机处理该输入的源码编码成确定长度（统一取最大长度M——M是该计算机可以存储的最长比特串长度，比如$2^{40}$比特）的字符串，每个字符表示一个指令——这个其实等价于把源码编译成机器码（每个机器指令由一样的长度的比特串表示），然后把这个比特串补全成统一长度M</li>
</ul>
</li>
<li>因为源码是M比特长，所以最多有$2^M$ 种不同的源码，根据上文，可以为每种源码构造一个DFA</li>
<li>然后开始构造DFA<ul>
<li>该DFA分为两个部分：第一个部分解释输入的源码字符串，第二个部分实际运行输入的源码来跑输入的数据——即实际运行$2^M$ 个不同的DFA中的一个</li>
<li>DFA第一个部分，其读入长度M的字符串（也就是源码），从而把该台DFA导向某个状态，这个状态是$2^M$ 个实际运行代码的DFA中的一个的起始态</li>
<li>第二部分就是那$2^M$ 台DFA，其接受输入，并最终停在某个状态——accept态或者是其他状态</li>
</ul>
</li>
<li>从而该DFA接受$\cup A_i$ ，其中$A_i$ 是该计算机可以运行的任意一段代码接受的字符串集合</li>
</ul>
<h3 id="计算机可以死循环，DFA不会死循环，为什么"><a href="#计算机可以死循环，DFA不会死循环，为什么" class="headerlink" title="计算机可以死循环，DFA不会死循环，为什么"></a>计算机可以死循环，DFA不会死循环，为什么</h3><ul>
<li>consider that，死循环指的是无输入情况下，不停机，而不是无限输入导致的不停机。</li>
</ul>
<ul>
<li><p>因为计算机的状态是有限的，所以，如果计算机死循环，那么其必然会重复处于某个状态，进而导致行为的重复——因为计算机的当前状态唯一确定了以后的行为。</p>
</li>
<li><p>在NFA，这种情况死循环的状况也会发生——一组状态以$\varepsilon$ 连接在一起形成环，从而导致无限读入$\varepsilon$ ，无限循环</p>
</li>
<li><p>截断导致NFA死循环的那个环，并不会影响接受的语言。假设该环是s1、s2、s3、s1，那么我们可以把其变成三条路：“s1、s2、s3”，“s2、s3、s1”，“s3、s1、s2” ，非形式化来说，因为这不会改变该图的连通性，所以接受的字符串集合不变</p>
</li>
<li><p>而按照<em>Introduction to the Theory of Computation</em> 的1.2节的<em>EQUIVALENCE OF NFAS AND DFAS</em>DFA 描述的方法，其正是去掉了这种$\varepsilon$ 环，所以不会死循环，具体去掉的方法如下（截图来自书本英文第三版P56）：</p>
<p><img src="./有限存储的计算机等价于有限自动机（DFA、NFA）/1.png" alt=""></p>
<p>$E(R)$ 是一个集合，集合中元素不重复，而$\varepsilon$ 环所到达的状态必然是重复的，所以就把$\varepsilon$ 环断开了</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/" data-id="cjjzt64ga00146bg4zismo5v8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DFA/">DFA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NFA/">NFA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/有限自动机/">有限自动机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算理论/">计算理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-n元逆序对数量求解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/n元逆序对数量求解/" class="article-date">
  <time datetime="2018-03-19T16:05:01.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/20/n元逆序对数量求解/">n元逆序对数量求解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>以下思路都是针对从小到大排序的序列的逆序对</p>
</blockquote>
<ul>
<li>首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对</li>
<li>主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量</li>
<li>假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]</li>
<li>首先看看如何求二元逆序对<ul>
<li>从左到右扫描序列，对于序列中位置为<code>i</code>的值<code>x</code>，flag[x]+=1</li>
<li>然后此时，以该x结尾的逆序对的数量就是$\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]</li>
<li>那么result的数组的和就是逆序对的数量</li>
<li>同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对</li>
</ul>
</li>
<li>三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n];<ul>
<li>同样扫描序列，对于位置为<code>i</code>的数<code>x</code>，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量</li>
<li>求$\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中</li>
<li>到最后，result_3就是结果</li>
</ul>
</li>
<li>更多元组的也如此思路</li>
<li>这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对</li>
<li>对于n元逆序对，同理，数组记录了当前已有的数<code>x</code>作为<code>最后一个元素是x的n-1元逆序对</code>的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与<code>比他大的数代表的n-1元逆序对</code>形成了更长的逆序对</li>
<li>然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第<code>i</code>位的值是<code>x</code>）</li>
</ul>
<blockquote>
<p>3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/n元逆序对数量求解/" data-id="cjjzt64fr000d6bg4ax61ft92" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/树状数组/">树状数组</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-printf的一个异常现象引发的对x86-64体系下可变参数传参的探究" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/" class="article-date">
  <time datetime="2018-01-19T03:31:36.000Z" itemprop="datePublished">2018-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP/">CSAPP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/">printf的一个异常现象引发的对x86-64体系下可变参数传参的探究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang version 3.8.1-24 (tags/RELEASE_381/final)</span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line"></span><br><span class="line">Linux version 4.9.0-deepin13-amd64 (yangbo@deepin.com) (gcc version 6.3.0 20170321 (Debian 6.3.0-11) ) #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19)</span><br></pre></td></tr></table></figure>
<h3 id="奇异现象复现"><a href="#奇异现象复现" class="headerlink" title="奇异现象复现"></a>奇异现象复现</h3><ul>
<li><p>代码</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">6.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lx\n"</span>	, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<p><img src="printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p6.png" alt=""></p>
</li>
<li><p>这段代码用的运行结果是随机的，无规律的，这是非常奇怪的</p>
</li>
</ul>
<h3 id="先说原因"><a href="#先说原因" class="headerlink" title="先说原因"></a>先说原因</h3><ul>
<li>printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 <code>a</code> 因为是double类型，所以放在xmm0寄存器。</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>先看glibc-2.26中<code>stdio-common/printf.c</code>的源码</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__printf (<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list arg;</span><br><span class="line">  <span class="keyword">int</span> done;</span><br><span class="line"></span><br><span class="line">  va_start (arg, format);</span><br><span class="line">  done = <span class="built_in">vfprintf</span> (<span class="built_in">stdout</span>, format, arg);</span><br><span class="line">  va_end (arg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到，使用的是stdarg的机制实现可变参数传参。</p>
</li>
<li><p>如果可变参数完全使用栈帧传递，那么结果不可能是随机的。那么只可能是使用寄存器传参</p>
</li>
<li><p>复习一下CSAPP第三章</p>
<p> <img src="./printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p1.png" alt=""></p>
<p> <img src="./printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p2.png" alt=""></p>
</li>
<li><p>可以看到，浮点参数的传参使用的是SIMD寄存器，而整形使用的是通用目的寄存器</p>
</li>
<li>那么猜测，这应该是问题所在。printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 <code>a</code> 因为是double类型，所以放在xmm0寄存器。</li>
</ul>
<h3 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h3><ul>
<li><p>使用 <code>clang -S d.c &amp;&amp;  clang d.s -g</code>命令编译上面那段问题代码。这样我们就可以在gdb里针对汇编指令设置断点</p>
</li>
<li><p>main函数部分汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subq	$16, %rsp</span><br><span class="line">movabsq	$.L.str, %rdi		# .L.str就是&quot;%lx\n&quot;</span><br><span class="line">movsd	.LCPI0_0, %xmm0    	</span><br><span class="line"># 字面量的浮点放在内存，.LCPI0_0引用的就是 double 类型的 6.0</span><br><span class="line">movsd	%xmm0, -8(%rbp)</span><br><span class="line">movsd	-8(%rbp), %xmm0        </span><br><span class="line">movb	$1, %al</span><br><span class="line">callq	printf</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到，double a 确实放在了xmm0,</p>
</li>
<li><p>用GDB在 <code>callq printf</code> 处设置断点(注意，运行到断点处，callq printf指令还没有执行)，检查用于传参的前四个通用目的寄存器</p>
<p><img src="./printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p4.png" alt=""></p>
<p>（红框内是前四个传参的通用目的寄存器）</p>
</li>
<li><p>执行gdb 的<code>next</code>指令 ，运行<code>callq printf</code>这条指令，检查输出</p>
<p><img src="./printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p3.png" alt=""></p>
</li>
<li><p>可以看到，与<code>rsi</code>寄存器的内容一样。可以初步确认，因为格式字符串是”%lx”，所以printf在通用目的寄存器读取可变参数</p>
</li>
<li><p>手动修改汇编代码，在callq printf之前加上一条<code>movq $16, %rsi</code>（注意，此处是十进制，而printf使用的格式字符串是”%lx”，所以程序输出的是十六进制）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movabsq	$.L.str, %rdi</span><br><span class="line">movsd	.LCPI0_0, %xmm0         # xmm0 = mem[0],zero</span><br><span class="line">movsd	%xmm0, -8(%rbp)</span><br><span class="line">movsd	-8(%rbp), %xmm0         # xmm0 = mem[0],zero</span><br><span class="line">movb	$1, %al</span><br><span class="line">movq    $16, %rsi 				# 这一条就是加上去的</span><br><span class="line">callq	printf</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行，结果是</p>
<p><img src="./printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p5.png" alt=""></p>
</li>
<li><p>符合预期，与rsi寄存器的东西一样</p>
</li>
<li><p>分析结果得到证实</p>
</li>
</ul>
<h3 id="探究过程出现的一些问题"><a href="#探究过程出现的一些问题" class="headerlink" title="探究过程出现的一些问题"></a>探究过程出现的一些问题</h3><ul>
<li>在不合时宜的时刻检查寄存器的值<ul>
<li>执行完<code>callq printf</code>后才检查xmm0、xmm1的内容，企图找到double a</li>
<li>执行完<code>callq printf</code>后才检查rdi、rsi的值。</li>
</ul>
</li>
<li>因为printf函数会使用这些寄存器，所以这样检查必然是不行的</li>
</ul>
<h3 id="关于vc-的一些补充"><a href="#关于vc-的一些补充" class="headerlink" title="关于vc++的一些补充"></a>关于vc++的一些补充</h3><ul>
<li><p><a href="https://msdn.microsoft.com/zh-cn/library/zthk2dkh.aspx" target="_blank" rel="noopener">Visual Studio 2015的参数传递文档</a></p>
<p><img src="./printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p8.png" alt=""></p>
<p><img src="./printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p7.png" alt=""></p>
<p>​    <strong>注意：这里的b不是在xmm0，而是在xmm1，d也是如此</strong></p>
</li>
</ul>
<ul>
<li><p><a href="https://msdn.microsoft.com//library/dd2wa36c.aspx" target="_blank" rel="noopener">Visual Studio 2015 的 Varargs文档 </a></p>
<blockquote>
<p> 如果参数是通过 vararg（例如省略号参数）传递的，则基本上会应用正常的参数传递过程，包括溢出第五个及后续参数。 此外，被调用方的责任是转储采用其地址的参数。<strong>仅处理浮点值时，如果被调用方要使用整数寄存器中的值，整数寄存器和浮点寄存器才会同时包含浮点值</strong></p>
<p> if parameters are passed via varargs (for example, ellipsis arguments), then essentially the normal parameter passing applies including spilling the fifth and subsequent arguments. It is again the callee’s responsibility to dump arguments that have their address taken. <strong>For floating-point values only, both the integer and the floating-point register will contain the float value in case the callee expects the value in the integer registers.</strong></p>
</blockquote>
</li>
<li><p>按照我的理解，加粗部分应该是说，如果实参里有integer也有float-point，那么我们在整形寄存器也可以读取到对应序号的浮点寄存器的值，<strong>比如test(3, 2.0, 1)，那么2.0既存在于RDX，也存在于XMM1， 1既存在于R8，也存在于xmm2。</strong>这样，我们使用stdarg的va_arg(ap, long long)读取第二个参数2.0时，就不会出错。如果是gcc，就会出错，因为gcc并不会把浮点放在整形寄存器。</p>
</li>
<li><p>这应该是微软为了兼容以前的老代码，以前可变参都是放在栈上，所以改变va_arg的第二个实参type也不会读错，只会形成强制类型转换。（由于手头没有vc++的编译器，只能借助跟师兄的远程合作来探究，所以这里只有部分猜测被证实，读者可以自己测试一下是否在对应序号的整形寄存器和浮点寄存器存在相同的内容）</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/" data-id="cjjzt64fs000e6bg4bfu7sml1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/">CSAPP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/printf/">printf</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/底层/">底层</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-从时间戳（毫秒）计算日历" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/02/从时间戳（毫秒）计算日历/" class="article-date">
  <time datetime="2017-10-02T08:58:15.000Z" itemprop="datePublished">2017-10-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/02/从时间戳（毫秒）计算日历/">从时间戳（毫秒）计算日历</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hour;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minute;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerSecond = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerMinute = <span class="number">1000</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerHour = <span class="number">3600</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerDay = <span class="number">24</span>*<span class="number">3600</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerPingNian = <span class="number">365</span>*timePerDay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerLeapYear = <span class="number">366</span>*timePerDay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeOf1970And1971 = timePerPingNian+timePerPingNian;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePer4Year = (<span class="keyword">long</span>)(<span class="number">365.25</span>*<span class="number">4</span>*timePerDay);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeEvery400Year = timePer4Year*<span class="number">100</span> - <span class="number">3</span>*timePerDay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeOf1970To2000 = timePer4Year*<span class="number">7</span>+timeOf1970And1971;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] daysPerMonth = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setMinuteAndSecond</span><span class="params">(<span class="keyword">long</span> milliTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> milliTime&lt;timePerDay;</span><br><span class="line">        <span class="keyword">if</span>(milliTime&gt;=timePerDay)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        hour = (<span class="keyword">int</span>)(milliTime/timePerHour);</span><br><span class="line">        <span class="keyword">long</span> t = milliTime%timePerHour;</span><br><span class="line">        minute = (<span class="keyword">int</span>)(t/timePerMinute);</span><br><span class="line">        t = t%timePerMinute;</span><br><span class="line">        second = (<span class="keyword">int</span>)(t/timePerSecond);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setMonthAndDay</span><span class="params">(<span class="keyword">long</span> milliTime, <span class="keyword">boolean</span> isLeapYear)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//this func should handle  the case where milliTime == 0;</span></span><br><span class="line">        <span class="comment">//this func get the milliseconds within 1 year;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> milliTime&lt;=timePerLeapYear &amp;&amp; isLeapYear || milliTime&lt;=timePerPingNian &amp;&amp; !isLeapYear;</span><br><span class="line">        <span class="keyword">if</span>(milliTime&gt;timePerLeapYear &amp;&amp; isLeapYear || milliTime&gt;timePerPingNian &amp;&amp; !isLeapYear) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        daysPerMonth[<span class="number">1</span>] = isLeapYear ? <span class="number">29</span> : <span class="number">28</span>; <span class="comment">//set the days of February;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            milliTime -= daysPerMonth[++cnt]*timePerDay;</span><br><span class="line">        &#125;<span class="keyword">while</span> (milliTime&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        month = cnt+<span class="number">1</span>;  <span class="comment">//for that the cnt begin from 0, but month begin from 1;</span></span><br><span class="line">        <span class="keyword">long</span> timeOfLastMonth = daysPerMonth[cnt]*timePerDay+milliTime;</span><br><span class="line">        day = (<span class="keyword">int</span>)(timeOfLastMonth/timePerDay)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        setMinuteAndSecond(timeOfLastMonth % timePerDay);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setDataFile</span><span class="params">(<span class="keyword">long</span> milliTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(milliTime&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> is1970Or1971 = milliTime&lt;timeOf1970And1971 ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> is20Century = milliTime&lt;timeOf1970To2000 ? <span class="keyword">true</span>: <span class="keyword">false</span>; </span><br><span class="line">       	<span class="comment">//if equal is 2000 1 1 0:0:0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is1970Or1971) &#123;</span><br><span class="line">            year = milliTime&gt;=timePerPingNian ? <span class="number">1971</span> : <span class="number">1970</span>;</span><br><span class="line">            setMonthAndDay(year==<span class="number">1971</span> ? milliTime-timePerPingNian : milliTime, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is20Century) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = (milliTime-timeOf1970And1971)/timePer4Year;  </span><br><span class="line">            <span class="keyword">long</span> t1 = milliTime-timeOf1970And1971-t*timePer4Year;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> t2 = t1-timePerLeapYear;</span><br><span class="line">            <span class="keyword">boolean</span> isLeapYear = t2&lt;<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> t3 = isLeapYear ? <span class="number">0</span> : t2/timePerPingNian+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            year = (<span class="keyword">int</span>)(<span class="number">1972</span>+t*<span class="number">4</span>+t3);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> l = isLeapYear ? t1 : (t1-t3*timePerPingNian-timePerDay);</span><br><span class="line">            setMonthAndDay(l, isLeapYear);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> p = milliTime-timeOf1970To2000;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t1 = p/timeEvery400Year;</span><br><span class="line">        <span class="keyword">long</span> p1 = p-t1*timeEvery400Year;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t2 = p1/timePer4Year;</span><br><span class="line">        <span class="keyword">long</span> tN = t2/<span class="number">25</span>;    </span><br><span class="line">      	<span class="comment">//in every 400 years, other year such as xy00(y!=0) is not leap year;</span></span><br><span class="line">        </span><br><span class="line">      	<span class="keyword">long</span> p2 = p1-t2*timePer4Year;</span><br><span class="line">        p2 += tN*timePerDay;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t3 = p2-timePerLeapYear;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isLeapYear = t3&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> t4 = isLeapYear ? <span class="number">0</span> : t3/timePerPingNian+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        year = (<span class="keyword">int</span>)(<span class="number">2000</span>+t1*<span class="number">400</span>+t2*<span class="number">4</span>+t4);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> lt = isLeapYear ? p2 : (p2-t4*timePerPingNian-timePerDay);</span><br><span class="line">        setMonthAndDay(lt, isLeapYear);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="设置时分秒（函数setMinuteAndSecond）"><a href="#设置时分秒（函数setMinuteAndSecond）" class="headerlink" title="设置时分秒（函数setMinuteAndSecond）"></a>设置时分秒（函数setMinuteAndSecond）</h4><ul>
<li>函数的输入是 小于 每天毫秒数  的一个整数</li>
<li>因为是从0:0:0开始计时，所以很好算</li>
<li>直接除以每小时毫秒数，结果就是 要求的小时数</li>
<li>然后把取模每小时毫秒数的结果除以每分钟毫秒数，算出来的结果就是分钟数</li>
<li>以此类推，算出秒数</li>
</ul>
<h4 id="设置月和日（函数setMonthAndDay）"><a href="#设置月和日（函数setMonthAndDay）" class="headerlink" title="设置月和日（函数setMonthAndDay）"></a>设置月和日（函数setMonthAndDay）</h4><ul>
<li>函数的输入为  小于  每年毫秒数  一个整数</li>
<li>依次减去每个月的毫秒数，当减去某个月后，得到负数，说明月份就是这个月。<strong>注意，如果减去后得到0，则是下个月的第一毫秒，因为毫秒数是相对1970.1.1.0:0:0计算的。举个例子，毫秒数==一个平年的毫秒数，那么加上1970.1.1.0:0:0后，就变成1971.1.1.0:0:0，而不是1970.12.31.23:59:59</strong></li>
<li>通过上面那个流程，得到属于一个月内的毫秒数（注意，比如说某个月的毫秒数是K，那么0~(K-1)都是属于这个月，但是K不是），然后除以每天的毫秒数，得到 P 。同样，如果整除，说明日期数是 P+1，如果不整除，那也是 P+1（注意，日期是从1开始，而不是从0开始）</li>
</ul>
<h4 id="设置年份（在函数setDataFile中）"><a href="#设置年份（在函数setDataFile中）" class="headerlink" title="设置年份（在函数setDataFile中）"></a>设置年份（在函数setDataFile中）</h4><ul>
<li><p>对1970/1971特殊处理，直接判断是否毫秒数是否 $\geq$ 一个平年的毫秒数，如果是，那么就是1971。<strong>注意，等于也是，原因如上所述。</strong>然后调用setMonthAndDay函数，设置日月</p>
</li>
<li><p>对1972.1.1.0:0:0到2000.1.1.0:0:0 特殊处理。先减去1970和1971的总的毫秒数，得到的结果除以每4年的毫秒数，得到H。同样，无论是否整除，年份数是在$[4H+1972, 4H+1972+3]$，整除就是$4H+1972$这一年的第一毫秒（0时0分0秒）。因为1970.1.1.0:0:0加上1970和1971总的毫秒数已经是1972.1.1.0:0:0了，再加上整数年$4H$就是(1972+4H).1.1.0:0:0了。</p>
<p>然后减去一个闰年的毫秒数，因为从1972年算起，每四年的第一年都是闰年，如果结果是负数，说明是闰年（同样的，如果是0，那么并不是闰年，而是闰年下一年的第一毫秒）。否则，把得到结果除以每个平年的毫秒数得到 P ，就是从闰年的下一年 开始的第 P 年，所以，年份就是$1972+4H+1+P$</p>
</li>
<li><p>然后，因为当年份数是100的倍数时，只有当年份可以被400整除，才是闰年。而2000年正好就是每400年里的第一年，所以要先计算，毫秒数里总的有多少个400年，如果有 $t$ 个，那么年份数就是$[2000+400t, 2000+400t+399]$</p>
<p>接下来就计算总的毫秒数减去1970到2000的毫秒数，再减去总共多少个400年的毫秒数，剩下的毫秒数里，算算有多少个4年，因为每4年是闰年。如果算出来的结果是$d$，那么年份数就是$[2000+400t+4d,2000+400t+4d+3]$</p>
<p>接下来判断剩下的毫秒数是否小于一个闰年的毫秒数，如果是，那么就是闰年，年份数是$2000+400t+4d$。如果不是，就减去一个闰年的毫秒数，然后算一算剩下的有多少个平年的毫秒数，假设算出来的结果是$b$，那么年份数就是$2000+400t+4d+b+1$</p>
<p>接下来调用setMonthAndDay函数设置月份日期</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/02/从时间戳（毫秒）计算日历/" data-id="cjjzt64fw000l6bg4pvnftt99" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日历/">日历</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/时间戳/">时间戳</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP/">CSAPP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发/">开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算理论/">计算理论</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACM/">ACM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP/">CSAPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP-Homework/">CSAPP Homework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP-Lab/">CSAPP Lab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFA/">DFA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijstra最短路/">Dijstra最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GUI/">GUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NFA/">NFA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/">Qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/clipboard/">clipboard</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/printf/">printf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xterm-clipboard/">xterm_clipboard</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/天梯赛/">天梯赛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/底层/">底层</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日历/">日历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/时间戳/">时间戳</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/有限自动机/">有限自动机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树状数组/">树状数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/汇编/">汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/系统剪切板/">系统剪切板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合数/">组合数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算理论/">计算理论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归/">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/错排/">错排</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ACM/" style="font-size: 20px;">ACM</a> <a href="/tags/CSAPP/" style="font-size: 10px;">CSAPP</a> <a href="/tags/CSAPP-Homework/" style="font-size: 10px;">CSAPP Homework</a> <a href="/tags/CSAPP-Lab/" style="font-size: 16.67px;">CSAPP Lab</a> <a href="/tags/DFA/" style="font-size: 10px;">DFA</a> <a href="/tags/Dijstra最短路/" style="font-size: 10px;">Dijstra最短路</a> <a href="/tags/GUI/" style="font-size: 10px;">GUI</a> <a href="/tags/Leetcode/" style="font-size: 10px;">Leetcode</a> <a href="/tags/NFA/" style="font-size: 10px;">NFA</a> <a href="/tags/Qt/" style="font-size: 10px;">Qt</a> <a href="/tags/clipboard/" style="font-size: 10px;">clipboard</a> <a href="/tags/printf/" style="font-size: 10px;">printf</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/xterm-clipboard/" style="font-size: 10px;">xterm_clipboard</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/天梯赛/" style="font-size: 10px;">天梯赛</a> <a href="/tags/底层/" style="font-size: 10px;">底层</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/数学/" style="font-size: 10px;">数学</a> <a href="/tags/日历/" style="font-size: 10px;">日历</a> <a href="/tags/时间戳/" style="font-size: 10px;">时间戳</a> <a href="/tags/有限自动机/" style="font-size: 10px;">有限自动机</a> <a href="/tags/树状数组/" style="font-size: 10px;">树状数组</a> <a href="/tags/汇编/" style="font-size: 10px;">汇编</a> <a href="/tags/算法/" style="font-size: 13.33px;">算法</a> <a href="/tags/系统剪切板/" style="font-size: 10px;">系统剪切板</a> <a href="/tags/组合数/" style="font-size: 10px;">组合数</a> <a href="/tags/计算理论/" style="font-size: 10px;">计算理论</a> <a href="/tags/递归/" style="font-size: 10px;">递归</a> <a href="/tags/错排/" style="font-size: 10px;">错排</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/20/LeetCode-11-Container-With-Most-Water/">LeetCode 11.Container With Most Water</a>
          </li>
        
          <li>
            <a href="/2018/06/05/vim不支持系统剪切板的解决方案/">vim 不支持系统剪切板的解决方案</a>
          </li>
        
          <li>
            <a href="/2018/05/20/洛谷2577-午餐/">洛谷2577 午餐</a>
          </li>
        
          <li>
            <a href="/2018/05/17/洛谷2320-鬼谷子的钱袋-形式化证明/">洛谷2320 鬼谷子的钱袋 形式化证明</a>
          </li>
        
          <li>
            <a href="/2018/05/14/组合数之错排数/">组合数之错排数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>