<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.0.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: false,
    messageStyle: "none",
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath:  [ ["$", "$"] ],
        displayMath: [ ["$$","$$"] ],
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a'],
        ignoreClass:"comment-content"
    },
    "HTML-CSS": {
        availableFonts: ["STIX","TeX"],
        showMathMenu: false
    }
});
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  




  <meta name="description" content="以下大部分是《java并发编程实战》的笔记，以JCIP简称之  对象的状态 （非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象） 对象的状态中包含了任何可能影响其外部可见行为的数据  线程安全性的定义 正确性的含义 某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，">
<meta property="og:type" content="article">
<meta property="og:title" content="My Java Concurrent Note">
<meta property="og:url" content="https://h-zex.github.io/2019/03/02/Java-Concurrent-Note/index.html">
<meta property="og:site_name" content="H-ZeX">
<meta property="og:description" content="以下大部分是《java并发编程实战》的笔记，以JCIP简称之  对象的状态 （非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象） 对象的状态中包含了任何可能影响其外部可见行为的数据  线程安全性的定义 正确性的含义 某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-03-02T04:52:40.822Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Java Concurrent Note">
<meta name="twitter:description" content="以下大部分是《java并发编程实战》的笔记，以JCIP简称之  对象的状态 （非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象） 对象的状态中包含了任何可能影响其外部可见行为的数据  线程安全性的定义 正确性的含义 某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，">



  <link rel="alternate" href="/atom.xml" title="H-ZeX" type="application/atom+xml"/>




  <link rel="canonical" href="https://h-zex.github.io/2019/03/02/Java-Concurrent-Note/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>My Java Concurrent Note | H-ZeX</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">H-ZeX</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">H-ZeX's Coding Life</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archives</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-友情链接">

    
    
    
      
    

    

    <a href="/link" rel="section"><i class="menu-item-icon fa fa-fw fa-link"></i> <br/>友情链接</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://h-zex.github.io/2019/03/02/Java-Concurrent-Note/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="H-ZeX"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H-ZeX"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">My Java Concurrent Note

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-02 12:49:04 / Modified: 12:52:40" itemprop="dateCreated datePublished" datetime="2019-03-02T12:49:04+08:00">2019-03-02</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaConcurrent/" itemprop="url" rel="index"><span itemprop="name">JavaConcurrent</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <a href="/2019/03/02/Java-Concurrent-Note/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments: </span> <span class="post-comments-count valine-comment-count" data-xid="/2019/03/02/Java-Concurrent-Note/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>以下大部分是《java并发编程实战》的笔记，以<code>JCIP</code>简称之</p>
</blockquote>
<h3 id="对象的状态"><a href="#对象的状态" class="headerlink" title="对象的状态"></a>对象的状态</h3><ul>
<li>（非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象）</li>
<li>对象的状态中包含了任何可能影响其外部可见行为的数据</li>
</ul>
<h3 id="线程安全性的定义"><a href="#线程安全性的定义" class="headerlink" title="线程安全性的定义"></a>线程安全性的定义</h3><ul>
<li>正确性的含义<ul>
<li>某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件来描述对象操作的结果</li>
</ul>
</li>
<li>当多个线程访问某个类时，这个类始终能够表现出正确的行为，那么就称这个类是线程安全的</li>
</ul>
<h3 id="JCIP中“同步”的含义"><a href="#JCIP中“同步”的含义" class="headerlink" title="JCIP中“同步”的含义"></a>JCIP中“同步”的含义</h3><ul>
<li>synchronized关键字</li>
<li>volatile变量</li>
<li>显式锁</li>
<li>原子变量</li>
</ul>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><ul>
<li>在并发编程中，由于不恰当的执行时序而出现不正确的结果（这不是正式的定义）</li>
<li>竞态条件类型举例<ul>
<li>先检查后执行（比如<code>if(i==1) {i=10;}</code>）。大多数竞态条件的本质：基于一种可能失效的观察结果来做出判断或执行计算</li>
</ul>
</li>
<li>并非所有的竞态条件都是数据竞争，同样并非所有的数据竞争都是竞态条件</li>
</ul>
<h3 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h3><ul>
<li><p>访问共享的非final类型的域时没有采用同步来协同，则会出现数据竞争</p>
<blockquote>
<p>A data race occurs when:</p>
<ul>
<li>two or more threads in a <strong>single process</strong> access the same memory location concurrently, and</li>
<li>at least one of the accesses is for writing, and</li>
<li>the threads are not using any exclusive locks to control their accesses to that memory.</li>
</ul>
<p>When these three conditions hold, the order of accesses is non-deterministic, and the computation may give different results from run to run depending on that order. Some data-races may be benign (for example, when the memory access is used for a busy-wait), but many data-races are bugs in the program.</p>
<p><a href="https://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html" target="_blank" rel="noopener">ref from</a></p>
</blockquote>
</li>
<li><p>在java的内存模型中，如果在代码中存在数据竞争，那么这段代码就没有确定的语义</p>
</li>
</ul>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul>
<li>假定有两个操作A、B，从执行A的线程来看，当另一个线程执行B时，要么将B完全执行完，要么完全不执行B，那么A和B对彼此来说是原子的</li>
<li>原子操作是指，对于访问同一个状态的所有操作（包括这个操作本身）来说，这个操作是以一种原子方式执行</li>
<li>与事务应用程序中的和原子性有相同的含义：一组语句作为一个不可分割的单元被执行</li>
</ul>
<h3 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h3><ul>
<li><p>用来确保变量的更新操作通知到其他线程</p>
</li>
<li><p>anything that was visible to thread A when it writes to volatile field <code>f</code> becomes visible to thread B when it reads <code>f</code>.</p>
</li>
<li><p>synchronized在内存可见性上的作用比volatile变量更强</p>
</li>
<li><p>依赖volatile变量来控制状态的可见性，通常比使用锁的代码更加脆弱，更加难以理解</p>
</li>
<li><p>无法确保原子性（锁可以确保原子性和可见性）</p>
</li>
<li><p>正确的使用方式</p>
<ul>
<li>确保他们状态的可见性</li>
<li>确保它们所引用的状态的可见性</li>
<li>标志一些重要的程序生命周期事件的发生</li>
</ul>
</li>
<li><p>满足以下所有条件时，才应该使用</p>
<ul>
<li>对变量的写入不依赖于当前值，或者只有单个线程<strong>写</strong>该变量</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中</li>
<li>在访问变量时不需要加锁</li>
</ul>
</li>
<li><p>关于重排序</p>
<blockquote>
<p><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">来自于</a></p>
<p>正确性有待验证</p>
</blockquote>
<ul>
<li><p>旧内存模型</p>
<ul>
<li>Under the old memory model, accesses to volatile variables could not be reordered with each other, but they could be reordered with nonvolatile variable accesses.</li>
</ul>
</li>
<li><p>新内存模型（新内存模型是JSR133）</p>
<ul>
<li><p>Under the new memory model, it is still true that volatile variables cannot be reordered with each other. The difference is that it is now no longer so easy to reorder normal field accesses around them.</p>
</li>
<li><p>Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, <strong>anything that was visible to thread A when it writes to volatile field <code>f</code> becomes visible to thread B when it reads <code>f</code>.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// uses x - guaranteed to see 42.</span></span><br><span class="line">      <span class="comment">// This would not have been true under the old memory model. </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Effectively, the semantics of volatile have been strengthened substantially, almost to the level of synchronization. Each read or write of a volatile field acts like “half” a synchronization, for purposes of visibility.</p>
</li>
<li><p>Note that it is important for both threads to access the same volatile variable in order to properly set up the happens-before relationship. It is not the case that everything visible to thread A when it writes volatile field <code>f</code> becomes visible to thread B after it reads volatile field <code>g</code>. <strong>The release and acquire have to “match” (</strong>i.e., be performed on the same volatile field) to have the right semantics</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Double-Checked-Locking-DCL"><a href="#Double-Checked-Locking-DCL" class="headerlink" title="Double Checked Locking(DCL)"></a>Double Checked Locking(DCL)</h3><blockquote>
<p><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">来自于</a></p>
<p>正确性有待进一步验证</p>
</blockquote>
<ul>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// double-checked-locking - don't do this!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Something instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Something <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">        instance = <span class="keyword">new</span> Something();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>There’s only one problem with it – <strong>it doesn’t work</strong>. Why not? The most obvious reason is that the writes which initialize <code>instance</code> and the write to the <code>instance</code> field can be reordered by the compiler or the cache, which would have the effect of <strong>returning what appears to be a partially constructed <code>Something</code></strong>. The result would be that we read an uninitialized object. </p>
</li>
<li><p>There is no way to fix it using the <strong>old Java memory model.</strong></p>
</li>
<li><p>Under the new memory model, making the <code>instance</code> field volatile will “fix” the problems with double-checked locking, because then there will be a happens-before relationship between the initialization of the <code>Something</code> by the constructing thread and the return of its value by the thread that reads it.</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Something</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Something INSTANCE = <span class="keyword">new</span> Something();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Something <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code is guaranteed to be correct because of the initialization guarantees for static fields; if a field is set in a static initializer, it is guaranteed to be made visible, correctly, to any thread that accesses that class.</p>
</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li>作用<ul>
<li>互斥</li>
<li>原子性（复合操作的执行过程中持有一个锁，则这组操作成为原子操作）</li>
<li>内存可见性（所有线程都能看到共享变量的最新值——只需要所有线程都在同一个锁上同步）</li>
</ul>
</li>
</ul>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul>
<li>用于实现原子性</li>
<li>可重入</li>
<li>确定临界区</li>
<li>Constructors in Java can not use the synchronized keyword，但是可以<code>synchronized(this){}</code></li>
<li>内存可见性——某个线程修改了对象状态后，其他线程可以看到发生的状态的变化</li>
<li>每个对象都有一个内部锁，该锁有一个内部条件（条件对应Object对象的final方法<code>wait</code>、<code>notify</code>、<code>notifyAll</code>方法）（所以一旦某个对象的一个<code>synchronized</code>方法被调用后，该对象的另一个<code>synchronized</code>方法会被阻塞）</li>
<li>调用synchronized静态方法获得相关的类对象（Class对象）的内部锁。要注意，使用不同的classLoader加载出来的Class对象是不同的</li>
<li><p>监视器</p>
<ul>
<li>用Java的术语来讲，监视器具有如下特性：<ul>
<li>监视器是只包含私有域的类。</li>
<li>每个监视器类的对象有一个相关的锁。</li>
<li>使用该锁对所有的方法进行加锁。换句话说，如果客户端调用obj.meth0d(),那么obj对象的锁是在方法调用开始时自动获得（这是获得锁的唯一途径），并且当方法返回时自动释放该锁（无论是正常退出还是异常退出）。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域</li>
<li>该锁可以有任意多个相关条件</li>
</ul>
</li>
<li>Java设计者以不是很精确的方式采用了监视器概念，Java中的每一个对象有一个内部的锁和内部的条件。如果一个方法用synchronized关键字声明，那么，它表现的就像是一个监视器方法。通过调用wait/notifyAll/notify来访问条件变量。然而，在下述的3个方面Java对象不同于监视器，从而使得线程的安全性下降：<ul>
<li>域不要求必须是private。</li>
<li>方法不要求必须是synchronized。</li>
<li>内部锁对客户是可用的。</li>
</ul>
</li>
</ul>
</li>
<li><p>局限</p>
<ul>
<li>不能中断一个正在试图获得锁的线程</li>
<li>没有超时</li>
<li>只有单一的条件</li>
</ul>
</li>
</ul>
<h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><ul>
<li>最低安全性<ul>
<li>某个线程没有同步情况下读取变量，可能会得到一个失效值，但这个值至少是之前某个线程设置的，而不是随机的</li>
<li>Java内存模型要求，变量的读取和写入必须是原子操作，但是非<code>volatile</code>的<code>long</code>，<code>double</code>例外</li>
<li>JVM允许将64bit的读或写操作分解为两个32bit的操作，因此可能无法满足最低安全性（除非用<code>volatile</code>声明或是用锁保护）</li>
</ul>
</li>
</ul>
<h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><h5 id="需要满足的条件"><a href="#需要满足的条件" class="headerlink" title="需要满足的条件"></a>需要满足的条件</h5><ul>
<li>对象创建后其状态不能修改</li>
<li>对象的所有域是final类型的（可以不用，比如<code>String</code>的<code>hashCode</code>这个field）</li>
<li>对象是正确创建的（创建期间，this没有逸出）</li>
</ul>
<h5 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h5><ul>
<li><p>对象内部可以使用可变对象来管理状态</p>
</li>
<li><p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stooges.add(<span class="string">"Moe"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Larry"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Curly"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>volatile</code>+不可变对象来实现一组状态的原子操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        <span class="comment">// 如果没有这个copyOf，就不是不可变的</span></span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache =</span><br><span class="line">            <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        <span class="comment">// 如果这里多个请求到来，某个请求调用getFactors调用到一半</span></span><br><span class="line">        <span class="comment">// 然后另一个请求则把cache赋值成另外一个对象，那么有没有问题？</span></span><br><span class="line">        <span class="comment">// 似乎c++就不可以这样做，因为这个需要自动垃圾收集</span></span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="正确的发布"><a href="#正确的发布" class="headerlink" title="正确的发布"></a>正确的发布</h3><ul>
<li><p>发布（publish）：使对象能够在当前作用域之外的代码中使用</p>
</li>
<li><p>逸出（escape）：某个不该发布的对象被发布</p>
</li>
<li><p>不可变对象可以通过任意的机制发布</p>
</li>
<li>事实不可变对象（比如某个<code>Date</code>对象被构造后，就只执行读操作，类似于java要求lambda可以读取的lambda外变量是“事实不可变的”）可以通过安全的方式发布</li>
<li>可变对象必须通过安全的方式来发布，并且必须是线程安全的或者某个锁保护起来</li>
</ul>
<h5 id="可变对象的正确的发布"><a href="#可变对象的正确的发布" class="headerlink" title="可变对象的正确的发布"></a>可变对象的正确的发布</h5><ul>
<li><p>即使某个对象的引用对于其他线程是可见的，也不意味着对象状态对于使用该对象的线程是一定可见的。为了确保对象状态呈现出一致性视图（对象的引用与对象的状态必须同时对其他线程可见），必须要使用<strong>同步</strong>（包括发布时和使存用时）</p>
</li>
<li><p>常用的发布模式</p>
<ul>
<li><p>在静态初始化函数中初始化一个对象引用（不知道“静态初始化函数”是否等价于“静态初始化器”）（因为静态初始化器由JVM在类的初始化阶段执行，JVM内部存在同步机制）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Holder holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将对象的引用保存在volatile类型的域或者AtomicReference对象中</p>
</li>
<li><p>将对象的引用保存在某个正确构造对象的final类型域中</p>
</li>
<li><p>将对象的引用保存在一个由锁保护的域中</p>
<ul>
<li>线程安全容器（比如<code>Hashtable</code>、<code>synchronizedMap</code>、<code>ConcurrentMap</code>、<code>Vector</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code>、<code>synchronizedList</code>、<code>synchronizedSet</code>、<code>BlockingQueue</code>、<code>ConcurrentLinkedQueue</code>）内部的同步意味着将对象放入到某个容器中，将满足这一条要求）</li>
<li><code>Future</code>、<code>Exchanger</code>也可以</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="不可变对象的正确的发布"><a href="#不可变对象的正确的发布" class="headerlink" title="不可变对象的正确的发布"></a>不可变对象的正确的发布</h5><ul>
<li>Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证</li>
<li>即使在发布不可变对象的引用时没有使用同步，也可以安全的访问该对象。为了实现这种安全，对象必须满足上面提到的不可变对象的所有要求</li>
<li>这种保证还包括被<strong>正确创建对象</strong>中的所有final类型的域。但是如果这些域是可变对象，那么在访问时还是需要同步</li>
</ul>
<h3 id="volatile-vs-锁"><a href="#volatile-vs-锁" class="headerlink" title="volatile vs 锁"></a>volatile vs 锁</h3><ul>
<li>锁可以确保可见性和原子性</li>
<li>volatile只确保可见性</li>
</ul>
<h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><ul>
<li>开发服务器应用时，要始终加上<code>-server</code>参数，client模式的JVM优化与server的不一样</li>
</ul>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><ul>
<li>内存屏障<ul>
<li>Other processors exhibit a weaker memory model, where special instructions, called <strong>memory barriers</strong>, are required to flush or invalidate the local processor cache in order to see writes made by other processors or make writes by this processor visible to others. These memory barriers are usually performed when lock and unlock actions are taken; they are invisible to programmers in a high level language.</li>
</ul>
</li>
</ul>
<h3 id="设计线程安全类"><a href="#设计线程安全类" class="headerlink" title="设计线程安全类"></a>设计线程安全类</h3><ul>
<li>三个要素<ul>
<li>找出构成对象状态的所有变量<ul>
<li>如果在对象域中引用了其他对象，那么该对象的状态就包含被引用对象的域</li>
<li>在定义哪些便利将构成对象的状态时，只考虑对象拥有的数据</li>
</ul>
</li>
<li>找出约束状态变量的不变性条件</li>
<li>建立对象状态的并发访问管理策略<ul>
<li>同步策略定义了如何在不违背对象不变条件或后验条件（在操作中会包含一些后验条件来判断状态的迁移是否有效——比如要求某变量如果当前是17，那么下一次更新是18）的情况下对其状态的访问操作进行协同</li>
<li>同步策略规定了如何将不可变性、线程封闭、加锁机制等结合起来维护线程的安全性。还规定了哪些变量由哪些锁来保护</li>
<li>必须要将同步策略写为正式文档</li>
</ul>
</li>
</ul>
</li>
<li>尽可能使用final域以缩小状态空间</li>
<li>如果变量的某些状态是无效的，那么就要对该变量进行封装以避免用户的修改使得该变量处于无效状态。如果某个操作中存在无效的状态转换那么该操作就必须是原子的</li>
<li>如果一个类是由多个独立且线程安全的状态变量组成，并且所有的操作都不包含无效的状态转换，那么可以将线程安全性委托给底层的状态变量</li>
<li>如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换（然而按照线程安全的定义，似乎如果满足以上要求，那么线程安全也就必然满足），那么就可以安全地发布这个变量</li>
</ul>
<h3 id="基于现有的线程安全类添加特性"><a href="#基于现有的线程安全类添加特性" class="headerlink" title="基于现有的线程安全类添加特性"></a>基于现有的线程安全类添加特性</h3><ul>
<li>最好的方法是直接修改原始类，这需要理解代码中的同步策略。好处在于所有实现同步策略的代码在同一个源文件中</li>
<li>另一种方法是extend这个类，但是可能有的类的一些状态是private，子类访问不到，所以行不通。不好的地方在于同步策略的实现被分布到多个单独维护的源文件中，如果底层的类改变了同步策略那么子类就不安全了。</li>
<li>客户端加锁：对于使用对象X的用户代码，在用户代码中，使用X本身用于保护其状态的锁来保护这段用户代码。这里的问题在于，如果文档没有明确指出X使用的锁，那么这个锁在以后版本中可能会修改，从而导致用户代码相对于X的代码不是原子的（在用户代码执行过程中，X内的代码可能执行）。这种会破坏同步策略的封装性（类似于extend会破坏实现的封装性）。与前一种一样，都是将派生类的行为与基类的行为耦合在一起</li>
<li>组合：类似于<code>Collections.synchronizedXXX</code>，用户传递一个对象给该方法（转移所有权，以后都通过这个工厂方法返回的对象来操作），新对象内使用委托和加锁来实现。这种不依赖于被委托对象的线程安全性和使用的锁策略</li>
</ul>
<h3 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h3><ul>
<li>类的不变性条件和后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（比如，从队列中pop时，队列必须非空）。如果某个操作中包含有基于状态的先验条件，则这个操作就叫做依赖状态的操作</li>
</ul>
<h3 id="使用私有的锁-vs-使用对象的内置锁"><a href="#使用私有的锁-vs-使用对象的内置锁" class="headerlink" title="使用私有的锁 vs 使用对象的内置锁"></a>使用私有的锁 vs 使用对象的内置锁</h3><ul>
<li>优点<ul>
<li>私有锁可以将锁封闭起来，避免用户代码得到锁，以避免用户代码参与到同步策略中</li>
<li>如果使用内置锁，要想验证锁是否被正确使用，需要检查整个程序</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><blockquote>
<p>来自JCIP的5.2.1，不清楚JDK5之后有没有修改</p>
</blockquote>
<ul>
<li>使用一种粒度更细的加锁机制——分段锁</li>
<li>一定数量的写入线程可以并发的修改Map</li>
<li>迭代器具有弱一致性，而不是fail-fast（HashMap等的是fail-fast，从而如果迭代时发现数量变化了，就会抛出<code>ConcurrentModificationException</code>），不会抛出<code>ConcurrentModificationException</code>。可以容忍并发的修改</li>
<li><code>size</code>返回的只是估计值</li>
<li>内部没有实现对map加锁以独占访问（对比之下，同步容器<code>Hashtable</code>，<code>synchronizedMap</code>中可以通过获取map的锁来实现独占），所以不能在用户代码通过获取map的锁来独占（所以如果确实需要独占，应该放弃ConcurrentHashMap）</li>
</ul>
<h3 id="串行线程的封闭"><a href="#串行线程的封闭" class="headerlink" title="串行线程的封闭"></a>串行线程的封闭</h3><ul>
<li>线程封闭对象的要求：<ul>
<li>只能由单个线程拥有</li>
<li>通过安全的发布来转移所有权（安全的发布确保对象状态对于新的所有者来说是可见的（不止这个作用？））</li>
<li>所有权转以后，只有接受所有权的线程才可以访问（独占的所有权）</li>
</ul>
</li>
<li>可以使用阻塞队列、ConcurrentHashMap的remove方法、AtomicReference的compareAndSet来完成</li>
</ul>
<h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><ul>
<li>每个线程都有一个<code>boolean</code>的中断标志</li>
<li><code>Thread.interrupted</code>方法将返回当前线程是否被中断，并<strong>清除中断标志</strong></li>
<li><code>Thread.currentThread().interrupt()</code>将中断当前线程</li>
<li>阻塞库方法，例如<code>Thread.sleep</code>，<code>Object.wait</code>会检查线程何时中断，并在发现时提前返回</li>
</ul>
<h3 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h3><ul>
<li>当一个方法会抛出这个异常时，表示这是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态</li>
<li>当在代码中调用将抛出该异常的方法时，我们的方法也就成了一个阻塞方法，必须要对中断进行响应。有两种选择<ul>
<li>传递<code>InterruptedException</code>：不捕获该异常，或者捕获后重新抛出</li>
<li>恢复中断：调用当前线程的interrupt方法恢复中断状态</li>
</ul>
</li>
<li>只有在对Thread进行扩展并且可以控制调用栈上的所有更高层代码时才可以屏蔽该异常</li>
</ul>
<h3 id="MISC-1"><a href="#MISC-1" class="headerlink" title="MISC"></a>MISC</h3><ul>
<li>JVM只有在所有（非守护）线程全部终止后才会退出，因为如果无法正确的关闭Executor，JVM无法关闭</li>
</ul>
<h3 id="Timer-vs-SingleThreadExecutor"><a href="#Timer-vs-SingleThreadExecutor" class="headerlink" title="Timer vs SingleThreadExecutor"></a>Timer vs SingleThreadExecutor</h3><ul>
<li><h3 id="线程依赖死锁"><a href="#线程依赖死锁" class="headerlink" title="线程依赖死锁"></a>线程依赖死锁</h3></li>
<li><p>当线程池不够大，而线程池里的任务依赖于同一线程池的任务，那么会导致，某个任务正在跑，然后其依赖于处于队列中的任务，从而四所</p>
</li>
<li>这种就要求线程池要经过一定的配置——比如不能太小等。所以要将配置策略文档化</li>
<li>只有当任务相互独立时，为线程池或工作队列设置界限才是合理的。任务之间存在依赖性，有界的线程池或队列就可能导致线程饥饿死锁</li>
<li>解决方法<ul>
<li>使用无界的线程池，比如<code>newCachedThreadPool</code></li>
<li>使用有界的线程池，并使用<code>SynchronousQueue</code>作为工作队列（这样当线程池满的时候调用者就会被阻塞从而知道子任务无法运行），以及<code>Caller-Runs</code>饱和策略</li>
</ul>
</li>
</ul>
<h3 id="Thread安全策略"><a href="#Thread安全策略" class="headerlink" title="Thread安全策略"></a>Thread安全策略</h3><ul>
<li>使用<code>Executors.privilegedThreadFactory()</code>可以创建出线程工厂，用这种方式创建出来的线程，将于创建<code>privilegedThreadFactory</code>的线程拥有相同的访问权限、<code>AccessControlContext</code>和<code>contextClassLoader</code></li>
<li>如果不使用该方法，线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限</li>
</ul>
<h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><ul>
<li>确保不会并发执行任务。为了避免用户代码修改返回的ThreadPoolExecutor对象，从而改变不并发执行的语义，所以对其进行包装使得无法类型转换为ThreadPoolExecutor来修改那些特性</li>
<li><code>Executors.unconfigurableExecutorService()</code>包装的Executor就具有冻结配置的特性</li>
</ul>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><h5 id="afterExecute和beforeExecute方法"><a href="#afterExecute和beforeExecute方法" class="headerlink" title="afterExecute和beforeExecute方法"></a>afterExecute和beforeExecute方法</h5><ul>
<li><p>以下是<code>runWorker</code>方法内的片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    beforeExecute(wt, task);</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterExecute(task, thrown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    task = <span class="keyword">null</span>;</span><br><span class="line">    w.completedTasks++;</span><br><span class="line">    w.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出</p>
<ul>
<li>如果beforeExecute抛出异常，则不会执行task和afterExecute</li>
<li>无论task抛出什么异常，都会执行afterExecute</li>
</ul>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="动态锁顺序死锁"><a href="#动态锁顺序死锁" class="headerlink" title="动态锁顺序死锁"></a>动态锁顺序死锁</h4><ul>
<li><p>在持有锁时调用某个外部方法，那么将可能出现死锁，或阻塞时间过长</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: deadlock-prone!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispatcher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> location;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">        <span class="keyword">if</span> (location.equals(destination))</span><br><span class="line">            dispatcher.notifyAvailable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">        availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">        availableTaxis.add(taxi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> Image();</span><br><span class="line">        <span class="keyword">for</span> (Taxi t : taxis)</span><br><span class="line">            image.drawMarker(t.getLocation());</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某个线程调用<code>setLocation</code>，然后在持有该Taxis的锁时调用Dispatcher的<code>notifyAvaiable</code>。同时，另一个线程调用getImage，持有dispatcher的锁然后请求taxis的锁。从而死锁</p>
</li>
<li><p>开放调用：调用某个方法时不需要持有锁。即可能使用开放调用，可以更容易找到需要获得多个锁的代码路径。如果因为开放调用而导致某些操作不是原子的，那么可以通过一些协议来避免该路径被并发执行——比如搞一个标志，然后其他线程看到该标志为xx时就不执行</p>
</li>
</ul>
<h4 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h4><ul>
<li>比如某个线程持有某个链接池的链接等待另一个链接池的链接，另一个线程顺序颠倒地持有和请求</li>
<li>线程饥饿死锁</li>
</ul>
<h3 id="饥饿和优先级"><a href="#饥饿和优先级" class="headerlink" title="饥饿和优先级"></a>饥饿和优先级</h3><ul>
<li>尽量不要改变线程优先级，如果改变了，那么程序的行为就与平台相关了。并且可能导致饥饿</li>
<li>在大多数java应用程序中，所有线程都具有相同的<code>Thread.NORM_PRIORITY</code>，我测试了Daemon线程和非Daemon线程，都是<code>5</code>（linux 4.18.0-13）</li>
<li><code>Thread.yield</code>和<code>Thread.sleep(0)</code>的语义都是未定义的，JVM可以将他们实现为空操作，也可以把他们视为线程调度的参考。在unix系统中并不要求他们拥有<code>sleep（0）</code>的语义——将当前线程放在该优先级对应的运行队列末尾，并将执行全交给相同优先级的其他线程，尽管有些JVM是按照这种方法来实现yield的</li>
</ul>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><ul>
<li>不会阻塞线程但是也无法继续执行，因为线程总是不断重复执行相同的操作，而且总是失败<ul>
<li>比如：某个消息被处理时一定会失败，然而开发者错误的将这种错误当做可以修复的错误，从而把该消息又加入了消息队列头部，从而消息处理器会反复调用，并返回相同的结果，从而程序无法继续执行下去</li>
</ul>
</li>
<li>Livelock can also occur when multiple cooperating threads change their state in response to the others in such a way that no thread can ever make progress<ul>
<li>This is similar to what happens when two overly polite people are walking in opposite directions in a hallway: each steps out of the other’s way, and now they are again in each other’s way.so they both step aside again, and again, and again</li>
<li>解决方法：重试时引入随机性，比如信道上冲突时，随机退避一段时间</li>
</ul>
</li>
</ul>
<h3 id="加速比的计算"><a href="#加速比的计算" class="headerlink" title="加速比的计算"></a>加速比的计算</h3><ul>
<li>$\text{speedup}\leq \frac{1}{F+\frac{(1-F)}{N}}$</li>
<li>其中$F$是串行化的比例，$N$是CPU数目，比如$F=10%$，$N=10$，则在加速比为5.3</li>
</ul>
<h3 id="非竞争同步和竞争同步"><a href="#非竞争同步和竞争同步" class="headerlink" title="非竞争同步和竞争同步"></a>非竞争同步和竞争同步</h3><ul>
<li>非竞争同步可以完全在JVM中处理，竞争同步可能需要操作系统的介入</li>
</ul>
<h5 id="非竞争同步"><a href="#非竞争同步" class="headerlink" title="非竞争同步"></a>非竞争同步</h5><ul>
<li>volatile通常是非竞争同步</li>
<li>synchronized针对无竞争同步进行了优化</li>
<li>在java5时（作者编写JCIP时）一个Fast-Path的非竞争同步将消耗20~250个时钟周期</li>
<li>其对程序整体性能的影响很低</li>
</ul>
<h5 id="竞争同步"><a href="#竞争同步" class="headerlink" title="竞争同步"></a>竞争同步</h5><ul>
<li>JVM将根据历史等待时间选择在发生锁竞争被阻塞时是否要spin-wait，但是大多数JVM只是将线程挂起</li>
</ul>
<h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><ul>
<li><code>Thread.setDaemon()</code>:  This method must be invoked before the thread is started</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li><p>有安全性测试和活跃性测试</p>
<ul>
<li>安全性测试：不发生任何错误的行为</li>
<li>活跃性测试：某个良好的行为终究发生</li>
</ul>
</li>
<li><p>测试时可以使用以下随机数发生器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xorShift</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">6</span>);</span><br><span class="line">    y ^= (y &gt;&gt;&gt; <span class="number">21</span>);</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用<code>/home/hzx/MyStudy/notes/java/JSR166TestCase.java</code>作为测试基类（来自于<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/JSR166TestCase.java）" target="_blank" rel="noopener">http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/JSR166TestCase.java）</a></p>
</li>
<li></li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/18/GF-2-n上算术运算的实现/" rel="next" title="$GF(2^n)$上算术运算的实现">
                <i class="fa fa-chevron-left"></i> $GF(2^n)$上算术运算的实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/02/JVM-Note/" rel="prev" title="My JVM Note">
                My JVM Note <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  

  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">H-ZeX</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">50</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/H-ZeX" title="GitHub &rarr; https://github.com/H-ZeX" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:hzx20112012@gmail.com" title="E-Mail &rarr; mailto:hzx20112012@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的状态"><span class="nav-text">对象的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全性的定义"><span class="nav-text">线程安全性的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JCIP中“同步”的含义"><span class="nav-text">JCIP中“同步”的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#竞态条件"><span class="nav-text">竞态条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据竞争"><span class="nav-text">数据竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性"><span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile变量"><span class="nav-text">volatile变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Double-Checked-Locking-DCL"><span class="nav-text">Double Checked Locking(DCL)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁"><span class="nav-text">锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存可见性"><span class="nav-text">内存可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变对象"><span class="nav-text">不可变对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正确的发布"><span class="nav-text">正确的发布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-vs-锁"><span class="nav-text">volatile vs 锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MISC"><span class="nav-text">MISC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存模型"><span class="nav-text">内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计线程安全类"><span class="nav-text">设计线程安全类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于现有的线程安全类添加特性"><span class="nav-text">基于现有的线程安全类添加特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖状态的操作"><span class="nav-text">依赖状态的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用私有的锁-vs-使用对象的内置锁"><span class="nav-text">使用私有的锁 vs 使用对象的内置锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串行线程的封闭"><span class="nav-text">串行线程的封闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interrupt"><span class="nav-text">Interrupt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InterruptedException"><span class="nav-text">InterruptedException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MISC-1"><span class="nav-text">MISC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timer-vs-SingleThreadExecutor"><span class="nav-text">Timer vs SingleThreadExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程依赖死锁"><span class="nav-text">线程依赖死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread安全策略"><span class="nav-text">Thread安全策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SingleThreadExecutor"><span class="nav-text">SingleThreadExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-text">ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态锁顺序死锁"><span class="nav-text">动态锁顺序死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源死锁"><span class="nav-text">资源死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#饥饿和优先级"><span class="nav-text">饥饿和优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#活锁"><span class="nav-text">活锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加速比的计算"><span class="nav-text">加速比的计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非竞争同步和竞争同步"><span class="nav-text">非竞争同步和竞争同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Daemon"><span class="nav-text">Daemon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试"><span class="nav-text">测试</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">H-ZeX</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: '2zewWM7OPwRwvylk6pRcPGm7-gzGzoHsz',
    appKey: 'qPGJQQgN9YMXkOQLEC97Ufhf',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false
  });
</script>




  


  





  

  

  

  

  
  

  
  

  


  

  

  

  

  

  

  

  
  

  
  

  


</body>
</html>
