<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.0.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: false,
    messageStyle: "none",
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath:  [ ["$", "$"] ],
        displayMath: [ ["$$","$$"] ],
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a'],
        ignoreClass:"comment-content"
    },
    "HTML-CSS": {
        availableFonts: ["STIX","TeX"],
        showMathMenu: false
    }
});
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  




  <meta name="description" content="以下大部分是《java并发编程实战》的笔记，以JCIP简称之  对象的状态 （非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象） 对象的状态中包含了任何可能影响其外部可见行为的数据  线程安全性的定义 正确性的含义 某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，">
<meta property="og:type" content="article">
<meta property="og:title" content="My Java Concurrent Note">
<meta property="og:url" content="https://h-zex.github.io/2019/03/02/Java-Concurrent-Note/index.html">
<meta property="og:site_name" content="H-ZeX">
<meta property="og:description" content="以下大部分是《java并发编程实战》的笔记，以JCIP简称之  对象的状态 （非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象） 对象的状态中包含了任何可能影响其外部可见行为的数据  线程安全性的定义 正确性的含义 某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-03-06T16:17:41.041Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Java Concurrent Note">
<meta name="twitter:description" content="以下大部分是《java并发编程实战》的笔记，以JCIP简称之  对象的状态 （非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象） 对象的状态中包含了任何可能影响其外部可见行为的数据  线程安全性的定义 正确性的含义 某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，">



  <link rel="alternate" href="/atom.xml" title="H-ZeX" type="application/atom+xml"/>




  <link rel="canonical" href="https://h-zex.github.io/2019/03/02/Java-Concurrent-Note/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>My Java Concurrent Note | H-ZeX</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">H-ZeX</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">H-ZeX's Coding Life</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archives</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-友情链接">

    
    
    
      
    

    

    <a href="/link" rel="section"><i class="menu-item-icon fa fa-fw fa-link"></i> <br/>友情链接</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://h-zex.github.io/2019/03/02/Java-Concurrent-Note/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="H-ZeX"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H-ZeX"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">My Java Concurrent Note

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-02 12:49:04" itemprop="dateCreated datePublished" datetime="2019-03-02T12:49:04+08:00">2019-03-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-07 00:17:41" itemprop="dateModified" datetime="2019-03-07T00:17:41+08:00">2019-03-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaConcurrent/" itemprop="url" rel="index"><span itemprop="name">JavaConcurrent</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <a href="/2019/03/02/Java-Concurrent-Note/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments: </span> <span class="post-comments-count valine-comment-count" data-xid="/2019/03/02/Java-Concurrent-Note/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>以下大部分是《java并发编程实战》的笔记，以<code>JCIP</code>简称之</p>
</blockquote>
<h3 id="对象的状态"><a href="#对象的状态" class="headerlink" title="对象的状态"></a>对象的状态</h3><ul>
<li>（非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象）</li>
<li>对象的状态中包含了任何可能影响其外部可见行为的数据</li>
</ul>
<h3 id="线程安全性的定义"><a href="#线程安全性的定义" class="headerlink" title="线程安全性的定义"></a>线程安全性的定义</h3><ul>
<li>正确性的含义<ul>
<li>某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件来描述对象操作的结果</li>
</ul>
</li>
<li>当多个线程访问某个类时，这个类始终能够表现出正确的行为，那么就称这个类是线程安全的</li>
</ul>
<h3 id="JCIP中“同步”的含义"><a href="#JCIP中“同步”的含义" class="headerlink" title="JCIP中“同步”的含义"></a>JCIP中“同步”的含义</h3><ul>
<li>synchronized关键字</li>
<li>volatile变量</li>
<li>显式锁</li>
<li>原子变量</li>
</ul>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><ul>
<li>在并发编程中，由于不恰当的执行时序而出现不正确的结果（这不是正式的定义）</li>
<li>竞态条件类型举例<ul>
<li>先检查后执行（比如<code>if(i==1) {i=10;}</code>）。大多数竞态条件的本质：基于一种可能失效的观察结果来做出判断或执行计算</li>
</ul>
</li>
<li>并非所有的竞态条件都是数据竞争，同样并非所有的数据竞争都是竞态条件</li>
</ul>
<h3 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h3><ul>
<li><p>访问共享的非final类型的域时没有采用同步来协同，则会出现数据竞争</p>
<blockquote>
<p>A data race occurs when:</p>
<ul>
<li>two or more threads in a <strong>single process</strong> access the same memory location concurrently, and</li>
<li>at least one of the accesses is for writing, and</li>
<li>the threads are not using any exclusive locks to control their accesses to that memory.</li>
</ul>
<p>When these three conditions hold, the order of accesses is non-deterministic, and the computation may give different results from run to run depending on that order. Some data-races may be benign (for example, when the memory access is used for a busy-wait), but many data-races are bugs in the program.</p>
<p><a href="https://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html" target="_blank" rel="noopener">ref from</a></p>
</blockquote>
</li>
<li><p>在java的内存模型中，如果在代码中存在数据竞争，那么这段代码就没有确定的语义</p>
</li>
</ul>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul>
<li>假定有两个操作A、B，从执行A的线程来看，当另一个线程执行B时，要么将B完全执行完，要么完全不执行B，那么A和B对彼此来说是原子的</li>
<li>原子操作是指，对于访问同一个状态的所有操作（包括这个操作本身）来说，这个操作是以一种原子方式执行</li>
<li>与事务应用程序中的和原子性有相同的含义：一组语句作为一个不可分割的单元被执行</li>
</ul>
<h3 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h3><ul>
<li><p>只有成员变量才能使用它</p>
</li>
<li><p>用来确保变量的更新操作通知到其他线程</p>
<p>以下代码可以复现，无论是否有<code>server</code>模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去掉volatile，则无限循环</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> sleep = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!sleep) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"out of sleep"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        sleep = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>anything that was visible to thread A when it writes to volatile field <code>f</code> becomes visible to thread B when it reads <code>f</code>.</p>
</li>
<li><p>synchronized在内存可见性上的作用比volatile变量更强</p>
</li>
<li><p>依赖volatile变量来控制状态的可见性，通常比使用锁的代码更加脆弱，更加难以理解</p>
</li>
<li><p>无法确保原子性（锁可以确保原子性和可见性）</p>
</li>
<li><p>正确的使用方式</p>
<ul>
<li>确保他们状态的可见性</li>
<li>确保它们所引用的状态的可见性</li>
<li>标志一些重要的程序生命周期事件的发生</li>
</ul>
</li>
<li><p>满足以下所有条件时，才应该使用</p>
<ul>
<li>对变量的写入不依赖于当前值，或者只有单个线程<strong>写</strong>该变量</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中</li>
<li>在访问变量时不需要加锁</li>
</ul>
</li>
<li><p>关于重排序</p>
<blockquote>
<p><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">来自于</a></p>
<p>正确性有待验证</p>
</blockquote>
<ul>
<li><p>旧内存模型</p>
<ul>
<li>Under the old memory model, accesses to volatile variables could not be reordered with each other, but they could be reordered with nonvolatile variable accesses.</li>
</ul>
</li>
<li><p>新内存模型（新内存模型是JSR133）</p>
<ul>
<li><p>Under the new memory model, it is still true that volatile variables cannot be reordered with each other. The difference is that it is now no longer so easy to reorder normal field accesses around them.</p>
</li>
<li><p>Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, <strong>anything that was visible to thread A when it writes to volatile field <code>f</code> becomes visible to thread B when it reads <code>f</code>.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// uses x - guaranteed to see 42.</span></span><br><span class="line">      <span class="comment">// This would not have been true under the old memory model. </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Effectively, the semantics of volatile have been strengthened substantially, almost to the level of synchronization. Each read or write of a volatile field acts like “half” a synchronization, for purposes of visibility.</p>
</li>
<li><p>Note that it is important for both threads to access the same volatile variable in order to properly set up the happens-before relationship. It is not the case that everything visible to thread A when it writes volatile field <code>f</code> becomes visible to thread B after it reads volatile field <code>g</code>. <strong>The release and acquire have to “match” </strong>(i.e., be performed on the same volatile field) to have the right semantics</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><ul>
<li>即使某个对象的引用对于其他线程是可见的，也并不意味着对象状态对于使用该对象的线程一定是可见的</li>
<li>为了确保对象状态能够呈现出一致的视图，必须使用同步</li>
</ul>
<h3 id="Final域"><a href="#Final域" class="headerlink" title="Final域"></a>Final域</h3><ul>
<li><p>还有一种情况可以安全地访问一个共享域， 即这个域声明为 final 时</p>
</li>
<li><p>在java内存模型中，final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。为了维持这种初始化安全性的保证，需要满足不可变性的所有需求</p>
<ul>
<li>状态不可修改</li>
<li>所有域都是final类型</li>
<li>正确的构造</li>
</ul>
<p>这种保证还延伸到正确创建的对象中所有final类型的域，在没有额外同步的情况下，也可以安全的访问final类型的域。不过，如果这些final域指向的是可变对象，那么访问这些域所指向的对象的状态时还是需要同步</p>
</li>
<li><p>（？）考虑以下声明：<code>final Map&lt;String, Double&gt;accounts = new HashKap&lt;&gt;()</code>；其他线程会在构造函数完成构造之后才看到这个 accounts 变量。如果不使用 final，就不能保证其他线程看到的是 accounts 更新后的值，它们可能都只是看到 null, 而不是新构造的 HashMap</p>
</li>
</ul>
<h3 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h3><ul>
<li>如果有大量线程要访问相同的原子值， 性能会大幅下降， 因为乐观更新需要太多次重试。</li>
<li>Java SE 8 提供了 LongAdder 和 LongAccumulator 类来解决这个问题。LongAdder 包括多个变量（加数)， 其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下， 只有当所有工作都完成之后才需要总和的值， 对于这种情况，这种方法会很高效。性能会有显著的提升。</li>
</ul>
<h3 id="Double-Checked-Locking-DCL"><a href="#Double-Checked-Locking-DCL" class="headerlink" title="Double Checked Locking(DCL)"></a>Double Checked Locking(DCL)</h3><blockquote>
<p><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">来自于</a></p>
<p>正确性有待进一步验证</p>
</blockquote>
<ul>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// double-checked-locking - don't do this!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Something instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Something <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">        instance = <span class="keyword">new</span> Something();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>There’s only one problem with it – <strong>it doesn’t work</strong>. Why not? The most obvious reason is that the writes which initialize <code>instance</code> and the write to the <code>instance</code> field can be reordered by the compiler or the cache, which would have the effect of <strong>returning what appears to be a partially constructed <code>Something</code></strong>. The result would be that we read an uninitialized object. </p>
</li>
<li><p>There is no way to fix it using the <strong>old Java memory model.</strong></p>
</li>
<li><p>Under the new memory model, making the <code>instance</code> field volatile will “fix” the problems with double-checked locking, because then there will be a happens-before relationship between the initialization of the <code>Something</code> by the constructing thread and the return of its value by the thread that reads it.（我猜，这个happen-before是不是就是<code>程序顺序规则</code>（each action in a thread haappens-before every action in that thread that come later in the program order）和<code>传递性</code>和<code>volatile 变量规则</code>的结合——就是<code>instance=new Something()</code>在单线程中必须保证构造操作在赋值给instance操作之前，然后volatile又保证了写入在读取之前，所以一旦另一个线程读取了instance，则根据传递性，构造操作已经完成了）</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Something</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Something INSTANCE = <span class="keyword">new</span> Something();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Something <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code is guaranteed to be correct because of the initialization guarantees for static fields; if a field is set in a static initializer, it is guaranteed to be made visible, correctly, to any thread that accesses that class.</p>
</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li>作用<ul>
<li>互斥</li>
<li>原子性（复合操作的执行过程中持有一个锁，则这组操作成为原子操作）</li>
<li>内存可见性（所有线程都能看到共享变量的最新值——只需要所有线程都在同一个锁上同步）</li>
</ul>
</li>
</ul>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul>
<li>用于实现原子性</li>
<li>可重入</li>
<li>确定临界区</li>
<li>Constructors in Java can not use the synchronized keyword，但是可以<code>synchronized(this){}</code></li>
<li>内存可见性——某个线程修改了对象状态后，其他线程可以看到发生的状态的变化</li>
<li>每个对象都有一个内部锁，该锁有一个内部条件（条件对应Object对象的final方法<code>wait</code>、<code>notify</code>、<code>notifyAll</code>方法）（所以一旦某个对象的一个<code>synchronized</code>方法被调用后，该对象的另一个<code>synchronized</code>方法会被阻塞）</li>
<li>调用synchronized静态方法获得相关的类对象（Class对象）的内部锁。要注意，使用不同的classLoader加载出来的Class对象是不同的</li>
<li><p>监视器</p>
<ul>
<li>用Java的术语来讲，监视器具有如下特性：<ul>
<li>监视器是只包含私有域的类。</li>
<li>每个监视器类的对象有一个相关的锁。</li>
<li>使用该锁对所有的方法进行加锁。换句话说，如果客户端调用obj.meth0d(),那么obj对象的锁是在方法调用开始时自动获得（这是获得锁的唯一途径），并且当方法返回时自动释放该锁（无论是正常退出还是异常退出）。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域</li>
<li>该锁可以有任意多个相关条件</li>
</ul>
</li>
<li>Java设计者以不是很精确的方式采用了监视器概念，Java中的每一个对象有一个内部的锁和内部的条件。如果一个方法用synchronized关键字声明，那么，它表现的就像是一个监视器方法。通过调用wait/notifyAll/notify来访问条件变量。然而，在下述的3个方面Java对象不同于监视器，从而使得线程的安全性下降：<ul>
<li>域不要求必须是private。</li>
<li>方法不要求必须是synchronized。</li>
<li>内部锁对客户是可用的。</li>
</ul>
</li>
</ul>
</li>
<li><p>局限</p>
<ul>
<li>不能中断一个正在试图获得锁的线程</li>
<li>没有超时</li>
<li>只有单一的条件</li>
<li>不提供公平的锁</li>
</ul>
</li>
</ul>
<h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><ul>
<li>最低安全性<ul>
<li>某个线程没有同步情况下读取变量，可能会得到一个失效值，但这个值至少是之前某个线程设置的，而不是随机的</li>
<li>Java内存模型要求，变量的读取和写入必须是原子操作，但是非<code>volatile</code>的<code>long</code>，<code>double</code>例外</li>
<li>JVM允许将64bit的读或写操作分解为两个32bit的操作，因此可能无法满足最低安全性（除非用<code>volatile</code>声明或是用锁保护）</li>
</ul>
</li>
</ul>
<h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><h5 id="需要满足的条件"><a href="#需要满足的条件" class="headerlink" title="需要满足的条件"></a>需要满足的条件</h5><ul>
<li>对象创建后其状态不能修改</li>
<li>对象的所有域是final类型的（可以不用，比如<code>String</code>的<code>hashCode</code>这个field）</li>
<li>对象是正确创建的（创建期间，this没有逸出）</li>
</ul>
<h5 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h5><ul>
<li><p>对象内部可以使用可变对象来管理状态</p>
</li>
<li><p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stooges.add(<span class="string">"Moe"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Larry"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Curly"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>volatile</code>+不可变对象来实现一组状态的原子操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        <span class="comment">// 如果没有这个copyOf，就不是不可变的</span></span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache =</span><br><span class="line">            <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        <span class="comment">// 如果这里多个请求到来，某个请求调用getFactors调用到一半</span></span><br><span class="line">        <span class="comment">// 然后另一个请求则把cache赋值成另外一个对象，那么有没有问题？</span></span><br><span class="line">        <span class="comment">// 似乎c++就不可以这样做，因为这个需要自动垃圾收集</span></span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="正确的发布"><a href="#正确的发布" class="headerlink" title="正确的发布"></a>正确的发布</h3><ul>
<li><p>发布（publish）：使对象能够在当前作用域之外的代码中使用</p>
</li>
<li><p>逸出（escape）：某个不该发布的对象被发布</p>
</li>
<li><p>不可变对象可以通过任意的机制发布</p>
</li>
<li>事实不可变对象（比如某个<code>Date</code>对象被构造后，就只执行读操作，类似于java要求lambda可以读取的lambda外变量是“事实不可变的”）可以通过安全的方式发布</li>
<li>可变对象必须通过安全的方式来发布，并且必须是线程安全的或者某个锁保护起来</li>
</ul>
<h5 id="可变对象的正确的发布"><a href="#可变对象的正确的发布" class="headerlink" title="可变对象的正确的发布"></a>可变对象的正确的发布</h5><ul>
<li><p>即使某个对象的引用对于其他线程是可见的，也不意味着对象状态对于使用该对象的线程是一定可见的。为了确保对象状态呈现出一致性视图（对象的引用与对象的状态必须同时对其他线程可见），必须要使用<strong>同步</strong>（包括发布时和使存用时）</p>
</li>
<li><p>常用的发布模式</p>
<ul>
<li><p>在静态初始化函数中初始化一个对象引用（不知道“静态初始化函数”是否等价于“静态初始化器”）（因为静态初始化器由JVM在类的初始化阶段执行，JVM内部存在同步机制）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Holder holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将对象的引用保存在volatile类型的域或者AtomicReference对象中</p>
</li>
<li><p>将对象的引用保存在某个正确构造对象的final类型域中</p>
</li>
<li><p>将对象的引用保存在一个由锁保护的域中</p>
<ul>
<li>线程安全容器（比如<code>Hashtable</code>、<code>synchronizedMap</code>、<code>ConcurrentMap</code>、<code>Vector</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code>、<code>synchronizedList</code>、<code>synchronizedSet</code>、<code>BlockingQueue</code>、<code>ConcurrentLinkedQueue</code>）内部的同步意味着将对象放入到某个容器中，将满足这一条要求）</li>
<li><code>Future</code>、<code>Exchanger</code>也可以</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="不可变对象的正确的发布"><a href="#不可变对象的正确的发布" class="headerlink" title="不可变对象的正确的发布"></a>不可变对象的正确的发布</h5><ul>
<li>Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证</li>
<li>即使在发布不可变对象的引用时没有使用同步，也可以安全的访问该对象。为了实现这种安全，对象必须满足上面提到的不可变对象的所有要求</li>
<li>这种保证还包括被<strong>正确创建对象</strong>中的所有final类型的域。但是如果这些域是可变对象，那么在访问时还是需要同步</li>
</ul>
<h3 id="lambda使用外部的对象（或value-type的变量）"><a href="#lambda使用外部的对象（或value-type的变量）" class="headerlink" title="lambda使用外部的对象（或value type的变量）"></a>lambda使用外部的对象（或value type的变量）</h3><blockquote>
<p>以下均为我个人根据final域的特性认为的——不知道final域与final变量的差别是什么</p>
</blockquote>
<ul>
<li>lambda可以使用外部的final或事实final的变量</li>
<li>如果是这个final对象引用的变量，没有问题，可见（就是引用对于其他线程可见时，其内部的状态也是，可以保证一致性）</li>
<li>如果引用的是可变对象，则要同步</li>
</ul>
<h3 id="内部类与final变量"><a href="#内部类与final变量" class="headerlink" title="内部类与final变量"></a>内部类与final变量</h3><ul>
<li>TODO：内部类引用外部的变量时，不要求其为final的，那么怎么办，可见性如何保证</li>
</ul>
<h3 id="volatile-vs-锁"><a href="#volatile-vs-锁" class="headerlink" title="volatile vs 锁"></a>volatile vs 锁</h3><ul>
<li>锁可以确保可见性和原子性</li>
<li>volatile只确保可见性</li>
</ul>
<h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><ul>
<li>开发服务器应用时，要始终加上<code>-server</code>参数，client模式的JVM优化与server的不一样</li>
</ul>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><ul>
<li>内存屏障<ul>
<li>Other processors exhibit a weaker memory model, where special instructions, called <strong>memory barriers</strong>, are required to flush or invalidate the local processor cache in order to see writes made by other processors or make writes by this processor visible to others. These memory barriers are usually performed when lock and unlock actions are taken; they are invisible to programmers in a high level language.</li>
</ul>
</li>
</ul>
<h3 id="设计线程安全类"><a href="#设计线程安全类" class="headerlink" title="设计线程安全类"></a>设计线程安全类</h3><ul>
<li>三个要素<ul>
<li>找出构成对象状态的所有变量<ul>
<li>如果在对象域中引用了其他对象，那么该对象的状态就包含被引用对象的域</li>
<li>在定义哪些变量将构成对象的状态时，只考虑对象拥有的数据</li>
</ul>
</li>
<li>找出约束状态变量的不变性条件</li>
<li>建立对象状态的并发访问管理策略<ul>
<li>同步策略定义了如何在不违背对象不变条件或后验条件（在操作中会包含一些后验条件来判断状态的迁移是否有效——比如要求某变量如果当前是17，那么下一次更新是18）的情况下对其状态的访问操作进行协同</li>
<li>同步策略规定了如何将不可变性、线程封闭、加锁机制等结合起来维护线程的安全性。还规定了哪些变量由哪些锁来保护</li>
<li>必须要将同步策略写为正式文档</li>
</ul>
</li>
</ul>
</li>
<li>尽可能使用final域以缩小状态空间</li>
<li>如果变量的某些状态是无效的，那么就要对该变量进行封装以避免用户的修改使得该变量处于无效状态。如果某个操作中存在无效的状态转换那么该操作就必须是原子的</li>
<li>如果一个类是由多个独立且线程安全的状态变量组成，并且所有的操作都不包含无效的状态转换，那么可以将线程安全性委托给底层的状态变量</li>
<li>如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换（然而按照线程安全的定义，似乎如果满足以上要求，那么线程安全也就必然满足），那么就可以安全地发布这个变量</li>
</ul>
<h3 id="基于现有的线程安全类添加特性"><a href="#基于现有的线程安全类添加特性" class="headerlink" title="基于现有的线程安全类添加特性"></a>基于现有的线程安全类添加特性</h3><ul>
<li>最好的方法是直接修改原始类，这需要理解代码中的同步策略。好处在于所有实现同步策略的代码在同一个源文件中</li>
<li>另一种方法是extend这个类，但是可能有的类的一些状态是private，子类访问不到，所以行不通。不好的地方在于同步策略的实现被分布到多个单独维护的源文件中，如果底层的类改变了同步策略那么子类就不安全了。</li>
<li>客户端加锁：对于使用对象X的用户代码，在用户代码中，使用X本身用于保护其状态的锁来保护这段用户代码。这里的问题在于，如果文档没有明确指出X使用的锁，那么这个锁在以后版本中可能会修改，从而导致用户代码相对于X的代码不是原子的（在用户代码执行过程中，X内的代码可能执行）。这种会破坏同步策略的封装性（类似于extend会破坏实现的封装性）。与前一种一样，都是将派生类的行为与基类的行为耦合在一起</li>
<li>组合：类似于<code>Collections.synchronizedXXX</code>，用户传递一个对象给该方法（转移所有权，以后都通过这个工厂方法返回的对象来操作），新对象内使用委托和加锁来实现。这种不依赖于被委托对象的线程安全性和使用的锁策略</li>
</ul>
<h3 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h3><ul>
<li>类的不变性条件和后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（比如，从队列中pop时，队列必须非空）。如果某个操作中包含有基于状态的先验条件，则这个操作就叫做依赖状态的操作</li>
</ul>
<h3 id="使用私有的锁-vs-使用对象的内置锁"><a href="#使用私有的锁-vs-使用对象的内置锁" class="headerlink" title="使用私有的锁 vs 使用对象的内置锁"></a>使用私有的锁 vs 使用对象的内置锁</h3><ul>
<li>优点<ul>
<li>私有锁可以将锁封闭起来，避免用户代码得到锁，以避免用户代码参与到同步策略中</li>
<li>如果使用内置锁，要想验证锁是否被正确使用，需要检查整个程序</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><blockquote>
<p>来自JCIP的5.2.1，不清楚JDK5之后有没有修改</p>
</blockquote>
<ul>
<li>使用一种粒度更细的加锁机制——分段锁</li>
<li>一定数量的写入线程可以并发的修改Map</li>
<li>迭代器具有弱一致性，而不是fail-fast（HashMap等的是fail-fast，从而如果迭代时发现数量变化了，就会抛出<code>ConcurrentModificationException</code>），不会抛出<code>ConcurrentModificationException</code>。可以容忍并发的修改</li>
<li><code>size</code>返回的只是估计值</li>
<li>内部没有实现对map加锁以独占访问（对比之下，同步容器<code>Hashtable</code>，<code>synchronizedMap</code>中可以通过获取map的锁来实现独占），所以不能在用户代码通过获取map的锁来独占（所以如果确实需要独占，应该放弃ConcurrentHashMap）</li>
</ul>
<h3 id="串行线程的封闭"><a href="#串行线程的封闭" class="headerlink" title="串行线程的封闭"></a>串行线程的封闭</h3><ul>
<li>线程封闭对象的要求：<ul>
<li>只能由单个线程拥有</li>
<li>通过安全的发布来转移所有权（安全的发布确保对象状态对于新的所有者来说是可见的（不止这个作用？））</li>
<li>所有权转以后，只有接受所有权的线程才可以访问（独占的所有权）</li>
</ul>
</li>
<li>可以使用阻塞队列、ConcurrentHashMap的remove方法、AtomicReference的compareAndSet来完成</li>
</ul>
<h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><ul>
<li>每个线程都有一个<code>boolean</code>的中断标志</li>
<li><code>Thread.interrupted</code>方法将返回当前线程是否被中断，并<strong>清除中断标志</strong></li>
<li><code>Thread.currentThread().interrupt()</code>将中断当前线程</li>
<li>阻塞库方法，例如<code>Thread.sleep</code>，<code>Object.wait</code>会检查线程何时中断，并在发现时提前返回</li>
</ul>
<h3 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h3><ul>
<li>当一个方法会抛出这个异常时，表示这是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态</li>
<li>当在代码中调用将抛出该异常的方法时，我们的方法也就成了一个阻塞方法，必须要对中断进行响应。有两种选择<ul>
<li>传递<code>InterruptedException</code>：不捕获该异常，或者捕获后重新抛出</li>
<li>恢复中断：调用当前线程的interrupt方法恢复中断状态</li>
</ul>
</li>
<li>只有在对Thread进行扩展并且可以控制调用栈上的所有更高层代码时才可以屏蔽该异常</li>
</ul>
<h3 id="MISC-1"><a href="#MISC-1" class="headerlink" title="MISC"></a>MISC</h3><ul>
<li>JVM只有在所有（非守护）线程全部终止后才会退出，因为如果无法正确的关闭Executor，JVM无法关闭</li>
</ul>
<h3 id="Timer-vs-SingleThreadExecutor"><a href="#Timer-vs-SingleThreadExecutor" class="headerlink" title="Timer vs SingleThreadExecutor"></a>Timer vs SingleThreadExecutor</h3><ul>
<li><h3 id="Thread安全策略"><a href="#Thread安全策略" class="headerlink" title="Thread安全策略"></a>Thread安全策略</h3></li>
<li><p>使用<code>Executors.privilegedThreadFactory()</code>可以创建出线程工厂，用这种方式创建出来的线程，将于创建<code>privilegedThreadFactory</code>的线程拥有相同的访问权限、<code>AccessControlContext</code>和<code>contextClassLoader</code></p>
</li>
<li>如果不使用该方法，线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限</li>
</ul>
<h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><ul>
<li>确保不会并发执行任务。为了避免用户代码修改返回的ThreadPoolExecutor对象，从而改变不并发执行的语义，所以对其进行包装使得无法类型转换为ThreadPoolExecutor来修改那些特性</li>
<li><code>Executors.unconfigurableExecutorService()</code>包装的Executor就具有冻结配置的特性</li>
</ul>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><h5 id="afterExecute和beforeExecute方法"><a href="#afterExecute和beforeExecute方法" class="headerlink" title="afterExecute和beforeExecute方法"></a>afterExecute和beforeExecute方法</h5><ul>
<li><p>以下是<code>runWorker</code>方法内的片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    beforeExecute(wt, task);</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterExecute(task, thrown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    task = <span class="keyword">null</span>;</span><br><span class="line">    w.completedTasks++;</span><br><span class="line">    w.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出</p>
<ul>
<li>如果beforeExecute抛出异常，则不会执行task和afterExecute</li>
<li>无论task抛出什么异常，都会执行afterExecute</li>
</ul>
</li>
</ul>
<h5 id="submit的策略"><a href="#submit的策略" class="headerlink" title="submit的策略"></a>submit的策略</h5><ul>
<li><p>如果运行的corePoolSize线程少于corePoolSize，则会创建一个新线程来处理请求，即使其他工作线程处于空闲状态也是如此。否则，如果正在运行少于maximumPoolSize的线程，则只有在队列已满时才会创建一个新线程来处理请求</p>
</li>
<li><p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get();</span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果core线程还有剩（就是当前启动的线程数少于核心线程数），那么新加<br>worker（等价于新加线程，加入线程后，会run firstTask——<code>prestartAllCoreThreads</code>方法加入的核心worker的firstTask都是null，从而run firstTask不会去运行task）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是内部的Worker（实现了Runnable接口）的run方法，在addWorker后会调用该worker的thread的start方法，从而调用该run方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>否则就尝试push到工作队列里（即使核心线程不忙，也是直接push到队列中，然后核心线程从队列中获得task）（worker运行的线程会阻塞的等待工作队列有东西返回）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">    <span class="comment">// 这来自ThreadPoolExecutor的runWorker方法，worker将run方法委托给这个方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果工作队列已经满了就会尝试去添加非核心线程</p>
</li>
<li><p>因为在添加到工作队列时，使用的是<code>offer</code>，所以即使是<code>SynchronousQueue</code>，也不会阻塞，而是没有线程正在等待接受就立刻返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SynchronousQueue&lt;E&gt; <span class="keyword">public</span> <span class="keyword">boolean</span> offer</span><br><span class="line">Inserts the specified element into <span class="keyword">this</span> queue, <span class="keyword">if</span> another thread is waiting to receive it.</span><br><span class="line">Returns: <span class="keyword">true</span> <span class="keyword">if</span> the element was added to <span class="keyword">this</span> queue, <span class="keyword">else</span> <span class="keyword">false</span></span><br><span class="line"><span class="comment">// 截取自SynchronousQueue的doc</span></span><br></pre></td></tr></table></figure>
<p>因为，如果核心线程已满，但是这个queue无法被offer，那么说明核心线程都忙（会不会出现<code>executor.prestartAllCoreThreads</code>跑完但是有的线程还没到等待点的情况，从而虽然有的线程不忙但是还是无法offer？），所以尝试启动新的非核心线程</p>
</li>
<li><p>这意味着，queue不能太小：否则，如果无法添加新线程，而有的线程虽然不忙，但是可能没能及时得到cpu时间去把task从队列中拿出来，就会导致执行<code>RejectedExecutionHandler</code></p>
</li>
<li><p>要特别注意<code>execute</code>的这一个片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>即使coreSize==0（maxSize为0是非法的）， 并且这是无界队列，线程池还是会保证至少有一个线程在跑</p>
</li>
<li><p>如果使用了无界队列，其实maxSize也没什么用，因为总是会添加队列成功——除非超过了<code>Integer.MAX_VALUE</code>。</p>
</li>
<li><p>队列的作用在于</p>
<ul>
<li>防止core线程不忙但是没能及时从队列中pop出task导致添加多余的线程</li>
<li>使得系统平缓应对小波峰——避免一有风吹草动系统就跟着波动（怎么感觉有点像惊群效应）。小波峰的含义是，对用户的响应的延迟在接受范围内</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="动态锁顺序死锁"><a href="#动态锁顺序死锁" class="headerlink" title="动态锁顺序死锁"></a>动态锁顺序死锁</h4><ul>
<li><p>在持有锁时调用某个外部方法，那么将可能出现死锁，或阻塞时间过长</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: deadlock-prone!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispatcher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> location;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">        <span class="keyword">if</span> (location.equals(destination))</span><br><span class="line">            dispatcher.notifyAvailable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">        availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">        availableTaxis.add(taxi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> Image();</span><br><span class="line">        <span class="keyword">for</span> (Taxi t : taxis)</span><br><span class="line">            image.drawMarker(t.getLocation());</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某个线程调用<code>setLocation</code>，然后在持有该Taxis的锁时调用Dispatcher的<code>notifyAvaiable</code>。同时，另一个线程调用getImage，持有dispatcher的锁然后请求taxis的锁。从而死锁</p>
</li>
<li><p>开放调用：调用某个方法时不需要持有锁。即可能使用开放调用，可以更容易找到需要获得多个锁的代码路径。如果因为开放调用而导致某些操作不是原子的，那么可以通过一些协议来避免该路径被并发执行——比如搞一个标志，然后其他线程看到该标志为xx时就不执行</p>
</li>
</ul>
<h4 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h4><ul>
<li>比如某个线程持有某个链接池的链接等待另一个链接池的链接，另一个线程顺序颠倒地持有和请求</li>
<li>线程依赖死锁<ul>
<li>当线程池不够大，而线程池里的任务依赖于同一线程池的任务，那么会导致，某个任务正在跑，然后其依赖于处于队列中的任务，从而死锁</li>
<li>这种就要求线程池要经过一定的配置——比如不能太小等。所以要将配置策略文档化</li>
<li>只有当任务相互独立时，为线程池或工作队列设置界限才是合理的。任务之间存在依赖性，有界的线程池或队列就可能导致线程饥饿死锁</li>
<li>解决方法<ul>
<li>使用无界的线程池，比如<code>newCachedThreadPool</code></li>
<li>使用有界的线程池，并使用<code>SynchronousQueue</code>作为工作队列（这样当线程池满的时候调用者就会被阻塞从而知道子任务无法运行），以及<code>Caller-Runs</code>饱和策略</li>
<li>为什么不使用0长度的其他blockingQueue而使用SynchronousQueue（以下均为个人观点）<ul>
<li>一方面，其他blockingQueue不支持0长度。所以有可能有一个被等待的子任务就死锁了</li>
<li>另一方面，如果无法增加核心worker（新建线程），那么task都跑到队列中，这时候，如果没有线程在等待从队列中获得task，队列就会立刻返回（因为使用的是<code>offer</code>而不是会阻塞的<code>put</code>），从而在可能死锁时（就是子任务没线程能运行时），可以执行拒绝策略。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="饥饿和优先级"><a href="#饥饿和优先级" class="headerlink" title="饥饿和优先级"></a>饥饿和优先级</h3><ul>
<li>在 Java 程序设计语言中，每一个线程有一个优先级。</li>
<li>默认情况下， 一个线程继承它的父线程的优先级。</li>
<li>可以用<code>setPriority</code> 方法提高或降低任何一个线程的优先级</li>
<li>可以将优先级设置为在 MIN_PRIORITY (在 Thread 类中定义为 1 ) 与 MAX_PRIORITY (定义为 10 ) 之间的任何值。NORM_PRIORITY 被定义为 5</li>
<li>每当线程调度器有机会选择新线程时， 它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的</li>
<li><p>如果有几个高优先级的线程没有进入非活动状态， 低优先级的线程<strong>可能</strong>永远也不能执行</p>
</li>
<li><p>尽量不要改变线程优先级，如果改变了，那么程序的行为就与平台相关了。并且可能导致饥饿</p>
</li>
<li>在大多数java应用程序中，所有线程都具有相同的<code>Thread.NORM_PRIORITY</code>，我测试了Daemon线程和非Daemon线程，都是<code>5</code>（linux 4.18.0-13）</li>
<li><code>Thread.yield</code>和<code>Thread.sleep(0)</code>的语义都是未定义的，JVM可以将他们实现为空操作，也可以把他们视为线程调度的参考。在unix系统中并不要求他们拥有<code>sleep（0）</code>的语义——将当前线程放在该优先级对应的运行队列末尾，并将执行全交给相同优先级的其他线程，尽管有些JVM是按照这种方法来实现yield的</li>
</ul>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><ul>
<li>不会阻塞线程但是也无法继续执行，因为线程总是不断重复执行相同的操作，而且总是失败<ul>
<li>比如：某个消息被处理时一定会失败，然而开发者错误的将这种错误当做可以修复的错误，从而把该消息又加入了消息队列头部，从而消息处理器会反复调用，并返回相同的结果，从而程序无法继续执行下去</li>
</ul>
</li>
<li>Livelock can also occur when multiple cooperating threads change their state in response to the others in such a way that no thread can ever make progress<ul>
<li>This is similar to what happens when two overly polite people are walking in opposite directions in a hallway: each steps out of the other’s way, and now they are again in each other’s way.so they both step aside again, and again, and again</li>
<li>解决方法：重试时引入随机性，比如信道上冲突时，随机退避一段时间</li>
</ul>
</li>
</ul>
<h3 id="加速比的计算"><a href="#加速比的计算" class="headerlink" title="加速比的计算"></a>加速比的计算</h3><ul>
<li>$\text{speedup}\leq \frac{1}{F+\frac{(1-F)}{N}}$</li>
<li>其中$F$是串行化的比例，$N$是CPU数目，比如$F=10%$，$N=10$，则在加速比为5.3</li>
</ul>
<h3 id="非竞争同步和竞争同步"><a href="#非竞争同步和竞争同步" class="headerlink" title="非竞争同步和竞争同步"></a>非竞争同步和竞争同步</h3><ul>
<li>非竞争同步可以完全在JVM中处理，竞争同步可能需要操作系统的介入</li>
</ul>
<h5 id="非竞争同步"><a href="#非竞争同步" class="headerlink" title="非竞争同步"></a>非竞争同步</h5><ul>
<li>volatile通常是非竞争同步</li>
<li>synchronized针对无竞争同步进行了优化</li>
<li>在java5时（作者编写JCIP时）一个Fast-Path的非竞争同步将消耗20~250个时钟周期</li>
<li>其对程序整体性能的影响很低</li>
</ul>
<h5 id="竞争同步"><a href="#竞争同步" class="headerlink" title="竞争同步"></a>竞争同步</h5><ul>
<li>JVM将根据历史等待时间选择在发生锁竞争被阻塞时是否要spin-wait，但是大多数JVM只是将线程挂起</li>
</ul>
<h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><ul>
<li><code>Thread.setDaemon()</code>:  This method must be invoked before the thread is started</li>
<li>当只剩下守护线程时， 虚拟机就退出了，由于如果只剩下守护线程， 就没必要继续运行程序了。</li>
<li>守护线程应该永远不去访问固有资源， 如文件、 数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</li>
</ul>
<h3 id="UncaughtExceptionHandler"><a href="#UncaughtExceptionHandler" class="headerlink" title="UncaughtExceptionHandler"></a>UncaughtExceptionHandler</h3><ul>
<li>可以用 <code>setUncaughtExceptionHandler</code> 方法为任何线程安装一个处理器。也可以用 Thread类的静态方法 <code>setDefaultUncaughtExceptionHandler</code> 为所有线程安装一个默认的处理器</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li><p>有安全性测试和活跃性测试</p>
<ul>
<li>安全性测试：不发生任何错误的行为</li>
<li>活跃性测试：某个良好的行为终究发生</li>
</ul>
</li>
<li><p>测试时可以使用以下随机数发生器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xorShift</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">6</span>);</span><br><span class="line">    y ^= (y &gt;&gt;&gt; <span class="number">21</span>);</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用<code>/home/hzx/MyStudy/notes/java/JSR166TestCase.java</code>作为测试基类（来自于<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/JSR166TestCase.java）" target="_blank" rel="noopener">http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/JSR166TestCase.java）</a></p>
</li>
</ul>
<h3 id="Lock类"><a href="#Lock类" class="headerlink" title="Lock类"></a>Lock类</h3><ul>
<li>Lock实现中必须提供与内部锁相同的内存可见性语义</li>
<li>加锁语义、调度算法、顺序保证、性能特性方面可以与内置所有所不同</li>
</ul>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul>
<li>获取ReentrantLock时，有着与进入同步代码块相同的内存语义</li>
<li>释放时，有着与退出同步代码块相同的内存语义</li>
</ul>
<h3 id="Thread-suspend"><a href="#Thread-suspend" class="headerlink" title="Thread.suspend"></a>Thread.suspend</h3><ul>
<li>与 stop 不同，suspend 不会破坏对象。但是，如果用 suspend 挂起一个持有一个锁的线程， 那么，该锁在恢复之前是不可用的。 如果调用suspend 方法的线程试图获得同一个锁， 那么程序死锁</li>
</ul>
<h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork-Join"></a>Fork-Join</h3><ul>
<li>fork-join 框架使用了一种有效的智能方法来平衡可用线程的工作负载，这种方法称为工作密取（work stealing)。每个工作线程都有一个双端队列 ( deque ) 来完成任务。一个工作线程将子任务压人其双端队列的队头。（只有一个线程可以访问队头，所以不需要加锁。）一个工作线程空闲时，它会从另一个双端队列的队尾“ 密取” 一个任务</li>
</ul>
<h3 id="Thread-状态"><a href="#Thread-状态" class="headerlink" title="Thread 状态"></a>Thread 状态</h3><ul>
<li><p>状态转换</p>
<ul>
<li>当一个线程被阻塞或等待时（或终止时） ，另一个线程被调度为运行状态</li>
<li>当一个线程被重新激活（例如， 因为超时期满或成功地获得了一个锁)， 调度器检查它是否具有比当前运行线程更高的优先级。 如果是这样，调度器从当前运行线程中挑选一个， 剥夺其运行权，选择一个新的线程运行。</li>
</ul>
</li>
<li><p>new：当用 new 操作符创建一个新线程时， 如 <code>new Thread(r)</code>， 该线程还没有开始运行。这意味着它的状态是 new。当一个线程处于新创建状态时， 程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做</p>
</li>
<li>Runnable：一旦调用 start 方法，线程处于 runnable 状态。一个可运行的线桿<strong>可能正在运行也可能没有运行</strong>， 这取决于操作系统给线程提供运行的时间。（A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor）（Java 的规范说明没有将它作为一个单独状态。一个正在运行中的线程仍然处于可运行状态)</li>
<li><p>Blocked：当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。（ 细节取决于它是怎样达到非活动状态的) 。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态</p>
<ul>
<li>当一个线程试图获取一个内部的对象锁（而不是 java.util.concurrent 库中的锁，) 而该锁被其他线程持有， 则该线程进人阻塞状态。（Thread state for a thread blocked waiting for a <strong>monitor lock.</strong> A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait.）。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态</li>
</ul>
</li>
<li><p>WAITING</p>
<ul>
<li><p>当线程等待另一个线程通知调度器一个条件时， 它自己进入<strong>等待状态</strong>。（使用<code>Object.wait</code>或<code>Thread.join</code>方法，或是等待<code>java.util.concurrent</code>库中的Lock或Condition时，就会出现这种情况）</p>
</li>
<li><p>Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods:</p>
<ul>
<li>Object.wait with no timeout</li>
<li>Thread.join with no timeout</li>
<li>LockSupport.park</li>
</ul>
<p>A thread in the waiting state is waiting for another thread to perform a particular action.</p>
</li>
</ul>
</li>
<li><p>TIMED_WAITING</p>
<ul>
<li>Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time:<ul>
<li>Thread.sleep</li>
<li>Object.wait with timeout</li>
<li>Thread.join with timeout</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUntil</li>
</ul>
</li>
</ul>
</li>
<li><p>TERMINATED</p>
<ul>
<li>Thread state for a terminated thread. The thread has <strong>completed execution</strong></li>
<li>线程因如下两个原因之一而被终止<ul>
<li>因为 run 方法正常退出而自然死亡。</li>
<li>因为一个没有捕获的异常终止了 nm 方法而意外死亡</li>
<li>可以调用线程的 stop 方法杀死一个线程。 该方法抛出 <code>ThreadDeath</code> 错误对象,由此杀死线程。但是，stop 方法已过时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul>
<li><p>构成前提条件的变量必须由对象的锁来保护，从而使得它们在测试前提条件的同时保持不变。如果前提条件尚未满足，就必须释放锁</p>
</li>
<li><p>条件队列：每个对象都可以作为一个条件队列。其使得一组线程（等待线程集合）能够通过某种方式来等待特定的条件变为真</p>
</li>
<li><p>Monitor Condition</p>
<ul>
<li>如果调用同步方法的线程必须被阻塞或是其他原因不能立刻进行，它能够在一个监视条件上等待，这将导致该客户线程暂时<strong>释放监视锁</strong>，并<strong>挂起（WAITING / TIMED_WAITING）</strong>在监视条件上</li>
<li>同步方法线程回复。一旦早先挂起在某监视条件上的同步方法线程获取通知，它将继续在最初的等待监视条件的点上执行，执行的条件是唤醒后抢占到监视锁。当线程从wait方法中被唤醒时，他在重新请求锁时不具有任何特殊的优先级，而要与任何其他尝试进入同步代码块的线程一起正常的在锁上竞争</li>
<li><p>当调用wait时，需要持有锁，否则会抛出<code>IllegalMonitorStateException</code></p>
</li>
<li><p>不提供公平的队列</p>
</li>
<li>只有一个条件变量</li>
</ul>
</li>
<li><p>应该将条件队列相关联的条件谓词以及在这些谓词上等待的操作都写入文档</p>
</li>
<li><p>调用wait之前要测试条件谓词，并且从wait中返回时再次进行测试。要在循环中调用wait</p>
<ul>
<li>信号丢失：如果线程A通知了一个条件队列，但是线程B随后调用wait，那么wait并不会立刻醒来，而是要等待另一个通知来唤醒它。所以在wait之前要检查条件谓词</li>
<li>Spurious wakeup：（来自<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">wiki</a>。内容可能有争议）。比如，当只有一个资源变得可用时，本来我们调用notify，那么可以相信醒来的那个一定可以拿到资源。但是，并不是如此，实际操作系统中，有时会出现即使是上面那种情况，醒来后还是发现资源不可用</li>
<li>有个问题：wait唤醒后需要抢占锁，那么，是否有可能某线程虽然被notify唤醒，也就是只有一个等待该条件的线程醒来获得资源，但是同时外界来了一个线程，并且竞争锁先成功，那么这个被唤醒的不就没资源了吗，从而类似假醒</li>
</ul>
</li>
<li><p>确保使用与条件队列相关联的锁来保护条件谓词的各个状态变量</p>
</li>
<li><p>调用wait、notify、notifyAll时，要持有与条件队列相关的锁</p>
</li>
<li><p>检查条件谓词之后以及开始执行相关操作之前，不要释放锁</p>
</li>
<li><p>调用notify时，JVM会从条件队列上等待的多个线程中选择一个来唤醒，而调用notifyAll时则会唤醒所有在这个条件队列上等待的线程。调用notify或notifyAll时必须持有条件队列对象的锁，而如果这些等待的线程此时不能重新获得锁，那么无法从wait返回，因此发出通知的线程要尽快释放锁</p>
</li>
<li><p>在一个条件队列上等待同一个条件谓词</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V[] buf;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseBoundedBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buf = (V[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        buf[tail] = v;</span><br><span class="line">        <span class="keyword">if</span> (++tail == buf.length)</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> V <span class="title">doTake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        V v = buf[head];</span><br><span class="line">        buf[head] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++head == buf.length)</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == buf.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// CONDITION PREDICATE: not-full (!isFull())</span></span><br><span class="line"><span class="comment">// CONDITION PREDICATE: not-empty (!isEmpty())</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BLOCKS-UNTIL: not-full</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull())</span><br><span class="line">            wait();</span><br><span class="line">        doPut(v);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BLOCKS-UNTIL: not-empty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isEmpty())</span><br><span class="line">            wait();</span><br><span class="line">        V v = doTake();</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下有个问题：调用notify后，take被叫醒，然而还是empty——此时isFull不满足，所以本应该put方法被得到通知被执行，所以这个信号就好像丢失了</p>
</li>
<li><p>只有在同时满足以下两个条件时，才能用单一的notify而不是notifyAll</p>
<ul>
<li>所有等待的线程类型相同。只有一个条件谓词与条件队列相关，并且每个线程从wait返回后将执行相同的操作</li>
<li>在条件变量上每次通知最多只能唤醒一个线程来执行</li>
</ul>
</li>
<li><p>使用notifyAll比notify更容易正确，所以除非notifyAll对性能影响过大，否则应该优先使用notifyAll</p>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>对象的正确发布的责任是否是在使用者而不是在线程安全类，即线程安全类也要求被正确发布</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/18/GF-2-n上算术运算的实现/" rel="next" title="$GF(2^n)$上算术运算的实现">
                <i class="fa fa-chevron-left"></i> $GF(2^n)$上算术运算的实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/02/JVM-Note/" rel="prev" title="My JVM Note">
                My JVM Note <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  

  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">H-ZeX</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">60</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/H-ZeX" title="GitHub &rarr; https://github.com/H-ZeX" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:hzx20112012@gmail.com" title="E-Mail &rarr; mailto:hzx20112012@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的状态"><span class="nav-text">对象的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全性的定义"><span class="nav-text">线程安全性的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JCIP中“同步”的含义"><span class="nav-text">JCIP中“同步”的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#竞态条件"><span class="nav-text">竞态条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据竞争"><span class="nav-text">数据竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性"><span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile变量"><span class="nav-text">volatile变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的初始化"><span class="nav-text">对象的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Final域"><span class="nav-text">Final域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子变量"><span class="nav-text">原子变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Double-Checked-Locking-DCL"><span class="nav-text">Double Checked Locking(DCL)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁"><span class="nav-text">锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存可见性"><span class="nav-text">内存可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变对象"><span class="nav-text">不可变对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正确的发布"><span class="nav-text">正确的发布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda使用外部的对象（或value-type的变量）"><span class="nav-text">lambda使用外部的对象（或value type的变量）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类与final变量"><span class="nav-text">内部类与final变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-vs-锁"><span class="nav-text">volatile vs 锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MISC"><span class="nav-text">MISC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存模型"><span class="nav-text">内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计线程安全类"><span class="nav-text">设计线程安全类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于现有的线程安全类添加特性"><span class="nav-text">基于现有的线程安全类添加特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖状态的操作"><span class="nav-text">依赖状态的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用私有的锁-vs-使用对象的内置锁"><span class="nav-text">使用私有的锁 vs 使用对象的内置锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串行线程的封闭"><span class="nav-text">串行线程的封闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interrupt"><span class="nav-text">Interrupt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InterruptedException"><span class="nav-text">InterruptedException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MISC-1"><span class="nav-text">MISC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timer-vs-SingleThreadExecutor"><span class="nav-text">Timer vs SingleThreadExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread安全策略"><span class="nav-text">Thread安全策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SingleThreadExecutor"><span class="nav-text">SingleThreadExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-text">ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态锁顺序死锁"><span class="nav-text">动态锁顺序死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源死锁"><span class="nav-text">资源死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#饥饿和优先级"><span class="nav-text">饥饿和优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#活锁"><span class="nav-text">活锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加速比的计算"><span class="nav-text">加速比的计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非竞争同步和竞争同步"><span class="nav-text">非竞争同步和竞争同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Daemon"><span class="nav-text">Daemon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UncaughtExceptionHandler"><span class="nav-text">UncaughtExceptionHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试"><span class="nav-text">测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock类"><span class="nav-text">Lock类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock"><span class="nav-text">ReentrantLock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-suspend"><span class="nav-text">Thread.suspend</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join"><span class="nav-text">Fork-Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-状态"><span class="nav-text">Thread 状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件变量"><span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题"><span class="nav-text">问题</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">H-ZeX</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: '2zewWM7OPwRwvylk6pRcPGm7-gzGzoHsz',
    appKey: 'qPGJQQgN9YMXkOQLEC97Ufhf',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false
  });
</script>




  


  





  

  

  

  

  
  

  
  

  


  

  

  

  

  

  

  

  
  

  
  

  


</body>
</html>
